"""Generic YANG data parser implementation

This module provides a generic algorithm for parsing YANG data from different
sources (XML, JSON) using the YangData protocol.
"""

import testing
import base64
import xml

import yang
import yang.gdata
import yang.schema
from yang.identity import complete_and_validate_identityref
from yang.identityref import Identityref, PartialIdentityref


NETCONF_OPS = {"create", "delete", "remove", "replace", "merge"}
NETCONF_NS = "urn:ietf:params:xml:ns:netconf:base:1.0"

# Map of gdata getter method names to actual methods
GDATA_TAKERS = {
    # Container getters
    "get_cnt": yang.gdata.Node.get_cnt,
    "get_opt_cnt": yang.gdata.Node.get_opt_cnt,
    # List getters
    "get_list": yang.gdata.Node.get_list,
    "get_opt_list": yang.gdata.Node.get_opt_list,
    # Leaf getters
    "get_str": yang.gdata.Node.get_str,
    "get_opt_str": yang.gdata.Node.get_opt_str,
    "get_int": yang.gdata.Node.get_int,
    "get_opt_int": yang.gdata.Node.get_opt_int,
    "get_float": yang.gdata.Node.get_float,
    "get_opt_float": yang.gdata.Node.get_opt_float,
    "get_bool": yang.gdata.Node.get_bool,
    "get_opt_bool": yang.gdata.Node.get_opt_bool,
    "get_opt_empty": yang.gdata.Node.get_opt_empty,
    "get_bytes": yang.gdata.Node.get_bytes,
    "get_opt_bytes": yang.gdata.Node.get_opt_bytes,
    "get_value": yang.gdata.Node.get_value,
    "get_opt_value": yang.gdata.Node.get_opt_value,
    "get_Identityref": yang.gdata.Node.get_Identityref,
    "get_opt_Identityref": yang.gdata.Node.get_opt_Identityref,
    # LeafList getters
    "get_strs": yang.gdata.Node.get_strs,
    "get_opt_strs": yang.gdata.Node.get_opt_strs,
    "get_ints": yang.gdata.Node.get_ints,
    "get_opt_ints": yang.gdata.Node.get_opt_ints,
    "get_floats": yang.gdata.Node.get_floats,
    "get_opt_floats": yang.gdata.Node.get_opt_floats,
    "get_bools": yang.gdata.Node.get_bools,
    "get_opt_bools": yang.gdata.Node.get_opt_bools,
    "get_bytess": yang.gdata.Node.get_bytess,
    "get_opt_bytess": yang.gdata.Node.get_opt_bytess,
    "get_values": yang.gdata.Node.get_values,
    "get_opt_values": yang.gdata.Node.get_opt_values,
    "get_Identityrefs": yang.gdata.Node.get_Identityrefs,
    "get_opt_Identityrefs": yang.gdata.Node.get_opt_Identityrefs,
}


class PathElement:
    """Represents an element in a schema path, with optional key values for lists"""
    node: yang.schema.DNode
    keys: ?dict[str, value]

    def __init__(self, node: yang.schema.DNode, keys: ?dict[str, value]=None):
        self.node = node
        self.keys = keys


class YangValidationError(ValueError):
    schema_path: list[PathElement]
    expected_type: yang.schema.Type
    actual_value: value

    def __init__(self, schema_path: list[PathElement], expected_type: yang.schema.Type, actual_value: value):
        self.error_message = ""
        self.schema_path = schema_path
        self.expected_type = expected_type
        self.actual_value = actual_value

    def __str__(self) -> str:
        path_str = format_schema_path(self.schema_path)
        type_str = format_type(self.expected_type)
        return "Invalid value at {path_str}: '{self.actual_value}' - expected {type_str}"


def format_type(dt: yang.schema.Type) -> str:
    """Format a Type for error messages"""
    if dt.name == "union" and len(dt.type_) > 0:
        union_types = [format_type(t) for t in dt.type_]
        return "union of [" + ", ".join(union_types) + "]"
    range_obj = dt.range_
    if range_obj is not None:
        return dt.name + " with range " + range_obj.value
    return dt.name


def parse_range_constraint(range_str: str) -> list[(min_str: str, max_str: str)]:
    intervals = []
    parts = range_str.split("|")
    for part in parts:
        part = part.strip()
        if ".." in part:
            range_parts = part.split("..")
            if len(range_parts) == 2:
                min_str = range_parts[0].strip()
                max_str = range_parts[1].strip()
                intervals.append((min_str=min_str, max_str=max_str))
        elif part != "":
            # Singleton range token, e.g., "5" => [5,5]
            intervals.append((min_str=part, max_str=part))
    return intervals


def validate_int_range(value: int, range_str: str, type_name: str) -> bool:
    intervals = parse_range_constraint(range_str)
    numeric_value_i: int = value
    for interval in intervals:
        min_str = interval.min_str
        max_str = interval.max_str

        # Compute integer bounds
        min_val_i: int = 0
        if min_str == "min":
            if type_name == "int8":
                min_val_i = -128
            elif type_name == "int16":
                min_val_i = -32768
            elif type_name == "int32":
                min_val_i = -2147483648
            elif type_name == "int64":
                min_val_i = -9223372036854775808
            elif type_name in ["uint8", "uint16", "uint32", "uint64"]:
                min_val_i = 0
            else:
                min_val_i = -9223372036854775808
        else:
            try:
                min_val_i = int(min_str)
            except ValueError:
                # Malformed bound for integer type, skip this interval
                continue

        max_val_i: int = 0
        if max_str == "max":
            if type_name == "int8":
                max_val_i = 127
            elif type_name == "int16":
                max_val_i = 32767
            elif type_name == "int32":
                max_val_i = 2147483647
            elif type_name == "int64":
                max_val_i = 9223372036854775807
            elif type_name == "uint8":
                max_val_i = 255
            elif type_name == "uint16":
                max_val_i = 65535
            elif type_name == "uint32":
                max_val_i = 4294967295
            elif type_name == "uint64":
                max_val_i = 18446744073709551615
            else:
                max_val_i = 9223372036854775807
        else:
            try:
                max_val_i = int(max_str)
            except ValueError:
                # Malformed bound for integer type, skip this interval
                continue

        if numeric_value_i >= min_val_i and numeric_value_i <= max_val_i:
            return True
    return False


def validate_decimal_range(value: float, range_str: str) -> bool:
    intervals = parse_range_constraint(range_str)
    numeric_value_f: float = value
    for interval in intervals:
        min_str = interval.min_str
        max_str = interval.max_str
        # Defaults align with previous behavior
        min_val_f: float = 0.0
        if min_str == "min":
            min_val_f = -9223372036854775808.0
        else:
            try:
                min_val_f = float(min_str)
            except ValueError:
                continue
        max_val_f: float = 0.0
        if max_str == "max":
            max_val_f = 9223372036854775807.0
        else:
            try:
                max_val_f = float(max_str)
            except ValueError:
                continue
        if numeric_value_f >= min_val_f and numeric_value_f <= max_val_f:
            return True
    return False



def format_schema_path(path: list[PathElement]) -> str:
    path_str = ""

    for i, elem in enumerate(path):
        if i > 0:
            prev = path[i-1].node
            if not isinstance(prev, yang.schema.DRoot):
                path_str = path_str + "/"
            if isinstance(prev, yang.schema.DNodeInner):
                un = yang.schema._UniqueNamer(prev)
                path_str = path_str + un.unique_name(elem.node.name, elem.node.prefix)
                keys_dict = elem.keys
                if keys_dict is not None and len(keys_dict) > 0:
                    predicates = ["{k}={repr(v)}" for k, v in keys_dict.items()]
                    path_str = path_str + "[" + ",".join(predicates) + "]"
        elif isinstance(elem.node, yang.schema.DRoot):
            path_str = "/"
        else:
            # Relative path
            path_str = elem.node.name
    return path_str


def get_netconf_operation(node: xml.Node) -> str:
    """Extract NETCONF operation from an XML node
    """
    def ns_uri(prefix: ?str) -> ?str:
        for p, uri in node.nsdefs:
            # default namespace is stored with prefix == None
            if (prefix is None and p is None) or (prefix is not None and p is not None and prefix == p):
                return uri
        return None

    for attr_key, attr_val in node.attributes:
        if attr_key == "operation":
            # Unprefixed operation; must be in default NETCONF namespace
            if attr_val in NETCONF_OPS and ns_uri(None) == NETCONF_NS:
                return attr_val
        elif attr_key.endswith(":operation"):
            # Prefixed operation; resolve prefix and validate NETCONF namespace
            prefix = attr_key.split(":", 1)[0]
            if attr_val in NETCONF_OPS and ns_uri(prefix) == NETCONF_NS:
                return attr_val

    return "merge"


def _test_get_nc_op_def():
    xml_in = xml.decode('<cfg xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" operation="delete"/>')
    op = get_netconf_operation(xml_in)
    testing.assertEqual(op, "delete")


def _test_get_nc_op_pref():
    xml_in = xml.decode('<cfg xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="replace"/>')
    op = get_netconf_operation(xml_in)
    testing.assertEqual(op, "replace")


def try_parse_value(text_value: str, schema_type: yang.schema.Type, path: list[PathElement]) -> (t: str, val: value):
    """Parse a textual value according to the provided schema type.

    Returns:
        (t, val): A typed tuple with the concrete type name and native value
                  (e.g. ("uint8", 42)). For unions, returns the successful
                  member type and parsed value.

    Errors:
        Raises YangValidationError with a message including the formatted
        schema path (from the path parameter) and a textual description of the
        expected type (including range constraints if present).
    """
    type_name = schema_type.name
    if type_name == "union":
        for member_type in schema_type.type_:
            try:
                return try_parse_value(text_value, member_type, path)
            except YangValidationError:
                continue
        raise YangValidationError(path, schema_type, text_value)
    elif type_name == "string":
        return (t=type_name, val=text_value)
    elif type_name == "int8" or type_name == "int16" or type_name == "int32" or type_name == "int64":
        try:
            int_val = int(text_value)
            range_obj = schema_type.range_
            if range_obj is not None:
                if not validate_int_range(int_val, range_obj.value, type_name):
                    raise YangValidationError(path, schema_type, text_value)
            return (t=type_name, val=int_val)
        except ValueError:
            raise YangValidationError(path, schema_type, text_value)
    elif type_name == "uint8" or type_name == "uint16" or type_name == "uint32" or type_name == "uint64":
        try:
            int_val = int(text_value)
            if int_val < 0:
                raise YangValidationError(path, schema_type, text_value)
            range_obj = schema_type.range_
            if range_obj is not None:
                if not validate_int_range(int_val, range_obj.value, type_name):
                    raise YangValidationError(path, schema_type, text_value)
            return (t=type_name, val=int_val)
        except ValueError:
            raise YangValidationError(path, schema_type, text_value)
    elif type_name == "decimal64":
        try:
            float_val = float(text_value)
            range_obj = schema_type.range_
            if range_obj is not None:
                if not validate_decimal_range(float_val, range_obj.value):
                    raise YangValidationError(path, schema_type, text_value)
            return (t=type_name, val=float_val)
        except ValueError:
            raise YangValidationError(path, schema_type, text_value)
    elif type_name == "boolean":
        if text_value == "true":
            return (t=type_name, val=True)
        elif text_value == "false":
            return (t=type_name, val=False)
        else:
            raise YangValidationError(path, schema_type, text_value)
    elif type_name == "enumeration":
        for e in schema_type.enum:
            if text_value == e.name:
                return (t=type_name, val=text_value)
        raise YangValidationError(path, schema_type, text_value)
    elif type_name == "binary":
        try:
            return (t=type_name, val=base64.decode(text_value.encode()))
        except Exception:
            raise YangValidationError(path, schema_type, text_value)
    elif type_name == "empty":
        return (t=type_name, val=True)
    else:
        return (t="string", val=text_value)


protocol YangData:
    """Protocol for YANG data nodes

    Provides a uniform interface for extracting data from different data formats
    that can carry YANG-modeled data, like XML and JSON
    """
    take_container: mut(yang.schema.DContainer, str, ?str, list[PathElement]) -> ?value
    take_list: mut(yang.schema.DList, str, ?str, list[PathElement]) -> list[value]
    # Return a typed tuple for leaves. The tuple carries the concrete type name
    # and the parsed value. Missing leaves return None.
    take_leaf: mut(yang.schema.DLeaf, str, ?str, list[PathElement]) -> ?(t: str, val: ?value)
    # For leaf-lists, return a list of typed tuples (t, val).
    # For identityref items, val holds a PartialIdentityref.
    take_leaflist: mut(yang.schema.DLeafList, str, ?str, list[PathElement]) -> list[(t: str, val: ?value)]


extension xml.Node (YangData):
    def take_container(self, schema: yang.schema.DContainer, name: str, ns: ?str=None, path: list[PathElement]=[]) -> ?value:
        child_node = yang.gdata.get_xml_opt_child(self, name, ns)
        if child_node is not None:
            return child_node
        return None

    def take_list(self, schema: yang.schema.DList, name: str, ns: ?str=None, path: list[PathElement]=[]) -> list[value]:
        elements = yang.gdata.get_xml_children(self, name, ns)
        return elements

    def take_leaf(self, schema: yang.schema.DLeaf, name: str, ns: ?str=None, path: list[PathElement]=[]) -> ?(t: str, val: ?value):
        new_path = path + [PathElement(schema)]
        maybe_node = yang.gdata.get_xml_opt_child(self, name, ns)
        if maybe_node is not None:
            text_value = maybe_node.text
            if text_value is not None:
                if schema.type_.name == "identityref":
                    return (t="identityref", val=Identityref.from_xml(text_value, maybe_node.nsdefs))
                elif schema.type_.name == "binary":
                    return (t="binary", val=base64.decode(text_value.encode()))
                result = try_parse_value(text_value, schema.type_, new_path)
                return result
            else:
                if schema.type_.name == "empty":
                    return (t="empty", val=True)
                else:
                    return None
        else:
            return None

    def take_leaflist(self, schema: yang.schema.DLeafList, name: str, ns: ?str=None, path: list[PathElement]=[]) -> list[(t: str, val: ?value)]:
        new_path = path + [PathElement(schema)]
        values: list[(t: str, val: ?value)] = []
        children = yang.gdata.get_xml_children(self, name, ns)
        # Ignore NETCONF operation
        if schema.type_.name == "identityref":
            for child in children:
                if isinstance(child, xml.Node):
                    text_value = child.text
                    if text_value is not None:
                        values.append((t="identityref", val=Identityref.from_xml(text_value, child.nsdefs)))
        elif schema.type_.name == "binary":
            for child in children:
                if isinstance(child, xml.Node):
                    text_value = child.text
                    if text_value is not None:
                        values.append((t="binary", val=base64.decode(text_value.encode())))
        else:
            for child in children:
                if isinstance(child, xml.Node):
                    text_value = child.text
                    if text_value is not None:
                        tv = try_parse_value(text_value, schema.type_, new_path)
                        values.append(tv)
        return values


extension dict[A(Hashable), B] (YangData):
    def take_container(self, schema: yang.schema.DContainer, name: str, ns: ?str=None, path: list[PathElement]=[]) -> ?value:
        if isinstance(self, dict):
            maybe = None
            # For cross-namespace children, only accept module-qualified keys
            if ns is not None and schema.module is not None and schema.module != "":
                maybe = self.get(f"{schema.module}:{name}")
            else:
                maybe = self.get(name)
            if isinstance(maybe, dict):
                return maybe
        return None

    def take_list(self, schema: yang.schema.DList, name: str, ns: ?str=None, path: list[PathElement]=[]) -> list[value]:
        if isinstance(self, dict):
            lv = None
            if ns is not None and schema.module is not None and schema.module != "":
                lv = self.get(f"{schema.module}:{name}")
            else:
                lv = self.get(name)
            if lv is not None:
                return lv
        return []

    def take_leaf(self, schema: yang.schema.DLeaf, name: str, ns: ?str=None, path: list[PathElement]=[]) -> ?(t: str, val: ?value):
        new_path = path + [PathElement(schema)]
        if isinstance(self, dict):
            leaf_value = None
            if ns is not None and schema.module is not None and schema.module != "":
                leaf_value = self.get(f"{schema.module}:{name}")
            else:
                leaf_value = self.get(name)
            if leaf_value is not None:
                if isinstance(leaf_value, str):
                    if schema.type_.name == "identityref":
                        return (t="identityref", val=Identityref.from_json(leaf_value))
                    elif schema.type_.name == "binary":
                        return (t="binary", val=base64.decode(leaf_value.encode()))
                    result = try_parse_value(leaf_value, schema.type_, new_path)
                    return result
                else:
                    # Special-case empty leaf JSON encoding: [null]
                    if schema.type_.name == "empty":
                        if isinstance(leaf_value, list) and len(leaf_value) == 1 and leaf_value[0] is None:
                            return (t="empty", val=True)
                        else:
                            raise ValueError(f"Expected [null] for empty leaf {name}, got {leaf_value}")
                    concrete_type = schema.type_.name
                    if concrete_type == "union":
                        for member_type in schema.type_.type_:
                            member_name = member_type.name
                            if isinstance(leaf_value, bool) and member_name == "boolean":
                                concrete_type = "boolean"
                                break
                            elif isinstance(leaf_value, int) and not isinstance(leaf_value, bool):
                                if member_name in ["int8", "int16", "int32", "int64", "uint8", "uint16", "uint32", "uint64"]:
                                    range_obj = member_type.range_
                                    if range_obj is not None:
                                        if validate_int_range(leaf_value, range_obj.value, member_name):
                                            concrete_type = member_name
                                            break
                                    else:
                                        concrete_type = member_name
                                        break
                            elif isinstance(leaf_value, float) and member_name == "decimal64":
                                concrete_type = "decimal64"
                                break
                    range_obj = schema.type_.range_
                    if range_obj is not None:
                        if isinstance(leaf_value, int) and not isinstance(leaf_value, bool):
                            if not validate_int_range(leaf_value, range_obj.value, concrete_type):
                                raise YangValidationError(new_path, schema.type_, str(leaf_value))
                        elif isinstance(leaf_value, float):
                            if not validate_decimal_range(leaf_value, range_obj.value):
                                raise YangValidationError(new_path, schema.type_, str(leaf_value))
                    return (t=concrete_type, val=leaf_value)
            else:
                return None
        else:
            return None

    def take_leaflist(self, schema: yang.schema.DLeafList, name: str, ns: ?str=None, path: list[PathElement]=[]) -> list[(t: str, val: ?value)]:
        values: list[(t: str, val: ?value)] = []
        if isinstance(self, dict):
            leaflist_data = None
            if ns is not None and schema.module is not None and schema.module != "":
                leaflist_data = self.get(f"{schema.module}:{name}")
            else:
                leaflist_data = self.get(name)
            if isinstance(leaflist_data, list):
                if schema.type_.name == "identityref":
                    for item in leaflist_data:
                        if isinstance(item, str):
                            values.append((t="identityref", val=Identityref.from_json(item)))
                        else:
                            raise ValueError(f"Expected string for identityref in leaf-list {name}, got {type(item)}")
                    return values
                elif schema.type_.name == "binary":
                    for item in leaflist_data:
                        if isinstance(item, str):
                            values.append((t="binary", val=base64.decode(item.encode())))
                        else:
                            raise ValueError(f"Expected string for binary in leaf-list {name}, got {type(item)}")
                    return values
                new_path = path + [PathElement(schema)]
                for item in leaflist_data:
                    if isinstance(item, str):
                        tv = try_parse_value(item, schema.type_, new_path)
                        values.append(tv)
                    else:
                        concrete_type = schema.type_.name
                        if concrete_type == "union":
                            for member_type in schema.type_.type_:
                                member_name = member_type.name
                                if isinstance(item, bool) and member_name == "boolean":
                                    concrete_type = "boolean"
                                    break
                                elif isinstance(item, int) and not isinstance(item, bool):
                                    if member_name in ["int8", "int16", "int32", "int64", "uint8", "uint16", "uint32", "uint64"]:
                                        range_obj = member_type.range_
                                        if range_obj is not None:
                                            if validate_int_range(item, range_obj.value, member_name):
                                                concrete_type = member_name
                                                break
                                        else:
                                            concrete_type = member_name
                                            break
                                elif isinstance(item, float) and member_name == "decimal64":
                                    concrete_type = "decimal64"
                                    break
                        range_obj = schema.type_.range_
                        if range_obj is not None:
                            if isinstance(item, int) and not isinstance(item, bool):
                                if not validate_int_range(item, range_obj.value, concrete_type):
                                    raise YangValidationError(new_path, schema.type_, str(item))
                            elif isinstance(item, float):
                                if not validate_decimal_range(item, range_obj.value):
                                    raise YangValidationError(new_path, schema.type_, str(item))
                        values.append((t=concrete_type, val=item))
        return values


def _user_order(ordered_by):
    return True if ordered_by == "user" else False


def _parse_qualified_name(name: str) -> (str, ?str):
    if ":" in name:
        parts = name.split(":", 1)
        return (parts[1], parts[0])
    return (name, None)


def has_mandatory_content(container: yang.schema.DContainer) -> bool:
    """Return True if a non-presence container has any mandatory content.

    A container has mandatory content if it contains any mandatory leaf, or
    any non-presence child container that itself has mandatory content.
    """
    for c in container.children:
        if isinstance(c, yang.schema.DLeaf):
            if c.mandatory:
                return True
        elif isinstance(c, yang.schema.DContainer):
            if not c.presence and has_mandatory_content(c):
                return True
    return False


def from_json_path(root: yang.schema.DRoot, data: dict[str, ?value], path: list[str], op: str="merge", loose: bool=False) -> yang.gdata.Container:
    r"""Convert JSON to a gdata tree rooted at the schema root, with data applied
    at the specified path.

    Unlike from_data which can create partial trees starting at any schema node,
    this function ALWAYS creates a sparse tree from the root of the schema,
    meaning that it  only creates containers and list entries required to hold
    the data at the specified path location. This is useful for NETCONF/RESTCONF
    operations where the payload is a subtree rooted in the provided query path.

    Args:
        root: Root schema node (must be the actual root, not an inner node)
        data: JSON data to apply at the target path location
        path: List of path elements to navigate from root, e.g. ["mod1:c1", "list1", "key1", "inner"]
              - Container/List names "name" or "module:name"
              - List entries: comma-separated key values, e.g. "key1,key2"
        op: Operation to perform - "merge" (default) or "remove"
        loose: Whether to allow missing mandatory fields

    Returns:
        A sparse gdata tree from root with data only at the specified path

    Examples:
        # Creates: root -> c1 -> c2 -> {leaf1: "value"}
        from_json_path(schema, {"leaf1": "value"}, ["mod:c1", "c2"])

        # Creates: root -> list1[key1] -> container -> {field: "value"}
        from_json_path(schema, {"field": "value"}, ["mod:list1", "key1", "container"])

        # Creates: root -> list1[key1] as Absent (for removal)
        from_json_path(schema, {}, ["mod:list1", "key1"], "remove")
    """
    result = _from_json_path_recursive(root, root.identities, data, path, op, loose, [PathElement(root)], True, True)
    # The top-level call always returns a Container because:
    # - If path is empty, from_data returns Container
    # - If path is non-empty, we wrap in Container
    if isinstance(result, yang.gdata.Container):
        return result
    else:
        raise ValueError("Internal error: expected Container at root level")


def _from_json_path_recursive(s: yang.schema.DNodeInner, global_identity, data: dict[str, ?value], path: list[str], op: str, loose: bool, current_path: list[PathElement], top: bool, set_ns: bool) -> yang.gdata.Node:
    if isinstance(s, yang.schema.DRoot) or isinstance(s, yang.schema.DContainer):
        if len(path) == 0:
            # Base case: no more path elements, process the data
            if op == "merge":
                # TODO: set_ns??
                return _from_data_recursive(s, global_identity, data, loose=loose, set_ns=set_ns, spath=current_path)
            elif op == "remove":
                return yang.gdata.Absent()
            raise ValueError("Invalid operation at {format_schema_path(current_path)}: {op}")
        else:   # len(path) > 0
            # More path to traverse - create a container with just the next child
            unique_namer = yang.schema._UniqueNamer(s)
            def uname(n):
                return unique_namer.unique_name(n.name, n.prefix)

            point = path[0]
            rest_path = path[1:]

            local_name, module = _parse_qualified_name(point)
            child = s.get(local_name, module=module, allow_unqualified=False)

            if isinstance(child, yang.schema.DNodeInner):
                # Recursively process the child node
                perhaps = True if (top or set_ns) and s.namespace != "" else False
                cchild = _from_json_path_recursive(child, global_identity, data, rest_path, op, loose, current_path + [PathElement(child)], False, s.namespace != child.namespace)
                # Create a container with just this one child
                return yang.gdata.Container({uname(child): cchild}, ns=s.namespace if perhaps else None, module=s.module if perhaps else None)

            # Path tries to go through a leaf - this is an error
            raise ValueError("Invalid JSON path to non-inner node at {format_schema_path(current_path + [PathElement(child)])}: {point}")
    elif isinstance(s, yang.schema.DList):
        if len(path) == 1:
            # Base case: keys are the last path element
            point = path[0]
            keys = point.split(",")
            # Check that all keys are present in payload.
            # If present, they must equal the keys in the path
            # If not present, fill in from path
            data_with_keys = dict(data.items())
            for key in s.key:
                if key not in data_with_keys:
                    data_with_keys[key] = keys.pop(0)
                else:
                    if str(data_with_keys[key]) != keys.pop(0):
                        raise ValueError("Key value mismatch between path and payload at {format_schema_path(current_path)}")
            element_gdata = _from_data_recursive(s, global_identity, data_with_keys, loose, set_ns=False, spath=current_path + [PathElement(s, {k: v for k, v in data_with_keys.items() if k in s.key and v is not None})])
            elements = []
            if op == "merge":
                elements.append(element_gdata)
            elif op == "remove":
                elements.append(yang.gdata.Absent(element_gdata.key_children(s.key)))
            else:
                raise ValueError("Invalid operation at {format_schema_path(current_path)}: {op}")
            perhaps = True if (top or set_ns) and s.namespace != "" else False
            return yang.gdata.List(s.key, elements, _user_order(s.ordered_by), ns=s.namespace if perhaps else None, module=s.module if perhaps else None)
        elif len(path) > 1:
            # The path crosses this list element and references another inner node
            point = path[0]
            rest_path = path[1:]

            # First create this list with a single element with only key children.
            # For nested lists, we always use "merge" for intermediate elements.
            slist = _from_json_path_recursive(s, global_identity, {}, [point], "merge", loose, current_path, top, set_ns)

            # The return type must be a List, we just requested it
            if isinstance(slist, yang.gdata.List):
                # Now process the rest of the path following the structural list keys
                unique_namer = yang.schema._UniqueNamer(s)
                def uname(n):
                    return unique_namer.unique_name(n.name, n.prefix)

                child_point = rest_path[0]
                child_rest_path = rest_path[1:]

                local_name, module = _parse_qualified_name(child_point)

                lchild = s.get(local_name, module=module, allow_unqualified=False)
                if isinstance(lchild, yang.schema.DNodeInner):
                    # Now extract gdata for the rest of the path, from the child point
                    inner_result = _from_json_path_recursive(lchild, global_identity, data, child_rest_path, op, loose, current_path + [PathElement(lchild)], False, False)

                    # Add it to the structural list element, next to the existing keys
                    slist.elements[0].children[uname(lchild)] = inner_result
                    return slist
                else:
                    raise ValueError("Node at {format_schema_path(current_path + [PathElement(lchild)])} is not inner: {type(lchild)}")

            raise ValueError("unreachable")
        raise ValueError("Unable to resolve path at {format_schema_path(current_path)}: no keys provided")


    raise ValueError("Unknown schema node type at {format_schema_path(current_path)}: {type(s)}")


def from_data[A(YangData)](root: yang.schema.DRoot, data: A, loose: bool=False, root_path: list[str]=[]) -> yang.gdata.Container:
    """Generic function to convert data to gdata tree based on schema

    Args:
        root: Root schema node (must be the actual root, not an inner node)
        data: Data wrapped in a YangData protocol implementation (XML or JSON)
        loose: Whether to use loose parsing (allows optional fields to be missing)
        root_path: Path from s to the actual data location in the input. This enables
                  partial parsing where the data doesn't start at the schema root but
                  at some inner node. For example, if root_path=["mod:c1", "c2"],
                  the function will navigate from s through c1 and c2 before starting
                  to parse the actual data.

    Returns:
        A yang.gdata.Container containing the parsed data tree
    """
    return _from_data_recursive(root, root.identities, data, loose, root_path=root_path, spath=[PathElement(root)])

def _from_data_recursive[A(YangData)](s: yang.schema.DNodeInner, global_identity: list[yang.schema.DIdentity], data: A, loose: bool=False, set_ns: bool=True, root_path: list[str]=[], spath: list[PathElement]=[]) -> yang.gdata.Container:
    """Internal function with additional recursion accumulators

    Args:
        s: Schema node (container or list) - the root of the schema tree to start parsing from
        global_identity: List of identity definitions for resolving identityref values
        data: Data wrapped in a YangData protocol implementation (XML or JSON)
        loose: Whether to use loose parsing (allows optional fields to be missing)
        set_ns: Whether to set namespace information on generated nodes
        root_path: Path from s to the actual data location in the input. This enables
                  partial parsing where the data doesn't start at the schema root but
                  at some inner node. For example, if root_path=["mod:c1", "c2"],
                  the function will navigate from s through c1 and c2 before starting
                  to parse the actual data.
        spath: Accumulated schema path as list[PathElement], including list key
               predicates when descending into list elements. This is passed to
               YangData.take_* so that any validation errors can render full,
               human-friendly paths (e.g., /c1/l2[k1='A']/v1).

    Returns:
        A yang.gdata.Container containing the parsed data tree
    """

    # Navigate to root path if specified
    if root_path != [] and len(spath) -1 < len(root_path):
        next = root_path[len(spath) - 1]

        local_name, module = _parse_qualified_name(next)
        child = s.get(local_name, module=module, allow_unqualified=False)
        if isinstance(child, yang.schema.DNodeInner):
            return _from_data_recursive(child, global_identity, data, loose, set_ns, root_path, spath + [PathElement(child)])
        raise ValueError("Node at {format_schema_path(spath + [PathElement(child)])} is not inner: {type(child)}")

    children: dict[str, yang.gdata.Node] = {}

    unique_namer = yang.schema._UniqueNamer(s)
    def uname(n) -> str:
        return unique_namer.unique_name(n.name, n.prefix)

    source_is_xml = isinstance(data, xml.Node)
    for child in s.children:
        # Only process data nodes
        if not (isinstance(child, yang.schema.DNodeLeaf) or isinstance(child, yang.schema.DContainer) or isinstance(child, yang.schema.DList)):
            continue

        def path_with_child(k=None):
            return spath + [PathElement(child, k)]

        # Determine namespace (only include if different from parent)
        ns = None
        mod = None
        if child.namespace != s.namespace:
            ns = child.namespace
            mod = child.module

        if isinstance(child, yang.schema.DContainer):
            val = data.take_container(child, child.name, ns, spath)
            if val is not None:
                if isinstance(val, xml.Node):
                    # NETCONF operation on container
                    cop = get_netconf_operation(val)
                    cns = child.namespace if set_ns and child.namespace != "" else None
                    cmod = child.module if set_ns and child.module != "" else None
                    if cop == "remove":
                        children[uname(child)] = yang.gdata.Absent(ns=cns, module=cmod)
                    elif cop == "delete":
                        children[uname(child)] = yang.gdata.Delete(ns=cns, module=cmod)
                    elif cop == "create":
                        inner = _from_data_recursive(child, global_identity, val, loose, set_ns=False, root_path=root_path, spath=spath + [PathElement(child)])
                        children[uname(child)] = yang.gdata.Create(inner.children, ns=cns, module=cmod)
                    elif cop == "replace":
                        inner = _from_data_recursive(child, global_identity, val, loose, set_ns=False, root_path=root_path, spath=spath + [PathElement(child)])
                        children[uname(child)] = yang.gdata.Replace(inner.children, ns=cns, module=cmod)
                    else:
                        maybe = _from_data_recursive(child, global_identity, val, loose, set_ns=s.namespace != child.namespace, root_path=root_path, spath=spath + [PathElement(child)])
                        children[uname(child)] = maybe
                elif isinstance(val, dict):
                    maybe = _from_data_recursive(child, global_identity, val, loose, set_ns=s.namespace != child.namespace, root_path=root_path, spath=spath + [PathElement(child)])
                    children[uname(child)] = maybe
                else:
                    children[uname(child)] = yang.gdata.Container({})
            else:
                # Missing container: if this is a non-presence container and it has
                # mandatory content, then raise an error in strict mode.
                if not loose and isinstance(child, yang.schema.DContainer) and not child.presence:
                    if has_mandatory_content(child):
                        raise ValueError("Error reading {format_schema_path(path_with_child())}: Cannot find xml child with name {child.name}")

        elif isinstance(child, yang.schema.DList):
            list_val = data.take_list(child, child.name, ns, spath)
            list_elements = []

            def unwrap_key[T](name: str, val: ?T) -> T:
                if val is not None:
                    return val
                raise ValueError("Missing key value at {format_schema_path(path_with_child())}: {name}")

            for element_data in list_val:
                if isinstance(element_data, xml.Node):
                    # Extract key values for better error context directly from the data (XML)
                    key_values = {}
                    for key_name in child.key:
                        key_node = unwrap_key(key_name, yang.gdata.get_xml_opt_child(element_data, key_name))
                        key_values[key_name] = unwrap_key(key_name, key_node.text)
                    # Check NETCONF operation on the element
                    eop = get_netconf_operation(element_data)
                    if eop in ["remove", "delete"]:
                            # Build element to extract proper key leaves, then create Absent/Delete with keys
                            eg = _from_data_recursive(child, global_identity, element_data, loose, set_ns=False, root_path=root_path, spath=spath + [PathElement(child, key_values)])
                            key_children = {key: unwrap_key(key, eg.children.get(key)) for key in child.key}
                            if eop == "remove":
                                list_elements.append(yang.gdata.Absent(key_children))
                            else:
                                list_elements.append(yang.gdata.Delete(key_children))
                    elif eop in ["create", "replace"]:
                        eg = _from_data_recursive(child, global_identity, element_data, loose, set_ns=False, root_path=root_path, spath=spath + [PathElement(child, key_values)])
                        if eop == "create":
                            list_elements.append(yang.gdata.Create(eg.children))
                        else:
                            list_elements.append(yang.gdata.Replace(eg.children))
                    else:
                        element_gdata = _from_data_recursive(child, global_identity, element_data, loose, set_ns=False, root_path=root_path, spath=spath + [PathElement(child, key_values)])
                        list_elements.append(element_gdata)
                elif isinstance(element_data, dict):
                    # Extract key values for better error context directly from the data (JSON)
                    key_values = {k: unwrap_key(k, element_data.get(k)) for k in child.key}
                    element_gdata = _from_data_recursive(child, global_identity, element_data, loose, set_ns=False, root_path=root_path, spath=spath + [PathElement(child, key_values)])
                    list_elements.append(element_gdata)
                else:
                    raise ValueError("Unsupported type for list element at {format_schema_path(path_with_child())}: {type(element_data)}")
            if list_elements:
                list_gdata = yang.gdata.List(child.key, list_elements, user_order=_user_order(child.ordered_by), ns=ns, module=mod)
                children[uname(child)] = list_gdata

        elif isinstance(child, yang.schema.DLeafList):
            leaflist_val = data.take_leaflist(child, child.name, ns, spath)
            if len(leaflist_val) > 0:
                if child.type_.name == "identityref":
                    validated_values = []
                    for val in leaflist_val:
                        ival = val.val
                        if isinstance(ival, PartialIdentityref):
                            validated, error = complete_and_validate_identityref(
                                ival, global_identity, child.type_.base, child.module
                            )
                            if validated is not None:
                                validated_values.append(validated)
                            else:
                                raise ValueError("Invalid value for identityref leaf-list at {format_schema_path(path_with_child())}: {error}")
                        else:
                            raise ValueError("Expected PartialIdentityref for identityref leaf-list at {format_schema_path(path_with_child())}, got {type(ival)}")
                    if len(validated_values) > 0:
                        children[uname(child)] = yang.gdata.LeafList("identityref", validated_values, user_order=_user_order(child.ordered_by))
                else:
                    # Unwrap typed tuples
                    unwrapped_values: list[value] = []
                    for item in leaflist_val:
                        iv = item.val
                        if iv is not None:
                            unwrapped_values.append(iv)
                    leaflist_type = "union" if child.type_.name == "union" else (leaflist_val[0].t)
                    if len(unwrapped_values) > 0:
                        children[uname(child)] = yang.gdata.LeafList(leaflist_type, unwrapped_values, user_order=_user_order(child.ordered_by))

        elif isinstance(child, yang.schema.DLeaf):
            typed = None
            # If XML, inspect NETCONF operation first
            if isinstance(data, xml.Node):
                leaf_node = yang.gdata.get_xml_opt_child(data, child.name, ns)
                if leaf_node is not None:
                    lop = get_netconf_operation(leaf_node)
                    if lop == "remove":
                        # Represent removal of the leaf
                        children[uname(child)] = yang.gdata.Absent()
                        # Skip normal value parsing
                        typed = None
                        # Continue to next child
                        continue
                    elif lop == "delete":
                        children[uname(child)] = yang.gdata.Delete()
                        typed = None
                        continue
                    # create/replace for leaf are treated as normal set; a scalar set replaces any prior value
            typed = data.take_leaf(child, child.name, ns, spath)
            if typed is not None:
                # identityref validation
                if child.type_.name == "identityref":
                    ival = typed.val
                    if isinstance(ival, PartialIdentityref):
                        validated, error = complete_and_validate_identityref(
                            ival, global_identity, child.type_.base, child.module
                        )
                        if validated is not None:
                            children[uname(child)] = yang.gdata.Leaf("identityref", validated)
                        else:
                            raise ValueError("Invalid value for identityref at {format_schema_path(path_with_child())}: {error}")
                    else:
                        raise ValueError("Expected PartialIdentityref for identityref leaf at {format_schema_path(path_with_child())}, got {type(typed.val)}")
                else:
                    # Determine concrete type
                    leaf_ns = None
                    leaf_module = None
                    if ns is not None:
                        leaf_ns = child.namespace
                        leaf_module = child.module
                    concrete_type = typed.t
                    av = typed.val
                    if child.type_.name == "union":
                        if av is not None:
                            # For XML, keep the original textual representation; for JSON, preserve actual type
                            if source_is_xml and not isinstance(av, bytes):
                                children[uname(child)] = yang.gdata.Leaf("union", str(av), ns=leaf_ns, module=leaf_module)
                            else:
                                children[uname(child)] = yang.gdata.Leaf("union", av, ns=leaf_ns, module=leaf_module)
                    else:
                        if av is not None:
                            children[uname(child)] = yang.gdata.Leaf(concrete_type, av, ns=leaf_ns, module=leaf_module)
            else:
                # Missing leaf value
                if not loose and child.mandatory:
                    # Match legacy error format expected by tests
                    raise ValueError("Error reading {format_schema_path(path_with_child())}: Cannot find xml child with name {child.name}")
        else:
            raise ValueError(f"Unknown schema node type at {format_schema_path(path_with_child())}: {child}")

    if isinstance(s, yang.schema.DContainer):
        return yang.gdata.Container(children, presence=s.presence, ns=s.namespace if set_ns and s.namespace != "" else None, module=s.module if set_ns and s.module != "" else None)
    elif isinstance(s, yang.schema.DList) or isinstance(s, yang.schema.DRoot):
        # When processing a list element, return it as a Container
        # The List wrapper is created by the parent when processing all elements
        return yang.gdata.Container(children)
    elif isinstance(s, yang.schema.DOutput):
        return yang.gdata.Container(children)
    else:
        raise ValueError("Unknown schema node type at {format_schema_path(spath)}: {type(s)}")


def pradata(root: yang.schema.DRoot, node: yang.gdata.Node, self_name: str="ad", loose: bool=False, root_path: list[str]=[]):
    return _pradata_recursive(root, node, self_name, loose, top=True, root_path=root_path, spath=[PathElement(root)])


def _pradata_recursive(s: yang.schema.DNodeInner, node: yang.gdata.Node, self_name: str, loose: bool=False, top: bool=False, list_element: bool=False, root_path: list[str]=[], spath: list[PathElement]=[]):
    # Navigate to root path if specified
    if root_path != [] and len(spath) - 1 < len(root_path):
        next = root_path[len(spath) - 1]
        local_name, module = _parse_qualified_name(next)
        child = s.get(local_name, module=module, allow_unqualified=False)
        if isinstance(child, yang.schema.DNodeInner):
            return _pradata_recursive(child, node, self_name, loose, top, list_element, root_path, spath + [PathElement(child)])
        raise ValueError("Node at {format_schema_path(spath + [PathElement(child)])} is not inner: {type(child)}")

    def pname(n):
        return yang.schema.get_path_name(n)

    def _find_non_optional_subtree(container: yang.schema.DNodeInner, node: yang.gdata.Node, path: list[str], local_prefix="_") -> (list[str], list[str]):
        r"""Discover the non-optional descendants of a container

        The container here is either a DContainer or a DList (representing
        a list element). We recursively traverse the child nodes of the
        container, looking for non-optional leaves and containers. A
        container is non-optional if it is not a presence container and it
        contains other non-optional nodes.

        As we traverse the tree, we build intermediate container objects
        using their non-optional arguments.

        Args:
            container: The container node to analyze
            path: List of attribute names representing the path from the root
                    to the current container (e.g. ['self', 'child1', 'child2'])
            local_prefix: Prefix used for variable access in generated code,
                            typically "_" for local variables or "" for self references

        The function returns a tuple of two lists:
        - non_optional_args: list of non-optional arguments for the outer container
        - non_optional_containers: list of code lines that declare the
        intermediate containers and their arguments

        Note on f-string evaluation timing:
        This function uses nested f-strings with two evaluation phases:
        1. Generation-time: Outer f-strings resolve class names, paths, variable names
        2. Runtime: Inner f-strings ({{...}}) become {...} and evaluate when pradata() executes.
        """
        non_optional_args = []
        non_optional_containers = []
        unique_namer = yang.schema._UniqueNamer(container)

        for cchild in container.children:
            if not (isinstance(cchild, yang.schema.DNodeLeaf) or isinstance(cchild, yang.schema.DContainer) or isinstance(cchild, yang.schema.DList)):
                continue
            if isinstance(cchild, yang.schema.DLeaf):
                # The list of children is already sorted so that key leaves
                # come first in the correct order.
                if not yang.schema.is_optional_arg_yang_leaf(cchild, loose):
                    taker_name = yang.schema.taker_name(cchild, "gdata", loose)
                    taken_node = GDATA_TAKERS[taker_name](node, unique_namer.unique_name(cchild.name, cchild.prefix))
                    if taken_node is not None:
                        non_optional_args.append("{repr(taken_node)}")
                    else:
                        raise ValueError("Missing non-optional leaf {pname(cchild)}")
            elif isinstance(cchild, yang.schema.DContainer):
                if not (cchild.presence or loose or yang.schema.optional_subtree(cchild)):
                    cchild_safe_name = unique_namer.unique_safe_name(cchild.name, cchild.prefix)

                    # Recursively build subtree for non-optional children
                    sub_args, sub_containers = _find_non_optional_subtree(cchild, node.get_cnt(cchild.name), path + [cchild_safe_name], local_prefix)

                    # Create variable declaration for this container
                    mcchild_var = "{'_'.join(path)}_{cchild_safe_name}"

                    if sub_args:
                        sub_args_str = ", ".join(sub_args)
                        non_optional_containers.append("{mcchild_var} = {pname(cchild)}({sub_args_str})")
                    else:
                        non_optional_containers.append("{mcchild_var} = {pname(cchild)}()")

                    # Add nested variable declarations
                    non_optional_containers.extend(sub_containers)

                    non_optional_args.append(mcchild_var)

        return non_optional_args, non_optional_containers

    unique_namer = yang.schema._UniqueNamer(s)
    def usname(n) -> str:
        return unique_namer.unique_safe_name(n.name, n.prefix)
    def uname(n) -> str:
        return unique_namer.unique_name(n.name, n.prefix)
    res = []
    if top:
        res.append('# Top node: {format_schema_path(spath)}')
        # Build constructor arguments for non-optional children (same logic as in __init__)
        constructor_args, constructor_containers = _find_non_optional_subtree(s, node, ["self"], local_prefix="")
        if constructor_args:
            # Add variable declarations in reverse order to ensure dependencies are declared before use.
            # For example, if container C needs argument from container B, which needs argument from A,
            # we must generate: A_var = ..., B_var = ..., C_var = ... in that order.
            # Since find_non_optional_subtree() builds the list depth-first, we reverse it.
            res.extend(list(reversed(constructor_containers)))
            args_str = ", ".join(constructor_args)
            res.append("{self_name} = {pname(s)}({args_str})")
        else:
            res.append("{self_name} = {pname(s)}()")
    leaves = []
    for child in s.children:
        # Only process data nodes
        if not (isinstance(child, yang.schema.DNodeLeaf) or isinstance(child, yang.schema.DContainer) or isinstance(child, yang.schema.DList)):
            continue

        def path_with_child(k=None):
            return spath + [PathElement(child, k)]

        taker_name = yang.schema.taker_name(child, "gdata", loose)
        taken_nodes = None
        try:
            taken_nodes = GDATA_TAKERS[taker_name](node, uname(child))
        except ValueError as err:
            raise ValueError("Error reading {format_schema_path(path_with_child())}: {err.error_message}")

        if taken_nodes is not None:
            if isinstance(child, yang.schema.DNodeLeaf):
                if not top and not yang.schema.is_optional_arg_yang_leaf(child, loose):
                    # Do not print non-optional leafs if not top level, because
                    # they are implicitly set with .create*()
                    continue
                # DLeaf and DLeafList are both copied verbatim, except for empty
                # leaf-list. The gdata takers for leaf-list return an empty list
                # as default: (see yang.gdata.get_opt_*s)
                if isinstance(child, yang.schema.DLeafList) and isinstance(taken_nodes, list) and len(taken_nodes) == 0:
                    continue
                leaves.append("{self_name}.{usname(child)} = {repr(taken_nodes)}")
            elif isinstance(child, yang.schema.DContainer) and isinstance(taken_nodes, yang.gdata.Container):
                if child.presence:
                    res.append("")
                    res.append("# P-container: {format_schema_path(path_with_child())}")
                    # Build .pradata() code for this P-container
                    pc_args, pc_var_declarations = _find_non_optional_subtree(child, taken_nodes, [usname(child)])

                    # Add variable declarations in reverse order to ensure the prerequisites are met
                    res.extend(list(reversed(pc_var_declarations)))

                    child_accessor = yang.schema._safe_name(child.name)
                    pc_args_str = ", ".join(pc_args)
                    res.append("{child_accessor} = {self_name}.create_{usname(child)}({pc_args_str})")
                    # Recursive call to pradata() for the P-container, to fill in the rest of the optional children
                    res.extend(_pradata_recursive(child, taken_nodes, usname(child), loose, root_path=root_path, spath=spath + [PathElement(child)]).splitlines())
                else:
                    res.extend(_pradata_recursive(child, taken_nodes, "{self_name}.{usname(child)}", loose, root_path=root_path, spath=spath + [PathElement(child)]).splitlines())
            elif isinstance(child, yang.schema.DList) and isinstance(taken_nodes, yang.gdata.List):
                for element in taken_nodes.elements:
                    res.append("")
                    res.append("# List {format_schema_path(path_with_child())} element: {element.key_str(child.key)}")

                    # Build the list of arguments for create() method
                    list_create_args = []

                    non_optional_args, non_optional_containers = _find_non_optional_subtree(child, element, ["element"])

                    res.extend(list(reversed(non_optional_containers)))
                    list_create_args.extend(non_optional_args)

                    create_args_str = ", ".join(list_create_args)
                    res.append("{usname(child)}_element = {self_name}.{usname(child)}.create({create_args_str})")
                    # Recursive call to pradata() for the list element
                    res.extend(_pradata_recursive(child, element, "{usname(child)}_element", loose, list_element=True, root_path=root_path, spath=path_with_child(element.key_values(child.key))).splitlines())
            else:
                raise ValueError("Unhandled child type in .pradata() at {format_schema_path(path_with_child())}: {type(child)}")

    # Add the leaves as a single group at the beginning of the section,
    # optionally add container header if we're not printing a list element
    if leaves:
        if not list_element:
            res = ["", "# Container: {format_schema_path(spath)}"] + leaves + res
        else:
            res = leaves + res
    return "\n".join(res)

def _test_y1_xml():
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    description "Container 1";
    leaf l1 {
      type string;
      description "Leaf 1";
    }
    list l2 {
      key "k1";
      leaf k1 {
        type string;
        description "Key 1";
      }
      leaf v1 {
        type string;
        description "Value 1";
      }
    }
    leaf-list ll1 {
      type string;
      description "Leaf List 1";
    }
  }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y1">
  <l1>Value for l1</l1>
  <l2>
    <k1>Key 1</k1>
    <v1>Value for v1</v1>
  </l2>
  <ll1>Item 1</ll1>
  <ll1>Item 2</ll1>
</c1>
</data>"""

    s = yang.compile([y1])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_mandatory_leaf():
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;
  container c1 {
    leaf l1 {
      type string;
      mandatory true;
    }
  }
}"""
    s = yang.compile([y1])

    try:
        from_data(s, xml.decode('<data><c1 xmlns="urn:example:y1"/></data>'))
    except ValueError as err:
        if err.error_message != "Error reading /c1/l1: Cannot find xml child with name l1":
            testing.error("Unexpected error: {err}")


def _test_y1_json():
    """Test JSON parsing with the same schema as XML test"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    description "Container 1";
    leaf l1 {
      type string;
      description "Leaf 1";
    }
    list l2 {
      key "k1";
      leaf k1 {
        type string;
        description "Key 1";
      }
      leaf v1 {
        type string;
        description "Value 1";
      }
    }
    leaf-list ll1 {
      type string;
      description "Leaf List 1";
    }
  }
}"""

    json_data = {
        "y1:c1": {
            "l1": "Value for l1",
            "l2": [
                {
                    "k1": "Key 1",
                    "v1": "Value for v1"
                }
            ],
            "ll1": ["Item 1", "Item 2"]
        }
    }

    s = yang.compile([y1])
    gd = from_data(s, json_data)
    return gd.prsrc()


def _test_root_path():
    """Test root_path argument for navigating to nested containers"""
    y1 = r"""module acme-y1 {
  namespace "urn:example:acme-y1";
  prefix y1;

  container top {
    description "Top container";
    container nested {
      description "Nested container";
      leaf value {
        type string;
        description "Test value";
      }
    }
  }
}"""

    xml_in = r"""<data>
  <nested>
    <value>test data</value>
  </nested>
</data>"""

    s = yang.compile([y1])

    # Start parsing at the /acme-y1:top container (acme-y1 is the module name, not prefix)
    gd_nested = from_data(s, xml.decode(xml_in), root_path=["acme-y1:top"])

    return gd_nested.prsrc()

def _test_error_path_json_list_range():
    """Error path includes list key predicate for JSON payloads"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    list l2 {
      key "k1";
      leaf k1 { type string; }
      leaf v1 {
        type uint8 { range 1..10; }
      }
    }
  }
}"""

    s = yang.compile([y1])
    # v1 is out of range (100)
    json_in = {"y1:c1": {"l2": [{"k1": "Key 1", "v1": "100"}]}}
    try:
        from_data(s, json_in)
    except ValueError as err:
        return str(err)
    raise AssertionError("Expected error not raised")

def _test_error_path_xml_leaf_range():
    """Error path includes nested container for XML payloads"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container top {
    container nested {
      leaf value { type uint8 { range "0..5"; } }
    }
  }
}"""

    xml_in = r"""<data>
<top xmlns="urn:example:y1">
  <nested>
    <value>42</value>
  </nested>
</top>
</data>"""

    s = yang.compile([y1])
    try:
        from_data(s, xml.decode(xml_in))
    except ValueError as err:
        return str(err)
    raise AssertionError("Expected error not raised")


def _test_uint64_edge_json_ok_max_keyword():
    """uint64 accepts max value when range uses 'max'"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c {
    leaf u {
      type uint64 { range "0..max"; }
    }
  }
}"""

    s = yang.compile([y1])
    # Use the maximum uint64 value
    json_in = {"y1:c": {"u": "18446744073709551615"}}
    # Should not raise
    gd = from_data(s, json_in)


def _test_uint64_edge_json_fail_overflow():
    """uint64 rejects value above max with explicit bound"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c {
    leaf u {
      type uint64 { range "0..18446744073709551615"; }
    }
  }
}"""

    s = yang.compile([y1])
    # One above max
    json_in = {"y1:c": {"u": "18446744073709551616"}}
    try:
        from_data(s, json_in)
    except ValueError as err:
        return str(err)
    raise AssertionError("Expected error not raised")


def _test_missing_list_key_json():
    """Test error message when list key is missing in JSON"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    list l1 {
      key "k1 k2";
      leaf k1 { type string; }
      leaf k2 { type string; }
      leaf v1 { type string; }
    }
  }
}"""

    s = yang.compile([y1])
    # Missing k2 key in the list element
    json_in = {"y1:c1": {"l1": [{"k1": "key1", "v1": "value1"}]}}
    try:
        from_data(s, json_in)
        testing.error("Expected ValueError not raised")
    except ValueError as err:
        testing.assertEqual("Missing key value at /c1/l1: k2", err.error_message)


def _test_missing_list_key_xml():
    """Test error message when list key is missing in XML"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    list l1 {
      key "k1 k2";
      leaf k1 { type string; }
      leaf k2 { type int32; }
      leaf v1 { type string; }
    }
  }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y1">
  <l1>
    <k1>key1</k1>
    <v1>value1</v1>
  </l1>
</c1>
</data>"""

    s = yang.compile([y1])
    try:
        from_data(s, xml.decode(xml_in))
        testing.error("Expected ValueError not raised")
    except ValueError as err:
        expected = "Missing key value at /c1/l1: k2"
        testing.assertEqual(expected, err.error_message)


def _test_format_schema_path_empty():
    """format_schema_path renders empty as ''"""
    path: list[PathElement] = []
    out = format_schema_path(path)
    if out != "":
        testing.error("Unexpected path: {out}")


def _test_format_schema_path_root():
    """format_schema_path renders root as '/'"""
    path: list[PathElement] = [PathElement(yang.schema.DRoot())]
    out = format_schema_path(path)
    if out != "/":
        testing.error("Unexpected path: {out}")


def _test_format_schema_path_list_predicate():
    """format_schema_path renders list key predicate"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c {
    list l {
      key "k1";
      leaf k1 { type string; }
      leaf v { type string; }
    }
  }
}"""

    s = yang.compile([y1])
    # Locate nodes using schema get()
    cnode = s.get("c")
    lnode = cnode.get("l")
    vnode = lnode.get("v")

    path = [PathElement(s), PathElement(cnode), PathElement(lnode, keys={"k1": "Key 1"}), PathElement(vnode)]
    out = format_schema_path(path)
    expected = "/c/l[k1='Key 1']/v"
    if out != expected:
        testing.error("Unexpected path: {out}")


def _test_json_path_basic():
    """Test basic JSON path navigation"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    leaf l1 {
      type string;
    }
    container c2 {
      leaf l2 {
        type string;
      }
    }
  }
}"""

    s = yang.compile([y1])

    # Test navigating to a leaf in a nested container
    gd = from_json_path(s, {"l2": "test value"}, ["y1:c1", "c2"])
    expected = yang.gdata.Container({
        "c1": yang.gdata.Container({
            "c2": yang.gdata.Container({
                "l2": yang.gdata.Leaf("string", "test value")
            })
        }, ns='urn:example:y1', module='y1')
    })
    testing.assertEqual(gd.prsrc(), expected.prsrc())


def _test_json_path_qualified_names():
    """Test JSON path with module-qualified names"""
    mod1 = r"""module mod1 {
  namespace "urn:example:mod1";
  prefix m1;

  container c1 {
    leaf l1 {
      type string;
    }
  }
}"""

    mod2 = r"""module mod2 {
  namespace "urn:example:mod2";
  prefix m2;
  import mod1 { prefix m1; }

  augment "/m1:c1" {
    leaf l2 {
      type string;
    }
  }
}"""

    s = yang.compile([mod1, mod2])

    # Test navigating with qualified name
    gd = from_json_path(s, {"mod2:l2": "augmented value"}, ["mod1:c1"])
    expected = yang.gdata.Container({
        "c1": yang.gdata.Container({
            "l2": yang.gdata.Leaf("string", "augmented value", ns="urn:example:mod2", module="mod2")
        }, ns="urn:example:mod1", module="mod1")
    })
    testing.assertEqual(gd.prsrc(), expected.prsrc())


def _test_json_path_list():
    """Test JSON path navigation to list elements"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    list l1 {
      key name;
      leaf name {
        type string;
      }
      leaf value {
        type string;
      }
      container inner {
        leaf data {
          type string;
        }
      }
    }
  }
}"""

    s = yang.compile([y1])

    # Test navigating to a specific list element
    gd = from_json_path(s, {"name": "test", "value": "data"}, ["y1:c1", "l1", "test"])
    # Should create a list with single element
    expected = yang.gdata.Container({
      'c1': yang.gdata.Container({
        'l1': yang.gdata.List(['name'], elements=[
          yang.gdata.Container({
            'name': yang.gdata.Leaf('string', 'test'),
            'value': yang.gdata.Leaf('string', 'data')
          })
        ])
      }, ns='urn:example:y1', module='y1')
    })
    testing.assertEqual(gd.prsrc(), expected.prsrc())


def _test_json_path_remove():
    """Test JSON path with remove operation"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    list l1 {
      key name;
      leaf name {
        type string;
      }
      leaf value {
        type string;
      }
    }
  }
}"""

    s = yang.compile([y1])

    # Test remove operation on a list element
    gd = from_json_path(s, {}, ["y1:c1", "l1", "test"], "remove")
    # Should contain an Absent node with the key
    expected = yang.gdata.Container({
      'c1': yang.gdata.Container({
        'l1': yang.gdata.List(['name'], elements=[
          yang.gdata.Absent({
            'name': yang.gdata.Leaf('string', 'test')
          })
        ])
      }, ns='urn:example:y1', module='y1')
    })
    testing.assertEqual(gd.prsrc(), expected.prsrc())


def _test_json_path_errors():
    """Test error handling in JSON path navigation"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    leaf l1 {
      type string;
    }
  }
}"""

    s = yang.compile([y1])

    # Test missing namespace qualification
    try:
        from_json_path(s, {}, ["y1:c1", "nonexistent"])
        testing.error("Should have raised ValueError for missing namespace qualification")
    except ValueError as e:
        testing.assertIn("Child 'nonexistent' not found", e.error_message)

    # Test navigating beyond leaf
    try:
        from_json_path(s, {}, ["y1:c1", "l1", "beyond"])
        testing.error("Should have raised ValueError for navigating beyond leaf")
    except ValueError as e:
        testing.assertIn("Invalid JSON path to non-inner node", e.error_message)

    # Test invalid operation
    try:
        from_json_path(s, {}, ["y1:c1"], "invalid")
        testing.error("Should have raised ValueError for invalid operation")
    except ValueError as e:
        testing.assertIn("Invalid operation", e.error_message)


def _test_json_path_nested_lists():
    """Test JSON path navigation through nested lists"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    list outer {
      key "outer-key";
      leaf outer-key {
        type string;
      }
      list inner {
        key "inner-key";
        leaf inner-key {
          type string;
        }
        leaf value {
          type string;
        }
        list deep {
          key "deep-key";
          leaf deep-key {
            type string;
          }
          leaf data {
            type int32;
          }
        }
      }
    }
  }
}"""

    s = yang.compile([y1])

    # Test navigating to a nested list element
    gd = from_json_path(s, {"value": "test-value"}, ["y1:c1", "outer", "key1", "inner", "key2"])
    expected = yang.gdata.Container({
        'c1': yang.gdata.Container({
            'outer': yang.gdata.List(['outer-key'], elements=[
                yang.gdata.Container({
                    'outer-key': yang.gdata.Leaf('string', 'key1'),
                    'inner': yang.gdata.List(['inner-key'], elements=[
                        yang.gdata.Container({
                            'inner-key': yang.gdata.Leaf('string', 'key2'),
                            'value': yang.gdata.Leaf('string', 'test-value')
                        })
                    ])
                })
            ])
        }, ns='urn:example:y1', module='y1')
    })
    testing.assertEqual(gd.prsrc(), expected.prsrc())

    # Test navigating to a deeply nested list element (3 levels)
    gd2 = from_json_path(s, {"data": 42}, ["y1:c1", "outer", "key1", "inner", "key2", "deep", "key3"])
    expected2 = yang.gdata.Container({
        'c1': yang.gdata.Container({
            'outer': yang.gdata.List(['outer-key'], elements=[
                yang.gdata.Container({
                    'outer-key': yang.gdata.Leaf('string', 'key1'),
                    'inner': yang.gdata.List(['inner-key'], elements=[
                        yang.gdata.Container({
                            'inner-key': yang.gdata.Leaf('string', 'key2'),
                            'deep': yang.gdata.List(['deep-key'], elements=[
                                yang.gdata.Container({
                                    'deep-key': yang.gdata.Leaf('string', 'key3'),
                                    'data': yang.gdata.Leaf('int32', 42)
                                })
                            ])
                        })
                    ])
                })
            ])
        }, ns='urn:example:y1', module='y1')
    })
    testing.assertEqual(gd2.prsrc(), expected2.prsrc())

def _test_netconf_remove_container():
    """NETCONF remove on a container produces Absent"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 {
    presence "p";
    leaf l1 { type string; }
  }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y" xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="remove"/>
</data>"""

    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_remove_list_element():
    """NETCONF remove on a list element produces Absent with key children"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 {
    list l2 {
      key "k1";
      leaf k1 { type string; }
      leaf v1 { type string; }
    }
  }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y">
  <l2 xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="remove">
    <k1>Key 1</k1>
  </l2>
</c1>
</data>"""

    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_remove_leaf():
    """NETCONF remove on a leaf produces Absent"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 {
    leaf l1 { type string; }
  }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y">
  <l1 xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="remove"/>
</c1>
</data>"""

    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_replace_leaf_sets_value():
    """NETCONF replace on a leaf is treated as a normal set"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 {
    leaf l1 { type string; }
  }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y">
  <l1 xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="replace">VAL</l1>
</c1>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_remove_mixed():
    """Mixed normal and remove elements in the same list"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  list l {
    key "k";
    leaf k { type string; }
    leaf v { type string; }
  }
}"""

    xml_in = r"""<data>
<l xmlns="urn:example:y">
  <k>A</k>
  <v>keep</v>
</l>
<l xmlns="urn:example:y" xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="remove">
  <k>B</k>
</l>
</data>
"""

    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_create_list_element():
    """NETCONF create on a list element renders operation and content"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 {
    list l2 {
      key "k1";
      leaf k1 { type string; }
      leaf v1 { type string; }
    }
  }
}"""
    xml_in = r"""<data>
<c1 xmlns="urn:example:y">
  <l2 xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="create">
    <k1>X</k1>
    <v1>Y</v1>
  </l2>
</c1>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_replace_list_element():
    """NETCONF replace on a list element renders operation and content"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 {
    list l2 {
      key "k1";
      leaf k1 { type string; }
      leaf v1 { type string; }
    }
  }
}"""
    xml_in = r"""<data>
<c1 xmlns="urn:example:y">
  <l2 xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="replace">
    <k1>Z</k1>
    <v1>W</v1>
  </l2>
</c1>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_delete_list_element():
    """NETCONF delete on a list element renders operation with keys only"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 {
    list l2 {
      key "k1";
      leaf k1 { type string; }
      leaf v1 { type string; }
    }
  }
}"""
    xml_in = r"""<data>
<c1 xmlns="urn:example:y">
  <l2 xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="delete">
    <k1>DEL</k1>
  </l2>
</c1>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_union_int_json():
    """Union(int8 range 1..10 | string): textual int within range resolves as int"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  leaf u {
    type union {
      type int8 { range 1..10; }
      type string;
    }
  }
}"""
    s = yang.compile([y])
    jd = {"y:u": "7"}
    gd = from_data(s, jd)
    return gd.prsrc()

def _test_union_str_json():
    """Union(int8 range 1..10 | string): textual int out of range resolves as string"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  leaf u {
    type union {
      type int8 { range 1..10; }
      type string;
    }
  }
}"""
    s = yang.compile([y])
    jd = {"y:u": "100"}
    gd = from_data(s, jd)
    return gd.prsrc()

def _test_union_str_xml():
    """Union(int8 range 1..10 | string): XML numeric text out of range resolves as string"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  leaf u {
    type union {
      type int8 { range 1..10; }
      type string;
    }
  }
}"""
    xml_in = r"""<data>
<u xmlns="urn:example:y">100</u>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_union_binary_xml():
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  leaf u {
    type union {
      type enumeration { enum "unlimited"; }
      type binary;
    }
  }
}"""
    xml_in = r"""<data>
<u xmlns="urn:example:y">aGk=</u>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    print(gd.get_bytes('u'))
    testing.assertEqual(gd.get_bytes('u'), "hi".encode())
    return gd.prsrc()

def _test_union_binary_json():
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  leaf u {
    type union {
      type enumeration { enum "unlimited"; }
      type binary;
    }
  }
}"""
    s = yang.compile([y])
    jd = {"y:u": "aGk="}
    gd = from_data(s, jd)
    testing.assertEqual(gd.get_bytes('u'), "hi".encode())
    return gd.prsrc()

def _test_netconf_create_container():
    """NETCONF create on a container produces Create wrapper and serializes op"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 { leaf l1 { type string; } }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y" xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="create">
  <l1>v</l1>
</c1>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_replace_container():
    """NETCONF replace on a container produces Replace wrapper and serializes op"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 { leaf l1 { type string; } }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y" xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="replace">
  <l1>nv</l1>
</c1>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_delete_container():
    """NETCONF delete on a container produces Delete wrapper and serializes op"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 { leaf l1 { type string; } }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y" xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="delete"/>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

    # Test remove operation on nested list element
    gd3 = from_json_path(s, {}, ["y1:c1", "outer", "key1", "inner", "key2"], "remove")
    expected3 = yang.gdata.Container({
        'c1': yang.gdata.Container({
            'outer': yang.gdata.List(['outer-key'], elements=[
                yang.gdata.Container({
                    'outer-key': yang.gdata.Leaf('string', 'key1'),
                    'inner': yang.gdata.List(['inner-key'], elements=[
                        yang.gdata.Absent({
                            'inner-key': yang.gdata.Leaf('string', 'key2')
                        })
                    ])
                })
            ])
        }, ns='urn:example:y1', module='y1')
    })
    testing.assertEqual(gd3.prsrc(), expected3.prsrc())


def _test_pradata():
    schema_str = r"""module test {
      namespace "urn:example:test";
      prefix test;

      leaf top-level-leaf {
        type string;
        description "A leaf at the module root level";
      }

      container c1 {
        leaf optional-leaf {
          type int32;
        }
        container c2 {
          presence "This is a presence container";
          leaf l1 {
            type string;
          }
          leaf mandatory-leaf {
            type string;
            mandatory true;
          }
        }
        list li1 {
          key name;
          leaf name {
            type string;
          }
          leaf value {
            type int32;
          }
          container c3 {
            leaf nested-leaf {
              type string;
            }
          }
        }
        leaf-list always-empty {
          // Leave this empty, we check that empty leaf-list is not printed
          type string;
        }
      }
    }"""

    s = yang.compile([schema_str])

    gdata_tree = yang.gdata.Container({
        "top-level-leaf": yang.gdata.Leaf("string", "root value"),
        "c1": yang.gdata.Container({
            "optional-leaf": yang.gdata.Leaf("int32", 42),
            "c2": yang.gdata.Container({
                "l1": yang.gdata.Leaf("string", "inner value"),
                "mandatory-leaf": yang.gdata.Leaf("string", "required value")
            }, presence=True),
            "li1": yang.gdata.List(["name"], [
                yang.gdata.Container({
                    "name": yang.gdata.Leaf("string", "item1"),
                    "value": yang.gdata.Leaf("int32", 100)
                }),
                yang.gdata.Container({
                    "name": yang.gdata.Leaf("string", "item2"),
                    "value": yang.gdata.Leaf("int32", 200),
                    "c3": yang.gdata.Container({
                        "nested-leaf": yang.gdata.Leaf("string", "birb")
                    })
                })
            ])
        })
    })

    result = pradata(s, gdata_tree)
    return result


def _test_pradata_root_path():
    schema_str = r"""module test {
      namespace "urn:example:test";
      prefix test;

      container outer {
        container middle {
          leaf value1 {
            type string;
          }
          container inner {
            leaf value2 {
              type int32;
            }
          }
        }
      }
    }"""

    s = yang.compile([schema_str])

    gdata_tree = yang.gdata.Container({
        "outer": yang.gdata.Container({
            "middle": yang.gdata.Container({
                "value1": yang.gdata.Leaf("string", "test value"),
                "inner": yang.gdata.Container({
                    "value2": yang.gdata.Leaf("int32", 42)
                })
            })
        })
    })

    middle_node = gdata_tree.get_cnt("outer").get_cnt("middle")
    result = pradata(s, middle_node, root_path=["test:outer", "middle"])

    return result


def _test_json_path_container_list_container():
    """Test JSON path navigation through container -> list -> container pattern"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container top {
    list middle {
      key "name";
      leaf name {
        type string;
      }
      container bottom {
        leaf data {
          type string;
        }
        leaf value {
          type int32;
        }
      }
    }
  }
}"""

    s = yang.compile([y1])

    # Test navigating through container -> list -> container and setting data
    gd = from_json_path(s, {"data": "test", "value": 42}, ["y1:top", "middle", "item1", "bottom"])
    expected = yang.gdata.Container({
        'top': yang.gdata.Container({
            'middle': yang.gdata.List(['name'], elements=[
                yang.gdata.Container({
                    'name': yang.gdata.Leaf('string', 'item1'),
                    'bottom': yang.gdata.Container({
                        'data': yang.gdata.Leaf('string', 'test'),
                        'value': yang.gdata.Leaf('int32', 42)
                    })
                })
            ])
        }, ns='urn:example:y1', module='y1')
    })
    testing.assertEqual(gd.prsrc(), expected.prsrc())

    # Test remove operation on the inner container
    gd2 = from_json_path(s, {}, ["y1:top", "middle", "item1", "bottom"], "remove")
    expected2 = yang.gdata.Container({
        'top': yang.gdata.Container({
            'middle': yang.gdata.List(['name'], elements=[
                yang.gdata.Container({
                    'name': yang.gdata.Leaf('string', 'item1'),
                    'bottom': yang.gdata.Absent()
                })
            ])
        }, ns='urn:example:y1', module='y1')
    })
    testing.assertEqual(gd2.prsrc(), expected2.prsrc())
