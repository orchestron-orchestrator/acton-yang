"""Generic YANG data parser implementation

This module provides a generic algorithm for parsing YANG data from different
sources (XML, JSON) using the YangData protocol.
"""

import testing
import base64
import xml

import yang
import yang.adata
import yang.gdata
import yang.schema
from yang.identityref import Identityref, PartialIdentityref
from yang.gdata import repr_yang
from yang.type import Decimal, Ranges


OP_MERGE = "merge"
OP_CREATE = "create"
OP_DELETE = "delete"
OP_REMOVE = "remove"
OP_REPLACE = "replace"
NETCONF_OPS = {OP_CREATE, OP_DELETE, OP_REMOVE, OP_REPLACE, OP_MERGE}
NETCONF_NS = "urn:ietf:params:xml:ns:netconf:base:1.0"


class PathElement:
    """Represents an element in a schema path, with optional key values for lists"""
    node: yang.schema.DNode
    keys: ?dict[str, value]

    def __init__(self, node: yang.schema.DNode, keys: ?dict[str, value]=None):
        self.node = node
        self.keys = keys


class YangValidationError(ValueError):
    schema_path: list[PathElement]
    expected_type: yang.schema.DType
    actual_value: ?value

    def __init__(self, schema_path: list[PathElement], expected_type: yang.schema.DType, actual_value: ?value):
        self.error_message = ""
        self.schema_path = schema_path
        self.expected_type = expected_type
        self.actual_value = actual_value

    def __str__(self) -> str:
        path_str = format_schema_path(self.schema_path)
        type_str = self.expected_type.format_hint()
        return "Invalid value at {path_str}: '{self.actual_value}' - expected {type_str}"



def format_schema_path(path: list[PathElement]) -> str:
    path_str = ""

    for i, elem in enumerate(path):
        if i > 0:
            prev = path[i-1].node
            if not isinstance(prev, yang.schema.DRoot):
                path_str = path_str + "/"
            if isinstance(prev, yang.schema.DNodeInner):
                un = yang.schema._UniqueNamer(prev)
                path_str = path_str + un.unique_name(elem.node.name, elem.node.prefix)
                keys_dict = elem.keys
                if keys_dict is not None and len(keys_dict) > 0:
                    predicates = ["{k}='{(v if isinstance(v, str) else str(v)).replace("'", "\\'")}'" for k, v in keys_dict.items()]
                    path_str = path_str + "[" + ",".join(predicates) + "]"
        elif isinstance(elem.node, yang.schema.DRoot):
            path_str = "/"
        else:
            # Relative path
            path_str = elem.node.name
    return path_str


def get_netconf_operation(node: xml.Node) -> str:
    """Extract NETCONF operation from an XML node
    """
    def ns_uri(prefix: ?str) -> ?str:
        for p, uri in node.nsdefs:
            # default namespace is stored with prefix == None
            if (prefix is None and p is None) or (prefix is not None and p is not None and prefix == p):
                return uri
        return None

    for attr_key, attr_val in node.attributes:
        if attr_key == "operation":
            # Unprefixed operation; must be in default NETCONF namespace
            if attr_val in NETCONF_OPS and ns_uri(None) == NETCONF_NS:
                return attr_val
        elif attr_key.endswith(":operation"):
            # Prefixed operation; resolve prefix and validate NETCONF namespace
            prefix = attr_key.split(":", 1)[0]
            if attr_val in NETCONF_OPS and ns_uri(prefix) == NETCONF_NS:
                return attr_val

    return OP_MERGE


def _test_get_nc_op_def():
    xml_in = xml.decode('<cfg xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" operation="delete"/>')
    op = get_netconf_operation(xml_in)
    testing.assertEqual(op, "delete")


def _test_get_nc_op_pref():
    xml_in = xml.decode('<cfg xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="replace"/>')
    op = get_netconf_operation(xml_in)
    testing.assertEqual(op, "replace")


protocol YangData:
    """Protocol for YANG data nodes

    Provides a uniform interface for extracting data from different data formats
    that can carry YANG-modeled data, like XML and JSON
    """
    # TODO: can value implement YangData?
    take_container: mut(yang.schema.DContainer, str, bool, bool, list[PathElement]) -> ?value
    take_list: mut(yang.schema.DList, str, bool, bool, list[PathElement]) -> list[value]
    # Return a typed tuple for leaves. The tuple carries the concrete type name
    # and the parsed value. Missing leaves return None.
    take_leaf: mut(yang.schema.DRoot, yang.schema.DLeaf, str, bool, bool, list[PathElement]) -> ?(op: ?str, t: str, val: ?value)
    # For leaf-lists, return a list of typed tuples (t, val).
    # For identityref items, val holds a PartialIdentityref.
    take_leaflist: mut(yang.schema.DRoot, yang.schema.DLeafList, str, bool, bool, list[PathElement]) -> list[(t: str, val: ?value)]


extension xml.Node (YangData):
    def take_container(self, schema: yang.schema.DContainer, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> ?value:
        child_node = yang.gdata.get_xml_opt_child(self, name, schema.namespace if ns_qualified else None)
        if child_node is not None:
            return child_node
        return None

    def take_list(self, schema: yang.schema.DList, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> list[value]:
        elements = yang.gdata.get_xml_children(self, name, schema.namespace if ns_qualified else None)
        return elements

    mut def take_leaf(self, root: yang.schema.DRoot, schema: yang.schema.DLeaf, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> ?(op: str, t: str, val: ?value):
        new_path = path + [PathElement(schema)]
        maybe_node = yang.gdata.get_xml_opt_child(self, name, schema.namespace if ns_qualified else None)
        if maybe_node is not None:
            op = get_netconf_operation(maybe_node)
            tv = try_parse_xml_value(maybe_node.text, schema, schema.type_, new_path, maybe_node.nsdefs, root)
            if tv is not None:
                return (op=op, t=tv.t, val=tv.val)
            # TODO: schema.type_.name may not be correct (union), but it's going away soon ...
            return (op=op, t=schema.type_.name, val=None)
        else:
            return None

    def take_leaflist(self, root: yang.schema.DRoot, schema: yang.schema.DLeafList, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> list[(t: str, val: ?value)]:
        new_path = path + [PathElement(schema)]
        values: list[(t: str, val: ?value)] = []
        children = yang.gdata.get_xml_children(self, name, schema.namespace if ns_qualified else None)
        # Ignore NETCONF operation
        for child in children:
            if isinstance(child, xml.Node):
                text_value = child.text
                tv = try_parse_xml_value(text_value, schema, schema.type_, new_path, child.nsdefs, root)
                if tv is not None:
                    values.append(tv)
        return values


def try_parse_xml_value(text_value: ?str, schema_node: yang.schema.DNodeLeaf, schema_type: yang.schema.DType, path: list[PathElement], nsdefs: list[(?str, str)], root: yang.schema.DRoot) -> ?(t: str, val: value):
    """Parse a textual value according to the provided schema type.

    Returns:
        (t, val): A typed tuple with the concrete type name and native value
                  (e.g. ("uint8", 42)). For unions, returns the successful
                  member type and parsed value.

    Errors:
        Raises YangValidationError with a message including the formatted
        schema path (from the path parameter) and a textual description of the
        expected type (including range constraints if present).
    """
    type_name = schema_type.builtin_type

    if isinstance(schema_type, yang.schema.DTypeUnion):
        for alt_type in schema_type.types:
            try:
                return try_parse_xml_value(text_value, schema_node, alt_type, path, nsdefs, root)
            except YangValidationError:
                continue
        if text_value is not None:
            raise YangValidationError(path, schema_type, text_value)
        return None
    elif isinstance(schema_type, yang.schema.DTypeEmpty):
        if text_value is not None and len(text_value) != 0:
            raise YangValidationError(path, schema_type, text_value)
        return (t=type_name, val=True)

    if text_value is not None:
        val: ?value = None
        if isinstance(schema_type, yang.schema.DTypeString):
            val = text_value
        elif isinstance(schema_type, yang.schema.DTypeInteger):
            try:
                val = bigint(text_value)
            except ValueError:
                raise YangValidationError(path, schema_type, text_value)
        elif isinstance(schema_type, yang.schema.DTypeEnum):
            val = text_value
        elif isinstance(schema_type, yang.schema.DTypeDecimal64):
            val = Decimal.try_parse(text_value)
        elif isinstance(schema_type, yang.schema.DTypeBoolean):
            if text_value == "true":
                val = True
            elif text_value == "false":
                val = False
        elif isinstance(schema_type, yang.schema.DTypeBinary):
            try:
                val = base64.decode(text_value.encode())
            except ValueError:
                pass
        elif isinstance(schema_type, yang.schema.DTypeIdentityref):
            partial = Identityref.from_xml(text_value, nsdefs)
            res = yang.schema.complete_identityref(partial, root.identities, schema_node.module)
            val = res.0
        elif isinstance(schema_type, yang.schema.DTypeLeafref):
            val = text_value
        elif isinstance(schema_type, yang.schema.DTypeInstanceIdentifier):
            val = text_value
        elif isinstance(schema_type, yang.schema.DTypeBits):
            bits_val = set(None)
            for bit in text_value.split(" "):
                if bit in schema_type.name_to_pos:
                    bits_val.add(bit)
                else:
                    raise YangValidationError(path, schema_type, text_value)
            val = bits_val

        if val is not None and schema_type.validate_value(val):
            return (t=type_name, val=val)

        raise YangValidationError(path, schema_type, text_value)

    return None


extension dict[A(Hashable), B] (YangData):
    def take_container(self, schema: yang.schema.DContainer, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> ?value:
        if isinstance(self, dict):
            maybe = None
            # For cross-namespace children, only accept module-qualified keys
            if ns_qualified and schema.module is not None and schema.module != "":
                maybe = self.get(f"{schema.module}:{name}")
            else:
                maybe = self.get(name)
            if isinstance(maybe, dict):
                return maybe
        return None

    def take_list(self, schema: yang.schema.DList, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> list[value]:
        if isinstance(self, dict):
            lv = None
            if ns_qualified and schema.module is not None and schema.module != "":
                lv = self.get(f"{schema.module}:{name}")
            else:
                lv = self.get(name)
            if lv is not None:
                return lv
        return []

    def take_leaf(self, root: yang.schema.DRoot, schema: yang.schema.DLeaf, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> ?(op: ?str, t: str, val: ?value):
        new_path = path + [PathElement(schema)]
        if isinstance(self, dict):
            leaf_value = None
            if ns_qualified and schema.module is not None and schema.module != "":
                leaf_value = self.get(f"{schema.module}:{name}")
            else:
                leaf_value = self.get(name)
            if leaf_value is not None:
                tv = try_parse_json_value(leaf_value, schema, schema.type_, new_path, root)
                if tv is not None:
                    return (op=None, t=tv.t, val=tv.val)
            else:
                return None
        else:
            return None

    def take_leaflist(self, root: yang.schema.DRoot, schema: yang.schema.DLeafList, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> list[(t: str, val: ?value)]:
        values: list[(t: str, val: ?value)] = []
        if isinstance(self, dict):
            leaflist_data = None
            if ns_qualified and schema.module is not None and schema.module != "":
                leaflist_data = self.get(f"{schema.module}:{name}")
            else:
                leaflist_data = self.get(name)
            if isinstance(leaflist_data, list):
                new_path = path + [PathElement(schema)]
                for item in leaflist_data:
                    tv = try_parse_json_value(item, schema, schema.type_, new_path, root)
                    if tv is not None:
                        values.append(tv)
        return values


def try_parse_json_value(leaf_value: ?value, schema_node: yang.schema.DNodeLeaf, schema_type: yang.schema.DType, path: list[PathElement], root: yang.schema.DRoot) -> ?(t: str, val: value):
    """Parse a textual value according to the provided schema type.

    Returns:
        (t, val): A typed tuple with the concrete type name and native value
                  (e.g. ("uint8", 42)). For unions, returns the successful
                  member type and parsed value.

    Errors:
        Raises YangValidationError with a message including the formatted
        schema path (from the path parameter) and a textual description of the
        expected type (including range constraints if present).
    """
    type_name = schema_type.builtin_type

    if isinstance(schema_type, yang.schema.DTypeUnion):
        for alt_type in schema_type.types:
            try:
                return try_parse_json_value(leaf_value, schema_node, alt_type, path, root)
            except YangValidationError:
                continue
        if leaf_value is not None:
            raise YangValidationError(path, schema_type, leaf_value)
        return None
    elif isinstance(schema_type, yang.schema.DTypeEmpty):
        # Empty leaf JSON encoding: [null]
        if isinstance(leaf_value, list) and len(leaf_value) == 1 and leaf_value[0] is None:
            return (t=type_name, val=True)
        elif leaf_value is not None and schema_type.validate_value(leaf_value):
            return (t=type_name, val=True)
        raise YangValidationError(path, schema_type, leaf_value)

    if leaf_value is not None:
        val: ?value = None
        if isinstance(schema_type, yang.schema.DTypeString):
            val = leaf_value
        elif isinstance(schema_type, yang.schema.DTypeInteger):
            if isinstance(leaf_value, atom):
                try:
                    val = bigint(leaf_value)
                except ValueError:
                    raise YangValidationError(path, schema_type, leaf_value)
            else:
                raise YangValidationError(path, schema_type, leaf_value)
        elif isinstance(schema_type, yang.schema.DTypeEnum):
            val = leaf_value
        elif isinstance(schema_type, yang.schema.DTypeDecimal64):
            if isinstance(leaf_value, str):
                val = Decimal.try_parse(leaf_value)
            elif isinstance(leaf_value, float):
                # TODO: Make sure we won't receive floats as those may lose precision
                val = Decimal.try_parse(str(leaf_value))
            else:
                val = leaf_value
        elif isinstance(schema_type, yang.schema.DTypeBoolean):
            if isinstance(leaf_value, str):
                if leaf_value == "true":
                    val = True
                elif leaf_value == "false":
                    val = False
            else:
                val = leaf_value
        elif isinstance(schema_type, yang.schema.DTypeBinary):
            if isinstance(leaf_value, str):
                try:
                    val = base64.decode(leaf_value.encode())
                except ValueError:
                    pass
            else:
                val = leaf_value
        elif isinstance(schema_type, yang.schema.DTypeIdentityref):
            if isinstance(leaf_value, str):
                partial = Identityref.from_json(leaf_value)
                res = yang.schema.complete_identityref(partial, root.identities, schema_node.module)
                val = res.0
            else:
                val = leaf_value
        elif isinstance(schema_type, yang.schema.DTypeLeafref):
            val = leaf_value
        elif isinstance(schema_type, yang.schema.DTypeInstanceIdentifier):
            val = leaf_value
        elif isinstance(schema_type, yang.schema.DTypeBits):
            if isinstance(leaf_value, str):
                bits_val = set(None)
                for bit in leaf_value.split(" "):
                    if bit in schema_type.name_to_pos:
                        bits_val.add(bit)
                    else:
                        raise YangValidationError(path, schema_type, leaf_value)
                val = bits_val
            else:
                val = leaf_value

        if val is not None and schema_type.validate_value(val):
            return (t=type_name, val=val)

        raise YangValidationError(path, schema_type, leaf_value)

    return None


extension yang.adata.MNode (YangData):
    def take_container(self, schema: yang.schema.DContainer, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> ?value:
        usname = yang.schema._safe_name(name if is_unique else "{schema.prefix}_{name}")
        return self._get_attr(usname)

    def take_list(self, schema: yang.schema.DList, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> list[value]:
        usname = yang.schema._safe_name(name if is_unique else "{schema.prefix}_{name}")
        maybe_list = self._get_attr(usname)
        if maybe_list is not None and isinstance(maybe_list, Iterator):
            return list(maybe_list)
        return [] # ??

    def take_leaf(self, root: yang.schema.DRoot, schema: yang.schema.DLeaf, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> ?(op: ?str, t: str, val: ?value):
        new_path = path + [PathElement(schema)]
        usname = yang.schema._safe_name(name if is_unique else "{schema.prefix}_{name}")
        maybe_attr = self._get_attr(usname)
        if maybe_attr is not None:
            schema_type = schema.type_
            tv = try_validate_mnode_value(maybe_attr, schema_type)
            if tv is not None:
                return (op=None, t=tv.t, val=tv.val)
            raise YangValidationError(path, schema_type, maybe_attr)

    def take_leaflist(self, root: yang.schema.DRoot, schema: yang.schema.DLeafList, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> list[(t: str, val: ?value)]:
        new_path = path + [PathElement(schema)]
        values: list[(t: str, val: ?value)] = []
        usname = yang.schema._safe_name(name if is_unique else "{schema.prefix}_{name}")
        children = self._get_attr(usname)
        if isinstance(children, list):
            schema_type = schema.type_
            for child in children:
                tv = try_validate_mnode_value(child, schema_type)
                if tv is not None:
                    values.append(tv)
                else:
                    raise YangValidationError(path, schema_type, child)
        return values


def try_validate_mnode_value(val: value, schema_type: yang.schema.DType) -> ?(t: str, val: value):
    if isinstance(schema_type, yang.schema.DTypeUnion):
        if isinstance(val, int):
            # Handle case where mnode leaf value type is 'value'
            # where an assigned integer literal is by default interpreted as int rather than the bigint we want
            _val = bigint(val)
        else:
            _val = val
        for alt_type in schema_type.types:
            tv = try_validate_mnode_value(_val, alt_type)
            if tv is not None:
                return tv
    else:
        if schema_type.validate_value(val):
            return (t=schema_type.builtin_type, val=val)
    return None



def _user_order(ordered_by):
    return True if ordered_by == "user" else False


def _parse_qualified_name(name: str) -> (str, ?str):
    if ":" in name:
        parts = name.split(":", 1)
        return (parts[1], parts[0])
    return (name, None)


def has_mandatory_content(container: yang.schema.DContainer) -> bool:
    """Return True if a non-presence container has any mandatory content.

    A container has mandatory content if it contains any mandatory leaf, or
    any non-presence child container that itself has mandatory content.
    """
    for c in container.children:
        if isinstance(c, yang.schema.DLeaf):
            if c.mandatory:
                return True
        elif isinstance(c, yang.schema.DContainer):
            if not c.presence and has_mandatory_content(c):
                return True
    return False


def from_json_path(root: yang.schema.DRoot, data: dict[str, ?value], path: list[str], op: str="merge", loose: bool=False) -> yang.gdata.Container:
    r"""Convert JSON to a gdata tree rooted at the schema root, with data applied
    at the specified path.

    Unlike from_data which can create partial trees starting at any schema node,
    this function ALWAYS creates a sparse tree from the root of the schema,
    meaning that it  only creates containers and list entries required to hold
    the data at the specified path location. This is useful for NETCONF/RESTCONF
    operations where the payload is a subtree rooted in the provided query path.

    Args:
        root: Root schema node (must be the actual root, not an inner node)
        data: JSON data to apply at the target path location
        path: List of path elements to navigate from root, e.g. ["mod1:c1", "list1", "key1", "inner"]
              - Container/List names "name" or "module:name"
              - List entries: comma-separated key values, e.g. "key1,key2"
        op: Operation to perform - "merge" (default) or "remove"
        loose: Whether to allow missing mandatory fields

    Returns:
        A sparse gdata tree from root with data only at the specified path

    Examples:
        # Creates: root -> c1 -> c2 -> {leaf1: "value"}
        from_json_path(schema, {"leaf1": "value"}, ["mod:c1", "c2"])

        # Creates: root -> list1[key1] -> container -> {field: "value"}
        from_json_path(schema, {"field": "value"}, ["mod:list1", "key1", "container"])

        # Creates: root -> list1[key1] as Absent (for removal)
        from_json_path(schema, {}, ["mod:list1", "key1"], "remove")
    """
    result = _from_json_path_recursive(root, root, data, path, op, loose, [PathElement(root)], True, True)
    # The top-level call always returns a Container because:
    # - If path is empty, from_data returns Container
    # - If path is non-empty, we wrap in Container
    if isinstance(result, yang.gdata.Container):
        return result
    else:
        raise ValueError("Internal error: expected Container at root level")


def _from_json_path_recursive(root: yang.schema.DRoot, s: yang.schema.DNodeInner, data: dict[str, ?value], path: list[str], op: str, loose: bool, current_path: list[PathElement], top: bool, set_ns: bool) -> yang.gdata.Node:
    if isinstance(s, yang.schema.DRoot) or isinstance(s, yang.schema.DContainer):
        if len(path) == 0:
            # Base case: no more path elements, process the data
            if op == "merge":
                # TODO: set_ns??
                return _from_data_recursive(root, s, data, loose=loose, set_ns=set_ns, spath=current_path)
            elif op == "remove":
                return yang.gdata.Absent()
            raise ValueError("Invalid operation at {format_schema_path(current_path)}: {op}")
        else:   # len(path) > 0
            # More path to traverse - create a container with just the next child
            unique_namer = yang.schema._UniqueNamer(s)
            def uname(n):
                return unique_namer.unique_name(n.name, n.prefix)

            point = path[0]
            rest_path = path[1:]

            local_name, module = _parse_qualified_name(point)
            child = s.get(local_name, module=module, allow_unqualified=False)

            if isinstance(child, yang.schema.DNodeInner):
                # Recursively process the child node
                perhaps = True if (top or set_ns) and s.namespace != "" else False
                cchild = _from_json_path_recursive(root, child, data, rest_path, op, loose, current_path + [PathElement(child)], False, s.namespace != child.namespace)
                # Create a container with just this one child
                return yang.gdata.Container({uname(child): cchild}, ns=s.namespace if perhaps else None, module=s.module if perhaps else None)

            # Path tries to go through a leaf - this is an error
            raise ValueError("Invalid JSON path to non-inner node at {format_schema_path(current_path + [PathElement(child)])}: {point}")
    elif isinstance(s, yang.schema.DList):
        if len(path) == 1:
            # Base case: keys are the last path element
            point = path[0]
            keys = point.split(",")
            # Check that all keys are present in payload.
            # If present, they must equal the keys in the path
            # If not present, fill in from path
            data_with_keys = dict(data.items())
            for key in s.key:
                if key not in data_with_keys:
                    data_with_keys[key] = keys.pop(0)
                else:
                    if str(data_with_keys[key]) != keys.pop(0):
                        raise ValueError("Key value mismatch between path and payload at {format_schema_path(current_path)}")
            element_gdata = _from_data_recursive(root, s, data_with_keys, loose, set_ns=False, spath=current_path + [PathElement(s, {k: v for k, v in data_with_keys.items() if k in s.key and v is not None})])
            elements = []
            if op == "merge":
                elements.append(element_gdata)
            elif op == "remove":
                elements.append(yang.gdata.Absent(element_gdata.key_children(s.key)))
            else:
                raise ValueError("Invalid operation at {format_schema_path(current_path)}: {op}")
            perhaps = True if (top or set_ns) and s.namespace != "" else False
            return yang.gdata.List(s.key, elements, _user_order(s.ordered_by), ns=s.namespace if perhaps else None, module=s.module if perhaps else None)
        elif len(path) > 1:
            # The path crosses this list element and references another inner node
            point = path[0]
            rest_path = path[1:]

            # First create this list with a single element with only key children.
            # For nested lists, we always use "merge" for intermediate elements.
            slist = _from_json_path_recursive(root, s, {}, [point], "merge", loose, current_path, top, set_ns)

            # The return type must be a List, we just requested it
            if isinstance(slist, yang.gdata.List):
                # Now process the rest of the path following the structural list keys
                unique_namer = yang.schema._UniqueNamer(s)
                def uname(n):
                    return unique_namer.unique_name(n.name, n.prefix)

                child_point = rest_path[0]
                child_rest_path = rest_path[1:]

                local_name, module = _parse_qualified_name(child_point)

                lchild = s.get(local_name, module=module, allow_unqualified=False)
                if isinstance(lchild, yang.schema.DNodeInner):
                    # Now extract gdata for the rest of the path, from the child point
                    inner_result = _from_json_path_recursive(root, lchild, data, child_rest_path, op, loose, current_path + [PathElement(lchild)], False, False)

                    # Add it to the structural list element, next to the existing keys
                    slist.elements[0].children[uname(lchild)] = inner_result
                    return slist
                else:
                    raise ValueError("Node at {format_schema_path(current_path + [PathElement(lchild)])} is not inner: {type(lchild)}")

            raise ValueError("unreachable")
        raise ValueError("Unable to resolve path at {format_schema_path(current_path)}: no keys provided")


    raise ValueError("Unknown schema node type at {format_schema_path(current_path)}: {type(s)}")


def from_data[A(YangData)](root: yang.schema.DRoot, data: A, loose: bool=False, root_path: list[str]=[]) -> yang.gdata.Container:
    """Generic function to convert data to gdata tree based on schema

    Args:
        root: Root schema node (must be the actual root, not an inner node)
        data: Data wrapped in a YangData protocol implementation (XML or JSON)
        loose: Whether to use loose parsing (allows optional fields to be missing)
        root_path: Path from s to the actual data location in the input. This enables
                  partial parsing where the data doesn't start at the schema root but
                  at some inner node. For example, if root_path=["mod:c1", "c2"],
                  the function will navigate from s through c1 and c2 before starting
                  to parse the actual data.

    Returns:
        A yang.gdata.Container containing the parsed data tree
    """
    return _from_data_recursive(root, root, data, loose, root_path=root_path, spath=[PathElement(root)])

def _from_data_recursive[A(YangData)](root: yang.schema.DRoot, s: yang.schema.DNodeInner, data: A, loose: bool=False, set_ns: bool=True, root_path: list[str]=[], spath: list[PathElement]=[]) -> yang.gdata.Container:
    """Internal function with additional recursion accumulators

    Args:
        root: Root schema node (must be the actual root, not an inner node), e.g. for resolving identityref values
        s: Schema node (container or list) - the root of the schema tree to start parsing from
        data: Data wrapped in a YangData protocol implementation (XML or JSON)
        loose: Whether to use loose parsing (allows optional fields to be missing)
        set_ns: Whether to set namespace information on generated nodes
        root_path: Path from s to the actual data location in the input. This enables
                  partial parsing where the data doesn't start at the schema root but
                  at some inner node. For example, if root_path=["mod:c1", "c2"],
                  the function will navigate from s through c1 and c2 before starting
                  to parse the actual data.
        spath: Accumulated schema path as list[PathElement], including list key
               predicates when descending into list elements. This is passed to
               YangData.take_* so that any validation errors can render full,
               human-friendly paths (e.g., /c1/l2[k1='A']/v1).

    Returns:
        A yang.gdata.Container containing the parsed data tree
    """

    # Navigate to root path if specified
    if root_path != [] and len(spath) -1 < len(root_path):
        next = root_path[len(spath) - 1]

        local_name, module = _parse_qualified_name(next)
        child = s.get(local_name, module=module, allow_unqualified=False)
        if isinstance(child, yang.schema.DNodeInner):
            return _from_data_recursive(root, child, data, loose, set_ns, root_path, spath + [PathElement(child)])
        raise ValueError("Node at {format_schema_path(spath + [PathElement(child)])} is not inner: {type(child)}")

    children: dict[str, yang.gdata.Node] = {}

    unique_namer = yang.schema._UniqueNamer(s)
    def uname(n) -> str:
        return unique_namer.unique_name(n.name, n.prefix)
    def is_unique(n) -> bool:
        return unique_namer.is_unique(n.name)

    source_is_xml = isinstance(data, xml.Node)
    for child in s.children:
        # Only process data nodes
        if not (isinstance(child, yang.schema.DNodeLeaf) or isinstance(child, yang.schema.DContainer) or isinstance(child, yang.schema.DList)):
            continue

        def path_with_child(k=None):
            return spath + [PathElement(child, k)]

        # Determine namespace (only include if different from parent)
        ns = None
        mod = None
        if child.namespace != s.namespace:
            ns = child.namespace
            mod = child.module

        if isinstance(child, yang.schema.DContainer):
            val = data.take_container(child, child.name, s.namespace != child.namespace, is_unique(child), spath)
            if val is not None:
                if isinstance(val, xml.Node):
                    # NETCONF operation on container
                    cop = get_netconf_operation(val)
                    cns = child.namespace if set_ns and child.namespace != "" else None
                    cmod = child.module if set_ns and child.module != "" else None
                    if cop == "remove":
                        children[uname(child)] = yang.gdata.Absent(ns=cns, module=cmod)
                    elif cop == "delete":
                        children[uname(child)] = yang.gdata.Delete(ns=cns, module=cmod)
                    elif cop == "create":
                        inner = _from_data_recursive(root, child, val, loose, set_ns=False, root_path=root_path, spath=path_with_child())
                        children[uname(child)] = yang.gdata.Create(inner.children, ns=cns, module=cmod)
                    elif cop == "replace":
                        inner = _from_data_recursive(root, child, val, loose, set_ns=False, root_path=root_path, spath=path_with_child())
                        children[uname(child)] = yang.gdata.Replace(inner.children, ns=cns, module=cmod)
                    else:
                        maybe = _from_data_recursive(root, child, val, loose, set_ns=s.namespace != child.namespace, root_path=root_path, spath=path_with_child())
                        children[uname(child)] = maybe
                elif isinstance(val, dict):
                    maybe = _from_data_recursive(root, child, val, loose, set_ns=s.namespace != child.namespace, root_path=root_path, spath=path_with_child())
                    children[uname(child)] = maybe
                elif isinstance(val, yang.adata.MNode):
                    # TODO: can't we change YangData prorocol such that val implements YangData?!
                    maybe = _from_data_recursive(root, child, val, loose, set_ns=s.namespace != child.namespace, root_path=root_path, spath=path_with_child())
                    children[uname(child)] = maybe
                else:
                    children[uname(child)] = yang.gdata.Container({})
            else:
                # Missing container: if this is a non-presence container and it has
                # mandatory content, then raise an error in strict mode.
                if not loose and isinstance(child, yang.schema.DContainer) and not child.presence:
                    if has_mandatory_content(child):
                        raise ValueError("Error reading {format_schema_path(path_with_child())}: Cannot find xml child with name {child.name}")

        elif isinstance(child, yang.schema.DList):
            list_val = data.take_list(child, child.name, s.namespace != child.namespace, is_unique(child), spath)
            list_elements = []

            def unwrap_key[T](name: str, val: ?T) -> T:
                if val is not None:
                    return val
                raise ValueError("Missing key value at {format_schema_path(path_with_child())}: {name}")

            for element_data in list_val:
                if isinstance(element_data, xml.Node):
                    # Extract key values for better error context directly from the data (XML)
                    key_values = {}
                    for key_name in child.key:
                        key_node = unwrap_key(key_name, yang.gdata.get_xml_opt_child(element_data, key_name))
                        key_values[key_name] = unwrap_key(key_name, key_node.text)
                    # Check NETCONF operation on the element
                    eop = get_netconf_operation(element_data)
                    if eop in ["remove", "delete"]:
                            # Build element to extract proper key leaves, then create Absent/Delete with keys
                            eg = _from_data_recursive(root, child, element_data, loose, set_ns=False, root_path=root_path, spath=path_with_child(key_values))
                            key_children = {key: unwrap_key(key, eg.children.get(key)) for key in child.key}
                            if eop == "remove":
                                list_elements.append(yang.gdata.Absent(key_children))
                            else:
                                list_elements.append(yang.gdata.Delete(key_children))
                    elif eop in ["create", "replace"]:
                        eg = _from_data_recursive(root, child, element_data, loose, set_ns=False, root_path=root_path, spath=path_with_child(key_values))
                        if eop == "create":
                            list_elements.append(yang.gdata.Create(eg.children))
                        else:
                            list_elements.append(yang.gdata.Replace(eg.children))
                    else:
                        element_gdata = _from_data_recursive(root, child, element_data, loose, set_ns=False, root_path=root_path, spath=path_with_child(key_values))
                        list_elements.append(element_gdata)
                elif isinstance(element_data, dict):
                    # Extract key values for better error context directly from the data (JSON)
                    key_values = {k: unwrap_key(k, element_data.get(k)) for k in child.key}
                    element_gdata = _from_data_recursive(root, child, element_data, loose, set_ns=False, root_path=root_path, spath=path_with_child(key_values))
                    list_elements.append(element_gdata)
                elif isinstance(element_data, yang.adata.MNode):
                    # Extract key values for better error context directly from the data (adata)
                    key_values = {k: unwrap_key(k, element_data._get_attr(yang.schema._safe_name(k))) for k in child.key}
                    element_gdata = _from_data_recursive(root, child, element_data, loose, set_ns=False, root_path=root_path, spath=path_with_child(key_values))
                    list_elements.append(element_gdata)
                else:
                    raise ValueError("Unsupported type for list element at {format_schema_path(path_with_child())}: {type(element_data)}")
            if list_elements:
                list_gdata = yang.gdata.List(child.key, list_elements, user_order=_user_order(child.ordered_by), ns=ns, module=mod)
                children[uname(child)] = list_gdata

        elif isinstance(child, yang.schema.DLeafList):
            leaflist_val = data.take_leaflist(root, child, child.name,s.namespace != child.namespace, is_unique(child), spath)
            if len(leaflist_val) > 0:
                # Unwrap typed tuples
                unwrapped_values: list[value] = []
                for item in leaflist_val:
                    iv = item.val
                    if iv is not None:
                        unwrapped_values.append(iv)
                leaflist_type = "union" if child.type_.builtin_type == "union" else (leaflist_val[0].t)
                if len(unwrapped_values) > 0:
                    children[uname(child)] = yang.gdata.LeafList(leaflist_type, unwrapped_values, user_order=_user_order(child.ordered_by))
            elif not yang.schema.is_optional_arg_yang_leaf(child, yang.schema.list_keys(s), loose):
                # Missing leaf-list value
                raise ValueError("Error reading {format_schema_path(path_with_child())}: Cannot find xml child with name {child.name}")

        elif isinstance(child, yang.schema.DLeaf):
            typed = data.take_leaf(root, child, child.name, s.namespace != child.namespace, is_unique(child), spath)
            if typed is not None:
                if typed.op == OP_REMOVE:
                    children[uname(child)] = yang.gdata.Absent()
                    continue
                elif typed.op == OP_DELETE:
                    children[uname(child)] = yang.gdata.Delete()
                    continue
                # create/replace for leaf are treated as normal set; a scalar set replaces any prior value
                # Determine concrete type
                leaf_ns = None
                leaf_module = None
                if ns is not None:
                    leaf_ns = child.namespace
                    leaf_module = child.module
                concrete_type = typed.t
                av = typed.val
                if av is not None:
                    children[uname(child)] = yang.gdata.Leaf(concrete_type, av, ns=leaf_ns, module=leaf_module)
            elif not yang.schema.is_optional_arg_yang_leaf(child, yang.schema.list_keys(s), loose):
                # Missing leaf value
                raise ValueError("Error reading {format_schema_path(path_with_child())}: Cannot find xml child with name {child.name}")
        else:
            raise ValueError(f"Unknown schema node type at {format_schema_path(path_with_child())}: {child}")

    if isinstance(s, yang.schema.DContainer):
        return yang.gdata.Container(children, presence=s.presence, ns=s.namespace if set_ns and s.namespace != "" else None, module=s.module if set_ns and s.module != "" else None)
    elif isinstance(s, yang.schema.DList) or isinstance(s, yang.schema.DRoot):
        # When processing a list element, return it as a Container
        # The List wrapper is created by the parent when processing all elements
        return yang.gdata.Container(children)
    elif isinstance(s, yang.schema.DOutput) or isinstance(s, yang.schema.DInput):
        return yang.gdata.Container(children)
    else:
        raise ValueError("Unknown schema node type at {format_schema_path(spath)}: {type(s)}")


def pradata(root: yang.schema.DRoot, node: yang.gdata.Node, self_name: str="ad", loose: bool=False, root_path: list[str]=[]):
    return _pradata_recursive(root, node, self_name, loose, top=True, root_path=root_path, spath=[PathElement(root)])


def _pradata_recursive(s: yang.schema.DNodeInner, node: yang.gdata.Node, self_name: str, loose: bool=False, top: bool=False, list_element: bool=False, root_path: list[str]=[], spath: list[PathElement]=[]):
    # Navigate to root path if specified
    if root_path != [] and len(spath) - 1 < len(root_path):
        next = root_path[len(spath) - 1]
        local_name, module = _parse_qualified_name(next)
        child = s.get(local_name, module=module, allow_unqualified=False)
        if isinstance(child, yang.schema.DNodeInner):
            return _pradata_recursive(child, node, self_name, loose, top, list_element, root_path, spath + [PathElement(child)])
        raise ValueError("Node at {format_schema_path(spath + [PathElement(child)])} is not inner: {type(child)}")

    def pname(pe: list[PathElement]):
        return yang.schema.get_path_name([e.node for e in pe])

    def _find_non_optional_subtree(container: yang.schema.DNodeInner, spath: list[PathElement], node: yang.gdata.Node, path: list[str], local_prefix="_") -> (list[str], list[str]):
        r"""Discover the non-optional descendants of a container

        The container here is either a DContainer or a DList (representing
        a list element). We recursively traverse the child nodes of the
        container, looking for non-optional leaves and containers. A
        container is non-optional if it is not a presence container and it
        contains other non-optional nodes.

        As we traverse the tree, we build intermediate container objects
        using their non-optional arguments.

        Args:
            container: The container node to analyze
            path: List of attribute names representing the path from the root
                    to the current container (e.g. ['self', 'child1', 'child2'])
            local_prefix: Prefix used for variable access in generated code,
                            typically "_" for local variables or "" for self references

        The function returns a tuple of two lists:
        - non_optional_args: list of non-optional arguments for the outer container
        - non_optional_containers: list of code lines that declare the
        intermediate containers and their arguments

        Note on f-string evaluation timing:
        This function uses nested f-strings with two evaluation phases:
        1. Generation-time: Outer f-strings resolve class names, paths, variable names
        2. Runtime: Inner f-strings ({{...}}) become {...} and evaluate when pradata() executes.
        """
        non_optional_args = []
        non_optional_containers = []
        unique_namer = yang.schema._UniqueNamer(container)

        for cchild in container.children:
            def path_with_child():
                return spath + [PathElement(cchild)]

            if not (isinstance(cchild, yang.schema.DNodeLeaf) or isinstance(cchild, yang.schema.DContainer) or isinstance(cchild, yang.schema.DList)):
                continue
            if isinstance(cchild, yang.schema.DLeaf):
                # The list of children is already sorted so that key leaves
                # come first in the correct order.
                if not yang.schema.is_optional_arg_yang_leaf(cchild, yang.schema.list_keys(container), loose):
                    leaf = node.get_leaf(unique_namer.unique_name(cchild.name, cchild.prefix))
                    non_optional_args.append("{repr_yang(leaf.val)}")
            elif isinstance(cchild, yang.schema.DContainer):
                if not (cchild.presence or loose or yang.schema.optional_subtree(cchild)):
                    cchild_safe_name = unique_namer.unique_safe_name(cchild.name, cchild.prefix)

                    # Recursively build subtree for non-optional children
                    sub_args, sub_containers = _find_non_optional_subtree(cchild, path_with_child(), node.get_cnt(cchild.name), path + [cchild_safe_name], local_prefix)

                    # Create variable declaration for this container
                    mcchild_var = "{'_'.join(path)}_{cchild_safe_name}"

                    if sub_args:
                        sub_args_str = ", ".join(sub_args)
                        non_optional_containers.append("{mcchild_var} = {pname(path_with_child())}({sub_args_str})")
                    else:
                        non_optional_containers.append("{mcchild_var} = {pname(path_with_child())}()")

                    # Add nested variable declarations
                    non_optional_containers.extend(sub_containers)

                    non_optional_args.append(mcchild_var)

        return non_optional_args, non_optional_containers

    unique_namer = yang.schema._UniqueNamer(s)
    def usname(n) -> str:
        return unique_namer.unique_safe_name(n.name, n.prefix)
    def uname(n) -> str:
        return unique_namer.unique_name(n.name, n.prefix)
    res = []
    if top:
        res.append('# Top node: {format_schema_path(spath)}')
        # Build constructor arguments for non-optional children (same logic as in __init__)
        constructor_args, constructor_containers = _find_non_optional_subtree(s, spath, node, ["self"], local_prefix="")
        if constructor_args:
            # Add variable declarations in reverse order to ensure dependencies are declared before use.
            # For example, if container C needs argument from container B, which needs argument from A,
            # we must generate: A_var = ..., B_var = ..., C_var = ... in that order.
            # Since find_non_optional_subtree() builds the list depth-first, we reverse it.
            res.extend(list(reversed(constructor_containers)))
            args_str = ", ".join(constructor_args)
            res.append("{self_name} = {pname(spath)}({args_str})")
        else:
            res.append("{self_name} = {pname(spath)}()")
    leaves = []
    for child in s.children:
        # Only process data nodes
        if not (isinstance(child, yang.schema.DNodeLeaf) or isinstance(child, yang.schema.DContainer) or isinstance(child, yang.schema.DList)):
            continue

        def path_with_child(k=None):
            return spath + [PathElement(child, k)]

        if isinstance(child, yang.schema.DLeaf):
            leaf = node.get_opt_leaf(uname(child))
            if leaf is not None:
                if not top and not yang.schema.is_optional_arg_yang_leaf(child, yang.schema.list_keys(s), loose):
                    # Do not print non-optional leafs if not top level, because
                    # they are implicitly set with .create*()
                    continue
                # DLeaf values are copied verbatim
                leaves.append("{self_name}.{usname(child)} = {repr_yang(leaf.val)}")
        elif isinstance(child, yang.schema.DLeafList):
            leaflist = node.get_opt_leaflist(uname(child))
            if leaflist is not None:
                # DLeafList values are copied verbatim
                leaves.append("{self_name}.{usname(child)} = {repr_yang(leaflist.vals)}")
        elif isinstance(child, yang.schema.DContainer):
            container = node.get_opt_cnt(uname(child))
            if container is not None:
                if child.presence:
                    res.append("")
                    res.append("# P-container: {format_schema_path(path_with_child())}")
                    # Build .pradata() code for this P-container
                    pc_args, pc_var_declarations = _find_non_optional_subtree(child, path_with_child(), container, [usname(child)])

                    # Add variable declarations in reverse order to ensure the prerequisites are met
                    res.extend(list(reversed(pc_var_declarations)))

                    child_accessor = yang.schema._safe_name(child.name)
                    pc_args_str = ", ".join(pc_args)
                    res.append("{child_accessor} = {self_name}.create_{usname(child)}({pc_args_str})")
                    # Recursive call to pradata() for the P-container, to fill in the rest of the optional children
                    res.extend(_pradata_recursive(child, container, usname(child), loose, root_path=root_path, spath=path_with_child()).splitlines())
                else:
                    res.extend(_pradata_recursive(child, container, "{self_name}.{usname(child)}", loose, root_path=root_path, spath=path_with_child()).splitlines())
        elif isinstance(child, yang.schema.DList):
            glist = node.get_opt_list(uname(child))
            if glist is not None:
                for element in glist.elements:
                    res.append("")
                    res.append("# List {format_schema_path(path_with_child())} element: {element.key_str(child.key)}")

                    # Build the list of arguments for create() method
                    list_create_args = []

                    non_optional_args, non_optional_containers = _find_non_optional_subtree(child, path_with_child(), element, ["element"])

                    res.extend(list(reversed(non_optional_containers)))
                    list_create_args.extend(non_optional_args)

                    create_args_str = ", ".join(list_create_args)
                    res.append("{usname(child)}_element = {self_name}.{usname(child)}.create({create_args_str})")
                    # Recursive call to pradata() for the list element
                    res.extend(_pradata_recursive(child, element, "{usname(child)}_element", loose, list_element=True, root_path=root_path, spath=path_with_child(element.key_values(child.key))).splitlines())
        else:
            raise ValueError("Unhandled child type in .pradata() at {format_schema_path(path_with_child())}: {type(child)}")

    # Add the leaves as a single group at the beginning of the section,
    # optionally add container header if we're not printing a list element
    if leaves:
        if top:
            res = res + leaves
        elif not list_element:
            res = ["", "# Container: {format_schema_path(spath)}"] + leaves + res
        else:
            res = leaves + res
    return "\n".join(res)

def _test_y1_xml():
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    description "Container 1";
    leaf l1 {
      type string;
      description "Leaf 1";
    }
    list l2 {
      key "k1";
      leaf k1 {
        type string;
        description "Key 1";
      }
      leaf v1 {
        type string;
        description "Value 1";
      }
    }
    leaf-list ll1 {
      type string;
      description "Leaf List 1";
    }
  }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y1">
  <l1>Value for l1</l1>
  <l2>
    <k1>Key 1</k1>
    <v1>Value for v1</v1>
  </l2>
  <ll1>Item 1</ll1>
  <ll1>Item 2</ll1>
</c1>
</data>"""

    s = yang.compile([y1])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_mandatory_leaf():
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;
  container c1 {
    leaf l1 {
      type string;
      mandatory true;
    }
  }
}"""
    s = yang.compile([y1])

    try:
        from_data(s, xml.decode('<data><c1 xmlns="urn:example:y1"/></data>'))
    except ValueError as err:
        if err.error_message != "Error reading /c1/l1: Cannot find xml child with name l1":
            testing.error("Unexpected error: {err}")


def _test_y1_json():
    """Test JSON parsing with the same schema as XML test"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    description "Container 1";
    leaf l1 {
      type string;
      description "Leaf 1";
    }
    list l2 {
      key "k1";
      leaf k1 {
        type string;
        description "Key 1";
      }
      leaf v1 {
        type string;
        description "Value 1";
      }
    }
    leaf-list ll1 {
      type string;
      description "Leaf List 1";
    }
  }
}"""

    json_data = {
        "y1:c1": {
            "l1": "Value for l1",
            "l2": [
                {
                    "k1": "Key 1",
                    "v1": "Value for v1"
                }
            ],
            "ll1": ["Item 1", "Item 2"]
        }
    }

    s = yang.compile([y1])
    gd = from_data(s, json_data)
    return gd.prsrc()


def _test_root_path():
    """Test root_path argument for navigating to nested containers"""
    y1 = r"""module acme-y1 {
  namespace "urn:example:acme-y1";
  prefix y1;

  container top {
    description "Top container";
    container nested {
      description "Nested container";
      leaf value {
        type string;
        description "Test value";
      }
    }
  }
}"""

    xml_in = r"""<data>
  <nested>
    <value>test data</value>
  </nested>
</data>"""

    s = yang.compile([y1])

    # Start parsing at the /acme-y1:top container (acme-y1 is the module name, not prefix)
    gd_nested = from_data(s, xml.decode(xml_in), root_path=["acme-y1:top"])

    return gd_nested.prsrc()

def _test_error_path_json_list_range():
    """Error path includes list key predicate for JSON payloads"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    list l2 {
      key "k1";
      leaf k1 { type string; }
      leaf v1 {
        type uint8 { range 1..10; }
      }
    }
  }
}"""

    s = yang.compile([y1])
    # v1 is out of range (100)
    json_in = {"y1:c1": {"l2": [{"k1": "Key 1", "v1": "100"}]}}
    try:
        from_data(s, json_in)
    except ValueError as err:
        return str(err)
    raise AssertionError("Expected error not raised")

def _test_error_path_xml_leaf_range():
    """Error path includes nested container for XML payloads"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container top {
    container nested {
      leaf value { type uint8 { range "0..5"; } }
    }
  }
}"""

    xml_in = r"""<data>
<top xmlns="urn:example:y1">
  <nested>
    <value>42</value>
  </nested>
</top>
</data>"""

    s = yang.compile([y1])
    try:
        from_data(s, xml.decode(xml_in))
    except ValueError as err:
        return str(err)
    raise AssertionError("Expected error not raised")


def _test_uint64_edge_json_ok_max_keyword():
    """uint64 accepts max value when range uses 'max'"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c {
    leaf u {
      type uint64 { range "0..max"; }
    }
  }
}"""

    s = yang.compile([y1])
    # Use the maximum uint64 value
    json_in = {"y1:c": {"u": "18446744073709551615"}}
    # Should not raise
    gd = from_data(s, json_in)


def _test_uint64_edge_json_fail_overflow():
    """uint64 rejects value above max with explicit bound"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c {
    leaf u {
      type uint64 { range "0..18446744073709551615"; }
    }
  }
}"""

    s = yang.compile([y1])
    # One above max
    json_in = {"y1:c": {"u": "18446744073709551616"}}
    try:
        from_data(s, json_in)
    except ValueError as err:
        return str(err)
    raise AssertionError("Expected error not raised")


def _test_missing_list_key_json():
    """Test error message when list key is missing in JSON"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    list l1 {
      key "k1 k2";
      leaf k1 { type string; }
      leaf k2 { type string; }
      leaf v1 { type string; }
    }
  }
}"""

    s = yang.compile([y1])
    # Missing k2 key in the list element
    json_in = {"y1:c1": {"l1": [{"k1": "key1", "v1": "value1"}]}}
    try:
        from_data(s, json_in)
        testing.error("Expected ValueError not raised")
    except ValueError as err:
        testing.assertEqual("Missing key value at /c1/l1: k2", err.error_message)


def _test_missing_list_key_xml():
    """Test error message when list key is missing in XML"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    list l1 {
      key "k1 k2";
      leaf k1 { type string; }
      leaf k2 { type int32; }
      leaf v1 { type string; }
    }
  }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y1">
  <l1>
    <k1>key1</k1>
    <v1>value1</v1>
  </l1>
</c1>
</data>"""

    s = yang.compile([y1])
    try:
        from_data(s, xml.decode(xml_in))
        testing.error("Expected ValueError not raised")
    except ValueError as err:
        expected = "Missing key value at /c1/l1: k2"
        testing.assertEqual(expected, err.error_message)


def _test_format_schema_path_empty():
    """format_schema_path renders empty as ''"""
    path: list[PathElement] = []
    out = format_schema_path(path)
    if out != "":
        testing.error("Unexpected path: {out}")


def _test_format_schema_path_root():
    """format_schema_path renders root as '/'"""
    path: list[PathElement] = [PathElement(yang.schema.DRoot())]
    out = format_schema_path(path)
    if out != "/":
        testing.error("Unexpected path: {out}")


def _test_format_schema_path_list_predicate():
    """format_schema_path renders list key predicate"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c {
    list l {
      key "k1 k2";
      leaf k1 { type string; }
      leaf k2 { type int32; }
      leaf v { type string; }
    }
  }
}"""

    s = yang.compile([y1])
    # Locate nodes using schema get()
    cnode = s.get("c")
    lnode = cnode.get("l")
    vnode = lnode.get("v")

    path = [PathElement(s), PathElement(cnode), PathElement(lnode, keys={"k1": "Key 1", "k2": 1}), PathElement(vnode)]
    out = format_schema_path(path)
    testing.assertEqual("/c/l[k1='Key 1',k2='1']/v", out)

    path = [PathElement(s), PathElement(cnode), PathElement(lnode, keys={"k1": "Key 1, with extra's", "k2": 1}), PathElement(vnode)]
    out = format_schema_path(path)
    testing.assertEqual(r"""/c/l[k1='Key 1, with extra\'s',k2='1']/v""", out)

def _test_json_path_basic():
    """Test basic JSON path navigation"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    leaf l1 {
      type string;
    }
    container c2 {
      leaf l2 {
        type string;
      }
    }
  }
}"""

    s = yang.compile([y1])

    # Test navigating to a leaf in a nested container
    gd = from_json_path(s, {"l2": "test value"}, ["y1:c1", "c2"])
    expected = yang.gdata.Container({
        "c1": yang.gdata.Container({
            "c2": yang.gdata.Container({
                "l2": yang.gdata.Leaf("string", "test value")
            })
        }, ns='urn:example:y1', module='y1')
    })
    testing.assertEqual(gd.prsrc(), expected.prsrc())


def _test_json_path_qualified_names():
    """Test JSON path with module-qualified names"""
    mod1 = r"""module mod1 {
  namespace "urn:example:mod1";
  prefix m1;

  container c1 {
    leaf l1 {
      type string;
    }
  }
}"""

    mod2 = r"""module mod2 {
  namespace "urn:example:mod2";
  prefix m2;
  import mod1 { prefix m1; }

  augment "/m1:c1" {
    leaf l2 {
      type string;
    }
  }
}"""

    s = yang.compile([mod1, mod2])

    # Test navigating with qualified name
    gd = from_json_path(s, {"mod2:l2": "augmented value"}, ["mod1:c1"])
    expected = yang.gdata.Container({
        "c1": yang.gdata.Container({
            "l2": yang.gdata.Leaf("string", "augmented value", ns="urn:example:mod2", module="mod2")
        }, ns="urn:example:mod1", module="mod1")
    })
    testing.assertEqual(gd.prsrc(), expected.prsrc())


def _test_json_path_list():
    """Test JSON path navigation to list elements"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    list l1 {
      key name;
      leaf name {
        type string;
      }
      leaf value {
        type string;
      }
      container inner {
        leaf data {
          type string;
        }
      }
    }
  }
}"""

    s = yang.compile([y1])

    # Test navigating to a specific list element
    gd = from_json_path(s, {"name": "test", "value": "data"}, ["y1:c1", "l1", "test"])
    # Should create a list with single element
    expected = yang.gdata.Container({
      'c1': yang.gdata.Container({
        'l1': yang.gdata.List(['name'], elements=[
          yang.gdata.Container({
            'name': yang.gdata.Leaf('string', 'test'),
            'value': yang.gdata.Leaf('string', 'data')
          })
        ])
      }, ns='urn:example:y1', module='y1')
    })
    testing.assertEqual(gd.prsrc(), expected.prsrc())


def _test_json_path_remove():
    """Test JSON path with remove operation"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    list l1 {
      key name;
      leaf name {
        type string;
      }
      leaf value {
        type string;
      }
    }
  }
}"""

    s = yang.compile([y1])

    # Test remove operation on a list element
    gd = from_json_path(s, {}, ["y1:c1", "l1", "test"], "remove")
    # Should contain an Absent node with the key
    expected = yang.gdata.Container({
      'c1': yang.gdata.Container({
        'l1': yang.gdata.List(['name'], elements=[
          yang.gdata.Absent({
            'name': yang.gdata.Leaf('string', 'test')
          })
        ])
      }, ns='urn:example:y1', module='y1')
    })
    testing.assertEqual(gd.prsrc(), expected.prsrc())


def _test_json_path_errors():
    """Test error handling in JSON path navigation"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    leaf l1 {
      type string;
    }
  }
}"""

    s = yang.compile([y1])

    # Test missing namespace qualification
    try:
        from_json_path(s, {}, ["y1:c1", "nonexistent"])
        testing.error("Should have raised ValueError for missing namespace qualification")
    except ValueError as e:
        testing.assertIn("Child 'nonexistent' not found", e.error_message)

    # Test navigating beyond leaf
    try:
        from_json_path(s, {}, ["y1:c1", "l1", "beyond"])
        testing.error("Should have raised ValueError for navigating beyond leaf")
    except ValueError as e:
        testing.assertIn("Invalid JSON path to non-inner node", e.error_message)

    # Test invalid operation
    try:
        from_json_path(s, {}, ["y1:c1"], "invalid")
        testing.error("Should have raised ValueError for invalid operation")
    except ValueError as e:
        testing.assertIn("Invalid operation", e.error_message)


def _test_json_path_nested_lists():
    """Test JSON path navigation through nested lists"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    list outer {
      key "outer-key";
      leaf outer-key {
        type string;
      }
      list inner {
        key "inner-key";
        leaf inner-key {
          type string;
        }
        leaf value {
          type string;
        }
        list deep {
          key "deep-key";
          leaf deep-key {
            type string;
          }
          leaf data {
            type int32;
          }
        }
      }
    }
  }
}"""

    s = yang.compile([y1])

    # Test navigating to a nested list element
    gd = from_json_path(s, {"value": "test-value"}, ["y1:c1", "outer", "key1", "inner", "key2"])
    expected = yang.gdata.Container({
        'c1': yang.gdata.Container({
            'outer': yang.gdata.List(['outer-key'], elements=[
                yang.gdata.Container({
                    'outer-key': yang.gdata.Leaf('string', 'key1'),
                    'inner': yang.gdata.List(['inner-key'], elements=[
                        yang.gdata.Container({
                            'inner-key': yang.gdata.Leaf('string', 'key2'),
                            'value': yang.gdata.Leaf('string', 'test-value')
                        })
                    ])
                })
            ])
        }, ns='urn:example:y1', module='y1')
    })
    testing.assertEqual(gd.prsrc(), expected.prsrc())

    # Test navigating to a deeply nested list element (3 levels)
    gd2 = from_json_path(s, {"data": 42}, ["y1:c1", "outer", "key1", "inner", "key2", "deep", "key3"])
    expected2 = yang.gdata.Container({
        'c1': yang.gdata.Container({
            'outer': yang.gdata.List(['outer-key'], elements=[
                yang.gdata.Container({
                    'outer-key': yang.gdata.Leaf('string', 'key1'),
                    'inner': yang.gdata.List(['inner-key'], elements=[
                        yang.gdata.Container({
                            'inner-key': yang.gdata.Leaf('string', 'key2'),
                            'deep': yang.gdata.List(['deep-key'], elements=[
                                yang.gdata.Container({
                                    'deep-key': yang.gdata.Leaf('string', 'key3'),
                                    'data': yang.gdata.Leaf('int32', bigint(42))
                                })
                            ])
                        })
                    ])
                })
            ])
        }, ns='urn:example:y1', module='y1')
    })
    testing.assertEqual(gd2.prsrc(), expected2.prsrc())

def _test_netconf_remove_container():
    """NETCONF remove on a container produces Absent"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 {
    presence "p";
    leaf l1 { type string; }
  }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y" xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="remove"/>
</data>"""

    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_remove_list_element():
    """NETCONF remove on a list element produces Absent with key children"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 {
    list l2 {
      key "k1";
      leaf k1 { type string; }
      leaf v1 { type string; }
    }
  }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y">
  <l2 xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="remove">
    <k1>Key 1</k1>
  </l2>
</c1>
</data>"""

    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_remove_leaf():
    """NETCONF remove on a leaf produces Absent"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 {
    leaf l1 { type string; }
  }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y">
  <l1 xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="remove"/>
</c1>
</data>"""

    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_replace_leaf_sets_value():
    """NETCONF replace on a leaf is treated as a normal set"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 {
    leaf l1 { type string; }
  }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y">
  <l1 xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="replace">VAL</l1>
</c1>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_remove_mixed():
    """Mixed normal and remove elements in the same list"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  list l {
    key "k";
    leaf k { type string; }
    leaf v { type string; }
  }
}"""

    xml_in = r"""<data>
<l xmlns="urn:example:y">
  <k>A</k>
  <v>keep</v>
</l>
<l xmlns="urn:example:y" xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="remove">
  <k>B</k>
</l>
</data>
"""

    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_create_list_element():
    """NETCONF create on a list element renders operation and content"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 {
    list l2 {
      key "k1";
      leaf k1 { type string; }
      leaf v1 { type string; }
    }
  }
}"""
    xml_in = r"""<data>
<c1 xmlns="urn:example:y">
  <l2 xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="create">
    <k1>X</k1>
    <v1>Y</v1>
  </l2>
</c1>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_replace_list_element():
    """NETCONF replace on a list element renders operation and content"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 {
    list l2 {
      key "k1";
      leaf k1 { type string; }
      leaf v1 { type string; }
    }
  }
}"""
    xml_in = r"""<data>
<c1 xmlns="urn:example:y">
  <l2 xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="replace">
    <k1>Z</k1>
    <v1>W</v1>
  </l2>
</c1>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_delete_list_element():
    """NETCONF delete on a list element renders operation with keys only"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 {
    list l2 {
      key "k1";
      leaf k1 { type string; }
      leaf v1 { type string; }
    }
  }
}"""
    xml_in = r"""<data>
<c1 xmlns="urn:example:y">
  <l2 xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="delete">
    <k1>DEL</k1>
  </l2>
</c1>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_union_int_json():
    """Union(int8 range 1..10 | string): textual int within range resolves as int"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  leaf u {
    type union {
      type int8 { range 1..10; }
      type string;
    }
  }
}"""
    s = yang.compile([y])
    jd = {"y:u": "7"}
    gd = from_data(s, jd)
    return gd.prsrc()

def _test_union_str_json():
    """Union(int8 range 1..10 | string): textual int out of range resolves as string"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  leaf u {
    type union {
      type int8 { range 1..10; }
      type string;
    }
  }
}"""
    s = yang.compile([y])
    jd = {"y:u": "100"}
    gd = from_data(s, jd)
    return gd.prsrc()

def _test_union_str_xml():
    """Union(int8 range 1..10 | string): XML numeric text out of range resolves as string"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  leaf u {
    type union {
      type int8 { range 1..10; }
      type string;
    }
  }
}"""
    xml_in = r"""<data>
<u xmlns="urn:example:y">100</u>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_union_binary_xml():
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  leaf u {
    type union {
      type enumeration { enum "unlimited"; }
      type binary;
    }
  }
}"""
    xml_in = r"""<data>
<u xmlns="urn:example:y">aGk=</u>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    print(gd.get_bytes('u'))
    testing.assertEqual(gd.get_bytes('u'), "hi".encode())
    return gd.prsrc()

def _test_union_binary_json():
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  leaf u {
    type union {
      type enumeration { enum "unlimited"; }
      type binary;
    }
  }
}"""
    s = yang.compile([y])
    jd = {"y:u": "aGk="}
    gd = from_data(s, jd)
    testing.assertEqual(gd.get_bytes('u'), "hi".encode())
    return gd.prsrc()

def _test_netconf_create_container():
    """NETCONF create on a container produces Create wrapper and serializes op"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 { leaf l1 { type string; } }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y" xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="create">
  <l1>v</l1>
</c1>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_replace_container():
    """NETCONF replace on a container produces Replace wrapper and serializes op"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 { leaf l1 { type string; } }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y" xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="replace">
  <l1>nv</l1>
</c1>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_delete_container():
    """NETCONF delete on a container produces Delete wrapper and serializes op"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 { leaf l1 { type string; } }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y" xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="delete"/>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

    # Test remove operation on nested list element
    gd3 = from_json_path(s, {}, ["y1:c1", "outer", "key1", "inner", "key2"], "remove")
    expected3 = yang.gdata.Container({
        'c1': yang.gdata.Container({
            'outer': yang.gdata.List(['outer-key'], elements=[
                yang.gdata.Container({
                    'outer-key': yang.gdata.Leaf('string', 'key1'),
                    'inner': yang.gdata.List(['inner-key'], elements=[
                        yang.gdata.Absent({
                            'inner-key': yang.gdata.Leaf('string', 'key2')
                        })
                    ])
                })
            ])
        }, ns='urn:example:y1', module='y1')
    })
    testing.assertEqual(gd3.prsrc(), expected3.prsrc())


def _test_pradata():
    schema_str = r"""module test {
      namespace "urn:example:test";
      prefix test;

      leaf top-level-leaf {
        type string;
        description "A leaf at the module root level";
      }

      container c1 {
        leaf optional-leaf {
          type int32;
        }
        container c2 {
          presence "This is a presence container";
          leaf l1 {
            type string;
          }
          leaf mandatory-leaf {
            type string;
            mandatory true;
          }
        }
        list li1 {
          key "name extra-key";
          leaf name {
            type string;
          }
          leaf extra-key {
            type int32;
          }
          leaf value {
            type int32;
          }
          container c3 {
            leaf nested-leaf {
              type string;
            }
          }
        }
        leaf-list always-empty {
          // Leave this empty, we check that empty leaf-list is not printed
          type string;
        }
      }
    }"""

    s = yang.compile([schema_str])

    gdata_tree = yang.gdata.Container({
        "top-level-leaf": yang.gdata.Leaf("string", "root value"),
        "c1": yang.gdata.Container({
            "optional-leaf": yang.gdata.Leaf("int32", bigint(42)),
            "c2": yang.gdata.Container({
                "l1": yang.gdata.Leaf("string", "inner value"),
                "mandatory-leaf": yang.gdata.Leaf("string", "required value")
            }, presence=True),
            "li1": yang.gdata.List(["name", "extra-key"], [
                yang.gdata.Container({
                    "name": yang.gdata.Leaf("string", "item1"),
                    "extra-key": yang.gdata.Leaf("int32", bigint(1)),
                    "value": yang.gdata.Leaf("int32", bigint(100))
                }),
                yang.gdata.Container({
                    "name": yang.gdata.Leaf("string", "item2"),
                    "extra-key": yang.gdata.Leaf("int32", bigint(2)),
                    "value": yang.gdata.Leaf("int32", bigint(200)),
                    "c3": yang.gdata.Container({
                        "nested-leaf": yang.gdata.Leaf("string", "birb")
                    })
                })
            ])
        })
    })

    result = pradata(s, gdata_tree)
    return result


def _test_pradata_root_path():
    schema_str = r"""module test {
      namespace "urn:example:test";
      prefix test;

      container outer {
        container middle {
          leaf value1 {
            type string;
          }
          container inner {
            leaf value2 {
              type int32;
            }
          }
        }
      }
    }"""

    s = yang.compile([schema_str])

    gdata_tree = yang.gdata.Container({
        "outer": yang.gdata.Container({
            "middle": yang.gdata.Container({
                "value1": yang.gdata.Leaf("string", "test value"),
                "inner": yang.gdata.Container({
                    "value2": yang.gdata.Leaf("int32", bigint(42))
                })
            })
        })
    })

    middle_node = gdata_tree.get_cnt("outer").get_cnt("middle")
    result = pradata(s, middle_node, root_path=["test:outer", "middle"])

    return result


def _test_json_path_container_list_container():
    """Test JSON path navigation through container -> list -> container pattern"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container top {
    list middle {
      key "name";
      leaf name {
        type string;
      }
      container bottom {
        leaf data {
          type string;
        }
        leaf value {
          type int32;
        }
      }
    }
  }
}"""

    s = yang.compile([y1])

    # Test navigating through container -> list -> container and setting data
    gd = from_json_path(s, {"data": "test", "value": 42}, ["y1:top", "middle", "item1", "bottom"])
    expected = yang.gdata.Container({
        'top': yang.gdata.Container({
            'middle': yang.gdata.List(['name'], elements=[
                yang.gdata.Container({
                    'name': yang.gdata.Leaf('string', 'item1'),
                    'bottom': yang.gdata.Container({
                        'data': yang.gdata.Leaf('string', 'test'),
                        'value': yang.gdata.Leaf('int32', bigint(42))
                    })
                })
            ])
        }, ns='urn:example:y1', module='y1')
    })
    testing.assertEqual(gd.prsrc(), expected.prsrc())

    # Test remove operation on the inner container
    gd2 = from_json_path(s, {}, ["y1:top", "middle", "item1", "bottom"], "remove")
    expected2 = yang.gdata.Container({
        'top': yang.gdata.Container({
            'middle': yang.gdata.List(['name'], elements=[
                yang.gdata.Container({
                    'name': yang.gdata.Leaf('string', 'item1'),
                    'bottom': yang.gdata.Absent()
                })
            ])
        }, ns='urn:example:y1', module='y1')
    })
    testing.assertEqual(gd2.prsrc(), expected2.prsrc())
