"""Generic YANG data parser implementation

This module provides a generic algorithm for parsing YANG data from different
sources (XML, JSON) using the YangData protocol.
"""

import testing
import base64
import xml

import yang
import yang.adata
import yang.gdata
import yang.schema
from yang.identityref import Identityref, PartialIdentityref
from yang.gdata import repr_adata
from yang.type import Decimal, Ranges


OP_MERGE = "merge"
OP_CREATE = "create"
OP_DELETE = "delete"
OP_REMOVE = "remove"
OP_REPLACE = "replace"
NETCONF_OPS = {OP_CREATE, OP_DELETE, OP_REMOVE, OP_REPLACE, OP_MERGE}
NETCONF_NS = "urn:ietf:params:xml:ns:netconf:base:1.0"


class PathElement:
    """Represents an element in a schema path, with optional key values for lists"""
    node: yang.schema.DNode
    keys: ?dict[str, value]

    def __init__(self, node: yang.schema.DNode, keys: ?dict[str, value]=None):
        self.node = node
        self.keys = keys


class YangValidationError(ValueError):
    schema_path: list[PathElement]
    expected_type: yang.schema.DType
    actual_value: ?value

    def __init__(self, schema_path: list[PathElement], expected_type: yang.schema.DType, actual_value: ?value):
        self.error_message = ""
        self.schema_path = schema_path
        self.expected_type = expected_type
        self.actual_value = actual_value

    def __str__(self) -> str:
        path_str = format_schema_path(self.schema_path)
        type_str = self.expected_type.format_hint()
        return "Invalid value at {path_str}: '{self.actual_value}' - expected {type_str}"



def format_schema_path(path: list[PathElement]) -> str:
    path_str = ""

    for i, elem in enumerate(path):
        if i > 0:
            prev = path[i-1].node
            if not isinstance(prev, yang.schema.DRoot):
                path_str = path_str + "/"
            if isinstance(prev, yang.schema.DNodeInner):
                un = yang.schema._UniqueNamer(prev)
                path_str = path_str + un.unique_name(elem.node.name, elem.node.prefix)
                keys_dict = elem.keys
                if keys_dict is not None and len(keys_dict) > 0:
                    predicates = ["{k}='{(v if isinstance(v, str) else str(v)).replace("'", "\\'")}'" for k, v in keys_dict.items()]
                    path_str = path_str + "[" + ",".join(predicates) + "]"
        elif isinstance(elem.node, yang.schema.DRoot):
            path_str = "/"
        else:
            # Relative path
            path_str = elem.node.name
    return path_str


def get_netconf_operation(node: xml.Node) -> str:
    """Extract NETCONF operation from an XML node
    """
    def ns_uri(prefix: ?str) -> ?str:
        for p, uri in node.nsdefs:
            # default namespace is stored with prefix == None
            if (prefix is None and p is None) or (prefix is not None and p is not None and prefix == p):
                return uri
        return None

    for attr_key, attr_val in node.attributes:
        if attr_key == "operation":
            # Unprefixed operation; must be in default NETCONF namespace
            if attr_val in NETCONF_OPS and ns_uri(None) == NETCONF_NS:
                return attr_val
        elif attr_key.endswith(":operation"):
            # Prefixed operation; resolve prefix and validate NETCONF namespace
            prefix = attr_key.split(":", 1)[0]
            if attr_val in NETCONF_OPS and ns_uri(prefix) == NETCONF_NS:
                return attr_val

    return OP_MERGE


def _test_get_nc_op_def():
    xml_in = xml.decode('<cfg xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" operation="delete"/>')
    op = get_netconf_operation(xml_in)
    testing.assertEqual(op, "delete")


def _test_get_nc_op_pref():
    xml_in = xml.decode('<cfg xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="replace"/>')
    op = get_netconf_operation(xml_in)
    testing.assertEqual(op, "replace")


def _test_get_nc_op_pref_ancestor():
    xml_in = xml.decode('<cfg xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0"><item nc:operation="create"/></cfg>')
    op = get_netconf_operation(xml_in.children[0])
    # TODO: fix!
    #testing.assertEqual(op, "create")


def _fqname(n: yang.schema.DNode):
    return yang.gdata.Id(n.namespace, n.name)


def _fq_list_keys(l: yang.schema.DList):
    return [yang.gdata.Id(l.namespace, k) for k in l.key]


def unwrap_key[T](name: str, val: ?T, spath) -> T:
    if val is not None:
        return val
    raise ValueError("Missing key value at {format_schema_path(spath)}: {name}")


protocol YangData:
    """Protocol for YANG data nodes

    Provides a uniform interface for extracting data from different data formats
    that can carry YANG-modeled data, like XML and JSON
    """
    # TODO: can value implement YangData?
    take_container: mut(yang.schema.DContainer, str, bool, bool, list[PathElement]) -> ?(op: ?str, val: ?value)
    take_list: mut(yang.schema.DList, str, bool, bool, list[PathElement]) -> list[(op: ?str, key: dict[str, value], val: value)]
    # Return a typed tuple for leaves. The tuple carries the concrete type name
    # and the parsed value. Missing leaves return None.
    take_leaf: mut(yang.schema.DRoot, yang.schema.DLeaf, str, bool, bool, list[PathElement]) -> ?(op: ?str, t: str, val: ?value)
    # For leaf-lists, return a list of typed tuples (op, t, val).
    # For identityref items, val holds a PartialIdentityref.
    take_leaflist: mut(yang.schema.DRoot, yang.schema.DLeafList, str, bool, bool, list[PathElement]) -> list[(op: ?str, t: str, val: ?value)]


extension xml.Node (YangData):
    def take_container(self, schema: yang.schema.DContainer, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> ?(op: str, val: ?value):
        child_node = yang.gdata.get_xml_opt_child(self, name, schema.namespace if ns_qualified else None)
        if child_node is not None:
            op = get_netconf_operation(child_node)
            return (op=op, val=child_node)
        return None

    def take_list(self, schema: yang.schema.DList, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> list[(op: str, key: dict[str, value], val: value)]:
        new_path = path + [PathElement(schema)]
        elements = yang.gdata.get_xml_children(self, name, schema.namespace if ns_qualified else None)

        def extract_key(element_data):
            key_values = {}
            for key_name in schema.key:
                key_node = unwrap_key(key_name, yang.gdata.get_xml_opt_child(element_data, key_name), new_path)
                key_values[key_name] = unwrap_key(key_name, key_node.text, new_path)
            return key_values

        return [(op=get_netconf_operation(e), key=extract_key(e), val=e) for e in elements]

    mut def take_leaf(self, root: yang.schema.DRoot, schema: yang.schema.DLeaf, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> ?(op: str, t: str, val: ?value):
        new_path = path + [PathElement(schema)]
        maybe_node = yang.gdata.get_xml_opt_child(self, name, schema.namespace if ns_qualified else None)
        if maybe_node is not None:
            op = get_netconf_operation(maybe_node)
            tv = try_parse_xml_value(maybe_node.text, schema, schema.type_, new_path, maybe_node.nsdefs, root)
            if tv is not None:
                return (op=op, t=tv.t, val=tv.val)
            # TODO: schema.type_.name may not be correct (union), but it's going away soon ...
            return (op=op, t=schema.type_.name, val=None)
        else:
            return None

    def take_leaflist(self, root: yang.schema.DRoot, schema: yang.schema.DLeafList, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> list[(op: str, t: str, val: ?value)]:
        new_path = path + [PathElement(schema)]
        values: list[(op: str, t: str, val: ?value)] = []
        children = yang.gdata.get_xml_children(self, name, schema.namespace if ns_qualified else None)
        for child in children:
            if isinstance(child, xml.Node):
                op = get_netconf_operation(child)
                text_value = child.text
                tv = try_parse_xml_value(text_value, schema, schema.type_, new_path, child.nsdefs, root)
                if tv is not None:
                    values.append((op=op, t=tv.t, val=tv.val))
                else:
                    # TODO: schema.type_.name may not be correct (union), but it's going away soon ...
                    values.append((op=op, t=schema.type_.name, val=None))
        return values


def try_parse_xml_value(text_value: ?str, schema_node: yang.schema.DNodeLeaf, schema_type: yang.schema.DType, path: list[PathElement], nsdefs: list[(?str, str)], root: yang.schema.DRoot) -> ?(t: str, val: value):
    """Parse a textual value according to the provided schema type.

    Returns:
        (t, val): A typed tuple with the concrete type name and native value
                  (e.g. ("uint8", 42)). For unions, returns the successful
                  member type and parsed value.

    Errors:
        Raises YangValidationError with a message including the formatted
        schema path (from the path parameter) and a textual description of the
        expected type (including range constraints if present).
    """
    type_name = schema_type.builtin_type

    if isinstance(schema_type, yang.schema.DTypeUnion):
        for alt_type in schema_type.types:
            try:
                return try_parse_xml_value(text_value, schema_node, alt_type, path, nsdefs, root)
            except YangValidationError:
                continue
        if text_value is not None:
            raise YangValidationError(path, schema_type, text_value)
        return None
    elif isinstance(schema_type, yang.schema.DTypeEmpty):
        if text_value is not None and len(text_value) != 0:
            raise YangValidationError(path, schema_type, text_value)
        return (t=type_name, val=yang.gdata.Present())

    if text_value is not None:
        val: ?value = None
        if isinstance(schema_type, yang.schema.DTypeString):
            val = text_value
        elif isinstance(schema_type, yang.schema.DTypeInteger):
            try:
                val = bigint(text_value)
            except ValueError:
                raise YangValidationError(path, schema_type, text_value)
        elif isinstance(schema_type, yang.schema.DTypeEnum):
            val = text_value
        elif isinstance(schema_type, yang.schema.DTypeDecimal64):
            val = Decimal.try_parse(text_value)
        elif isinstance(schema_type, yang.schema.DTypeBoolean):
            if text_value == "true":
                val = True
            elif text_value == "false":
                val = False
        elif isinstance(schema_type, yang.schema.DTypeBinary):
            try:
                val = base64.decode(text_value.encode())
            except ValueError:
                pass
        elif isinstance(schema_type, yang.schema.DTypeIdentityref):
            partial = Identityref.from_xml(text_value, nsdefs)
            res = yang.schema.complete_identityref(partial, root.identities, schema_node.module)
            val = res.0
        elif isinstance(schema_type, yang.schema.DTypeLeafref):
            val = text_value
        elif isinstance(schema_type, yang.schema.DTypeInstanceIdentifier):
            val = text_value
        elif isinstance(schema_type, yang.schema.DTypeBits):
            bits_val = set(None)
            for bit in text_value.split(" "):
                if bit in schema_type.name_to_pos:
                    bits_val.add(bit)
                else:
                    raise YangValidationError(path, schema_type, text_value)
            val = bits_val

        if val is not None and schema_type.validate_value(val):
            return (t=type_name, val=val)

        raise YangValidationError(path, schema_type, text_value)

    return None


extension dict[A(Hashable), B] (YangData):
    def take_container(self, schema: yang.schema.DContainer, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> ?(op: ?str, val: ?value):
        if isinstance(self, dict):
            maybe = None
            # For cross-namespace children, only accept module-qualified keys
            if ns_qualified and schema.module is not None and schema.module != "":
                maybe = self.get(f"{schema.module}:{name}")
            else:
                maybe = self.get(name)
            if isinstance(maybe, dict):
                return (op=None, val=maybe)
        return None

    def take_list(self, schema: yang.schema.DList, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> list[(op: ?str, key: dict[str, value], val: value)]:
        new_path = path + [PathElement(schema)]
        if isinstance(self, dict):
            lv = None
            if ns_qualified and schema.module is not None and schema.module != "":
                lv = self.get(f"{schema.module}:{name}")
            else:
                lv = self.get(name)
            if isinstance(lv, list):
                key_values: (dict[str, ?value]) -> dict[str, value] = lambda element_data: {k: unwrap_key(k, element_data.get(k), new_path) for k in schema.key}
                return [(op=None, key=key_values(le), val=le) for le in lv]
        return []

    def take_leaf(self, root: yang.schema.DRoot, schema: yang.schema.DLeaf, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> ?(op: ?str, t: str, val: ?value):
        new_path = path + [PathElement(schema)]
        if isinstance(self, dict):
            leaf_value = None
            if ns_qualified and schema.module is not None and schema.module != "":
                leaf_value = self.get(f"{schema.module}:{name}")
            else:
                leaf_value = self.get(name)
            if leaf_value is not None:
                tv = try_parse_json_value(leaf_value, schema, schema.type_, new_path, root)
                if tv is not None:
                    return (op=None, t=tv.t, val=tv.val)
            else:
                return None
        else:
            return None

    def take_leaflist(self, root: yang.schema.DRoot, schema: yang.schema.DLeafList, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> list[(op: ?str, t: str, val: ?value)]:
        values: list[(op: ?str, t: str, val: ?value)] = []
        if isinstance(self, dict):
            leaflist_data = None
            if ns_qualified and schema.module is not None and schema.module != "":
                leaflist_data = self.get(f"{schema.module}:{name}")
            else:
                leaflist_data = self.get(name)
            if isinstance(leaflist_data, list):
                new_path = path + [PathElement(schema)]
                for item in leaflist_data:
                    tv = try_parse_json_value(item, schema, schema.type_, new_path, root)
                    if tv is not None:
                        values.append((op=None, t=tv.t, val=tv.val))
        return values


def try_parse_json_value(leaf_value: ?value, schema_node: yang.schema.DNodeLeaf, schema_type: yang.schema.DType, path: list[PathElement], root: yang.schema.DRoot) -> ?(t: str, val: value):
    """Parse a textual value according to the provided schema type.

    Returns:
        (t, val): A typed tuple with the concrete type name and native value
                  (e.g. ("uint8", 42)). For unions, returns the successful
                  member type and parsed value.

    Errors:
        Raises YangValidationError with a message including the formatted
        schema path (from the path parameter) and a textual description of the
        expected type (including range constraints if present).
    """
    type_name = schema_type.builtin_type

    if isinstance(schema_type, yang.schema.DTypeUnion):
        for alt_type in schema_type.types:
            try:
                return try_parse_json_value(leaf_value, schema_node, alt_type, path, root)
            except YangValidationError:
                continue
        if leaf_value is not None:
            raise YangValidationError(path, schema_type, leaf_value)
        return None
    elif isinstance(schema_type, yang.schema.DTypeEmpty):
        # Empty leaf JSON encoding: [null]
        if isinstance(leaf_value, list) and len(leaf_value) == 1 and leaf_value[0] is None:
            return (t=type_name, val=yang.gdata.Present())
        raise YangValidationError(path, schema_type, leaf_value)

    if leaf_value is not None:
        val: ?value = None
        if isinstance(schema_type, yang.schema.DTypeString):
            val = leaf_value
        elif isinstance(schema_type, yang.schema.DTypeInteger):
            if isinstance(leaf_value, atom):
                try:
                    val = bigint(leaf_value)
                except ValueError:
                    raise YangValidationError(path, schema_type, leaf_value)
            else:
                raise YangValidationError(path, schema_type, leaf_value)
        elif isinstance(schema_type, yang.schema.DTypeEnum):
            val = leaf_value
        elif isinstance(schema_type, yang.schema.DTypeDecimal64):
            if isinstance(leaf_value, str):
                val = Decimal.try_parse(leaf_value)
            elif isinstance(leaf_value, float):
                # TODO: Make sure we won't receive floats as those may lose precision
                val = Decimal.try_parse(str(leaf_value))
            else:
                val = leaf_value
        elif isinstance(schema_type, yang.schema.DTypeBoolean):
            if isinstance(leaf_value, str):
                if leaf_value == "true":
                    val = True
                elif leaf_value == "false":
                    val = False
            else:
                val = leaf_value
        elif isinstance(schema_type, yang.schema.DTypeBinary):
            if isinstance(leaf_value, str):
                try:
                    val = base64.decode(leaf_value.encode())
                except ValueError:
                    pass
            else:
                val = leaf_value
        elif isinstance(schema_type, yang.schema.DTypeIdentityref):
            if isinstance(leaf_value, str):
                partial = Identityref.from_json(leaf_value)
                res = yang.schema.complete_identityref(partial, root.identities, schema_node.module)
                val = res.0
            else:
                val = leaf_value
        elif isinstance(schema_type, yang.schema.DTypeLeafref):
            val = leaf_value
        elif isinstance(schema_type, yang.schema.DTypeInstanceIdentifier):
            val = leaf_value
        elif isinstance(schema_type, yang.schema.DTypeBits):
            if isinstance(leaf_value, str):
                bits_val = set(None)
                for bit in leaf_value.split(" "):
                    if bit in schema_type.name_to_pos:
                        bits_val.add(bit)
                    else:
                        raise YangValidationError(path, schema_type, leaf_value)
                val = bits_val
            else:
                val = leaf_value

        if val is not None and schema_type.validate_value(val):
            return (t=type_name, val=val)

        raise YangValidationError(path, schema_type, leaf_value)

    return None


extension yang.adata.MNode (YangData):
    def take_container(self, schema: yang.schema.DContainer, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> ?(op: ?str, val: ?value):
        usname = yang.schema._safe_name(name if is_unique else "{schema.prefix}_{name}")
        maybe_cnt = self._get_attr(usname)
        if maybe_cnt is not None:
            return (op=None, val=maybe_cnt)

    def take_list(self, schema: yang.schema.DList, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> list[(op: ?str, key: dict[str, value], val: value)]:
        new_path = path + [PathElement(schema)]
        usname = yang.schema._safe_name(name if is_unique else "{schema.prefix}_{name}")
        maybe_list = self._get_attr(usname)
        if maybe_list is not None and isinstance(maybe_list, Iterator):
            key_values = lambda element_data: {k: unwrap_key(k, element_data._get_attr(yang.schema._safe_name(k)), new_path) for k in schema.key}
            return [(op=None, key=key_values(e), val=e) for e in maybe_list]
        return [] # ??

    def take_leaf(self, root: yang.schema.DRoot, schema: yang.schema.DLeaf, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> ?(op: ?str, t: str, val: ?value):
        new_path = path + [PathElement(schema)]
        usname = yang.schema._safe_name(name if is_unique else "{schema.prefix}_{name}")
        maybe_attr = self._get_attr(usname)
        if maybe_attr is not None:
            schema_type = schema.type_
            tv = try_validate_mnode_value(maybe_attr, schema_type)
            if tv is not None:
                if tv.t == "empty":
                    return (op=None if tv.val else OP_REMOVE, t=tv.t, val=yang.gdata.Present() if tv.val else None)
                return (op=None, t=tv.t, val=tv.val)
            raise YangValidationError(path, schema_type, maybe_attr)

    def take_leaflist(self, root: yang.schema.DRoot, schema: yang.schema.DLeafList, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> list[(op: ?str, t: str, val: ?value)]:
        new_path = path + [PathElement(schema)]
        values: list[(op: ?str, t: str, val: ?value)] = []
        usname = yang.schema._safe_name(name if is_unique else "{schema.prefix}_{name}")
        children = self._get_attr(usname)
        if isinstance(children, list):
            schema_type = schema.type_
            for child in children:
                tv = try_validate_mnode_value(child, schema_type)
                if tv is not None:
                    values.append((op=None, t=tv.t, val=tv.val))
                else:
                    raise YangValidationError(path, schema_type, child)
        return values


def try_validate_mnode_value(val: value, schema_type: yang.schema.DType) -> ?(t: str, val: value):
    if isinstance(schema_type, yang.schema.DTypeUnion):
        if isinstance(val, int):
            # Handle case where mnode leaf value type is 'value'
            # where an assigned integer literal is by default interpreted as int rather than the bigint we want
            _val = bigint(val)
        else:
            _val = val
        for alt_type in schema_type.types:
            tv = try_validate_mnode_value(_val, alt_type)
            if tv is not None:
                return tv
    else:
        if schema_type.validate_value(val):
            return (t=schema_type.builtin_type, val=val)
    return None



def _user_order(ordered_by):
    return True if ordered_by == "user" else False


def _parse_qualified_name(name: str) -> (str, ?str):
    if ":" in name:
        parts = name.split(":", 1)
        return (parts[1], parts[0])
    return (name, None)


def has_mandatory_content(container: yang.schema.DContainer) -> bool:
    """Return True if a non-presence container has any mandatory content.

    A container has mandatory content if it contains any mandatory leaf, or
    any non-presence child container that itself has mandatory content.
    """
    for c in container.children:
        if isinstance(c, yang.schema.DLeaf):
            if c.mandatory:
                return True
        elif isinstance(c, yang.schema.DContainer):
            if not c.presence and has_mandatory_content(c):
                return True
    return False


def from_json_path(root: yang.schema.DRoot, data: dict[str, ?value], path: list[str], op: str="merge", loose: bool=False) -> yang.gdata.Container:
    r"""Convert JSON to a gdata tree rooted at the schema root, with data applied
    at the specified path.

    Unlike from_data which can create partial trees starting at any schema node,
    this function ALWAYS creates a sparse tree from the root of the schema,
    meaning that it  only creates containers and list entries required to hold
    the data at the specified path location. This is useful for NETCONF/RESTCONF
    operations where the payload is a subtree rooted in the provided query path.

    Args:
        root: Root schema node (must be the actual root, not an inner node)
        data: JSON data to apply at the target path location
        path: List of path elements to navigate from root, e.g. ["mod1:c1", "list1", "key1", "inner"]
              - Container/List names "name" or "module:name"
              - List entries: comma-separated key values, e.g. "key1,key2"
        op: Operation to perform - "merge" (default) or "remove"
        loose: Whether to allow missing mandatory fields

    Returns:
        A sparse gdata tree from root with data only at the specified path

    Examples:
        # Creates: root -> c1 -> c2 -> {leaf1: "value"}
        from_json_path(schema, {"leaf1": "value"}, ["mod:c1", "c2"])

        # Creates: root -> list1[key1] -> container -> {field: "value"}
        from_json_path(schema, {"field": "value"}, ["mod:list1", "key1", "container"])

        # Creates: root -> list1[key1] as Absent (for removal)
        from_json_path(schema, {}, ["mod:list1", "key1"], "remove")
    """
    result = _from_json_path_recursive(root, root, data, path, op, loose, [PathElement(root)], True, True)
    # The top-level call always returns a Container because:
    # - If path is empty, from_data returns Container
    # - If path is non-empty, we wrap in Container
    if isinstance(result, yang.gdata.Container):
        return result
    else:
        raise ValueError("Internal error: expected Container at root level")


def _from_json_path_recursive(root: yang.schema.DRoot, s: yang.schema.DNodeInner, data: dict[str, ?value], path: list[str], op: str, loose: bool, current_path: list[PathElement], top: bool, set_ns: bool) -> yang.gdata.Node:
    if isinstance(s, yang.schema.DRoot) or isinstance(s, yang.schema.DContainer):
        if len(path) == 0:
            # Base case: no more path elements, process the data
            if op == "merge":
                # TODO: set_ns??
                return _from_data_recursive(root, s, data, loose=loose, set_ns=set_ns, spath=current_path)
            elif op == "remove":
                return yang.gdata.Absent()
            raise ValueError("Invalid operation at {format_schema_path(current_path)}: {op}")
        else:   # len(path) > 0
            # More path to traverse - create a container with just the next child
            point = path[0]
            rest_path = path[1:]

            local_name, module = _parse_qualified_name(point)
            child = s.get(local_name, module=module, allow_unqualified=False)

            if isinstance(child, yang.schema.DNodeInner):
                # Recursively process the child node
                perhaps = True if (top or set_ns) and s.namespace != "" else False
                cchild = _from_json_path_recursive(root, child, data, rest_path, op, loose, current_path + [PathElement(child)], False, s.namespace != child.namespace)
                # Create a container with just this one child
                return yang.gdata.Container({_fqname(child): cchild}, ns=s.namespace if perhaps else None, module=s.module if perhaps else None)

            # Path tries to go through a leaf - this is an error
            raise ValueError("Invalid JSON path to non-inner node at {format_schema_path(current_path + [PathElement(child)])}: {point}")
    elif isinstance(s, yang.schema.DList):
        if len(path) == 1:
            # Base case: keys are the last path element
            point = path[0]
            keys = point.split(",")
            # Check that all keys are present in payload.
            # If present, they must equal the keys in the path
            # If not present, fill in from path
            data_with_keys = dict(data.items())
            for key in s.key:
                if key not in data_with_keys:
                    data_with_keys[key] = keys.pop(0)
                else:
                    if str(data_with_keys[key]) != keys.pop(0):
                        raise ValueError("Key value mismatch between path and payload at {format_schema_path(current_path)}")
            element_gdata = _from_data_recursive(root, s, data_with_keys, loose, set_ns=False, spath=current_path + [PathElement(s, {k: v for k, v in data_with_keys.items() if k in s.key and v is not None})])
            elements = []
            if op == "merge":
                elements.append(element_gdata)
            elif op == "remove":
                elements.append(yang.gdata.Absent(element_gdata.key_children(_fq_list_keys(s))))
            else:
                raise ValueError("Invalid operation at {format_schema_path(current_path)}: {op}")
            perhaps = True if (top or set_ns) and s.namespace != "" else False
            return yang.gdata.List(_fq_list_keys(s), elements, _user_order(s.ordered_by), ns=s.namespace if perhaps else None, module=s.module if perhaps else None)
        elif len(path) > 1:
            # The path crosses this list element and references another inner node
            point = path[0]
            rest_path = path[1:]

            # First create this list with a single element with only key children.
            # For nested lists, we always use "merge" for intermediate elements.
            slist = _from_json_path_recursive(root, s, {}, [point], "merge", loose, current_path, top, set_ns)

            # The return type must be a List, we just requested it
            if isinstance(slist, yang.gdata.List):
                # Now process the rest of the path following the structural list keys
                child_point = rest_path[0]
                child_rest_path = rest_path[1:]

                local_name, module = _parse_qualified_name(child_point)

                lchild = s.get(local_name, module=module, allow_unqualified=False)
                if isinstance(lchild, yang.schema.DNodeInner):
                    # Now extract gdata for the rest of the path, from the child point
                    inner_result = _from_json_path_recursive(root, lchild, data, child_rest_path, op, loose, current_path + [PathElement(lchild)], False, False)

                    # Add it to the structural list element, next to the existing keys
                    slist.elements[0].children[_fqname(lchild)] = inner_result
                    return slist
                else:
                    raise ValueError("Node at {format_schema_path(current_path + [PathElement(lchild)])} is not inner: {type(lchild)}")

            raise ValueError("unreachable")
        raise ValueError("Unable to resolve path at {format_schema_path(current_path)}: no keys provided")


    raise ValueError("Unknown schema node type at {format_schema_path(current_path)}: {type(s)}")


def from_data[A(YangData)](root: yang.schema.DRoot, data: A, loose: bool=False, root_path: list[str]=[]) -> yang.gdata.Container:
    """Generic function to convert data to gdata tree based on schema

    Args:
        root: Root schema node (must be the actual root, not an inner node)
        data: Data wrapped in a YangData protocol implementation (XML or JSON)
        loose: Whether to use loose parsing (allows optional fields to be missing)
        root_path: Path from s to the actual data location in the input. This enables
                  partial parsing where the data doesn't start at the schema root but
                  at some inner node. For example, if root_path=["mod:c1", "c2"],
                  the function will navigate from s through c1 and c2 before starting
                  to parse the actual data.

    Returns:
        A yang.gdata.Container containing the parsed data tree
    """
    return _from_data_recursive(root, root, data, loose, root_path=root_path, spath=[PathElement(root)])

def _from_data_recursive[A(YangData)](root: yang.schema.DRoot, s: yang.schema.DNodeInner, data: A, loose: bool=False, set_ns: bool=True, root_path: list[str]=[], spath: list[PathElement]=[], skip_nonkeys: bool=False) -> yang.gdata.Container:
    """Internal function with additional recursion accumulators

    Args:
        root: Root schema node (must be the actual root, not an inner node), e.g. for resolving identityref values
        s: Schema node (container or list) - the root of the schema tree to start parsing from
        data: Data wrapped in a YangData protocol implementation (XML or JSON)
        loose: Whether to use loose parsing (allows optional fields to be missing)
        set_ns: Whether to set namespace information on generated nodes
        root_path: Path from s to the actual data location in the input. This enables
                  partial parsing where the data doesn't start at the schema root but
                  at some inner node. For example, if root_path=["mod:c1", "c2"],
                  the function will navigate from s through c1 and c2 before starting
                  to parse the actual data.
        spath: Accumulated schema path as list[PathElement], including list key
               predicates when descending into list elements. This is passed to
               YangData.take_* so that any validation errors can render full,
               human-friendly paths (e.g., /c1/l2[k1='A']/v1).

    Returns:
        A yang.gdata.Container containing the parsed data tree
    """

    # Navigate to root path if specified
    if root_path != [] and len(spath) -1 < len(root_path):
        next = root_path[len(spath) - 1]

        local_name, module = _parse_qualified_name(next)
        child = s.get(local_name, module=module, allow_unqualified=False)
        if isinstance(child, yang.schema.DNodeInner):
            return _from_data_recursive(root, child, data, loose, set_ns, root_path, spath + [PathElement(child)])
        raise ValueError("Node at {format_schema_path(spath + [PathElement(child)])} is not inner: {type(child)}")

    children: dict[yang.gdata.Id, yang.gdata.Node] = {}

    unique_namer = yang.schema._UniqueNamer(s)
    def is_unique(n) -> bool:
        return unique_namer.is_unique(n.name)

    source_is_xml = isinstance(data, xml.Node)
    for child in s.children:
        if skip_nonkeys and isinstance(s, yang.schema.DList) and child.name not in s.key:
            continue

        # Only process data nodes
        if not (isinstance(child, yang.schema.DNodeLeaf) or isinstance(child, yang.schema.DContainer) or isinstance(child, yang.schema.DList)):
            continue

        def path_with_child(k=None):
            return spath + [PathElement(child, k)]

        # Determine namespace (only include if different from parent)
        ns = None
        mod = None
        if child.namespace != s.namespace:
            ns = child.namespace
            mod = child.module

        if isinstance(child, yang.schema.DContainer):
            opval = data.take_container(child, child.name, s.namespace != child.namespace, is_unique(child), spath)
            if opval is not None:
                val = opval.val
                if isinstance(val, xml.Node):
                    cchild = _from_data_recursive(root, child, val, loose, set_ns=s.namespace != child.namespace, root_path=root_path, spath=path_with_child())
                elif isinstance(val, dict):
                    cchild = _from_data_recursive(root, child, val, loose, set_ns=s.namespace != child.namespace, root_path=root_path, spath=path_with_child())
                elif isinstance(val, yang.adata.MNode):
                    cchild = _from_data_recursive(root, child, val, loose, set_ns=s.namespace != child.namespace, root_path=root_path, spath=path_with_child())
                else:
                    # TODO: can't we change YangData protocol such that val implements YangData?!
                    raise ValueError("Unsupported type for container {format_schema_path(path_with_child())}: {type(val)}")
                cns = child.namespace if set_ns and child.namespace != "" else None
                cmod = child.module if set_ns and child.module != "" else None
                wcchild = None
                if opval.op == OP_REMOVE:
                    wcchild = yang.gdata.Absent(cchild.children, ns=cns, module=cmod)
                elif opval.op == OP_DELETE:
                    wcchild = yang.gdata.Delete(cchild.children, ns=cns, module=cmod)
                elif opval.op == OP_CREATE:
                    wcchild = yang.gdata.Create(cchild.children, ns=cns, module=cmod)
                elif opval.op == OP_REPLACE:
                    wcchild = yang.gdata.Replace(cchild.children, ns=cns, module=cmod)

                if wcchild is not None and not isinstance(wcchild, yang.gdata.Container):
                    # Absent, Delete, Create, Replace wrappers are not Container and may not have any children
                    children[_fqname(child)] = wcchild
                elif isinstance(cchild, yang.gdata.Container) and (cchild.presence or len(cchild.children) > 0):
                    children[_fqname(child)] = cchild
            else:
                # Missing container: if this is a non-presence container and it has
                # mandatory content, then raise an error in strict mode.
                if not loose and isinstance(child, yang.schema.DContainer) and not child.presence:
                    if has_mandatory_content(child):
                        raise ValueError("Error reading {format_schema_path(path_with_child())}: Cannot find child node with name {child.name}")

        elif isinstance(child, yang.schema.DList):
            list_val = data.take_list(child, child.name, s.namespace != child.namespace, is_unique(child), spath)
            list_elements = []

            for element in list_val:
                element_data = element.val
                do_skip = True if element.op == OP_REMOVE or element.op == OP_DELETE else False
                if isinstance(element_data, xml.Node):
                    element_gdata = _from_data_recursive(root, child, element_data, loose, set_ns=False, root_path=root_path, spath=path_with_child(element.key), skip_nonkeys=do_skip)
                elif isinstance(element_data, dict):
                    element_gdata = _from_data_recursive(root, child, element_data, loose, set_ns=False, root_path=root_path, spath=path_with_child(element.key), skip_nonkeys=do_skip)
                elif isinstance(element_data, yang.adata.MNode):
                    element_gdata = _from_data_recursive(root, child, element_data, loose, set_ns=False, root_path=root_path, spath=path_with_child(element.key), skip_nonkeys=do_skip)
                else:
                    raise ValueError("Unsupported type for list element at {format_schema_path(path_with_child())}: {type(element_data)}")
                if element.op == OP_REMOVE:
                    list_elements.append(yang.gdata.Absent(element_gdata.key_children(_fq_list_keys(child))))
                elif element.op == OP_DELETE:
                    list_elements.append(yang.gdata.Delete(element_gdata.key_children(_fq_list_keys(child))))
                elif element.op == OP_CREATE:
                    list_elements.append(yang.gdata.Create(element_gdata.children))
                elif element.op == OP_REPLACE:
                    list_elements.append(yang.gdata.Replace(element_gdata.children))
                else:
                    list_elements.append(element_gdata)
            if len(list_elements) > 0:
                list_gdata = yang.gdata.List(_fq_list_keys(child), list_elements, user_order=_user_order(child.ordered_by), ns=ns, module=mod)
                children[_fqname(child)] = list_gdata

        elif isinstance(child, yang.schema.DLeafList):
            leaflist_val = data.take_leaflist(root, child, child.name, s.namespace != child.namespace, is_unique(child), spath)
            if len(leaflist_val) > 0:
                non_merge_ops = set()
                # Unwrap typed tuples, dropping values marked for remove/delete.
                unwrapped_values: list[value] = []
                for item in leaflist_val:
                    # TODO: we can't really handle create/replace without refactoring leaf-list to be more list-like
                    op = item.op
                    if op is not None and op != OP_MERGE and op != OP_CREATE and op != OP_REPLACE:
                        non_merge_ops.add(op)
                    if item.op == OP_REMOVE or item.op == OP_DELETE:
                        continue
                    iv = item.val
                    if iv is not None:
                        unwrapped_values.append(iv)
                if len(unwrapped_values) == 0 and not yang.schema.is_optional_arg_yang_leaf(child, yang.schema.list_keys(s), loose):
                    # Missing leaf-list value
                    raise ValueError("Error reading {format_schema_path(path_with_child())}: Missing non-optional leaf-list value")
                if len(unwrapped_values) > 0:
                    children[_fqname(child)] = yang.gdata.LeafList(unwrapped_values, user_order=_user_order(child.ordered_by), ns=ns, module=mod)
                elif len(non_merge_ops) > 1:
                    raise ValueError("Error reading {format_schema_path(path_with_child())}: Mixed leaf-list operations - {non_merge_ops}")
                elif len(non_merge_ops) == 1:
                    # All entries were remove/delete; map to absent/delete node
                    if non_merge_ops.pop() == OP_DELETE:
                        children[_fqname(child)] = yang.gdata.Delete()
                    else:
                        children[_fqname(child)] = yang.gdata.Absent()
            elif not yang.schema.is_optional_arg_yang_leaf(child, yang.schema.list_keys(s), loose):
                # Missing leaf-list value
                raise ValueError("Error reading {format_schema_path(path_with_child())}: Missing non-optional leaf-list value")

        elif isinstance(child, yang.schema.DLeaf):
            typed = data.take_leaf(root, child, child.name, s.namespace != child.namespace, is_unique(child), spath)
            if typed is not None:
                if typed.op == OP_REMOVE:
                    children[_fqname(child)] = yang.gdata.Absent()
                    continue
                elif typed.op == OP_DELETE:
                    children[_fqname(child)] = yang.gdata.Delete()
                    continue
                # create/replace for leaf are treated as normal set; a scalar set replaces any prior value
                av = typed.val
                if av is not None:
                    children[_fqname(child)] = yang.gdata.Leaf(av, ns=ns, module=mod)
            elif not yang.schema.is_optional_arg_yang_leaf(child, yang.schema.list_keys(s), loose):
                # Missing leaf value
                raise ValueError("Error reading {format_schema_path(path_with_child())}: Cannot find child node with name {child.name}")
        else:
            raise ValueError(f"Unknown schema node type at {format_schema_path(path_with_child())}: {child}")

    if isinstance(s, yang.schema.DContainer):
        return yang.gdata.Container(children, presence=s.presence, ns=s.namespace if set_ns and s.namespace != "" else None, module=s.module if set_ns and s.module != "" else None)
    elif isinstance(s, yang.schema.DList) or isinstance(s, yang.schema.DRoot):
        # When processing a list element, return it as a Container
        # The List wrapper is created by the parent when processing all elements
        return yang.gdata.Container(children)
    elif isinstance(s, yang.schema.DOutput) or isinstance(s, yang.schema.DInput):
        return yang.gdata.Container(children)
    else:
        raise ValueError("Unknown schema node type at {format_schema_path(spath)}: {type(s)}")


def pradata(root: yang.schema.DRoot, node: yang.gdata.Node, self_name: str="ad", loose: bool=False, root_path: list[str]=[]):
    return _pradata_recursive(root, node, self_name, loose, top=True, root_path=root_path, spath=[PathElement(root)])


def _pradata_recursive(s: yang.schema.DNodeInner, node: yang.gdata.Node, self_name: str, loose: bool=False, top: bool=False, list_element: bool=False, root_path: list[str]=[], spath: list[PathElement]=[]):
    # Navigate to root path if specified
    if root_path != [] and len(spath) - 1 < len(root_path):
        next = root_path[len(spath) - 1]
        local_name, module = _parse_qualified_name(next)
        child = s.get(local_name, module=module, allow_unqualified=False)
        if isinstance(child, yang.schema.DNodeInner):
            return _pradata_recursive(child, node, self_name, loose, top, list_element, root_path, spath + [PathElement(child)])
        raise ValueError("Node at {format_schema_path(spath + [PathElement(child)])} is not inner: {type(child)}")

    def pname(pe: list[PathElement]):
        return yang.schema.get_path_name([e.node for e in pe])

    def _find_non_optional_subtree(container: yang.schema.DNodeInner, spath: list[PathElement], node: yang.gdata.Node, path: list[str], local_prefix="_") -> (list[str], list[str]):
        r"""Discover the non-optional descendants of a container

        The container here is either a DContainer or a DList (representing
        a list element). We recursively traverse the child nodes of the
        container, looking for non-optional leaves and containers. A
        container is non-optional if it is not a presence container and it
        contains other non-optional nodes.

        As we traverse the tree, we build intermediate container objects
        using their non-optional arguments.

        Args:
            container: The container node to analyze
            path: List of attribute names representing the path from the root
                    to the current container (e.g. ['self', 'child1', 'child2'])
            local_prefix: Prefix used for variable access in generated code,
                            typically "_" for local variables or "" for self references

        The function returns a tuple of two lists:
        - non_optional_args: list of non-optional arguments for the outer container
        - non_optional_containers: list of code lines that declare the
        intermediate containers and their arguments

        Note on f-string evaluation timing:
        This function uses nested f-strings with two evaluation phases:
        1. Generation-time: Outer f-strings resolve class names, paths, variable names
        2. Runtime: Inner f-strings ({{...}}) become {...} and evaluate when pradata() executes.
        """
        non_optional_args = []
        non_optional_containers = []
        unique_namer = yang.schema._UniqueNamer(container)

        for cchild in container.children:
            def path_with_child():
                return spath + [PathElement(cchild)]

            if not (isinstance(cchild, yang.schema.DNodeLeaf) or isinstance(cchild, yang.schema.DContainer) or isinstance(cchild, yang.schema.DList)):
                continue
            if isinstance(cchild, yang.schema.DLeaf):
                # The list of children is already sorted so that key leaves
                # come first in the correct order.
                if not yang.schema.is_optional_arg_yang_leaf(cchild, yang.schema.list_keys(container), loose):
                    leaf = node.get_leaf(_fqname(cchild))
                    non_optional_args.append("{repr_adata(leaf.val)}")
            elif isinstance(cchild, yang.schema.DContainer):
                if not (cchild.presence or loose or yang.schema.optional_subtree(cchild)):
                    cchild_safe_name = unique_namer.unique_safe_name(cchild.name, cchild.prefix)

                    # Recursively build subtree for non-optional children
                    sub_args, sub_containers = _find_non_optional_subtree(cchild, path_with_child(), node.get_cnt(_fqname(cchild)), path + [cchild_safe_name], local_prefix)

                    # Create variable declaration for this container
                    mcchild_var = "{'_'.join(path)}_{cchild_safe_name}"

                    if sub_args:
                        sub_args_str = ", ".join(sub_args)
                        non_optional_containers.append("{mcchild_var} = {pname(path_with_child())}({sub_args_str})")
                    else:
                        non_optional_containers.append("{mcchild_var} = {pname(path_with_child())}()")

                    # Add nested variable declarations
                    non_optional_containers.extend(sub_containers)

                    non_optional_args.append(mcchild_var)

        return non_optional_args, non_optional_containers

    unique_namer = yang.schema._UniqueNamer(s)
    def usname(n) -> str:
        return unique_namer.unique_safe_name(n.name, n.prefix)
    res = []
    if top:
        res.append('# Top node: {format_schema_path(spath)}')
        # Build constructor arguments for non-optional children (same logic as in __init__)
        constructor_args, constructor_containers = _find_non_optional_subtree(s, spath, node, ["self"], local_prefix="")
        if constructor_args:
            # Add variable declarations in reverse order to ensure dependencies are declared before use.
            # For example, if container C needs argument from container B, which needs argument from A,
            # we must generate: A_var = ..., B_var = ..., C_var = ... in that order.
            # Since find_non_optional_subtree() builds the list depth-first, we reverse it.
            res.extend(list(reversed(constructor_containers)))
            args_str = ", ".join(constructor_args)
            res.append("{self_name} = {pname(spath)}({args_str})")
        else:
            res.append("{self_name} = {pname(spath)}()")
    leaves = []
    for child in s.children:
        # Only process data nodes
        if not (isinstance(child, yang.schema.DNodeLeaf) or isinstance(child, yang.schema.DContainer) or isinstance(child, yang.schema.DList)):
            continue

        def path_with_child(k=None):
            return spath + [PathElement(child, k)]

        if isinstance(child, yang.schema.DLeaf):
            if not top and not yang.schema.is_optional_arg_yang_leaf(child, yang.schema.list_keys(s), loose):
                # Do not print non-optional leafs if not top level, because
                # they are implicitly set with .create*()
                continue
            leaf = node.get_opt_leaf_or_absent(_fqname(child))
            if isinstance(leaf, yang.gdata.Leaf):
                # DLeaf values are copied verbatim
                leaves.append("{self_name}.{usname(child)} = {repr_adata(leaf.val)}")
            elif isinstance(leaf, yang.gdata.Absent):
                # "leaf": Absent() is a remove op on an empty leaf
                leaves.append("{self_name}.{usname(child)} = False")
        elif isinstance(child, yang.schema.DLeafList):
            leaflist = node.get_opt_leaflist(_fqname(child))
            if leaflist is not None:
                # DLeafList values are copied verbatim
                leaves.append("{self_name}.{usname(child)} = {repr_adata(leaflist.vals)}")
        elif isinstance(child, yang.schema.DContainer):
            container = node.get_opt_cnt(_fqname(child))
            if container is not None:
                if child.presence:
                    res.append("")
                    res.append("# P-container: {format_schema_path(path_with_child())}")
                    # Build .pradata() code for this P-container
                    pc_args, pc_var_declarations = _find_non_optional_subtree(child, path_with_child(), container, [usname(child)])

                    # Add variable declarations in reverse order to ensure the prerequisites are met
                    res.extend(list(reversed(pc_var_declarations)))

                    child_accessor = yang.schema._safe_name(child.name)
                    pc_args_str = ", ".join(pc_args)
                    res.append("{child_accessor} = {self_name}.create_{usname(child)}({pc_args_str})")
                    # Recursive call to pradata() for the P-container, to fill in the rest of the optional children
                    res.extend(_pradata_recursive(child, container, usname(child), loose, root_path=root_path, spath=path_with_child()).splitlines())
                else:
                    res.extend(_pradata_recursive(child, container, "{self_name}.{usname(child)}", loose, root_path=root_path, spath=path_with_child()).splitlines())
        elif isinstance(child, yang.schema.DList):
            glist = node.get_opt_list(_fqname(child))
            if glist is not None:
                for element in glist.elements:
                    res.append("")
                    res.append("# List {format_schema_path(path_with_child())} element: {element.key_str(_fq_list_keys(child))}")

                    # Build the list of arguments for create() method
                    list_create_args = []

                    non_optional_args, non_optional_containers = _find_non_optional_subtree(child, path_with_child(), element, ["element"])

                    res.extend(list(reversed(non_optional_containers)))
                    list_create_args.extend(non_optional_args)

                    create_args_str = ", ".join(list_create_args)
                    res.append("{usname(child)}_element = {self_name}.{usname(child)}.create({create_args_str})")
                    # Recursive call to pradata() for the list element
                    res.extend(_pradata_recursive(child, element, "{usname(child)}_element", loose, list_element=True, root_path=root_path, spath=path_with_child(element.key_values(_fq_list_keys(child)))).splitlines())
        else:
            raise ValueError("Unhandled child type in .pradata() at {format_schema_path(path_with_child())}: {type(child)}")

    # Add the leaves as a single group at the beginning of the section,
    # optionally add container header if we're not printing a list element
    if leaves:
        if top:
            res = res + leaves
        elif not list_element:
            res = ["", "# Container: {format_schema_path(spath)}"] + leaves + res
        else:
            res = leaves + res
    return "\n".join(res)

def _test_y1_xml():
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    description "Container 1";
    leaf l1 {
      type string;
      description "Leaf 1";
    }
    list l2 {
      key "k1";
      leaf k1 {
        type string;
        description "Key 1";
      }
      leaf v1 {
        type string;
        description "Value 1";
      }
    }
    leaf-list ll1 {
      type string;
      description "Leaf List 1";
    }
    leaf-list ll3 {
      type decimal64 {
        fraction-digits 2;
      }
    }
  }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y1">
  <l1>Value for l1</l1>
  <l2>
    <k1>Key 1</k1>
    <v1>Value for v1</v1>
  </l2>
  <ll1>Item 1</ll1>
  <ll1>Item 2</ll1>
  <ll3>3.14</ll3>
  <ll3>2.72</ll3>
</c1>
</data>"""

    s = yang.compile([y1])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_mandatory_leaf():
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;
  container c1 {
    leaf l1 {
      type string;
      mandatory true;
    }
  }
}"""
    s = yang.compile([y1])

    try:
        from_data(s, xml.decode('<data><c1 xmlns="urn:example:y1"/></data>'))
    except ValueError as err:
        if err.error_message != "Error reading /c1/l1: Cannot find child node with name l1":
            testing.error("Unexpected error: {err}")


def _test_y1_json():
    """Test JSON parsing with the same schema as XML test"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    description "Container 1";
    leaf l1 {
      type string;
      description "Leaf 1";
    }
    list l2 {
      key "k1";
      leaf k1 {
        type string;
        description "Key 1";
      }
      leaf v1 {
        type string;
        description "Value 1";
      }
    }
    leaf-list ll1 {
      type string;
      description "Leaf List 1";
    }
    leaf-list ll3 {
      type decimal64 {
        fraction-digits 2;
      }
    }
  }
}"""

    # According to RFC 7951, the decimal64 and uint64 YANG types must be encoded as
    # a JSON string, but we test with both here ...
    json_data = {
        "y1:c1": {
            "l1": "Value for l1",
            "l2": [
                {
                    "k1": "Key 1",
                    "v1": "Value for v1"
                }
            ],
            "ll1": ["Item 1", "Item 2"],
            "ll3": [3.14, "2.72"]
        }
    }

    s = yang.compile([y1])
    gd = from_data(s, json_data)
    return gd.prsrc()


def _test_root_path():
    """Test root_path argument for navigating to nested containers"""
    y1 = r"""module acme-y1 {
  namespace "urn:example:acme-y1";
  prefix y1;

  container top {
    description "Top container";
    container nested {
      description "Nested container";
      leaf value {
        type string;
        description "Test value";
      }
    }
  }
}"""

    xml_in = r"""<data>
  <nested>
    <value>test data</value>
  </nested>
</data>"""

    s = yang.compile([y1])

    # Start parsing at the /acme-y1:top container (acme-y1 is the module name, not prefix)
    gd_nested = from_data(s, xml.decode(xml_in), root_path=["acme-y1:top"])

    return gd_nested.prsrc()

def _test_error_path_json_list_range():
    """Error path includes list key predicate for JSON payloads"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    list l2 {
      key "k1";
      leaf k1 { type string; }
      leaf v1 {
        type uint8 { range 1..10; }
      }
    }
  }
}"""

    s = yang.compile([y1])
    # v1 is out of range (100)
    json_in = {"y1:c1": {"l2": [{"k1": "Key 1", "v1": "100"}]}}
    try:
        from_data(s, json_in)
    except ValueError as err:
        return str(err)
    raise AssertionError("Expected error not raised")

def _test_error_path_xml_leaf_range():
    """Error path includes nested container for XML payloads"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container top {
    container nested {
      leaf value { type uint8 { range "0..5"; } }
    }
  }
}"""

    xml_in = r"""<data>
<top xmlns="urn:example:y1">
  <nested>
    <value>42</value>
  </nested>
</top>
</data>"""

    s = yang.compile([y1])
    try:
        from_data(s, xml.decode(xml_in))
    except ValueError as err:
        return str(err)
    raise AssertionError("Expected error not raised")


def _test_uint64_edge_json_ok_max_keyword():
    """uint64 accepts max value when range uses 'max'"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c {
    leaf u {
      type uint64 { range "0..max"; }
    }
  }
}"""

    s = yang.compile([y1])
    # Use the maximum uint64 value
    json_in = {"y1:c": {"u": "18446744073709551615"}}
    # Should not raise
    gd = from_data(s, json_in)


def _test_uint64_edge_json_fail_overflow():
    """uint64 rejects value above max with explicit bound"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c {
    leaf u {
      type uint64 { range "0..18446744073709551615"; }
    }
  }
}"""

    s = yang.compile([y1])
    # One above max
    json_in = {"y1:c": {"u": "18446744073709551616"}}
    try:
        from_data(s, json_in)
    except ValueError as err:
        return str(err)
    raise AssertionError("Expected error not raised")


def _test_missing_list_key_json():
    """Test error message when list key is missing in JSON"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    list l1 {
      key "k1 k2";
      leaf k1 { type string; }
      leaf k2 { type string; }
      leaf v1 { type string; }
    }
  }
}"""

    s = yang.compile([y1])
    # Missing k2 key in the list element
    json_in = {"y1:c1": {"l1": [{"k1": "key1", "v1": "value1"}]}}
    try:
        from_data(s, json_in)
        testing.error("Expected ValueError not raised")
    except ValueError as err:
        testing.assertEqual("Missing key value at /c1/l1: k2", err.error_message)


def _test_missing_list_key_xml():
    """Test error message when list key is missing in XML"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    list l1 {
      key "k1 k2";
      leaf k1 { type string; }
      leaf k2 { type int32; }
      leaf v1 { type string; }
    }
  }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y1">
  <l1>
    <k1>key1</k1>
    <v1>value1</v1>
  </l1>
</c1>
</data>"""

    s = yang.compile([y1])
    try:
        from_data(s, xml.decode(xml_in))
        testing.error("Expected ValueError not raised")
    except ValueError as err:
        expected = "Missing key value at /c1/l1: k2"
        testing.assertEqual(expected, err.error_message)


def _test_format_schema_path_empty():
    """format_schema_path renders empty as ''"""
    path: list[PathElement] = []
    out = format_schema_path(path)
    if out != "":
        testing.error("Unexpected path: {out}")


def _test_format_schema_path_root():
    """format_schema_path renders root as '/'"""
    path: list[PathElement] = [PathElement(yang.schema.DRoot())]
    out = format_schema_path(path)
    if out != "/":
        testing.error("Unexpected path: {out}")


def _test_format_schema_path_list_predicate():
    """format_schema_path renders list key predicate"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c {
    list l {
      key "k1 k2";
      leaf k1 { type string; }
      leaf k2 { type int32; }
      leaf v { type string; }
    }
  }
}"""

    s = yang.compile([y1])
    # Locate nodes using schema get()
    cnode = s.get("c")
    lnode = cnode.get("l")
    vnode = lnode.get("v")

    path = [PathElement(s), PathElement(cnode), PathElement(lnode, keys={"k1": "Key 1", "k2": 1}), PathElement(vnode)]
    out = format_schema_path(path)
    testing.assertEqual("/c/l[k1='Key 1',k2='1']/v", out)

    path = [PathElement(s), PathElement(cnode), PathElement(lnode, keys={"k1": "Key 1, with extra's", "k2": 1}), PathElement(vnode)]
    out = format_schema_path(path)
    testing.assertEqual(r"""/c/l[k1='Key 1, with extra\'s',k2='1']/v""", out)

def _test_json_path_basic():
    """Test basic JSON path navigation"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    leaf l1 {
      type string;
    }
    container c2 {
      leaf l2 {
        type string;
      }
    }
  }
}"""

    s = yang.compile([y1])

    # Test navigating to a leaf in a nested container
    gd = from_json_path(s, {"l2": "test value"}, ["y1:c1", "c2"])
    expected = yang.gdata.Container({
        yang.gdata.Id("urn:example:y1", "c1"): yang.gdata.Container({
            yang.gdata.Id("urn:example:y1", "c2"): yang.gdata.Container({
                yang.gdata.Id("urn:example:y1", "l2"): yang.gdata.Leaf("test value")
            })
        }, ns='urn:example:y1', module='y1')
    })
    testing.assertEqual(gd.prsrc(), expected.prsrc())


def _test_json_path_qualified_names():
    """Test JSON path with module-qualified names"""
    mod1 = r"""module mod1 {
  namespace "urn:example:mod1";
  prefix m1;

  container c1 {
    leaf l1 {
      type string;
    }
  }
}"""

    mod2 = r"""module mod2 {
  namespace "urn:example:mod2";
  prefix m2;
  import mod1 { prefix m1; }

  augment "/m1:c1" {
    leaf l2 {
      type string;
    }
  }
}"""

    s = yang.compile([mod1, mod2])

    # Test navigating with qualified name
    gd = from_json_path(s, {"mod2:l2": "augmented value"}, ["mod1:c1"])
    expected = yang.gdata.Container({
        yang.gdata.Id("urn:example:mod1", "c1"): yang.gdata.Container({
            yang.gdata.Id("urn:example:mod2", "l2"): yang.gdata.Leaf("augmented value", ns="urn:example:mod2", module="mod2")
        }, ns="urn:example:mod1", module="mod1")
    })
    testing.assertEqual(gd.prsrc(), expected.prsrc())


def _test_json_path_list():
    """Test JSON path navigation to list elements"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    list l1 {
      key name;
      leaf name {
        type string;
      }
      leaf value {
        type string;
      }
      container inner {
        leaf data {
          type string;
        }
      }
    }
  }
}"""

    s = yang.compile([y1])

    # Test navigating to a specific list element
    gd = from_json_path(s, {"name": "test", "value": "data"}, ["y1:c1", "l1", "test"])
    # Should create a list with single element
    expected = yang.gdata.Container({
      yang.gdata.Id("urn:example:y1", "c1"): yang.gdata.Container({
        yang.gdata.Id("urn:example:y1", "l1"): yang.gdata.List([yang.gdata.Id("urn:example:y1", "name")], elements=[
          yang.gdata.Container({
            yang.gdata.Id("urn:example:y1", "name"): yang.gdata.Leaf('test'),
            yang.gdata.Id("urn:example:y1", "value"): yang.gdata.Leaf('data')
          })
        ])
      }, ns='urn:example:y1', module='y1')
    })
    testing.assertEqual(gd.prsrc(), expected.prsrc())


def _test_json_path_remove():
    """Test JSON path with remove operation"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    list l1 {
      key name;
      leaf name {
        type string;
      }
      leaf value {
        type string;
      }
    }
  }
}"""

    s = yang.compile([y1])

    # Test remove operation on a list element
    gd = from_json_path(s, {}, ["y1:c1", "l1", "test"], "remove")
    # Should contain an Absent node with the key
    expected = yang.gdata.Container({
      yang.gdata.Id("urn:example:y1", "c1"): yang.gdata.Container({
        yang.gdata.Id("urn:example:y1", "l1"): yang.gdata.List([yang.gdata.Id("urn:example:y1", "name")], elements=[
          yang.gdata.Absent({
            yang.gdata.Id("urn:example:y1", "name"): yang.gdata.Leaf('test')
          })
        ])
      }, ns='urn:example:y1', module='y1')
    })
    testing.assertEqual(gd.prsrc(), expected.prsrc())


def _test_json_path_errors():
    """Test error handling in JSON path navigation"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    leaf l1 {
      type string;
    }
  }
}"""

    s = yang.compile([y1])

    # Test missing namespace qualification
    try:
        from_json_path(s, {}, ["y1:c1", "nonexistent"])
        testing.error("Should have raised ValueError for missing namespace qualification")
    except ValueError as e:
        testing.assertIn("Child 'nonexistent' not found", e.error_message)

    # Test navigating beyond leaf
    try:
        from_json_path(s, {}, ["y1:c1", "l1", "beyond"])
        testing.error("Should have raised ValueError for navigating beyond leaf")
    except ValueError as e:
        testing.assertIn("Invalid JSON path to non-inner node", e.error_message)

    # Test invalid operation
    try:
        from_json_path(s, {}, ["y1:c1"], "invalid")
        testing.error("Should have raised ValueError for invalid operation")
    except ValueError as e:
        testing.assertIn("Invalid operation", e.error_message)


def _test_json_path_nested_lists():
    """Test JSON path navigation through nested lists"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    list outer {
      key "outer-key";
      leaf outer-key {
        type string;
      }
      list inner {
        key "inner-key";
        leaf inner-key {
          type string;
        }
        leaf value {
          type string;
        }
        list deep {
          key "deep-key";
          leaf deep-key {
            type string;
          }
          leaf data {
            type int32;
          }
        }
      }
    }
  }
}"""

    s = yang.compile([y1])

    # Test navigating to a nested list element
    gd = from_json_path(s, {"value": "test-value"}, ["y1:c1", "outer", "key1", "inner", "key2"])
    expected = yang.gdata.Container({
        yang.gdata.Id("urn:example:y1", "c1"): yang.gdata.Container({
            yang.gdata.Id("urn:example:y1", "outer"): yang.gdata.List([yang.gdata.Id("urn:example:y1", "outer-key")], elements=[
                yang.gdata.Container({
                    yang.gdata.Id("urn:example:y1", "outer-key"): yang.gdata.Leaf('key1'),
                    yang.gdata.Id("urn:example:y1", "inner"): yang.gdata.List([yang.gdata.Id("urn:example:y1", "inner-key")], elements=[
                        yang.gdata.Container({
                            yang.gdata.Id("urn:example:y1", "inner-key"): yang.gdata.Leaf('key2'),
                            yang.gdata.Id("urn:example:y1", "value"): yang.gdata.Leaf('test-value')
                        })
                    ])
                })
            ])
        }, ns='urn:example:y1', module='y1')
    })
    testing.assertEqual(gd.prsrc(), expected.prsrc())

    # Test navigating to a deeply nested list element (3 levels)
    gd2 = from_json_path(s, {"data": 42}, ["y1:c1", "outer", "key1", "inner", "key2", "deep", "key3"])
    expected2 = yang.gdata.Container({
        yang.gdata.Id("urn:example:y1", "c1"): yang.gdata.Container({
            yang.gdata.Id("urn:example:y1", "outer"): yang.gdata.List([yang.gdata.Id("urn:example:y1", "outer-key")], elements=[
                yang.gdata.Container({
                    yang.gdata.Id("urn:example:y1", "outer-key"): yang.gdata.Leaf('key1'),
                    yang.gdata.Id("urn:example:y1", "inner"): yang.gdata.List([yang.gdata.Id("urn:example:y1", "inner-key")], elements=[
                        yang.gdata.Container({
                            yang.gdata.Id("urn:example:y1", "inner-key"): yang.gdata.Leaf('key2'),
                            yang.gdata.Id("urn:example:y1", "deep"): yang.gdata.List([yang.gdata.Id("urn:example:y1", "deep-key")], elements=[
                                yang.gdata.Container({
                                    yang.gdata.Id("urn:example:y1", "deep-key"): yang.gdata.Leaf('key3'),
                                    yang.gdata.Id("urn:example:y1", "data"): yang.gdata.Leaf(bigint(42))
                                })
                            ])
                        })
                    ])
                })
            ])
        }, ns='urn:example:y1', module='y1')
    })
    testing.assertEqual(gd2.prsrc(), expected2.prsrc())

def _test_netconf_remove_container():
    """NETCONF remove on a container produces Absent"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 {
    presence "p";
    leaf l1 { type string; }
  }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y" xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="remove"/>
</data>"""

    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_remove_list_element():
    """NETCONF remove on a list element produces Absent with key children"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 {
    list l2 {
      key "k1";
      leaf k1 { type string; }
      leaf v1 { type string; }
    }
  }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y">
  <l2 xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="remove">
    <k1>Key 1</k1>
  </l2>
</c1>
</data>"""

    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_remove_leaf():
    """NETCONF remove on a leaf produces Absent"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 {
    leaf l1 { type string; }
  }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y">
  <l1 xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="remove"/>
</c1>
</data>"""

    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_replace_leaf_sets_value():
    """NETCONF replace on a leaf is treated as a normal set"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 {
    leaf l1 { type string; }
  }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y">
  <l1 xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="replace">VAL</l1>
</c1>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_remove_mixed():
    """Mixed normal and remove elements in the same list"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  list l {
    key "k";
    leaf k { type string; }
    leaf v { type string; }
  }
}"""

    xml_in = r"""<data>
<l xmlns="urn:example:y">
  <k>A</k>
  <v>keep</v>
</l>
<l xmlns="urn:example:y" xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="remove">
  <k>B</k>
</l>
</data>
"""

    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_create_list_element():
    """NETCONF create on a list element renders operation and content"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 {
    list l2 {
      key "k1";
      leaf k1 { type string; }
      leaf v1 { type string; }
    }
  }
}"""
    xml_in = r"""<data>
<c1 xmlns="urn:example:y">
  <l2 xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="create">
    <k1>X</k1>
    <v1>Y</v1>
  </l2>
</c1>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_replace_list_element():
    """NETCONF replace on a list element renders operation and content"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 {
    list l2 {
      key "k1";
      leaf k1 { type string; }
      leaf v1 { type string; }
    }
  }
}"""
    xml_in = r"""<data>
<c1 xmlns="urn:example:y">
  <l2 xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="replace">
    <k1>Z</k1>
    <v1>W</v1>
  </l2>
</c1>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_delete_list_element():
    """NETCONF delete on a list element renders operation with keys only"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 {
    list l2 {
      key "k1";
      leaf k1 { type string; }
      leaf v1 { type string; }
    }
  }
}"""
    xml_in = r"""<data>
<c1 xmlns="urn:example:y">
  <l2 xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="delete">
    <k1>DEL</k1>
  </l2>
</c1>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()


def _test_netconf_leaflist_merge_and_remove():
    """NETCONF merge + remove on a leaf-list keeps merge values only"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 {
    leaf-list ll {
      type string;
    }
  }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y">
  <ll>keep</ll>
  <ll xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="remove">drop</ll>
</c1>
</data>"""

    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    expected = yang.gdata.Container({
        yang.gdata.Id("urn:example:y", "c1"): yang.gdata.Container({
            yang.gdata.Id("urn:example:y", "ll"): yang.gdata.LeafList(['keep'])
        }, ns='urn:example:y', module='y')
    })
    testing.assertEqual(gd.prsrc(), expected.prsrc())


def _test_netconf_leaflist_all_delete():
    """NETCONF delete only on a leaf-list produces Delete node"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 {
    leaf-list ll {
      type string;
    }
  }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y">
  <ll xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="delete">drop</ll>
</c1>
</data>"""

    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    expected = yang.gdata.Container({
        yang.gdata.Id("urn:example:y", "c1"): yang.gdata.Container({
            yang.gdata.Id("urn:example:y", "ll"): yang.gdata.Delete()
        }, ns='urn:example:y', module='y')
    })
    testing.assertEqual(gd.prsrc(), expected.prsrc())


def _test_netconf_leaflist_all_remove():
    """NETCONF remove only on a leaf-list produces Absent node"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 {
    leaf-list ll {
      type string;
    }
  }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y">
  <ll xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="remove">gone</ll>
</c1>
</data>"""

    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    expected = yang.gdata.Container({
        yang.gdata.Id("urn:example:y", "c1"): yang.gdata.Container({
            yang.gdata.Id("urn:example:y", "ll"): yang.gdata.Absent()
        }, ns='urn:example:y', module='y')
    })
    testing.assertEqual(gd.prsrc(), expected.prsrc())

def _test_union_int_json():
    """Union(int8 range 1..10 | string): textual int within range resolves as int"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  leaf u {
    type union {
      type int8 { range 1..10; }
      type string;
    }
  }
}"""
    s = yang.compile([y])
    jd = {"y:u": "7"}
    gd = from_data(s, jd)
    return gd.prsrc()

def _test_union_str_json():
    """Union(int8 range 1..10 | string): textual int out of range resolves as string"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  leaf u {
    type union {
      type int8 { range 1..10; }
      type string;
    }
  }
}"""
    s = yang.compile([y])
    jd = {"y:u": "100"}
    gd = from_data(s, jd)
    return gd.prsrc()

def _test_union_str_xml():
    """Union(int8 range 1..10 | string): XML numeric text out of range resolves as string"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  leaf u {
    type union {
      type int8 { range 1..10; }
      type string;
    }
  }
}"""
    xml_in = r"""<data>
<u xmlns="urn:example:y">100</u>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_union_binary_xml():
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  leaf u {
    type union {
      type enumeration { enum "unlimited"; }
      type binary;
    }
  }
}"""
    xml_in = r"""<data>
<u xmlns="urn:example:y">aGk=</u>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    testing.assertEqual(gd.get_bytes(yang.gdata.Id("urn:example:y", "u")), "hi".encode())
    return gd.prsrc()

def _test_union_binary_json():
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  leaf u {
    type union {
      type enumeration { enum "unlimited"; }
      type binary;
    }
  }
}"""
    s = yang.compile([y])
    jd = {"y:u": "aGk="}
    gd = from_data(s, jd)
    testing.assertEqual(gd.get_bytes(yang.gdata.Id("urn:example:y", "u")), "hi".encode())
    return gd.prsrc()

def _test_netconf_create_container():
    """NETCONF create on a container produces Create wrapper and serializes op"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 { leaf l1 { type string; } }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y" xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="create">
  <l1>v</l1>
</c1>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_replace_container():
    """NETCONF replace on a container produces Replace wrapper and serializes op"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 { leaf l1 { type string; } }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y" xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="replace">
  <l1>nv</l1>
</c1>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_netconf_delete_container():
    """NETCONF delete on a container produces Delete wrapper and serializes op"""
    y = r"""module y {
  namespace "urn:example:y";
  prefix y;
  container c1 { leaf l1 { type string; } }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y" xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="delete"/>
</data>"""
    s = yang.compile([y])
    gd = from_data(s, xml.decode(xml_in))
    return gd.prsrc()

    # Test remove operation on nested list element
    gd3 = from_json_path(s, {}, ["y1:c1", "outer", "key1", "inner", "key2"], "remove")
    expected3 = yang.gdata.Container({
        yang.gdata.Id("urn:example:y1", "c1"): yang.gdata.Container({
            yang.gdata.Id("urn:example:y1", "outer"): yang.gdata.List([yang.gdata.Id("urn:example:y1", "outer-key")], elements=[
                yang.gdata.Container({
                    yang.gdata.Id("urn:example:y1", "outer-key"): yang.gdata.Leaf('key1'),
                    yang.gdata.Id("urn:example:y1", "inner"): yang.gdata.List([yang.gdata.Id("urn:example:y1", "inner-key")], elements=[
                        yang.gdata.Absent({
                            yang.gdata.Id("urn:example:y1", "inner-key"): yang.gdata.Leaf('key2')
                        })
                    ])
                })
            ])
        }, ns='urn:example:y1', module='y1')
    })
    testing.assertEqual(gd3.prsrc(), expected3.prsrc())


def _test_pradata():
    schema_str = r"""module test {
      namespace "urn:example:test";
      prefix test;

      leaf top-level-leaf {
        type string;
        description "A leaf at the module root level";
      }

      container c1 {
        leaf optional-leaf {
          type int32;
        }
        leaf empty-yes {
          type empty;
        }
        leaf empty-no {
          type empty;
        }
        leaf decimal {
          type decimal64 {
            fraction-digits 2;
          }
        }
        container c2 {
          presence "This is a presence container";
          leaf l1 {
            type string;
          }
          leaf mandatory-leaf {
            type string;
            mandatory true;
          }
        }
        list li1 {
          key "name extra-key";
          leaf name {
            type string;
          }
          leaf extra-key {
            type int32;
          }
          leaf value {
            type int32;
          }
          container c3 {
            leaf nested-leaf {
              type string;
            }
          }
        }
        leaf-list always-empty {
          // Leave this empty, we check that empty leaf-list is not printed
          type string;
        }
      }
    }"""

    s = yang.compile([schema_str])

    gdata_tree = yang.gdata.Container({
        yang.gdata.Id("urn:example:test", "top-level-leaf"): yang.gdata.Leaf("root value"),
        yang.gdata.Id("urn:example:test", "c1"): yang.gdata.Container({
            yang.gdata.Id("urn:example:test", "optional-leaf"): yang.gdata.Leaf(bigint(42)),
            yang.gdata.Id("urn:example:test", "empty-yes"): yang.gdata.Leaf(yang.gdata.Present()),
            yang.gdata.Id("urn:example:test", "empty-no"): yang.gdata.Absent(),
            yang.gdata.Id("urn:example:test", "decimal"): yang.gdata.Leaf(Decimal(314, -2)),
            yang.gdata.Id("urn:example:test", "c2"): yang.gdata.Container({
                yang.gdata.Id("urn:example:test", "l1"): yang.gdata.Leaf("inner value"),
                yang.gdata.Id("urn:example:test", "mandatory-leaf"): yang.gdata.Leaf("required value")
            }, presence=True),
            yang.gdata.Id("urn:example:test", "li1"): yang.gdata.List([yang.gdata.Id("urn:example:test", "name"), yang.gdata.Id("urn:example:test", "extra-key")], [
                yang.gdata.Container({
                    yang.gdata.Id("urn:example:test", "name"): yang.gdata.Leaf("item1"),
                    yang.gdata.Id("urn:example:test", "extra-key"): yang.gdata.Leaf(bigint(1)),
                    yang.gdata.Id("urn:example:test", "value"): yang.gdata.Leaf(bigint(100))
                }),
                yang.gdata.Container({
                    yang.gdata.Id("urn:example:test", "name"): yang.gdata.Leaf("item2"),
                    yang.gdata.Id("urn:example:test", "extra-key"): yang.gdata.Leaf(bigint(2)),
                    yang.gdata.Id("urn:example:test", "value"): yang.gdata.Leaf(bigint(200)),
                    yang.gdata.Id("urn:example:test", "c3"): yang.gdata.Container({
                        yang.gdata.Id("urn:example:test", "nested-leaf"): yang.gdata.Leaf("birb")
                    })
                })
            ])
        })
    })

    result = pradata(s, gdata_tree)
    return result


def _test_pradata_root_path():
    schema_str = r"""module test {
      namespace "urn:example:test";
      prefix test;

      container outer {
        container middle {
          leaf value1 {
            type string;
          }
          container inner {
            leaf value2 {
              type int32;
            }
          }
        }
      }
    }"""

    s = yang.compile([schema_str])

    gdata_tree = yang.gdata.Container({
        yang.gdata.Id("urn:example:test", "outer"): yang.gdata.Container({
            yang.gdata.Id("urn:example:test", "middle"): yang.gdata.Container({
                yang.gdata.Id("urn:example:test", "value1"): yang.gdata.Leaf("test value"),
                yang.gdata.Id("urn:example:test", "inner"): yang.gdata.Container({
                    yang.gdata.Id("urn:example:test", "value2"): yang.gdata.Leaf(bigint(42))
                })
            })
        })
    })

    middle_node = gdata_tree.get_cnt(yang.gdata.Id("urn:example:test", "outer")).get_cnt(yang.gdata.Id("urn:example:test", "middle"))
    result = pradata(s, middle_node, root_path=["test:outer", "middle"])

    return result


def _test_json_path_container_list_container():
    """Test JSON path navigation through container -> list -> container pattern"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container top {
    list middle {
      key "name";
      leaf name {
        type string;
      }
      container bottom {
        leaf data {
          type string;
        }
        leaf value {
          type int32;
        }
      }
    }
  }
}"""

    s = yang.compile([y1])

    # Test navigating through container -> list -> container and setting data
    gd = from_json_path(s, {"data": "test", "value": 42}, ["y1:top", "middle", "item1", "bottom"])
    expected = yang.gdata.Container({
        yang.gdata.Id("urn:example:y1", "top"): yang.gdata.Container({
            yang.gdata.Id("urn:example:y1", "middle"): yang.gdata.List([yang.gdata.Id("urn:example:y1", "name")], elements=[
                yang.gdata.Container({
                    yang.gdata.Id("urn:example:y1", "name"): yang.gdata.Leaf('item1'),
                    yang.gdata.Id("urn:example:y1", "bottom"): yang.gdata.Container({
                        yang.gdata.Id("urn:example:y1", "data"): yang.gdata.Leaf('test'),
                        yang.gdata.Id("urn:example:y1", "value"): yang.gdata.Leaf(bigint(42))
                    })
                })
            ])
        }, ns='urn:example:y1', module='y1')
    })
    testing.assertEqual(gd.prsrc(), expected.prsrc())

    # Test remove operation on the inner container
    gd2 = from_json_path(s, {}, ["y1:top", "middle", "item1", "bottom"], "remove")
    expected2 = yang.gdata.Container({
        yang.gdata.Id("urn:example:y1", "top"): yang.gdata.Container({
            yang.gdata.Id("urn:example:y1", "middle"): yang.gdata.List([yang.gdata.Id("urn:example:y1", "name")], elements=[
                yang.gdata.Container({
                    yang.gdata.Id("urn:example:y1", "name"): yang.gdata.Leaf('item1'),
                    yang.gdata.Id("urn:example:y1", "bottom"): yang.gdata.Absent()
                })
            ])
        }, ns='urn:example:y1', module='y1')
    })
    testing.assertEqual(gd2.prsrc(), expected2.prsrc())

def _test_identityref():
    # Extended test case from https://github.com/CESNET/libyang/issues/1009
    _ys_identityref = r"""module mod1 {
  yang-version 1.1;
  namespace "urn:cesent:mod1";
  prefix aa;

  identity id1;

  identity id4;

  identity id7;

  identity id2 {
    base id1;
  }

  identity id3 {
    base id2;
  }

  identity id5 {
    base id4;
  }

  identity id6 {
    base id5;
  }

  identity id8 {
    base id7;
    base id6;
  }

  leaf le1 {
    // Valid value must be derived from both bases (intersect)
    type identityref {
      base id1;
      base id4;
    }
    default "id8";  // "id8" is derived from "id4"
  }
  leaf le2 {
    // Valid value must be derived from either base (union)
    type union {
      type identityref {
        base id1;
      }
      type identityref {
        base id4;
      }
    }
  }
  leaf le3 {
    // Valid value must be derived from the base, and there are none!
    type identityref {
      base id8;
    }
  }
}"""
    s = yang.compile([_ys_identityref])

    # Invalid value is not derived from all bases
    xml_in = xml.decode("""<data><le1 xmlns="urn:cesent:mod1">id8</le1></data>""")
    try:
        gd = from_data(s, xml_in)
        testing.error("Expected validation error")
    except YangValidationError as e:
        testing.assertEqual(str(e), "Invalid value at /le1: 'id8' - expected identityref with bases: ['aa:id1', 'aa:id4']")

    # A valid value is derived from one of the bases in the union
    xml_in = xml.decode("""<data><le2 xmlns="urn:cesent:mod1">id8</le2></data>""")
    gd = from_data(s, xml_in)
    exp = yang.gdata.Container({
        yang.gdata.Id("urn:cesent:mod1", "le2"): yang.gdata.Leaf(Identityref('id8', ns='urn:cesent:mod1', mod='mod1', pfx='aa'), ns='urn:cesent:mod1', module='mod1')
    })
    testing.assertEqual(exp.prsrc(), gd.prsrc())

    # A base is not derived from iteslf
    xml_in = xml.decode("""<data><le3 xmlns="urn:cesent:mod1">id8</le3></data>""")
    try:
        gd = from_data(s, xml_in)
        testing.error("Expected validation error")
    except YangValidationError as e:
        testing.assertEqual(str(e), "Invalid value at /le3: 'id8' - expected identityref with bases: ['aa:id8']")
