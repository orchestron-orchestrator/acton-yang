"""Generic YANG data parser implementation

This module provides a generic algorithm for parsing YANG data from different
sources (XML, JSON) using the YangData protocol.
"""

import testing
import xml

import yang
import yang.gdata
import yang.schema


# Map of taker function names to actual functions
XML_TAKERS = {
    # Container takers
    "from_xml_cnt": yang.gdata.from_xml_cnt,
    "from_xml_opt_cnt": yang.gdata.from_xml_opt_cnt,
    # List takers
    "from_xml_list": yang.gdata.from_xml_list,
    "from_xml_opt_list": yang.gdata.from_xml_opt_list,
    # Leaf takers
    "from_xml_str": yang.gdata.from_xml_str,
    "from_xml_opt_str": yang.gdata.from_xml_opt_str,
    "from_xml_int": yang.gdata.from_xml_int,
    "from_xml_opt_int": yang.gdata.from_xml_opt_int,
    "from_xml_float": yang.gdata.from_xml_float,
    "from_xml_opt_float": yang.gdata.from_xml_opt_float,
    "from_xml_bool": yang.gdata.from_xml_bool,
    "from_xml_opt_bool": yang.gdata.from_xml_opt_bool,
    "from_xml_opt_empty": yang.gdata.from_xml_opt_empty,
    "from_xml_Identityref": yang.gdata.from_xml_Identityref,
    "from_xml_opt_Identityref": yang.gdata.from_xml_opt_Identityref,
    # LeafList takers
    "from_xml_strs": yang.gdata.from_xml_strs,
    "from_xml_opt_strs": yang.gdata.from_xml_opt_strs,
    "from_xml_ints": yang.gdata.from_xml_ints,
    "from_xml_opt_ints": yang.gdata.from_xml_opt_ints,
    "from_xml_floats": yang.gdata.from_xml_floats,
    "from_xml_opt_floats": yang.gdata.from_xml_opt_floats,
    "from_xml_bools": yang.gdata.from_xml_bools,
    "from_xml_opt_bools": yang.gdata.from_xml_opt_bools,
    "from_xml_bytes": yang.gdata.from_xml_bytes,
    "from_xml_opt_bytes": yang.gdata.from_xml_opt_bytes,
    "from_xml_bytess": yang.gdata.from_xml_bytess,
    "from_xml_opt_bytess": yang.gdata.from_xml_opt_bytess,
    "from_xml_value": yang.gdata.from_xml_value,
    "from_xml_opt_value": yang.gdata.from_xml_opt_value,
    "from_xml_values": yang.gdata.from_xml_values,
    "from_xml_opt_values": yang.gdata.from_xml_opt_values,
    "from_xml_Identityrefs": yang.gdata.from_xml_Identityrefs,
    "from_xml_opt_Identityrefs": yang.gdata.from_xml_opt_Identityrefs,
}

# Map of JSON taker function names to actual functions
JSON_TAKERS = {
    # Container takers
    "take_json_cnt": yang.gdata.take_json_cnt,
    "take_json_opt_cnt": yang.gdata.take_json_opt_cnt,
    # List takers
    "take_json_list": yang.gdata.take_json_list,
    "take_json_opt_list": yang.gdata.take_json_opt_list,
    # Leaf takers
    "take_json_str": yang.gdata.take_json_str,
    "take_json_opt_str": yang.gdata.take_json_opt_str,
    "take_json_int": yang.gdata.take_json_int,
    "take_json_opt_int": yang.gdata.take_json_opt_int,
    "take_json_int64": yang.gdata.take_json_int64,
    "take_json_opt_int64": yang.gdata.take_json_opt_int64,
    "take_json_float": yang.gdata.take_json_float,
    "take_json_opt_float": yang.gdata.take_json_opt_float,
    "take_json_bool": yang.gdata.take_json_bool,
    "take_json_opt_bool": yang.gdata.take_json_opt_bool,
    "take_json_opt_empty": yang.gdata.take_json_opt_empty,
    "take_json_bytes": yang.gdata.take_json_bytes,
    "take_json_opt_bytes": yang.gdata.take_json_opt_bytes,
    "take_json_value": yang.gdata.take_json_value,
    "take_json_opt_value": yang.gdata.take_json_opt_value,
    "take_json_Identityref": yang.gdata.take_json_Identityref,
    "take_json_opt_Identityref": yang.gdata.take_json_opt_Identityref,
    # LeafList takers
    "take_json_strs": yang.gdata.take_json_strs,
    "take_json_opt_strs": yang.gdata.take_json_opt_strs,
    "take_json_ints": yang.gdata.take_json_ints,
    "take_json_opt_ints": yang.gdata.take_json_opt_ints,
    "take_json_int64s": yang.gdata.take_json_int64s,
    "take_json_opt_int64s": yang.gdata.take_json_opt_int64s,
    "take_json_floats": yang.gdata.take_json_floats,
    "take_json_opt_floats": yang.gdata.take_json_opt_floats,
    "take_json_bools": yang.gdata.take_json_bools,
    "take_json_opt_bools": yang.gdata.take_json_opt_bools,
    "take_json_bytess": yang.gdata.take_json_bytess,
    "take_json_opt_bytess": yang.gdata.take_json_opt_bytess,
    "take_json_values": yang.gdata.take_json_values,
    "take_json_opt_values": yang.gdata.take_json_opt_values,
    "take_json_Identityrefs": yang.gdata.take_json_Identityrefs,
    "take_json_opt_Identityrefs": yang.gdata.take_json_opt_Identityrefs,
}


# TODO: implement this protocol on the actual data types instead of the wrapper classes:
# - XML: xml.Node, list[xml.Node]
# - JSON: dict[str, ?value], list[dict[str, ?value]]
# Lacking language support for union types, the common type to these is the
# value builtin type. In the extension, do an isinstance(data, XXX) for the
# supported data types and raise a runtime exception for unsupported.
protocol YangData[N]:
    """Protocol for YANG data nodes where N is the implementing wrapper type

    This protocol provides a uniform interface for extracting data from
    different formats (XML, JSON) while maintaining type safety.
    """
    # Generic take method that uses taker function names
    take: mut(str, str, ?str) -> ?value

    # Methods to wrap results in the same YangData type
    wrap: (value) -> N
    wrap_list: mut(list[value]) -> list[N]

    # Method to identify the format for parameter selection
    format_name: () -> str


class XmlYangData(value):
    """Wrapper for XML nodes that implements YangData protocol"""
    node: xml.Node

    def __init__(self, node: xml.Node):
        self.node = node


# Extension to make XmlYangData implement YangData protocol
extension XmlYangData (YangData[XmlYangData]):
    def take(self, taker_name: str, name: str, ns: ?str=None) -> ?value:
        """Generic take method that looks up the appropriate taker function"""
        if taker_name not in XML_TAKERS:
            raise ValueError(f"Unknown taker function: {taker_name}")
        taker_func = XML_TAKERS[taker_name]
        return taker_func(self.node, name, ns)

    def wrap(self, val: value) -> XmlYangData:
        """Wrap a value in XmlYangData if it's an xml.Node"""
        if isinstance(val, xml.Node):
            return XmlYangData(val)
        raise ValueError("Expected xml.Node to wrap")

    def wrap_list(self, vals: list[value]) -> list[XmlYangData]:
        """Wrap a list of values in XmlYangData"""
        result = []
        for val in vals:
            if isinstance(val, xml.Node):
                result.append(XmlYangData(val))
            else:
                raise ValueError("Expected xml.Node in list")
        return result

    def format_name(self) -> str:
        """Return the format name for parameter selection"""
        return "xml"


# Wrapper class for JSON data
class JsonYangData(value):
    """Wrapper for JSON data that implements YangData protocol"""
    data: dict[str, ?value]

    def __init__(self, data: dict[str, ?value]):
        self.data = data


# Extension to make JsonYangData implement YangData protocol
extension JsonYangData (YangData[JsonYangData]):
    def take(self, taker_name: str, name: str, module: ?str=None) -> ?value:
        """Generic take method that looks up the appropriate taker function"""
        if taker_name not in JSON_TAKERS:
            raise ValueError(f"Unknown taker function: {taker_name}")
        taker_func = JSON_TAKERS[taker_name]
        return taker_func(self.data, name, module)

    def wrap(self, val: value) -> JsonYangData:
        """Wrap a value in JsonYangData if it's a dict"""
        if isinstance(val, dict):
            return JsonYangData(val)
        raise ValueError("Expected dict to wrap")

    def wrap_list(self, vals: list[value]) -> list[JsonYangData]:
        """Wrap a list of values in JsonYangData"""
        result = []
        for val in vals:
            if isinstance(val, dict):
                result.append(JsonYangData(val))
            else:
                raise ValueError("Expected dict in list")
        return result

    def format_name(self) -> str:
        """Return the format name for parameter selection"""
        return "json"


def _user_order(ordered_by):
    return True if ordered_by == "user" else False


def _parse_qualified_name(name: str) -> (str, ?str):
    if ":" in name:
        parts = name.split(":", 1)
        return (parts[1], parts[0])
    return (name, None)


def _from_data(s: yang.schema.DNodeInner, data, loose: bool=False, set_ns: bool=True, path: list[str]=[], root_path: list[str]=[]) -> yang.gdata.Container:
    """Generic function to convert data to gdata tree based on schema

    Args:
        s: Schema node (container or list) - the root of the schema tree to start parsing from
        data: Data wrapped in a YangData protocol implementation (XML or JSON)
        loose: Whether to use loose parsing (allows optional fields to be missing)
        set_ns: Whether to set namespace information on generated nodes
        path: Internal parameter for recursion tracking (leave as default)
        root_path: Path from s to the actual data location in the input. This enables
                  partial parsing where the data doesn't start at the schema root but
                  at some inner node. For example, if root_path=["mod:c1", "c2"],
                  the function will navigate from s through c1 and c2 before starting
                  to parse the actual data.

    Returns:
        A yang.gdata.Container containing the parsed data tree
    """

    # Navigate to root path if specified
    if root_path != [] and len(path) < len(root_path):
        next = root_path[len(path)]
        print("Getting inner node {next} on path {path}", err=True)

        local_name, module = _parse_qualified_name(next)
        child = s.get(local_name, module, allow_unqualified=False)
        if isinstance(child, yang.schema.DNodeInner):
            return _from_data(child, data, loose, set_ns, path + [next], root_path)
        raise ValueError("Node on path {path} is not inner")

    children: dict[str, yang.gdata.Node] = {}

    unique_namer = yang.schema._UniqueNamer(s)
    def uname(n) -> str:
        return unique_namer.unique_name(n.name, n.prefix)

    for child in s.children:
        # Only process data nodes
        if not (isinstance(child, yang.schema.DNodeLeaf) or isinstance(child, yang.schema.DContainer) or isinstance(child, yang.schema.DList)):
            print("Skipping chilld: {child.name} of type {type(child)}", err=True)
            continue
        # Get the appropriate taker function name
        taker_name = yang.schema.taker_name(child, data.format_name(), loose)
        print("Processing child: {child.name} with taker {taker_name}", err=True)

        # Determine namespace (only include if different from parent)
        ns = None
        mod = None
        if child.namespace != s.namespace:
            ns = child.namespace
            mod = child.module

        # Use the protocol's take method
        taken_nodes: ?value = None
        try:
            # For XML, pass ns; for JSON, pass mod
            param = ns if data.format_name() == "xml" else mod
            taken_nodes = data.take(taker_name, child.name, param)
        except ValueError as err:
            raise ValueError("Error reading {yang.schema.get_path(child)}: {err.error_message}")

        if taken_nodes is not None:
            if isinstance(child, yang.schema.DList):
                # We add the gdata.List containing node here, then recursively process each element
                print("Processing list node: {child.name} with taker {taker_name} {ns}", err=True)
                # Use the list taker to get all list element nodes
                if isinstance(taken_nodes, list):
                    # Process each list element
                    list_elements = []
                    wrapped_nodes = data.wrap_list(taken_nodes)
                    for element_data in wrapped_nodes:
                        element_gdata = _from_data(child, element_data, loose, set_ns=False)
                        list_elements.append(element_gdata)

                    # Create the List with processed elements
                    if list_elements:
                        list_gdata = yang.gdata.List(child.key, list_elements, user_order=_user_order(child.ordered_by), ns=ns, module=mod)
                        children[uname(child)] = list_gdata

            elif isinstance(child, yang.schema.DNodeInner):
                # Process inner nodes (containers, lists)
                print("Processing inner node: {child.name} with taker {taker_name} {ns}", err=True)
                wrapped_node = data.wrap(taken_nodes)
                print("Child data wrapped, processing further", err=True)
                yang.gdata.maybe_add(children, uname(child), lambda x: _from_data(child, x, loose, set_ns=s.namespace != child.namespace), wrapped_node)
            elif isinstance(child, yang.schema.DNodeLeaf):
                # Process leaf nodes
                print("Processing leaf node: {child.name} with taker {taker_name} {ns}", err=True)
                if isinstance(child, yang.schema.DLeafList) and isinstance(taken_nodes, list):
                    children[uname(child)] = yang.gdata.LeafList(child.type_.name, taken_nodes, user_order=_user_order(child.ordered_by), ns=ns, module=mod)
                else:
                    children[uname(child)] = yang.gdata.Leaf(child.type_.name, taken_nodes, ns=ns, module=mod)
            else:
                raise ValueError(f"Unknown schema node type at {yang.schema.get_path(child)}: {child}")

    if s.gname == "Container":
        if isinstance(s, yang.schema.DContainer):
            return yang.gdata.Container(children, presence=s.presence, ns=s.namespace if set_ns and s.namespace != "" else None, module=s.module if set_ns else None)
        else:
            return yang.gdata.Container(children, ns=s.namespace if set_ns and s.namespace != "" else None, module=s.module if set_ns else None)
    elif s.gname == "List" and isinstance(s, yang.schema.DList):
        # When processing a list element, return it as a Container
        # The List wrapper is created by the parent when processing all elements
        return yang.gdata.Container(children)
    else:
        raise ValueError(f"Unknown schema node type: {s.gname} for {s}")


def from_xml(s: yang.schema.DNodeInner, node: xml.Node, loose: bool=False, root_path: list[str]=[]) -> yang.gdata.Container:
    """Convert XML node to gdata tree based on schema"""
    xml_data = XmlYangData(node)
    return _from_data(s, xml_data, loose, root_path=root_path)


def from_json(s: yang.schema.DNodeInner, node: dict[str, ?value], loose: bool=False, root_path: list[str]=[]) -> yang.gdata.Node:
    """Convert JSON node to gdata tree based on schema"""
    json_data = JsonYangData(node)
    return _from_data(s, json_data, loose, root_path=root_path)


def _test_y1_xml():
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    description "Container 1";
    leaf l1 {
      type string;
      description "Leaf 1";
    }
    list l2 {
      key "k1";
      leaf k1 {
        type string;
        description "Key 1";
      }
      leaf v1 {
        type string;
        description "Value 1";
      }
    }
    leaf-list ll1 {
      type string;
      description "Leaf List 1";
    }
  }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y1">
  <l1>Value for l1</l1>
  <l2>
    <k1>Key 1</k1>
    <v1>Value for v1</v1>
  </l2>
  <ll1>Item 1</ll1>
  <ll1>Item 2</ll1>
</c1>
</data>"""

    s = yang.compile([y1])
    gd = from_xml(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_mandatory_leaf():
    # Well, this is clearly less readable than YANG ...
    s = yang.schema.DContainer("y1", "urn:example:y1", "y1", name="c1", config=True, presence=False, children=[
        yang.schema.DLeaf("y1", "urn:example:y1", "y1", name="l1", config=True, mandatory=True, type_=yang.schema.Type("string"))
    ])

    try:
        from_xml(s, xml.decode("<c1/>"))
    except ValueError as err:
        if err.error_message != "Error reading /l1: Cannot find xml child with name l1":
            testing.error("Unexpected error: {err}")


def _test_y1_json():
    """Test JSON parsing with the same schema as XML test"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    description "Container 1";
    leaf l1 {
      type string;
      description "Leaf 1";
    }
    list l2 {
      key "k1";
      leaf k1 {
        type string;
        description "Key 1";
      }
      leaf v1 {
        type string;
        description "Value 1";
      }
    }
    leaf-list ll1 {
      type string;
      description "Leaf List 1";
    }
  }
}"""

    json_data = {
        "y1:c1": {
            "l1": "Value for l1",
            "l2": [
                {
                    "k1": "Key 1",
                    "v1": "Value for v1"
                }
            ],
            "ll1": ["Item 1", "Item 2"]
        }
    }

    s = yang.compile([y1])
    gd = from_json(s, json_data)
    return gd.prsrc()


def _test_root_path():
    """Test root_path argument for navigating to nested containers"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container top {
    description "Top container";
    container nested {
      description "Nested container";
      leaf value {
        type string;
        description "Test value";
      }
    }
  }
}"""

    xml_in = r"""<data>
<top xmlns="urn:example:y1">
  <nested>
    <value>test data</value>
  </nested>
</top>
</data>"""

    s = yang.compile([y1])

    # Test parsing from root (should include top container)
    gd_root = from_xml(s, xml.decode(xml_in))

    # Test parsing with root_path to navigate directly to nested container
    gd_nested = from_xml(s, xml.decode(xml_in), root_path=["y1:top", "nested"])

    return gd_nested.prsrc()
