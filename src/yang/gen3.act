import testing
import xml

import yang
import yang.gdata
import yang.schema


# Map of taker function names to actual functions
XML_TAKERS = {
    # Container takers
    "from_xml_cnt": yang.gdata.from_xml_cnt,
    "from_xml_opt_cnt": yang.gdata.from_xml_opt_cnt,
    # List takers
    "from_xml_list": yang.gdata.from_xml_list,
    "from_xml_opt_list": yang.gdata.from_xml_opt_list,
    # Leaf takers
    "from_xml_str": yang.gdata.from_xml_str,
    "from_xml_opt_str": yang.gdata.from_xml_opt_str,
    "from_xml_int": yang.gdata.from_xml_int,
    "from_xml_opt_int": yang.gdata.from_xml_opt_int,
    "from_xml_float": yang.gdata.from_xml_float,
    "from_xml_opt_float": yang.gdata.from_xml_opt_float,
    "from_xml_bool": yang.gdata.from_xml_bool,
    "from_xml_opt_bool": yang.gdata.from_xml_opt_bool,
    "from_xml_opt_empty": yang.gdata.from_xml_opt_empty,
    "from_xml_Identityref": yang.gdata.from_xml_Identityref,
    "from_xml_opt_Identityref": yang.gdata.from_xml_opt_Identityref,
    # LeafList takers
    "from_xml_strs": yang.gdata.from_xml_strs,
    "from_xml_opt_strs": yang.gdata.from_xml_opt_strs,
    "from_xml_ints": yang.gdata.from_xml_ints,
    "from_xml_opt_ints": yang.gdata.from_xml_opt_ints,
    "from_xml_floats": yang.gdata.from_xml_floats,
    "from_xml_opt_floats": yang.gdata.from_xml_opt_floats,
    "from_xml_bools": yang.gdata.from_xml_bools,
    "from_xml_opt_bools": yang.gdata.from_xml_opt_bools,
    "from_xml_bytes": yang.gdata.from_xml_bytes,
    "from_xml_opt_bytes": yang.gdata.from_xml_opt_bytes,
    "from_xml_bytess": yang.gdata.from_xml_bytess,
    "from_xml_opt_bytess": yang.gdata.from_xml_opt_bytess,
    "from_xml_value": yang.gdata.from_xml_value,
    "from_xml_opt_value": yang.gdata.from_xml_opt_value,
    "from_xml_values": yang.gdata.from_xml_values,
    "from_xml_opt_values": yang.gdata.from_xml_opt_values,
    "from_xml_Identityrefs": yang.gdata.from_xml_Identityrefs,
    "from_xml_opt_Identityrefs": yang.gdata.from_xml_opt_Identityrefs,
}

# Map of JSON taker function names to actual functions
JSON_TAKERS = {
    # Container takers
    "take_json_cnt": yang.gdata.take_json_cnt,
    "take_json_opt_cnt": yang.gdata.take_json_opt_cnt,
    # List takers
    "take_json_list": yang.gdata.take_json_list,
    "take_json_opt_list": yang.gdata.take_json_opt_list,
    # Leaf takers
    "take_json_str": yang.gdata.take_json_str,
    "take_json_opt_str": yang.gdata.take_json_opt_str,
    "take_json_int": yang.gdata.take_json_int,
    "take_json_opt_int": yang.gdata.take_json_opt_int,
    "take_json_int64": yang.gdata.take_json_int64,
    "take_json_opt_int64": yang.gdata.take_json_opt_int64,
    "take_json_float": yang.gdata.take_json_float,
    "take_json_opt_float": yang.gdata.take_json_opt_float,
    "take_json_bool": yang.gdata.take_json_bool,
    "take_json_opt_bool": yang.gdata.take_json_opt_bool,
    "take_json_opt_empty": yang.gdata.take_json_opt_empty,
    "take_json_bytes": yang.gdata.take_json_bytes,
    "take_json_opt_bytes": yang.gdata.take_json_opt_bytes,
    "take_json_value": yang.gdata.take_json_value,
    "take_json_opt_value": yang.gdata.take_json_opt_value,
    "take_json_Identityref": yang.gdata.take_json_Identityref,
    "take_json_opt_Identityref": yang.gdata.take_json_opt_Identityref,
    # LeafList takers
    "take_json_strs": yang.gdata.take_json_strs,
    "take_json_opt_strs": yang.gdata.take_json_opt_strs,
    "take_json_ints": yang.gdata.take_json_ints,
    "take_json_opt_ints": yang.gdata.take_json_opt_ints,
    "take_json_int64s": yang.gdata.take_json_int64s,
    "take_json_opt_int64s": yang.gdata.take_json_opt_int64s,
    "take_json_floats": yang.gdata.take_json_floats,
    "take_json_opt_floats": yang.gdata.take_json_opt_floats,
    "take_json_bools": yang.gdata.take_json_bools,
    "take_json_opt_bools": yang.gdata.take_json_opt_bools,
    "take_json_bytess": yang.gdata.take_json_bytess,
    "take_json_opt_bytess": yang.gdata.take_json_opt_bytess,
    "take_json_values": yang.gdata.take_json_values,
    "take_json_opt_values": yang.gdata.take_json_opt_values,
    "take_json_Identityrefs": yang.gdata.take_json_Identityrefs,
    "take_json_opt_Identityrefs": yang.gdata.take_json_opt_Identityrefs,
}


def _user_order(ordered_by):
    return True if ordered_by == "user" else False


def _parse_qualified_name(name: str) -> (str, ?str):
    if ":" in name:
        parts = name.split(":", 1)
        return (parts[1], parts[0])
    return (name, None)


def from_xml(s: yang.schema.DNodeInner, node: xml.Node, loose: bool=False, set_ns: bool=True, path: list[str]=[], root_path: list[str]=[]) -> yang.gdata.Container:
    """Convert XML node to gdata tree based on schema

    Args:
        s: Schema node (container or list) - the root of the schema tree to start parsing from
        data: Data wrapped in a YangData protocol implementation (XML or JSON)
        loose: Whether to use loose parsing (allows optional fields to be missing)
        set_ns: Whether to set namespace information on generated nodes
        path: Internal parameter for recursion tracking (leave as default)
        root_path: Path from s to the actual data location in the input. This enables
                  partial parsing where the data doesn't start at the schema root but
                  at some inner node. For example, if root_path=["mod:c1", "c2"],
                  the function will navigate from s through c1 and c2 before starting
                  to parse the actual data.

    Returns:
        A yang.gdata.Container containing the parsed data tree
    """

    # Navigate to root path if specified
    if root_path != [] and len(path) < len(root_path):
        next = root_path[len(path)]
        print("Getting inner node {next} on path {path}", err=True)

        local_name, module = _parse_qualified_name(next)
        child = s.get(local_name, module, allow_unqualified=False)
        if isinstance(child, yang.schema.DNodeInner):
            return from_xml(child, node, loose, set_ns, path + [next], root_path)
        raise ValueError("Node on path {path} is not inner")

    children: dict[str, yang.gdata.Node] = {}

    unique_namer = yang.schema._UniqueNamer(s)
    def uname(n) -> str:
        return unique_namer.unique_name(n.name, n.prefix)

    for child in s.children:
        # Only process data nodes
        if not (isinstance(child, yang.schema.DNodeLeaf) or isinstance(child, yang.schema.DContainer) or isinstance(child, yang.schema.DList)):
            print("Skipping chilld: {child.name} of type {type(child)}", err=True)
            continue
        # Get the appropriate taker function name
        taker_name = yang.schema.taker_name(child, "xml", loose)
        print("Processing child: {child.name} with taker {taker_name}", err=True)

        # Determine namespace (only include if different from parent)
        ns = None
        mod = None
        if child.namespace != s.namespace:
            ns = child.namespace
            mod = child.module

        # Get the taker function from our map
        if taker_name not in XML_TAKERS:
            raise ValueError(f"Unknown taker function: {taker_name}")
        taker_func = XML_TAKERS[taker_name]

        taken_nodes: ?value = None
        try:
            taken_nodes = taker_func(node, child.name, ns)
        except ValueError as err:
            raise ValueError("Error reading {yang.schema.get_path(child)}: {err.error_message}")

        if taken_nodes is not None:
            if isinstance(child, yang.schema.DList):
                # We add the gdata.List containing node here, then recursively process each element
                print("Processing list node: {child.name} with taker {taker_name} {ns}", err=True)
                # Use the list taker to get all list element nodes
                if isinstance(taken_nodes, list):
                    # Process each list element
                    list_elements = []
                    for element_node in taken_nodes:
                        element_gdata = from_xml(child, element_node, loose, set_ns=False)
                        list_elements.append(element_gdata)

                    # Create the List with processed elements
                    if list_elements:
                        list_gdata = yang.gdata.List(child.key, list_elements, user_order=_user_order(child.ordered_by), ns=ns, module=mod)
                        children[uname(child)] = list_gdata

            elif isinstance(child, yang.schema.DNodeInner):
                # Process inner nodes (containers, lists)
                print("Processing inner node: {child.name} with taker {taker_name} {ns}", err=True)
                if isinstance(taken_nodes, xml.Node):
                    print("Child data is a Node, processing further", err=True)
                    yang.gdata.maybe_add(children, uname(child), lambda x: from_xml(child, x, set_ns=s.namespace != child.namespace), taken_nodes)
            elif isinstance(child, yang.schema.DNodeLeaf):
                # Process leaf nodes
                print("Processing leaf node: {child.name} with taker {taker_name} {ns}", err=True)
                if isinstance(child, yang.schema.DLeafList) and isinstance(taken_nodes, list):
                    children[uname(child)] = yang.gdata.LeafList(child.type_.name, taken_nodes, user_order=_user_order(child.ordered_by), ns=ns, module=mod)
                else:
                    children[uname(child)] = yang.gdata.Leaf(child.type_.name, taken_nodes, ns=ns, module=mod)
            else:
                raise ValueError(f"Unknown schema node type at {yang.schema.get_path(child)}: {child}")
    if s.gname == "Container":
        if isinstance(s, yang.schema.DContainer):
            return yang.gdata.Container(children, presence=s.presence, ns=s.namespace if set_ns and s.namespace != "" else None, module=s.module if set_ns else None)
        else:
            return yang.gdata.Container(children, ns=s.namespace if set_ns and s.namespace != "" else None, module=s.module if set_ns else None)
    elif s.gname == "List" and isinstance(s, yang.schema.DList):
        # When processing a list element, return it as a Container
        # The List wrapper is created by the parent when processing all elements
        return yang.gdata.Container(children)
    else:
        raise ValueError(f"Unknown schema node type: {s.gname} for {s}")


def from_json(s: yang.schema.DNodeInner, node: dict[str, ?value], loose: bool=False, set_ns: bool=True, path: list[str]=[], root_path: list[str]=[]) -> yang.gdata.Container:
    """Convert XML node to gdata tree based on schema"""

    # Navigate to root path if specified
    if root_path != [] and len(path) < len(root_path):
        inner = s.get(root_path[len(path)])
        if isinstance(inner, yang.schema.DNodeInner):
            return from_json(inner, node, loose, set_ns, path + [root_path[len(path)]], root_path)
        raise ValueError("Node on path {path} is not inner")

    # Process container
    children: dict[str, yang.gdata.Node] = {}

    unique_namer = yang.schema._UniqueNamer(s)
    def uname(n) -> str:
        return unique_namer.unique_name(n.name, n.prefix)

    for child in s.children:
        # Get the appropriate taker function name
        taker_name = yang.schema.taker_name(child, "json", loose)
        print("Processing child: {child.name} with taker {taker_name}", err=True)

        # Determine namespace (only include if different from parent)
        ns = None
        mod = None
        if child.namespace != s.namespace:
            ns = child.namespace
            mod = child.module

        # Get the taker function from our map
        if taker_name not in JSON_TAKERS:
            raise ValueError(f"Unknown taker function: {taker_name}")
        taker_func = JSON_TAKERS[taker_name]

        taken_nodes: ?value = None
        try:
            taken_nodes = taker_func(node, child.name, mod)
        except ValueError as err:
            raise ValueError("Error reading {yang.schema.get_path(child)}: {err.error_message}")

        if taken_nodes is not None:
            if isinstance(child, yang.schema.DList):
                # We add the gdata.List containing node here, then recursively process each element
                print("Processing list node: {child.name} with taker {taker_name} {ns}", err=True)
                # Use the list taker to get all list element nodes
                if isinstance(taken_nodes, list):
                    # Process each list element
                    list_elements = []
                    for element_node in taken_nodes:
                        element_gdata = from_json(child, element_node, loose, set_ns=False)
                        list_elements.append(element_gdata)

                    # Create the List with processed elements
                    if list_elements:
                        list_gdata = yang.gdata.List(child.key, list_elements, user_order=_user_order(child.ordered_by), ns=ns, module=mod)
                        children[uname(child)] = list_gdata

            elif isinstance(child, yang.schema.DNodeInner):
                # Process inner nodes (containers, lists)
                print("Processing inner node: {child.name} with taker {taker_name} {ns}", err=True)
                if isinstance(taken_nodes, dict):
                    print("Child data is a Node, processing further", err=True)
                    yang.gdata.maybe_add(children, uname(child), lambda x: from_json(child, x, set_ns=s.namespace != child.namespace), taken_nodes)
            elif isinstance(child, yang.schema.DNodeLeaf):
                # Process leaf nodes
                print("Processing leaf node: {child.name} with taker {taker_name} {ns}", err=True)
                if isinstance(child, yang.schema.DLeafList) and isinstance(taken_nodes, list):
                    children[uname(child)] = yang.gdata.LeafList(child.type_.name, taken_nodes, user_order=_user_order(child.ordered_by), ns=ns, module=mod)
                else:
                    children[uname(child)] = yang.gdata.Leaf(child.type_.name, taken_nodes, ns=ns, module=mod)
            else:
                raise ValueError(f"Unknown schema node type at {yang.schema.get_path(child)}: {child}")
    if s.gname == "Container":
        if isinstance(s, yang.schema.DContainer):
            return yang.gdata.Container(children, presence=s.presence, ns=s.namespace if set_ns and s.namespace != "" else None, module=s.module if set_ns else None)
        else:
            return yang.gdata.Container(children, ns=s.namespace if set_ns and s.namespace != "" else None, module=s.module if set_ns else None)
    elif s.gname == "List" and isinstance(s, yang.schema.DList):
        # When processing a list element, return it as a Container
        # The List wrapper is created by the parent when processing all elements
        return yang.gdata.Container(children)
    else:
        raise ValueError(f"Unknown schema node type: {s.gname} for {s}")

def _test_y1_xml():
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    description "Container 1";
    leaf l1 {
      type string;
      description "Leaf 1";
    }
    list l2 {
      key "k1";
      leaf k1 {
        type string;
        description "Key 1";
      }
      leaf v1 {
        type string;
        description "Value 1";
      }
    }
    leaf-list ll1 {
      type string;
      description "Leaf List 1";
    }
  }
}"""

    xml_in = r"""<data>
<c1 xmlns="urn:example:y1">
  <l1>Value for l1</l1>
  <l2>
    <k1>Key 1</k1>
    <v1>Value for v1</v1>
  </l2>
  <ll1>Item 1</ll1>
  <ll1>Item 2</ll1>
</c1>
</data>"""

    s = yang.compile([y1])
    gd = from_xml(s, xml.decode(xml_in))
    return gd.prsrc()

def _test_mandatory_leaf():
    # Well, this is clearly less readable than YANG ...
    s = yang.schema.DContainer("y1", "urn:example:y1", "y1", name="c1", config=True, presence=False, children=[
        yang.schema.DLeaf("y1", "urn:example:y1", "y1", name="l1", config=True, mandatory=True, type_=yang.schema.Type("string"))
    ])

    try:
        from_xml(s, xml.decode("<c1/>"))
    except ValueError as err:
        if err.error_message != "Error reading /l1: Cannot find xml child with name l1":
            testing.error("Unexpected error: {err}")


def _test_y1_json():
    """Test JSON parsing with the same schema as XML test"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container c1 {
    description "Container 1";
    leaf l1 {
      type string;
      description "Leaf 1";
    }
    list l2 {
      key "k1";
      leaf k1 {
        type string;
        description "Key 1";
      }
      leaf v1 {
        type string;
        description "Value 1";
      }
    }
    leaf-list ll1 {
      type string;
      description "Leaf List 1";
    }
  }
}"""

    json_data = {
        "y1:c1": {
            "l1": "Value for l1",
            "l2": [
                {
                    "k1": "Key 1",
                    "v1": "Value for v1"
                }
            ],
            "ll1": ["Item 1", "Item 2"]
        }
    }

    s = yang.compile([y1])
    gd = from_json(s, json_data)
    return gd.prsrc()


def _test_root_path():
    """Test root_path argument for navigating to nested containers"""
    y1 = r"""module y1 {
  namespace "urn:example:y1";
  prefix y1;

  container top {
    description "Top container";
    container nested {
      description "Nested container";
      leaf value {
        type string;
        description "Test value";
      }
    }
  }
}"""

    xml_in = r"""<data>
<top xmlns="urn:example:y1">
  <nested>
    <value>test data</value>
  </nested>
</top>
</data>"""

    s = yang.compile([y1])

    # Test parsing from root (should include top container)
    gd_root = from_xml(s, xml.decode(xml_in))

    # Test parsing with root_path to navigate directly to nested container
    gd_nested = from_xml(s, xml.decode(xml_in), root_path=["y1:top", "nested"])

    return gd_nested.prsrc()
