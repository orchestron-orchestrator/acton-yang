#
# YANG schema
#
# This is an object model for YANG schema, based on YANG 1.1 although it should
# mostly work for YANG 1.0 just fine. There is no logic for either schema or
# data validation, so it is possible to represent an invalid schema using this
# model.
#
# - Statement: low level representation of a YANG schema as a tree of statements
# - SchemaNode: higher level representation of a YANG schema as a tree of schema nodes
# - DNode: the derived data node schema, similar to SchemaNode but for data
#   - typedefs & leaf(-list) types are resolved to their base types
#   - uses / groupings are expanded
#   - augments are applied
#
# There are two "levels" of object representation where the first low level
# representation is that of Statement. Everything in a YANG model is a
# statement, so this representation is fairly close to the YANG source code.
# For example, the order of all statements is preserved, so this model:
#
#    module foo {
#      prefix "f";
#      namespace "http://example.com/foo";
#    }
#
# Would become:
#
#   Statement("module", "foo", substatements=[
#     Statement("prefix", "f"),
#     Statement("namespace", "http://example.com/foo")
#   ])
#
# Whitespace, indentation and comments are not preserved but all parsed
# statements are. Thus if the Statements are rendered back to YANG source, it
# would look exactly like the original source code, presuming the use of
# canonical YANG formatting.
#
# The second level is that of schema nodes and is represented by the SchemaNode
# class. The SchemaNode class is a base class for all schema node types, such as
# Module, Container, List, Leaf, etc. There is a broad division between
# SchemaNodeInner, which are "inner" nodes in the schema that contain other
# nodes, e.g. have children, and SchemaNodeOuter which are the "outer" / leaf
# nodes of the tree that do not have any children. Different statements are
# modeled using discrete classes and statements that relate to a particular
# statement are attributes of that object class rather than being seen as just a
# tree of statements. For example, the following model:
#
#   module foo {
#     prefix "f";
#     namespace "http://example.com/foo";
#     container c1 {
#       leaf l1 {
#         type string;
#       }
#     }
#   }
#
# Would become:
#
#   Module("foo", namespace="http://example.com/foo", prefix="f", children=[
#     Container("c1", children=[
#       Leaf("l1", type_="string")
#     ])
#   ])
#
# Rendering that back to YANG source code will render the namespace & prefix
# statements in the canonical order specified by the YANG RFC, thus rendering
# the following:
#
#    module foo {
#      prefix "f";
#      namespace "http://example.com/foo";
#      container c1 {
#        leaf l1 {
#          type string;
#        }
#      }
#    }
#
# This higher layer SchemaNode representation is not suitable if it is desirable
# to keep statement order from the original source document (be aware that even
# with the lower leve Statement representation, whitespace & comments are still
# lost).
#
# Finally, the DNode representation is similar to the SchemaNode but focuses
# solely on the data nodes. We can think of it as "data nodes" or the "derived"
# schema (a term commonly used in the IETF to describe the result of compiling a
# YANG module). We can convert a SchemaNode tree to DNode by first compiling it
# and then running .to_dnode().

import base64
import re
from yang.identityref import Identityref, PartialIdentityref
from yang.pattern import YangPattern
from yang.type import Decimal, Ranges, RangesBuilder

RECURSION_LIMIT = 512

MAX_LENGTH_STMT = 9223372036854775807 # Maximum supported by len(str) should be 18446744073709551615 as per RFC7950 9.4.4
MAX_ENUM_VALUE = 2147483647 # RFC7950 9.6.4.2
MAX_BIT_POSITION = 4294967295 # RFC7950 9.7.4.2

def _yind(n):
    return "  " * n

def _ind(n):
    return "    " * n

_builtin_types = {
    "binary",
    "bits",
    "boolean",
    "decimal64",
    "empty",
    "enumeration",
    "identityref",
    "instance-identifier",
    "int8",
    "int16",
    "int32",
    "int64",
    "leafref",
    "string",
    "uint8",
    "uint16",
    "uint32",
    "uint64",
    "union"
}

# We always quote the arguments to these keywords regardless of the content.
# This is not a strict requirement but a preference of the authors, for example
# the argument "foo" is perfectly valid with out quotes.
_quoted_arg_keywords = set([
    "argument",
    "augment",
    "contact",
    "default",
    "description",
    "length",
    "if-feature",
    "must",
    "namespace",
    "organization",
    "pattern",
    "prefix",
    "range",
    "reference",
    "refine",
    "when",
    "yang-version",
])

class Statement(object):
    kw: str
    arg: ?str
    prefix: ?str
    substatements: list[Statement]
    def __init__(self, kw: str, arg: ?str=None, prefix: ?str=None):
        self.kw = kw
        self.arg = arg
        self.prefix = prefix
        self.substatements = []

    def pryang(self, indent=0):
        """Print YANG source code for this statement and its substatements
        """
        res = _yind(indent)
        prefix = self.prefix
        if prefix is not None:
            res += prefix + ":"
        res += self.kw
        arg = self.arg
        if arg is not None:
            # Always quote the argument if the argument contains any character
            # that require quoting to make it valid YANG (RFC 7950, section 6.1.3):
            res += " "
            m = re.match(r"[\s'\";{}]|//|/\\*|\\*/", arg)
            quoted_arg = True if self.kw in _quoted_arg_keywords or m is not None else False
            if quoted_arg:
                res += '"' + arg.replace('\\', '\\\\').replace('"', '\\"') + '"'
            else:
                res += arg
        if len(self.substatements) == 0:
            res += ";\n"
        else:
            res += " {{\n"
            for substatement in self.substatements:
                res += substatement.pryang(indent+1)
            res += _yind(indent) + "}}\n"
        return res

    def prsrc(self, indent=0):
        res = _yind(indent)
        res += "Statement(kw={repr(self.kw)}, arg={repr(self.arg)}, prefix={repr(self.prefix)}"
        if len(self.substatements) > 0:
            res += ", substatements=[\n"
            for substmt in self.substatements:
                res += substmt.prsrc(indent+1)
            res += _yind(indent)
            res += "]"
        res += ")\n"
        return res

    def to_dict(self) -> dict[str, ?value]:
        subs = [ss.to_dict() for ss in self.substatements]
        return {"kw": self.kw, "arg": self.arg, "prefix": self.prefix, "substatements": subs}

    @staticmethod
    def from_dict(d: dict[str, ?value]):
        def maybe_str(k):
            v = d[k]
            if isinstance(v, str):
                return v
        s = Statement(str(d["kw"]), maybe_str("arg"), maybe_str("prefix"))
        substatements = d.get("substatements")
        if isinstance(substatements, list):
            s.substatements = [Statement.from_dict(ss) for ss in substatements]
        return s


# YANG schema for data / the derived schema
#
# DNode provides a concrete YANG schema representation of a data tree. Unlike
# SchemaNode, which has a focus on properly representing the YANG schema
# document itself, including abstract concepts like imports, inherited types,
# groupings and augments, this module focuses on the statements relevant for
# representing a YANG modeled data tree. The data nodes in YANG are:
# - container, list, leaf, leaf-list, anydata, anyxml and the module itself can be
#   considered a form of container
# A YANG schema can be compiled into these data nodes, for example by expanding
# uses statements with the relevant groupings into the actual nodes and by
# applying augment statements to the relevant nodes.
#
# Similarly, concepts like config is represented as a boolean here, since all
# nodes are either config or not config, whereas in yang.schema, config is a
# tri-state value, since it can be None, meaning that the value is inherited from
# the parent node. Things like this makes it easier to work with the data tree
# from this module.
#
# Another concept is DTree which is a special node that acts as the virtual root
# of the data tree which can contain multiple YANG modules.

def optional_subtree(node: DNodeInner) -> bool:
    """Checks if a subtree is optional

    Returns True if the subtree is optional or False if any child node (or
    grandchild etc) is mandatory.
    """
    for child in node.children:
        if isinstance(child, DLeaf):
            if child.mandatory:
                return False
        elif isinstance(child, DLeafList):
            if child.min_elements > 0:
                return False
        elif isinstance(child, DContainer):
            if child.presence:
                return True
            return optional_subtree(child)
        elif isinstance(child, DList):
            if child.min_elements > 0:
                return False
    return True

def nest(n):
    return " " * n


class DNode(object):
    gname: str       # The name of the GData class, e.g. "Container" for yang.gdata.Container
    module: str      # The name of the module this node belongs to
    namespace: str
    prefix: str
    name: str
    config: bool
    description: ?str
    reference: ?str
    exts: list[Ext]

    def get(self, name: str, module: ?str=None, namespace: ?str=None, prefix: ?str=None, allow_unqualified=True) -> DNode:
        """Get child node by name with optional namespace qualifiers.

        Unqualified names first match against parent's module. If no match and allow_unqualified=True,
        searches other modules, returning match if unambiguous.
        """
        if isinstance(self, DNodeInner):
            # Collect all matching children
            matches = []
            same_module_match = None

            for child in self.children:
                # Check if child matches the name
                name_matches = False
                if isinstance(child, DAction) and child.name == name:
                    name_matches = True
                elif isinstance(child, DAnydata) and child.name == name:
                    name_matches = True
                elif isinstance(child, DAnyxml) and child.name == name:
                    name_matches = True
                elif isinstance(child, DContainer) and child.name == name:
                    name_matches = True
                elif isinstance(child, DInput) and name == 'input':
                    name_matches = True
                elif isinstance(child, DLeaf) and child.name == name:
                    name_matches = True
                elif isinstance(child, DLeafList) and child.name == name:
                    name_matches = True
                elif isinstance(child, DList) and child.name == name:
                    name_matches = True
                elif isinstance(child, DOutput) and name == 'output':
                    name_matches = True
                elif isinstance(child, DRpc) and child.name == name:
                    name_matches = True

                if not name_matches:
                    continue

                # Check qualifiers if provided (all must match)
                if module is not None or namespace is not None or prefix is not None:
                    if (module is not None and child.module == module or module is None) and \
                       (namespace is not None and child.namespace == namespace or namespace is None) and \
                       (prefix is not None and child.prefix == prefix or prefix is None):
                        return child

                # No qualifier provided - collect matches
                matches.append(child)
                # Track if we have a match in the same module as parent
                if self.module is not None and child.module == self.module:
                    same_module_match = child

            # Qualified search failed
            quals = []
            if module is not None:
                quals.append("module='{module}'")
            if namespace is not None:
                quals.append("namespace='{namespace}'")
            if prefix is not None:
                quals.append("prefix='{prefix}'")
            if quals:
                raise ValueError("Child '{name}' not found with qualifiers: {", ".join(quals)}")

            # First, prefer match in same module as parent
            if same_module_match is not None:
                return same_module_match

            # Should found qualified match in loop, or found unqualified match
            # in same module as parent
            if not allow_unqualified:
                if len(matches) > 0:
                    modules = {m.module for m in matches}
                    raise ValueError("Child '{name}' not found, requires qualifier, found in modules {modules}")
                else:
                    raise ValueError("Child '{name}' not found")

            # allow_unqualified=True
            # Return match if unambiguous
            if len(matches) == 0:
                raise ValueError("Child '{name}' not found")
            elif len(matches) == 1:
                return matches[0]

            # Multiple matches in different modules - ambiguous
            modules = {m.module for m in matches}
            raise ValueError("Child '{name}' not found, requires qualification, found in modules: {modules}")

        raise ValueError("Unable to get child from non-inner node")

    def _prdaclass_rec(self, spath: list[DNode], loose=False, top=True, set_ns=True, schema_ns=set(), include_state=False) -> list[str]:
        """Print the data class for this schema node
        """
        raise NotImplementedError('DNode pdc: {type(self)} - {get_path(spath)}')

    def _get_attrs(self) -> list[(str, ?value)]:
        raise NotImplementedError('DNode._get_attrs: {type(self)}')

    def _get_class_name(self):
        return type(self).split(".")[-1]

    def prsrc(self, indent=0):
        """Print Acton source code for this compiled schema node and its subnodes
        """
        res = []
        args = []
        attrs_text = _prsrc_attrs(indent, self._get_attrs())
        if len(attrs_text) > 0:
            args.append(attrs_text)
        have_children = True if isinstance(self, DNodeInner) and len(self.children) > 0 else False
        if have_children:
            args.append("children=[")
        args_text = ", ".join(args)
        text_line = "{_ind(indent)}{self._get_class_name()}({args_text}"
        if not have_children:
            text_line += ')'
        res.append(text_line)
        if isinstance(self, DNodeInner) and have_children:
            child_res = [child.prsrc(indent+1) for child in self.children]
            res.append(",\n".join(child_res))
            res.append(_ind(indent) + "])")
        return "\n".join(res)
        return ""

    def print_tree(self) -> str:
        r"""Print the tree representation for this schema node

        For example, the module

        module foo {
          prefix "f";
          namespace "http://example.com/foo";
          container c1 {
            leaf l1 {
              type string;
            }
            container c2 {
              presence "foo";
              leaf l2 {
                type int32;
              }
            }
            list list1 {
              key "k1 k2";
              leaf k1 {
                type string;
              }
              leaf k2 {
                type int32;
              }
            }
          }
        }

        would be printed as:

        module: junos-conf-protocols
            +--rw c1
               +--rw l1 string
               +--rw c2!
               |  +--rw l2 int32
               +--rw list1* [k1 k2]
                  +--rw k1 string
                  +--rw k2 int32
        """

        def print_node(node: DNode, prefix: str, has_siblings: bool=False) -> list[str]:
            res = []
            if isinstance(node, DRoot):
                # DRoot contains the combined children of all modules
                res.append("root:")
                for child in node.children:
                    res.extend(print_node(child, prefix + "   "))
                return res

            node_prefix = prefix + "+--r"
            if node.config:
                node_prefix += "w"
            else:
                node_prefix += "o"
            if isinstance(node, DLeaf):
                optional = "?" if node.mandatory == False else ""
                res.append("{node_prefix} {node.name}{optional} {node.type_.format_short_hint()}")
            elif isinstance(node, DLeafList):
                res.append("{node_prefix} {node.name}* {node.type_.format_short_hint()}")
            elif isinstance(node, DContainer):
                res.append("{node_prefix} {node.name}{'!' if node.presence else ''}")
            elif isinstance(node, DList):
                res.append("{node_prefix} {node.name}* [{' '.join(node.key)}]")
            elif isinstance(node, DModule):
                res.append("module: {node.name}")
            else:
                res.append("{node_prefix} {node.gname}")
            if isinstance(node, DNodeInner):
                new_has_siblings = len(node.children) > 1
                for i, child in enumerate(node.children):
                    if has_siblings:
                        new_prefix = prefix + "|  "
                    else:
                        new_prefix = prefix + "   "
                    if i == len(node.children) - 1:
                        new_has_siblings = False
                    res.extend(print_node(child, new_prefix, new_has_siblings))
            return res

        return "\n".join(print_node(self, ""))

    def resolve_references(self, root: DRoot):
        pass

class DNodeInner(DNode):
    children: list[DNode]

    def _prdaclass_rec(self, spath: list[DNode], loose=False, top=True, set_ns=True, schema_ns=set(), include_state=False) -> list[str]:
        """Print the data class for this schema node
        """
        def path_with_child(c):
            return spath + [c]

        if self.namespace != "":
            schema_ns.add(self.namespace)
        res = []

        # Reorder children so that positional arguments, like list keys, come first
        new_children = []
        pos_child_idx = 0
        for child in self.children:
            if include_state == False and child.config == False:
                continue
            elif isinstance(child, DRpc):
                continue
            elif isinstance(child, DAnydata):
                continue # TODO
            elif isinstance(child, DAnyxml):
                continue # TODO
            if isinstance(child, DLeaf) and isinstance(self, DList) and child.is_key(self):
                new_children.insert(pos_child_idx, child)
                pos_child_idx += 1
            else:
                new_children.append(child)
        self.children = new_children

        unique_namer = _UniqueNamer(self)

        def uname(n) -> str:
            return unique_namer.unique_name(n.name, n.prefix)

        def usname(n) -> str:
            return unique_namer.unique_safe_name(n.name, n.prefix)

        def pname(n: ?DNode=None):
            if n is not None:
                return get_path_name(spath + [n])
            else:
                return get_path_name(spath)

        def us_list_key():
            """Convert list key names (DList.key) to their unique safe names

            We use the containing list node prefix since the list keys must be
            defined in the same namespace as the list."""
            if isinstance(self, DList):
                return list(map(lambda x: unique_namer.unique_safe_name(x, self.prefix), self.key))
            raise ValueError("{self} not a list node")

        def maybe_user_order(n: DList):
            return ", user_order=True" if n.ordered_by == "user" else ""

        def maybe_user_order_ll(n: DLeafList):
            return ", user_order=True" if n.ordered_by == "user" else ""

        for child in self.children:
            if isinstance(child, DNodeLeaf):
                continue
            res.extend(child._prdaclass_rec(path_with_child(child), loose=loose, top=False, set_ns=child.namespace!=self.namespace, schema_ns=schema_ns, include_state=include_state))

        if isinstance(self, DList):
            # List has special handling as it actually results in two classes:
            # - the list itself
            # - the list entry class
            # Here we create the list entry class, the list itself comes later
            res.append("class {pname()}_entry(yang.adata.MNode):")
        else:
            res.append("class {pname()}(yang.adata.MNode):")

        for child in self.children:
            if isinstance(child, DLeaf):
                res.append("    {usname(child)}: {yang_leaf_to_acton_type(child, list_keys(self), loose)}")
            elif isinstance(child, DLeafList):
                res.append("    {usname(child)}: {yang_leaflist_to_acton_type(child)}")
            elif isinstance(child, DContainer):
                if child.presence:
                    res.append("    {usname(child)}: ?{pname(child)}")
                else:
                    res.append("    {usname(child)}: {pname(child)}")
            elif isinstance(child, DNodeInner):
                res.append("    {usname(child)}: {pname(child)}")
            elif isinstance(child, DAnydata):
                pass # TODO
            elif isinstance(child, DAnyxml):
                pass # TODO
            elif isinstance(child, DAction):
                pass # TODO
            elif isinstance(child, DRpc):
                pass # TODO
            elif isinstance(child, DInput):
                pass # TODO
            elif isinstance(child, DOutput):
                pass # TODO
            else:
                raise ValueError("unreachable, unknown child type: {type(child)}")
        res.append("")
        req_args = []
        opt_args = []
        for child in self.children:
            if isinstance(child, DContainer):
                if loose or child.presence or optional_subtree(child):
                    opt_args.append("{usname(child)}: ?{pname(child)}=None")
                else:
                    req_args.append("{usname(child)}: {pname(child)}")
            elif isinstance(child, DLeaf):
                defval = ""
                child_default = child.default
                if not loose and child_default is not None:
                    defval = "=None"
                child_arg = "{usname(child)}: {yang_leaf_to_acton_arg_type(child, list_keys(self), loose)}{defval}"
                if is_optional_arg_yang_leaf(child, list_keys(self), loose):
                    opt_args.append(child_arg)
                else:
                    req_args.append(child_arg)
            elif isinstance(child, DLeafList):
                opt_args.append("{usname(child)}: ?{yang_leaflist_to_acton_type(child)}=None")
            elif isinstance(child, DList):
                opt_args.append("{usname(child)}: list[{pname(child)}_entry]=[]")

        init_args_str = ", ".join(["self"] + req_args + opt_args)
        res.append("    mut def __init__({init_args_str}):")
        # Set namespace from us
        res.append("        self._ns = '{self.namespace}'")

        for child in self.children:
            if isinstance(child, DContainer):
                if (loose or optional_subtree(child)) and not child.presence:
                    res.append("        self.{usname(child)} = {usname(child)} if {usname(child)} is not None else {pname(child)}()")
                else:
                    # NOTE: the default argument for P-container is None, so
                    # although unconditionally set here, it can be None
                    res.append("        self.{usname(child)} = {usname(child)}")
            elif isinstance(child, DLeaf):
                child_default = child.default
                if not loose and child_default is not None:
                    child_type = child.type_
                    if isinstance(child_type, DTypeIdentityref):
                        res.append("        _default_{usname(child)}, error = complete_and_validate_identityref(Identityref.from_adata('{child_default}'), _identities, {DIdentity.format_base_identity_var_name_list(child_type.identity_bases)}, {repr(child.module)})")
                        res.append("        if _default_{usname(child)} is not None:")
                        res.append("            self.{usname(child)} = {usname(child)} if {usname(child)} is not None else _default_{usname(child)}")
                        res.append("        else:")
                        res.append("            raise ValueError('Invalid default value for identityref leaf {self.name}: {{error}}')")
                    else:
                        res.append("        self.{usname(child)} = {usname(child)} if {usname(child)} is not None else {prsrc_literal(child_type.builtin_type, child_default)}")
                else:
                    res.append("        self.{usname(child)} = {usname(child)}")
            elif isinstance(child, DLeafList):
                # TODO: this is where we can set the leaf-list to a default value, not []
                res.append("        self.{usname(child)} = {usname(child)} if {usname(child)} is not None else []")
            elif isinstance(child, DList):
                res.append("        self.{usname(child)} = {pname(child)}(elements={usname(child)})")
        if len(self.children) == 0:
            res.append("        pass")
        res.append("")

        # Handle all P-container children, we want a .create_XXX() method
        # for each that takes as arguments the mandatory children of the
        # container
        for child in self.children:
            if isinstance(child, DContainer) and child.presence:
                # We must generate unique safe names for this node children too
                child_unique_namer = _UniqueNamer(child)
                pc_args = ["self"]
                for cchild in child.children:
                    if isinstance(cchild, DLeaf):
                        if cchild.mandatory:
                            pc_args.append(child_unique_namer.unique_safe_name(cchild.name, cchild.prefix))
                    elif isinstance(cchild, DContainer):
                        if not (loose or optional_subtree(cchild) or cchild.presence):
                            pc_args.append(child_unique_namer.unique_safe_name(cchild.name, cchild.prefix))
                pc_args_str = ", ".join(pc_args)
                pc_args_str1 = ", ".join(pc_args[1:])
                res.append("    mut def create_{usname(child)}({pc_args_str}):")
                res.append("        existing = self.{usname(child)}")
                res.append("        if existing is not None:")
                res.append("            return existing")
                res.append("        res = {pname(child)}({pc_args_str1})")
                res.append("        self.{usname(child)} = res")
                res.append("        return res")
                res.append("")

        if len(self.children) > 0:
            res.append("    def _get_attr(self, name: str) -> ?value:")
            for child in self.children:
                res.append("        if name == '{usname(child)}':")
                if isinstance(child, DList):
                    res.append("            return iter(self.{usname(child)})")
                else:
                    res.append("            return self.{usname(child)}")
            res.append("        raise ValueError('Attribute {{name}} not found in {pname()}')")
            res.append("")

        # .to_gdata()
        res.append("    mut def to_gdata(self) -> yang.gdata.Node:")
        # TODO: we do an isinstance check to give a hint to the compiler that
        # this class implements the YangData protocol. But the compiler should
        # know self inherits from MNode?!
        res.append("        if isinstance(self, yang.adata.MNode):")
        if isinstance(self, DRoot):
            res.append("            return yang.gen3.from_data(src_dnode(), self, loose={loose})")
        else:
            root_path = ["{'{node.module}:' if prev.module != node.module else ''}{node.name}" if node is not None else None for prev, node in zip(spath, spath[1:] + [None])]
            res.append("            return yang.gen3.from_data(src_dnode(), self, loose={loose}, root_path={repr(root_path[:-1])})")
        res.append("        raise ValueError('unreachable')")
        res.append("")

        # .from_gdata()
        # TODO: should .from_gdata() not take a specific data node instead, like Container instead of yang.gdata.Node?
        from_gdata_args_list = []
        for child in self.children:
            if isinstance(child, DNodeLeaf):
                from_gdata_args_list.append("{usname(child)}=n.{taker_name(child, list_keys(self), loose=loose)}('{uname(child)}')")
            else:
                from_gdata_args_list.append("{usname(child)}={pname(child)}.from_gdata(n.{taker_name(child, list_keys(self), loose=loose)}('{uname(child)}'))")
        from_gdata_args = ", ".join(from_gdata_args_list)
        res.append("    @staticmethod")
        if isinstance(self, DList):
            res.append("    mut def from_gdata(n: yang.gdata.Node) -> {pname()}_entry:")
            res.append("        return {pname()}_entry({from_gdata_args})")
        else:
            opt_cnt = True if isinstance(self, DContainer) and self.presence else False
            res.append("    mut def from_gdata(n: ?yang.gdata.Node) -> {'?' if opt_cnt else ''}{pname()}:")
            res.append("        if n is not None:")
            res.append("            return {pname()}({from_gdata_args})")
            if opt_cnt:
                res.append("        return None")
            elif optional_subtree(self):
                res.append("        return {pname()}()")
            else:
                res.append("        raise ValueError('Missing required subtree {pname()}')")
        res.append("")

        # .copy() method
        res.append("    def copy(self):")
        res.append('        """Create a deep copy of this adata object"""')
        if isinstance(self, DList):
            res.append("        return {pname()}_entry.from_gdata(self.to_gdata())")
        else:
            opt_cnt = True if isinstance(self, DContainer) and self.presence else False
            # AdataPContainer.from_gdata(n) -> ?AdataPContainer, return type is optional.
            # But since we're copying an instance, the output of .copy() is non-optional.
            if opt_cnt:
                res.append("        ad = {pname()}.from_gdata(self.to_gdata())")
                res.append("        if ad is not None:")
                res.append("            return ad")
                res.append("        raise Exception('Unreachable in {pname()}.copy()')")
            else:
                res.append("        return {pname()}.from_gdata(self.to_gdata())")
        res.append("")

        if isinstance(self, DList):
            # List has special handling as it actually results in two classes:
            # - the list itself
            # - the list entry class
            # Here we create the list class, list entry class was created above
            res.append("class {pname()}(yang.adata.MNode):")
            res.append("    elements: list[{pname()}_entry]")

            init_args = ["self"]
            init_args.append("elements=[]")
            init_args_str: str = ", ".join(init_args)
            res.append("    mut def __init__({init_args_str}):")
            # Set namespace from us
            res.append("        self._ns = '{self.namespace}'")
            res.append("        self._name = {repr(self.name)}")
            res.append("        self.elements = elements")
            res.append("")

            # list_key_args contains the list keys names and also any
            # non-optional children. We use unique safe names for both to avoid conflicts.
            list_key_args = us_list_key()
            list_key_types = {}
            for child in self.children:
                if isinstance(child, DLeaf):
                    if usname(child) in list_key_args:
                        list_key_types[usname(child)] = child.type_
                        continue
                    if child.mandatory:
                        list_key_args.append(usname(child))
                elif isinstance(child, DContainer):
                    if not (loose or optional_subtree(child) or child.presence):
                        list_key_args.append(usname(child))
            list_create_args_str = ", ".join(["self"] + list_key_args)
            res.append("    mut def create({list_create_args_str}):")
            res.append("        for e in self:")
            res.append("            match = True")
            for us_key in us_list_key():
                # Order-preserving deduplication
                unique_base_types = []
                key_dtype = list_key_types[us_key]
                if isinstance(key_dtype, DTypeUnion):
                    for t in key_dtype.types:
                        acton_type = yang_type_to_acton_type(t)
                        if acton_type not in unique_base_types:
                            unique_base_types.append(acton_type)
                if len(unique_base_types) <= 1:
                    # Class attribute is a not a "value" Acton type because it
                    # is either not an union or it an union that was resolved
                    # to a single builtin type, it has equality check
                    res.append("            if e.{us_key} != {us_key}:")
                    res.append("                match = False")
                    res.append("                continue")
                else:
                    # Union types for mixed unions are Acton "value" types, so
                    # we need to first attempt to bind them to a more specific type
                    # TODO: use Acton unions
                    for t in unique_base_types:
                        res.append("            e_{us_key} = e.{us_key}")
                        res.append("            if isinstance(e_{us_key}, {t}) and isinstance({us_key}, {t}):")
                        res.append("                if e_{us_key} != {us_key}:")
                        res.append("                    match = False")
                        res.append("                    continue")
            res.append("            if match:")
            res.append("                return e")
            res.append("")
            list_key_args_str = ", ".join(list_key_args)
            res.append("        res = {pname()}_entry({list_key_args_str})")
            res.append("        self.elements.append(res)")
            res.append("        return res")
            res.append("")

#            # .from_gdata()
#            # TODO: should .from_gdata() not take a specific data node instead, like Container instead of yang.gdata.Node?
            res.append("    @staticmethod")
            res.append("    mut def from_gdata(n: ?yang.gdata.List) -> list[{pname()}_entry]:")
            res.append("        if n is not None:")
            res.append("            return [{pname()}_entry.from_gdata(e) for e in n.elements]")
            res.append("        return []")
            #res.append("        return list(map(lambda x: %s_entry.from_gdata(x), n.elements))" % pname())
            # TODO: trying to use list(map(lambda)) here results in an error,
            # why? Above code that iterates over n.elements works fine... Error is:
            # ERROR: Error when compiling y_cfs module: Type error
            # mut must be a subclass of pure
            res.append("")

            # .copy() method for list wrapper
            res.append("    def copy(self):")
            res.append('        """Create a deep copy of this list object"""')
            res.append("        # Copy each element in the list")
            res.append("        copied_elements = []")
            res.append("        for e in self:")
            res.append("            ce = e.copy()")
            res.append("            if ce is not None:")
            res.append("                copied_elements.append(ce)")
            res.append("        return {pname()}(elements=copied_elements)")
            res.append("")
            # Generate Iterable extension for the list class
            res.append("extension {pname()}(Iterable[{pname()}_entry]):")
            res.append("    def __iter__(self) -> Iterator[{pname()}_entry]:")
            res.append("        return self.elements.__iter__()")
        res.append("")


        if isinstance(self, DRoot) and len(self.rpcs) > 0:
            # First generate data classes for RPC input/output
            for rpc in self.rpcs:
                # Generate adata classes for DInput, DOutput, but override:
                # - set_ns: from DRpc (=True)
                # - include_state=True
                for child in rpc.children:
                    child_class_src = child._prdaclass_rec(spath + [rpc, child], loose=loose, top=False, set_ns=set_ns, schema_ns=schema_ns, include_state=True)
                    res.extend(child_class_src)

            # TODO: unique safe name for RPC function!
            # Generate rpc_root actor
            res.append("actor rpc_root(tp: yang.gdata.TreeProvider):")
            for rpc in self.rpcs:
                input_node = rpc.input
                output_node = rpc.output

                # Build method signature based on input/output presence:
                # - no input: in inp parameter in the wrapper signature
                # - no output: no output adata parameter in the callback signature
                if input_node is not None and output_node is not None:
                    # RPC with both input and output
                    res.append("    def {_safe_name(rpc.name)}(cb: action(?{get_path_name(spath + [rpc, output_node])}, ?Exception) -> None, inp: {'?' if optional_subtree(input_node) else ''}{get_path_name(spath + [rpc, input_node])}):")
                elif input_node is not None and output_node is None:
                    # RPC with only input (no output)
                    res.append("    def {_safe_name(rpc.name)}(cb: action(?Exception) -> None, inp: {'?' if optional_subtree(input_node) else ''}{get_path_name(spath + [rpc, input_node])}):")
                elif input_node is None and output_node is not None:
                    # RPC with only output (no input)
                    res.append("    def {_safe_name(rpc.name)}(cb: action(?{get_path_name(spath + [rpc, output_node])}, ?Exception) -> None):")
                else:
                    # RPC with neither input nor output
                    res.append("    def {_safe_name(rpc.name)}(cb: action(?Exception) -> None):")

                # Generate callback wrapper for parsing RPC output XML -> gdata -> adata
                if output_node is not None:
                    res.append("        def cb_wrap(res: ?xml.Node, err: ?Exception):")
                    res.append("            if res is not None:")
                    res.append('                gdata_res = yang.gen3.from_data(src_dnode(), res, {loose}, ["{rpc.module}:{rpc.name}", "output"])')
                    res.append("                adata_res = {get_path_name(spath + [rpc, output_node])}.from_gdata(gdata_res)")
                    res.append("                cb(adata_res, err)")
                    res.append("            else:")
                    res.append("                cb(None, err)")
                    res.append("")

                # Generate RPC XML, add input
                res.append("        rpc_xml = xml.Node({repr(rpc.name)}, nsdefs=[(None, {repr(rpc.namespace)})])")
                if input_node is not None:
                    res.append("        if inp is not None:")
                    res.append('            gdata_inp = yang.gen3.from_data(src_dnode(), inp, {loose}, ["{rpc.module}:{rpc.name}", "input"])')
                    res.append('            rpc_xml.children.extend(gdata_inp.to_xml())')

                # Call tp.rpc_xml with appropriate callback
                if output_node is not None:
                    res.append("        tp.rpc_xml(cb_wrap, rpc_xml)")
                else:
                    res.append("        tp.rpc_xml(lambda _, err: cb(err), rpc_xml)")
                res.append("")
            res.append("")
            res.append("")

        return res

    def resolve_references(self, root: DRoot):
        for child in self.children:
            child.resolve_references(root)

class DNodeLeaf(DNode):
    if_feature: list[str]
    must: list[Must]
    status: ?str
    type_: DType
    when: ?str

    def resolve_references(self, root: DRoot):
        self.type_.resolve_references(root)

class DAction(DNodeInner):
    if_feature: list[str]
    status: ?str

    def __init__(self, module: str, namespace: str, prefix: str, name: str, description: ?str=None, if_feature=[], reference=None, status=None, exts=[], children=[]):
        self.module = module
        self.namespace = namespace
        self.prefix = prefix
        self.name = name
        self.gname = "Action"
        self.config = False
        self.description = description
        self.if_feature = if_feature
        self.reference = reference
        self.status = status
        self.exts = exts
        self.children = children

    def _get_attrs(self):
        return [
            ("module", self.module),
            ("namespace", self.namespace),
            ("prefix", self.prefix),
            ("name", self.name),
            ("config", self.config),
            ("description", self.description),
            ("if_feature", self.if_feature),
            ("reference", self.reference),
            ("status", self.status),
            ("exts", self.exts),
        ]

class DAnydata(DNode):
    if_feature: list[str]
    mandatory: ?bool
    must: list[Must]
    status: ?str
    when: ?str

    def __init__(self, module: str, namespace: str, prefix: str, name: str, config: bool, description: ?str=None, if_feature: list[str]=[], mandatory: ?bool=None, must: list[Must]=[], reference: ?str=None, status: ?str=None, when: ?str=None, exts=[]):
        self.module = module
        self.namespace = namespace
        self.prefix = prefix
        self.name = name
        self.gname = "Anydata"
        self.config = config
        self.description = description
        self.if_feature = if_feature
        self.mandatory = mandatory
        self.must = must
        self.reference = reference
        self.status = status
        self.when = when
        self.exts = exts

    def _get_attrs(self):
        return [
            ("module", self.module),
            ("namespace", self.namespace),
            ("prefix", self.prefix),
            ("name", self.name),
            ("config", self.config),
            ("description", self.description),
            ("if_feature", self.if_feature),
            ("mandatory", self.mandatory),
            ("must", self.must),
            ("reference", self.reference),
            ("status", self.status),
            ("when", self.when),
            ("exts", self.exts),
        ]

class DAnyxml(DNode):
    if_feature: list[str]
    mandatory: ?bool
    must: list[Must]
    status: ?str
    when: ?str

    def __init__(self, module: str, namespace: str, prefix: str, name: str, config: bool, description: ?str=None, if_feature: list[str]=[], mandatory: ?bool=None, must: list[Must]=[], reference: ?str=None, status: ?str=None, when: ?str=None, exts=[]):
        self.module = module
        self.namespace = namespace
        self.prefix = prefix
        self.name = name
        self.gname = "Anyxml"
        self.config = config
        self.description = description
        self.if_feature = if_feature
        self.mandatory = mandatory
        self.must = must
        self.reference = reference
        self.status = status
        self.when = when
        self.exts = exts

    def _get_attrs(self):
        return [
            ("module", self.module),
            ("namespace", self.namespace),
            ("prefix", self.prefix),
            ("name", self.name),
            ("config", self.config),
            ("description", self.description),
            ("if_feature", self.if_feature),
            ("mandatory", self.mandatory),
            ("must", self.must),
            ("reference", self.reference),
            ("status", self.status),
            ("when", self.when),
            ("exts", self.exts),
        ]

class DContainer(DNodeInner):
    if_feature: list[str]
    must: list[Must]
    presence: bool
    status: ?str

    def __init__(self, module: str, namespace: str, prefix: str, name: str, config: bool, description: ?str=None, if_feature=[], must=[], presence: bool, reference=None, status=None, when=None, exts=[], children=[]):
        self.module = module
        self.namespace = namespace
        self.prefix = prefix
        self.name = name
        self.gname = "Container"
        self.config = config
        self.description = description
        self.if_feature = if_feature
        self.must = must
        self.presence = presence
        self.reference = reference
        self.status = status
        self.when = when
        self.exts = exts
        self.children = children

    def _get_attrs(self):
        return [
            ("module", self.module),
            ("namespace", self.namespace),
            ("prefix", self.prefix),
            ("name", self.name),
            ("config", self.config),
            ("description", self.description),
            ("if_feature", self.if_feature),
            ("must", self.must),
            ("presence", self.presence),
            ("reference", self.reference),
            ("status", self.status),
            ("when", self.when),
            ("exts", self.exts),
        ]

class DIdentity(DNode):
    base: list[DIdentity]

    def __init__(self, module: str, namespace: str, prefix: str, name: str, base: list[DIdentity]=[]):
        self.gname = "Identity"
        self.module = module
        self.namespace = namespace
        self.prefix = prefix
        self.name = name
        self.config = False
        self.description = None
        self.reference = None
        self.exts = []
        self.base = base

    def _get_attrs(self):
        return [
            ("module", self.module),
            ("namespace", self.namespace),
            ("prefix", self.prefix),
            ("name", self.name),
            ("exts", self.exts),
            ("base", self.base),
        ]

    def __repr__(self):
        base_reprs = [repr(b) for b in self.base]
        return "DIdentity(module={repr(self.module)}, namespace={repr(self.namespace)}, prefix={repr(self.prefix)}, name={repr(self.name)}, base=[{', '.join(base_reprs)}])"

    def key(self):
        return "{self.module}:{self.name}"

    @staticmethod
    def format_identity_list(identities: list[DIdentity]) -> list[str]:
        """Format a list of identities with proper variable declarations for bases

        Returns a list of strings to be added to the result
        """
        if len(identities) == 0:
            return ["_identities: list[DIdentity] = []", "", ""]

        result = []

        # Sort identities topologically (bases before derived)
        sorted_identities = []
        visited = set()

        def visit(identity):
            if identity.key() in visited:
                return
            visited.add(identity.key())
            # Visit bases first
            for base in identity.base:
                if isinstance(base, DIdentity):
                    visit(base)
            sorted_identities.append(identity)

        for identity in identities:
            visit(identity)

        # Assign (base) identity var name and also track it as a base
        base_var_map = {}
        for identity in identities:
            for base in identity.base:
                base_var_map[base.key()] = base.format_base_var_name()

        # Print variable declarations for identities that are used as bases in order of precedence
        for identity in sorted_identities:
            if identity.key() in base_var_map:
                var_name = base_var_map[identity.key()]
                base_refs = [base_var_map[base.key()] for base in identity.base]
                result.append("{var_name} = DIdentity(module={repr(identity.module)}, namespace={repr(identity.namespace)}, prefix={repr(identity.prefix)}, name={repr(identity.name)}, base=[{', '.join(base_refs)}])")

        # Build the global _identities list
        result.append("_identities = [")
        for identity in identities:
            if identity.key() in base_var_map:
                # Reference the variable
                result.append("    {base_var_map[identity.key()]},")
            else:
                # Inline declaration with base references
                base_refs = [base_var_map[base.key()] for base in identity.base]
                result.append("    DIdentity(module={repr(identity.module)}, namespace={repr(identity.namespace)}, prefix={repr(identity.prefix)}, name={repr(identity.name)}, base=[{', '.join(base_refs)}]),")
        result.append("]")
        result.append("")
        result.append("")

        return result

    @staticmethod
    def format_identityref_constants(identities: list[DIdentity]) -> list[str]:
        """Format a list of Identityref constants for each identity

        Returns a list of strings to be added to the result
        """
        if not identities:
            return []

        result = []
        result.append("# Identityref constants")

        for identity in identities:
            var_name = _safe_name("{identity.module}_{identity.name}", safe_kw=False)
            result.append("{var_name} = Identityref({repr(identity.name)}, ns={repr(identity.namespace)}, mod={repr(identity.module)}, pfx={repr(identity.prefix)})")
        result.append("")
        result.append("")

        return result

    @staticmethod
    def format_base_identity_var_name_list(identities: list[DIdentity]) -> str:
        return "[{", ".join([b.format_base_var_name() for b in identities])}]"

    def format_base_var_name(self):
        return "_base_{self.module}_{self.name}".replace("-", "_")

class DInput(DNodeInner):
    must: list[Must]

    def __init__(self, module: str, namespace: str, prefix: str, must=[], exts=[], children=[]):
        self.module = module
        self.namespace = namespace
        self.prefix = prefix
        self.name = "input"
        self.gname = "Container"
        self.config = False
        self.description = None
        self.reference = None
        self.must = must
        self.exts = exts
        self.children = children

    def _get_attrs(self):
        return [
            ("module", self.module),
            ("namespace", self.namespace),
            ("prefix", self.prefix),
            ("description", self.description),
            ("reference", self.reference),
            ("must", self.must),
            ("exts", self.exts),
        ]

class DModule(DNodeInner):
    augment: list[Augment]
    contact: ?str
    deviation: list[str]
    extension_: list[Extension]
    feature: list[Feature]
    identity: list[Identity]
    import_: list[Import]
    include: list[Include]
    organization: ?str
    revision: list[Revision]
    yang_version: float

    def __init__(self, module: str, namespace: str, prefix: str, name: str, yang_version: ?float, description: ?str=None, contact=None, deviation=[], extension_=[], feature=[], identity=[], import_=[], include=[], organization=None, reference=None, revision=[], exts=[], children=[]):
        self.module = module
        self.name = name
        self.gname = "Container"
        self.namespace = namespace
        self.prefix = prefix
        if yang_version is not None:
            self.yang_version = yang_version
        else:
            self.yang_version = 1.1
        self.config = True # module is not config in itself, but it is the root
                           # of the data tree and the default is config=True, so
                           # we set it here
        self.description = description
        self.augment = []
        self.contact = contact
        self.deviation = deviation
        self.extension_ = extension_
        self.feature = feature
        self.identity = identity
        self.import_ = import_
        self.include = include
        self.organization = organization
        self.reference = reference
        self.revision = revision
        self.exts = exts
        self.children = children

    def _get_attrs(self):
        return [
            ("module", self.module),
            ("namespace", self.namespace),
            ("prefix", self.prefix),
            ("name", self.name),
            ("yang_version", self.yang_version),
            ("description", self.description),
            ("augment", self.augment),
            ("contact", self.contact),
            ("deviation", self.deviation),
            ("extension_", self.extension_),
            ("feature", self.feature),
            ("identity", self.identity),
            ("import_", self.import_),
            ("include", self.include),
            ("organization", self.organization),
            ("reference", self.reference),
            ("revision", self.revision),
            ("exts", self.exts),
        ]

class DList(DNodeInner):
    if_feature: list[str]
    key: list[str]
    max_elements: ?int
    min_elements: int
    must: list[Must]
    ordered_by: str
    status: ?str
    unique: list[str]
    when: ?str

    def __init__(self, module: str, namespace: str, prefix: str, name: str, key: list[str]=[], config: bool, description: ?str=None, if_feature=[], max_elements: ?int=None, min_elements=0, must=[], ordered_by="system", reference=None, status=None, unique=[], when=None, exts=[], children=[]):
        self.module = module
        self.namespace = namespace
        self.prefix = prefix
        self.name = name
        self.gname = "List"
        self.key = key
        self.config = config
        self.description = description
        self.if_feature = if_feature
        self.max_elements = max_elements
        self.min_elements = min_elements
        self.must = must
        self.ordered_by = ordered_by
        self.reference = reference
        self.status = status
        self.unique = unique
        self.when = when
        self.exts = exts
        self.children = children

    def _get_attrs(self):
        return [
            ("module", self.module),
            ("namespace", self.namespace),
            ("prefix", self.prefix),
            ("name", self.name),
            ("key", self.key),
            ("config", self.config),
            ("description", self.description),
            ("if_feature", self.if_feature),
            ("max_elements", self.max_elements),
            ("min_elements", self.min_elements),
            ("must", self.must),
            ("ordered_by", self.ordered_by),
            ("reference", self.reference),
            ("status", self.status),
            ("unique", self.unique),
            ("when", self.when),
            ("exts", self.exts),
        ]

class DLeaf(DNodeLeaf):
    default: ?str
    mandatory: bool
    units: ?str

    def __init__(self, module: str, namespace: str, prefix: str, name: str, config: bool, description: ?str=None, default=None, if_feature=[], mandatory=False, must=[], reference=None, status=None, type_: DType, units=None, when=None, exts=[]):
        self.parent = None
        self.module = module
        self.namespace = namespace
        self.prefix = prefix
        self.name = name
        self.gname = "Leaf"
        self.config = config
        self.description = description
        self.default = default
        self.if_feature = if_feature
        self.mandatory = mandatory
        self.must = must
        self.reference = reference
        self.status = status
        self.type_ = type_
        self.units = units
        self.when = when
        self.exts = exts

    def is_key(self, parent: DList) -> bool:
        # If the leaf is in a different namespace as the list, it:
        # - cannot possibly be a key,
        # - may even have the same name as one of the keys!
        if self.namespace == parent.namespace:
            if self.name in parent.key:
                return True
        return False

    def _get_attrs(self):
        return [
            ("module", self.module),
            ("namespace", self.namespace),
            ("prefix", self.prefix),
            ("name", self.name),
            ("config", self.config),
            ("description", self.description),
            ("default", self.default),
            ("if_feature", self.if_feature),
            ("mandatory", self.mandatory),
            ("must", self.must),
            ("reference", self.reference),
            ("status", self.status),
            ("type_", self.type_),
            ("units", self.units),
            ("when", self.when),
            ("exts", self.exts),
        ]


class DLeafList(DNodeLeaf):
    default: ?list[str]
    max_elements: ?int
    min_elements: int
    ordered_by: str
    units: ?str

    def __init__(self, module: str, namespace: str, prefix: str, name: str, config: bool, description: ?str=None, default=None, if_feature=[], max_elements: ?int=None, min_elements=0, must=[], ordered_by="system", reference=None, status=None, type_: DType, units=None, when=None, exts=[]):
        self.parent = None
        self.module = module
        self.namespace = namespace
        self.prefix = prefix
        self.name = name
        self.gname = "LeafList"
        self.config = config
        self.description = description
        self.default = default
        self.if_feature = if_feature
        self.max_elements = max_elements
        self.min_elements = min_elements
        self.must = must
        self.ordered_by = ordered_by
        self.reference = reference
        self.status = status
        self.type_ = type_
        self.units = units
        self.when = when
        self.exts = exts

    def _get_attrs(self):
        return [
            ("module", self.module),
            ("namespace", self.namespace),
            ("prefix", self.prefix),
            ("name", self.name),
            ("config", self.config),
            ("description", self.description),
            ("default", self.default),
            ("if_feature", self.if_feature),
            ("max_elements", self.max_elements),
            ("min_elements", self.min_elements),
            ("must", self.must),
            ("ordered_by", self.ordered_by),
            ("reference", self.reference),
            ("status", self.status),
            ("type_", self.type_),
            ("units", self.units),
            ("when", self.when),
            ("exts", self.exts),
        ]


class DNotification(DNodeInner):
    if_feature: list[str]
    must: list[Must]
    status: ?str

    def __init__(self, module: str, namespace: str, prefix: str, name: str, description: ?str=None, if_feature=[], must=[], reference=None, status=None, exts=[], children=[]):
        self.module = module
        self.namespace = namespace
        self.prefix = prefix
        self.name = name
        self.gname = "Notification"
        self.config = False
        self.description = description
        self.if_feature = if_feature
        self.must = must
        self.reference = reference
        self.status = status
        self.exts = exts
        self.children = children

    def _get_attrs(self):
        return [
            ("module", self.module),
            ("namespace", self.namespace),
            ("prefix", self.prefix),
            ("name", self.name),
            ("config", self.config),
            ("description", self.description),
            ("if_feature", self.if_feature),
            ("must", self.must),
            ("reference", self.reference),
            ("status", self.status),
            ("exts", self.exts),
        ]

class DOutput(DNodeInner):
    must: list[Must]

    def __init__(self, module: str, namespace: str, prefix: str, must=[], exts=[], children=[]):
        self.module = module
        self.namespace = namespace
        self.prefix = prefix
        self.name = "output"
        self.gname = "Container"
        self.config = False
        self.description = None
        self.reference = None
        self.must = must
        self.exts = exts
        self.children = children

    def _get_attrs(self):
        return [
            ("module", self.module),
            ("namespace", self.namespace),
            ("prefix", self.prefix),
            ("description", self.description),
            ("reference", self.reference),
            ("must", self.must),
            ("exts", self.exts),
        ]

class DRoot(DNodeInner):
    identities: list[DIdentity]
    rpcs: list[DRpc]

    def __init__(self, children=[], identities=[], rpcs=[]):
        self.module = ""
        self.namespace = ""
        self.prefix = ""
        self.name = "root"
        self.gname = "Container"
        self.config = True
        self.description = None
        self.reference = None
        self.exts = []
        self.children = children + rpcs
        self.identities = identities
        self.rpcs = rpcs

    @staticmethod
    def from_modules(modules: list[DNode]=[]):
        # Build a global identity map from all modules
        children = []
        rpcs = []
        identity_map = {}  # Map from "prefix:name" to DIdentity instance
        for module in modules:
            if isinstance(module, DModule):
                for child in module.children:
                    if isinstance(child, DRpc):
                        rpcs.append(child)
                    children.append(child)

                # Add identities to global map
                for identity in module.identity:
                    key = "{identity.pfx}:{identity.name}"
                    if key in identity_map:
                        raise ValueError("Identity {identity.pfx}:{identity.name} is duplicated")
                    identity_map[key] = (
                        identity=DIdentity(
                            module=identity.get_module_name(),
                            namespace=identity.get_namespace(),
                            prefix=identity.get_prefix(),
                            name=identity.name),
                        base=identity.base)
            else:
                raise ValueError("DRoot can only contain DModule")

        # Resolve base references using the global map, ensure all bases exist
        for id in identity_map.values():
            resolved_bases = []
            for base_key in id.base:
                if base_key in identity_map:
                    resolved_bases.append(identity_map[base_key].identity)
                else:
                    raise ValueError("Could not resolve base '{base_key}' for identity '{id.identity.prefix}:{id.identity.name}'")
            id.identity.base = resolved_bases

        # Detect cycles in the identity hierarchy (DFS)
        # visited_global is shared across all DFS traversals to avoid re-checking
        # nodes that were already visited
        visited_global = set()

        def detect_cycles(identity_key: str, path: list[str], rec_stack: set[str]) -> ?str:
            if identity_key in rec_stack:
                # Found a cycle - build error message
                cycle_start = path.index(identity_key)
                cycle = " -> ".join(path[cycle_start:] + [identity_key])
                return "Cycle detected in identity hierarchy: {cycle}"

            if identity_key in visited_global:
                return None

            # Remember we already visited this node so we can skip it later
            visited_global.add(identity_key)
            rec_stack.add(identity_key)

            # Check our base identities
            for base_key in identity_map[identity_key].base:
                result = detect_cycles(base_key, path + [identity_key], rec_stack)
                if result is not None:
                    return result

            # Remove from rec_stack when backtracking
            rec_stack.discard(identity_key)
            return None

        for identity_key in identity_map.keys():
            if identity_key in visited_global:
                continue
            error = detect_cycles(identity_key, [], set())
            if error is not None:
                raise ValueError(error)

        identities = [v.identity for v in identity_map.values()]

        root = DRoot(children, identities, rpcs)

        # Resolve DType references, e.g. resolve base identities
        root.resolve_references(root)

        return root

    def _get_attrs(self):
        return [
            ("rpcs", self.rpcs),
            ("identities", self.identities),
        ]

    def prdaclass(self, schema_yang: ?list[str]=None, loose=False, include_state=False, top=True, root_path: list[str]=[]) -> str:
        def build_spath(spath: list[DNode]):
            if len(root_path) == len(spath) - 1:
                return spath

            next = root_path[len(spath) - 1]
            module, local_name = split_prefix_name(next)
            child = spath[-1].get(local_name, module=module, allow_unqualified=False)
            return build_spath(spath + [child])

        res = []
        res.append("import base64")
        res.append("import json")
        res.append("import xml")
        res.append("import yang")
        res.append("import yang.adata")
        res.append("import yang.gdata")
        res.append("import yang.gen3")
        res.append("from yang.gdata import repr_yang")
        res.append("from yang.identityref import Identityref, PartialIdentityref")
        res.append("from yang.pattern import YangPattern")
        res.append("from yang.schema import *")
        res.append("from yang.type import Decimal, Ranges")
        res.append("")
        res.append("# == This file is generated ==")
        res.append("")
        res.append("")
        res.append("")
        res.append("")
        res.extend(DIdentity.format_identity_list(self.identities))
        res.extend(DIdentity.format_identityref_constants(self.identities))
        if schema_yang is not None:
# TODO: serialize list[str] of YANG models with repr(), use raw string to avoid interpolation?!
# TODO: Why is the src_yang() function not found in from_xml, if it is
# defined at the bottom of the module?!
# After these two are addressed, then we can do away with these hacky workarounds
#
#"""def src_yang():
#   return {repr(self.src)}
#"""
            res.append("def src_yang():")
            res.append("    res = []")
            for s in schema_yang:
                res.append('    res.append(r"""{s}""")')
            res.append("    return res")
            res.append("")
            res.append("")

        spath = build_spath([self])
        schema_ns = set()
        res.extend(spath[-1]._prdaclass_rec(spath, loose=loose, top=top, set_ns=True, schema_ns=schema_ns, include_state=include_state))

        # TODO: module constant when we switch to DType
        # TODO: reuse namespace qualifiers from schema_namespaces to avoid allocating many new string
        res.append("def src_dnode():")
        res.append("    return {self.prsrc()}")
        res.append("")

        res.append("schema_namespaces: set[str] = {{")
        for ns in sorted(schema_ns):
            res.append("    '{ns}',")
        res.append("}}")
        res.append("")

        return "\n".join(res)


class DRpc(DNodeInner):
    if_feature: list[str]
    input: ?DInput
    output: ?DOutput
    status: ?str

    def __init__(self, module: str, namespace: str, prefix: str, name: str, description: ?str=None, if_feature=[], input: ?DInput=None, output: ?DOutput=None, reference=None, status=None, exts=[], children=[]):
        self.module = module
        self.namespace = namespace
        self.prefix = prefix
        self.name = name
        self.gname = "Rpc"
        self.config = False
        self.description = description
        self.if_feature = if_feature
        self.input = input
        self.output = output
        self.reference = reference
        self.status = status
        self.exts = exts
        self.children = children

    def _get_attrs(self):
        return [
            ("module", self.module),
            ("namespace", self.namespace),
            ("prefix", self.prefix),
            ("name", self.name),
            ("description", self.description),
            ("if_feature", self.if_feature),
            ("input", self.input),
            ("output", self.output),
            ("reference", self.reference),
            ("status", self.status),
            ("exts", self.exts),
        ]


class DType(object):
    parent: ?DNodeLeaf
    module: str      # The name of the module this node belongs to
    namespace: str
    prefix: str
    name: str
    config: bool
    description: ?str
    reference: ?str
    exts: list[Ext]
    builtin_type: str
    default: ?value
    units: ?str

    def __init__(self, module: str, namespace: str, prefix: str, name: str, description: ?str, reference: ?str, units: ?str, exts: list[Ext], builtin_type: str, default: ?value):
        self.parent = None
        self.module = module
        self.namespace = module
        self.prefix = prefix
        self.name = name
        self.config = False
        self.description = description
        self.reference = reference
        self.units = units
        self.exts = exts
        self.builtin_type = builtin_type
        self.default = default

    @staticmethod
    def from_resolved_type(type_: ResolvedType) -> DType:
        resolver = DTypeResolver.resolve(type_)
        return DType.from_resolver(resolver)

    @staticmethod
    def from_resolver(resolver: DTypeResolver) -> DType:
        if resolver.builtin_type == "string":
            return DTypeString.from_resolver(resolver)
        elif resolver.builtin_type in ["int8", "int16", "int32", "int64", "uint8", "uint16", "uint32", "uint64"]:
            return DTypeInteger.from_resolver(resolver)
        elif resolver.builtin_type == "boolean":
            return DTypeBoolean.from_resolver(resolver)
        elif resolver.builtin_type == "empty":
            return DTypeEmpty.from_resolver(resolver)
        elif resolver.builtin_type == "identityref":
            return DTypeIdentityref.from_resolver(resolver)
        elif resolver.builtin_type == "enumeration":
            return DTypeEnum.from_resolver(resolver)
        elif resolver.builtin_type == "decimal64":
            return DTypeDecimal64.from_resolver(resolver)
        elif resolver.builtin_type == "leafref":
            return DTypeLeafref.from_resolver(resolver)
        elif resolver.builtin_type == "union":
            return DTypeUnion.from_resolver(resolver)
        elif resolver.builtin_type == "binary":
            return DTypeBinary.from_resolver(resolver)
        elif resolver.builtin_type == "bits":
            return DTypeBits.from_resolver(resolver)
        elif resolver.builtin_type == "instance-identifier":
            return DTypeInstanceIdentifier.from_resolver(resolver)
        raise ValueError("Unable to resolve type ({resolver.type_}) into builtin base-type")

    def resolve_references(self, root: DRoot):
        pass

    # Validate value type. NOT relations to other data i.e. leafref/instance-identifier targets.
    def validate_value(self, val: value) -> bool:
        return False

    def prtyinst(self) -> str:
        return "DType({self.format_common_params()})"

    def format_common_params(self) -> str:
        return "module={repr(self.module)}, namespace={repr(self.namespace)}, prefix={repr(self.prefix)}, name={repr(self.name)}, description={repr(self.description)}, reference={repr(self.reference)}, exts={repr(self.exts)}, builtin_type={repr(self.builtin_type)}, default={repr(self.default)}"

    def format_short_hint(self) -> str:
        return  self.builtin_type if self.builtin_type == self.name else "{self.builtin_type} {self.name}"

    def format_hint(self) -> str:
        name_and_base = self.builtin_type if self.builtin_type == self.name else "{self.name} {self.builtin_type}"
        hints = self.format_hints()
        return "{name_and_base} with {", ".join(hints)}" if hints else name_and_base

    def format_hints(self) -> list[str]:
        return []

class DTypeBinary(DType):
    length: ?Ranges[int]

    def __init__(self, module: str, namespace: str, prefix: str, name: str, description: ?str, reference: ?str, units: ?str, exts: list[Ext], builtin_type: str, default: ?value, length: ?Ranges[int]):
        DType.__init__(self, module, namespace, prefix, name, description, reference, units, exts, builtin_type, default)
        self.length = length

    @staticmethod
    def from_resolver(resolver: DTypeResolver) -> DTypeBinary:
        t = resolver.type_
        return DTypeBinary(t.get_module_name(), t.get_namespace(), t.get_prefix(), t.name, resolver.description, resolver.reference, resolver.units, t.exts, resolver.builtin_type, resolver.default, resolver.length)

    def validate_value(self, val: value) -> bool:
        if isinstance(val, bytes):
            length = self.length
            if length is not None:
                return Ranges.match(length, len(val))
            return True
        return False

    def prtyinst(self) -> str:
        return "DTypeBinary({self.format_common_params()}, length={repr(self.length)})"

    def format_hints(self) -> list[str]:
        hints = DType.format_hints(self)
        _length = self.length
        if _length is not None:
            # Pending https://github.com/actonlang/acton/issues/1125
            # hints.append("length: ({str(_length)})")
            hints += ["length: ({str(_length)})"]
        return hints

class DTypeBits(DType):
    name_to_pos: dict[str, int]

    def __init__(self, module: str, namespace: str, prefix: str, name: str, description: ?str, reference: ?str, units: ?str, exts: list[Ext], builtin_type: str, default: ?value, name_to_pos: dict[str, int]):
        DType.__init__(self, module, namespace, prefix, name, description, reference, units, exts, builtin_type, default)
        self.name_to_pos = name_to_pos

    @staticmethod
    def from_resolver(resolver: DTypeResolver) -> DTypeBits:
        t = resolver.type_
        return DTypeBits(t.get_module_name(), t.get_namespace(), t.get_prefix(), t.name, resolver.description, resolver.reference, resolver.units, t.exts, resolver.builtin_type, resolver.default, resolver.bits)

    def validate_value(self, val: value) -> bool:
        if isinstance(val, set):
            for elem in val:
                if elem not in self.name_to_pos:
                    return False
            return True
        return False

    def prtyinst(self) -> str:
        return "DTypeBits({self.format_common_params()}, name_to_pos={repr(self.name_to_pos)})"

    def format_hints(self) -> list[str]:
        return ["[", ", ".join(self.name_to_pos.keys()) , "]"]

class DTypeBoolean(DType):
    # No restrictions

    def __init__(self, module: str, namespace: str, prefix: str, name: str, description: ?str, reference: ?str, units: ?str, exts: list[Ext], builtin_type: str, default: ?value):
        DType.__init__(self, module, namespace, prefix, name, description, reference, units, exts, builtin_type, default)

    @staticmethod
    def from_resolver(resolver: DTypeResolver) -> DTypeBoolean:
        t = resolver.type_
        return DTypeBoolean(t.get_module_name(), t.get_namespace(), t.get_prefix(), t.name, resolver.description, resolver.reference, resolver.units, t.exts, resolver.builtin_type, resolver.default)

    def validate_value(self, val: value) -> bool:
        return isinstance(val, bool)

    def prtyinst(self) -> str:
        return "DTypeBoolean({self.format_common_params()})"

class DTypeDecimal64(DType):
    fraction_digits: bigint
    ranges: ?Ranges[Decimal]

    def __init__(self, module: str, namespace: str, prefix: str, name: str, description: ?str, reference: ?str, units: ?str, exts: list[Ext], builtin_type: str, default: ?value, fraction_digits: bigint, ranges: ?Ranges[Decimal]):
        DType.__init__(self, module, namespace, prefix, name, description, reference, units, exts, builtin_type, default)
        self.fraction_digits = fraction_digits
        self.ranges = ranges

    @staticmethod
    def from_resolver(resolver: DTypeResolver) -> DTypeDecimal64:
        _fraction_digits = resolver.fraction_digits
        if _fraction_digits is not None:
            t = resolver.type_
            return DTypeDecimal64(t.get_module_name(), t.get_namespace(), t.get_prefix(), t.name, resolver.description, resolver.reference, resolver.units, t.exts, resolver.builtin_type, resolver.default, _fraction_digits, resolver.decimal_ranges)
        raise ValueError("Missing required fraction-digits for decimal64 type \"{resolver.type_.name}\"")

    def validate_value(self, val: value) -> bool:
        if isinstance(val, Decimal):
            if val.try_lossless_realign(-self.fraction_digits) is None:
                return False
            ranges = self.ranges
            if ranges is not None and not Ranges.match(ranges, val):
                return False
            return True
        return False

    def prtyinst(self) -> str:
        return "DTypeDecimal64({self.format_common_params()}, fraction_digits={repr(self.fraction_digits)}, ranges={repr(self.ranges)})"

    def format_hints(self) -> list[str]:
        hints = ["fraction-digits: {self.fraction_digits}"]
        _ranges = self.ranges
        if _ranges is not None:
            # Pending https://github.com/actonlang/acton/issues/1125
            # hints.append("range ({str(_ranges)})")
            hints += ["range ({str(_ranges)})"]
        return hints

class DTypeEmpty(DType):
    # No restrictions

    def __init__(self, module: str, namespace: str, prefix: str, name: str, description: ?str, reference: ?str, units: ?str, exts: list[Ext], builtin_type: str, default: ?value):
        DType.__init__(self, module, namespace, prefix, name, description, reference, units, exts, builtin_type)

    @staticmethod
    def from_resolver(resolver: DTypeResolver) -> DTypeEmpty:
        t = resolver.type_
        return DTypeEmpty(t.get_module_name(), t.get_namespace(), t.get_prefix(), t.name, resolver.description, resolver.reference, resolver.units, t.exts, resolver.builtin_type, resolver.default)

    def validate_value(self, val: value) -> bool:
        return isinstance(val, bool)

    def prtyinst(self) -> str:
        return "DTypeEmpty({self.format_common_params()})"

class DTypeEnum(DType):
    name_to_val: dict[str, int]

    def __init__(self, module: str, namespace: str, prefix: str, name: str, description: ?str, reference: ?str, units: ?str, exts: list[Ext], builtin_type: str, default: ?value, name_to_val: dict[str, int]):
        DType.__init__(self, module, namespace, prefix, name, description, reference, units, exts, builtin_type, default)
        self.name_to_val = name_to_val

    def prtyinst(self) -> str:
        return "DTypeEnum({self.format_common_params()}, name_to_val={repr(self.name_to_val)})"

    @staticmethod
    def from_resolver(resolver: DTypeResolver) -> DTypeEnum:
        t = resolver.type_
        return DTypeEnum(t.get_module_name(), t.get_namespace(), t.get_prefix(), t.name, resolver.description, resolver.reference, resolver.units, t.exts, resolver.builtin_type, resolver.default, resolver.enum_name_to_val)

    def validate_value(self, val: value) -> bool:
        return isinstance(val, str) and val in self.name_to_val

    def format_hints(self) -> list[str]:
        return ["either of {repr(list(self.name_to_val.keys()))}"]

class DTypeIdentityref(DType):
    identity_bases: list[DIdentity]
    identities: list[DIdentity]

    def __init__(self, module: str, namespace: str, prefix: str, name: str, description: ?str, reference: ?str, units: ?str, exts: list[Ext], builtin_type: str, default: ?value, identity_bases: list[DIdentity], identities: list[DIdentity]):
        DType.__init__(self, module, namespace, prefix, name, description, reference, units, exts, builtin_type, default)
        self.identity_bases = identity_bases
        self.identities = identities

    def prtyinst(self) -> str:
        return "DTypeIdentityref({self.format_common_params()}, identity_bases={DIdentity.format_base_identity_var_name_list(self.identity_bases)}, identities=_identities)"

    @staticmethod
    def from_resolver(resolver: DTypeResolver) -> DTypeIdentityref:
        identity_bases = []
        for base in resolver.identity_bases:
            maybe_prefix, name = split_prefix_name(base)
            prefix = maybe_prefix if maybe_prefix is not None else resolver.type_.get_prefix()
            # Create temporary DIdentity instances to be completed and replaced by resolve_references
            identity_base = DIdentity("", "", prefix, name, [])
            identity_bases.append(identity_base)
        t = resolver.type_
        return DTypeIdentityref(t.get_module_name(), t.get_namespace(), t.get_prefix(), t.name, resolver.description, resolver.reference, resolver.units, t.exts, resolver.builtin_type, resolver.default, identity_bases, [])

    def resolve_references(self, root: DRoot):
        resolved_identity_bases = []
        for identity_base in self.identity_bases:
            resolved_identity_base = find_identity_by_ref(root.identities, identity_base.name, prefix=identity_base.prefix)
            if resolved_identity_base is not None:
                resolved_identity_bases.append(resolved_identity_base)
            else:
                raise ValueError("Unknown base identity \"{identity_base.prefix}:{identity_base.name}\" in type \"{self.name}\"")
        self.identity_bases = resolved_identity_bases
        self.identities = root.identities

    def validate_value(self, val: value) -> bool:
        if isinstance(val, Identityref):
            identity = find_identity_by_ref(self.identities, val.val, val.ns, val.mod, val.pfx)
            if identity is not None:
                return is_derived_from(identity, self.identity_bases)
        return False

    def format_hints(self) -> list[str]:
        bases = ", ".join(["'{b.prefix}:{b.name}'" for b in self.identity_bases])
        return ["bases: [{bases}]"]

class DTypeInstanceIdentifier(DType):
    require_instance: bool

    def __init__(self, module: str, namespace: str, prefix: str, name: str, description: ?str, reference: ?str, units: ?str, exts: list[Ext], builtin_type: str, default: ?value, require_instance: bool):
        DType.__init__(self, module, namespace, prefix, name, description, reference, units, exts, builtin_type, default)
        self.require_instance = require_instance

    def prtyinst(self) -> str:
        return "DTypeInstanceIdentifier({self.format_common_params()}, require_instance={repr(self.require_instance)})"

    @staticmethod
    def from_resolver(resolver: DTypeResolver) -> DTypeInstanceIdentifier:
        t = resolver.type_
        _require_instance = resolver.require_instance
        return DTypeInstanceIdentifier(t.get_module_name(), t.get_namespace(), t.get_prefix(), t.name, resolver.description, resolver.reference, resolver.units, t.exts, resolver.builtin_type, resolver.default, _require_instance is not None and _require_instance)

    def validate_value(self, val: value) -> bool:
        return True # TODO

    def format_hints(self) -> list[str]:
        _require_instance = self.require_instance
        if _require_instance is not None and not _require_instance:
            return ["require-instance: false"]
        return []

class DTypeInteger(DType):
    ranges: ?Ranges[bigint]

    def __init__(self, module: str, namespace: str, prefix: str, name: str, description: ?str, reference: ?str, units: ?str, exts: list[Ext], builtin_type: str, default: ?value, ranges: ?Ranges[bigint]):
        DType.__init__(self, module, namespace, prefix, name, description, reference, units, exts, builtin_type, default)
        self.ranges = ranges

    def prtyinst(self) -> str:
        return "DTypeInteger({self.format_common_params()}, ranges={repr(self.ranges)})"

    @staticmethod
    def from_resolver(resolver: DTypeResolver) -> DTypeInteger:
        t = resolver.type_
        return DTypeInteger(t.get_module_name(), t.get_namespace(), t.get_prefix(), t.name, resolver.description, resolver.reference, resolver.units, t.exts, resolver.builtin_type, resolver.default, resolver.integer_ranges)

    def validate_value(self, val: value) -> bool:
        if isinstance(val, bigint):
            ranges = self.ranges
            if ranges is not None:
                return Ranges.match(ranges, val)
            return True
        # FIXME: Only allow bigint once all instances of int are removed from sorespo
        if isinstance(val, int):
            ranges = self.ranges
            if ranges is not None:
                return Ranges.match(ranges, bigint(val))
            return True
        return False

    def format_hints(self) -> list[str]:
        _ranges = self.ranges
        if _ranges is not None:
            return ["range {str(_ranges)}"]
        return []

class DTypeLeafref(DType):
    path: str # TODO: XPath
    require_instance: bool # default: True

    def __init__(self, module: str, namespace: str, prefix: str, name: str, description: ?str, reference: ?str, units: ?str, exts: list[Ext], builtin_type: str, default: ?value, path: str, require_instance: bool):
        DType.__init__(self, module, namespace, prefix, name, description, reference, units, exts, builtin_type, default)
        self.path = path
        self.require_instance = require_instance

    @staticmethod
    def from_resolver(resolver: DTypeResolver) -> DTypeLeafref:
        _path = resolver.path
        if _path is not None:
            t = resolver.type_
            _require_instance = resolver.require_instance
            return DTypeLeafref(t.get_module_name(), t.get_namespace(), t.get_prefix(), t.name, resolver.description, resolver.reference, resolver.units, t.exts, resolver.builtin_type, resolver.default, _path, _require_instance is not None and _require_instance)
        raise ValueError("Type {resolver.type_.name} of base-type leafref requires path restriction")

    def resolve_references(self, root: DRoot):
        pass # TODO: Verify path expression

    def validate_value(self, val: value) -> bool:
        return True # TODO

    def prtyinst(self) -> str:
        return "DTypeLeafref({self.format_common_params()}, path={repr(self.path)}, require_instance={repr(self.require_instance)})"

    def format_hints(self) -> list[str]:
        hints = ["path: {self.path}"]
        _require_instance = self.require_instance
        if _require_instance is not None and not _require_instance:
            # Pending https://github.com/actonlang/acton/issues/1125
            # hints.append("require-instance: false")
            hints += ["require-instance: false"]
        return hints

class DTypeString(DType):
    length: ?Ranges[int]
    patterns: list[YangPattern]

    def __init__(self, module: str, namespace: str, prefix: str, name: str, description: ?str, reference: ?str, units: ?str, exts: list[Ext], builtin_type: str, default: ?value, length: ?Ranges[int], patterns: list[YangPattern]):
        DType.__init__(self, module, namespace, prefix, name, description, reference, units, exts, builtin_type, default)
        self.length = length
        self.patterns = patterns

    @staticmethod
    def from_resolver(resolver: DTypeResolver) -> DTypeString:
        t = resolver.type_
        return DTypeString(t.get_module_name(), t.get_namespace(), t.get_prefix(), t.name, resolver.description, resolver.reference, resolver.units, t.exts, resolver.builtin_type, resolver.default, resolver.length, resolver.patterns)

    def validate_value(self, val: value) -> bool:
        if isinstance(val, str):
            length = self.length
            if length is not None and not Ranges.match(length, len(val)):
                return False

            for pattern in self.patterns:
                if not pattern.match(val):
                    return False

            return True
        return False

    def prtyinst(self) -> str:
        return "DTypeString({self.format_common_params()}, length={repr(self.length)}, patterns={repr(self.patterns)})"

    def format_hints(self) -> list[str]:
        hints = []
        _length = self.length
        if _length is not None:
            # Pending https://github.com/actonlang/acton/issues/1125
            # hints.append("length: ({str(_length)})")
            hints += ["length: {str(_length)}"]
        _patterns = self.patterns
        if len(_patterns) > 0:
            # Pending https://github.com/actonlang/acton/issues/1125
            # hints.append("pattern: {" AND ".join([str(p) for p in _patterns])}")
            hints += ["pattern: {" AND ".join([str(p) for p in _patterns])}"]
        return hints

class DTypeUnion(DType):
    types: list[DType]

    def __init__(self, module: str, namespace: str, prefix: str, name: str, description: ?str, reference: ?str, units: ?str, exts: list[Ext], builtin_type: str, default: ?value, types: list[DType]):
        DType.__init__(self, module, namespace, prefix, name, description, reference, units, exts, builtin_type, default)
        self.types = types

    @staticmethod
    def from_resolver(resolver: DTypeResolver) -> DTypeUnion:
        t = resolver.type_
        alt_types = [DType.from_resolver(r) for r in resolver.alt_types]
        return DTypeUnion(t.get_module_name(), t.get_namespace(), t.get_prefix(), t.name, resolver.description, resolver.reference, resolver.units, t.exts, resolver.builtin_type, resolver.default, alt_types)

    def resolve_references(self, root: DRoot):
        for t in self.types:
            t.resolve_references(root)

    def validate_value(self, val: value) -> bool:
        for t in self.types:
            if t.validate_value(val):
                return True
        return False

    def prtyinst(self) -> str:
        return "DTypeUnion({self.format_common_params()}, types=[{", ".join([t.prtyinst() for t in self.types])}])"

    def format_hints(self) -> list[str]:
        return ["types: [{" OR ".join([t.format_hint() for t in self.types])}]"]

class DTypeResolver(object):
    type_: ResolvedType
    builtin_type: str
    identity_bases: list[str] # RFC7950: "An identityref cannot be restricted."
    bits: dict[str, int] # # Assume only allowed in the type "bits" statement with no further restrictions in base-type chain
    enum_name_to_val: dict[str, int] # May be restricted to subset only
    enum_val_to_name: dict[int, str]
    fraction_digits: ?bigint # Assume only allowed in the type "decimal64" statement with no further restrictions in base-type chain
    length: ?Ranges[int] # May be restricted to sub-ranges only
    path: ?str # Assume only allowed in the type "leafref" statement, with no further restrictions in base-type chain
              # TODO: XPath !!!
    patterns: list[YangPattern] # A value must match patterns in type and base-types chain
    integer_ranges: ?Ranges[bigint] # May be restricted to sub-ranges only
    decimal_ranges: ?Ranges[Decimal] # May be restricted to sub-ranges only
    require_instance: ?bool # Assuming 'True' unless explicitly 'False' in base-type chain, disallowing redefinition from explicit 'True'
    alt_types: list[DTypeResolver] # Merge base type union sets
    default: ?value # sub-type overrides base-type
    description: ?str # sub-type overrides base-type
    reference: ?str # sub-type overrides base-type
    units: ?str # sub-type overrides base-type

    def __init__(self, type_: ResolvedType):
        self.type_ = type_
        self.builtin_type = ""
        self.identity_bases = []
        self.bits = {}
        self.enum_name_to_val = {}
        self.enum_val_to_name = {}
        self.fraction_digits = None
        self.length = None
        self.path = None
        self.patterns = []
        self.integer_ranges = None
        self.decimal_ranges = None
        self.require_instance = None
        self.alt_types = []
        self.default = None
        self.description = None
        self.reference = None
        self.units = None

    @staticmethod
    def resolve(type_: ResolvedType) -> DTypeResolver:
        r = DTypeResolver(type_)
        r._resolve(type_)
        return r

    def _resolve(self, t: ResolvedType):
        if t.name == "union":
            self.builtin_type = t.name
            for alt_type in t.type_:
                if isinstance(alt_type, ResolvedType):
                    alt_resolver = DTypeResolver.resolve(alt_type)
                    if alt_resolver.builtin_type == "union":
                        self.alt_types.extend(alt_resolver.alt_types)
                    else:
                        self.alt_types.append(alt_resolver)
                else:
                    raise ValueError("Internal error: expected resolved alt-types in {t.name}")
        else:
            # Resolve base typedef
            base_typedef  = t.resolved_base_typedef
            if base_typedef is not None:
                # default value
                if base_typedef.default is not None and self.default is None:
                    self.default = base_typedef.default
                # description
                if base_typedef.description is not None and self.description is None:
                    self.description = base_typedef.description
                # reference
                if base_typedef.reference is not None and self.reference is None:
                    self.reference = base_typedef.reference
                # units
                if base_typedef.units is not None and self.units is None:
                    self.units = base_typedef.units
                # recurse into base typedef
                base_typedef_type = base_typedef.type_
                if isinstance(base_typedef_type, ResolvedType):
                    self._resolve(base_typedef_type)
                else:
                    raise ValueError("Internal error: expected resolved in typedef {base_typedef.name}")
            else:
                if t.name not in _builtin_types:
                    raise ValueError("Type \"{t.name}\" does not have a builtin type as base")
                self.builtin_type = t.name

            # base
            _base = t.base
            if _base:
                if self.identity_bases:
                    raise ValueError("Invalid restriction of bases in type \"{t.name}\"")
                self.identity_bases = _base

            # bit
            _bit = t.bit
            if _bit:
                next_pos = 0
                if self.bits:
                    raise ValueError("Invalid restriction of bits in type \"{t.name}\"")
                positions = set(None)
                for b in _bit:
                    name = b.name
                    _position = b.position
                    if _position is not None:
                        position = _position
                        if position in positions:
                            raise ValueError("Duplicate bit position \"{name}\": {position} in type \"{t.name}\"")
                        if position >= next_pos:
                            next_pos = position + 1
                    else:
                        if next_pos >= MAX_BIT_POSITION:
                            raise ValueError("Bit \"{name}\" must be assigned an explicit position when automatic assignment would exceed maximum limit of {MAX_BIT_POSITION} in type \"{t.name}\"")
                        position = next_pos
                        next_pos += 1
                    self.bits[name] = position

            # enum
            _enum = t.enum
            if _enum:
                new_enum_name_to_val = {}
                new_enum_val_to_name = {}

                next_val: int = 0 # TODO no need to get values of base-type?

                for e in _enum:
                    name = e.name
                    val = None
                    val_str = e.value
                    if val_str is not None:
                        try:
                            val = int(val_str)
                        except ValueError:
                            raise ValueError("Invalid enum value \"{name}\": {e.value} in sub-type \"{t.name}\"")
                    if self.enum_name_to_val and name not in self.enum_name_to_val:
                        raise ValueError("Enum \"{name}\" is not present in base-type of \"{t.name}\"")
                    if val is not None:
                        try:
                            existing_val_name = self.enum_val_to_name[val]
                        except:
                            pass # Non-colliding value
                        else:
                            if existing_val_name != name:
                                raise ValueError("Enum \"{name}\" may not reuse value of \"{existing_val_name}\" in sub-type \"{t.name}\"")
                        new_enum_val_to_name[val] = name
                        new_enum_name_to_val[name] = val
                        if val >= next_val:
                            next_val = val + 1
                    else:
                        if next_val >= MAX_ENUM_VALUE:
                            raise ValueError("Enum \"{name}\" must be assigned an explicit value when automatic assignment would exceed maximum limit of {MAX_ENUM_VALUE} in type \"{t.name}\"")
                        new_enum_val_to_name[next_val] = name
                        new_enum_name_to_val[name] = next_val
                        next_val += 1

                self.enum_name_to_val = new_enum_name_to_val
                self.enum_val_to_name = new_enum_val_to_name

            # fraction-digits
            _fraction_digits = t.fraction_digits
            if _fraction_digits is not None:
                if self.fraction_digits is not None:
                    raise ValueError("The fraction-digits of a base-type may not be redefined in sub-type\"{t.name}\"")
                self.fraction_digits = bigint(_fraction_digits)

            # length
            _length = t.length
            if _length is not None:
                _last_length = self.length
                base_length = _last_length if _last_length is not None else Ranges([(0, MAX_LENGTH_STMT)])
                try:
                    new_length = parse_int_range_stmt(_length.value, base_length)
                except ValueError as ex:
                    raise ValueError("Invalid length in type \"{t.name}\": {ex.error_message}")
                self.length = new_length

            # path
            _path = t.path
            if _path is not None:
                if self.path is not None:
                    raise ValueError("The path of a base-type may not be redefined in sub-type \"{t.name}\"")
                self.path = _path # TODO: XPath !!!

            # pattern
            for pattern in t.pattern:
                _modifier = pattern.modifier
                invert_match = _modifier is not None and _modifier == "invert-match"
                try:
                    new_pattern = YangPattern.from_yang_regex(pattern.value, invert_match)
                except Exception as ex:
                    raise ValueError("Unable to parse pattern of \"{t.name}\": {ex.error_message}")
                self.patterns.append(new_pattern)

            # builtin restrictions
            if t.name == "int8":
                self.integer_ranges = Ranges([(-128, 127)])
            elif t.name == "int16":
                self.integer_ranges = Ranges([(-32768, 32767)])
            elif t.name == "int32":
                self.integer_ranges = Ranges([(-2147483648, 2147483647)])
            elif t.name == "int64":
                # self.integer_ranges = Ranges([(-9223372036854775808, 9223372036854775807)])
                # Workaround https://github.com/actonlang/acton/issues/2545
                self.integer_ranges = Ranges([(-92233720368547758080//10, 9223372036854775807)])
            elif t.name == "uint8":
                self.integer_ranges = Ranges([(0, 255)])
            elif t.name == "uint16":
                self.integer_ranges = Ranges([(0, 65535)])
            elif t.name == "uint32":
                self.integer_ranges = Ranges([(0, 4294967295)])
            elif t.name == "uint64":
                self.integer_ranges = Ranges([(0, bigint(18446744073709551615))])
            elif t.name == "decimal64":
                fraction_digits = self.fraction_digits
                if fraction_digits is not None:
                    if fraction_digits < 1 or fraction_digits > 18:
                        raise ValueError("Invalid fraction-digits value, must be between 1 and 18 inclusivly")
                    # self.decimal_ranges = Ranges([(Decimal(bigint(-9223372036854775808), -fraction_digits), Decimal(9223372036854775807, -fraction_digits))])
                    # Workaround https://github.com/actonlang/acton/issues/2545
                    self.decimal_ranges = Ranges([(Decimal(-92233720368547758080//10, -fraction_digits), Decimal(9223372036854775807, -fraction_digits))])
            # range
            _range = t.range_
            if _range is not None:
                if self.builtin_type == "decimal64":
                    base_decimal_ranges = self.decimal_ranges
                    if base_decimal_ranges is not None:
                        try:
                            new_decimal_ranges = parse_decimal_range_stmt(_range.value, base_decimal_ranges)
                        except ValueError as ex:
                            raise ValueError("Invalid range in type \"{t.name}\": {ex.error_message}")
                    else:
                        raise ValueError("Internal error: missing builtin ({self.builtin_type}) base range for {t.name}")
                    self.decimal_ranges = new_decimal_ranges
                else:
                    base_integer_ranges = self.integer_ranges
                    if base_integer_ranges is not None:
                        try:
                            new_integer_ranges = parse_bigint_range_stmt(_range.value, base_integer_ranges)
                        except ValueError as ex:
                            raise ValueError("Invalid range in type \"{t.name}\": {ex.error_message}")
                    else:
                        raise ValueError("Internal error: missing builtin ({self.builtin_type}) base range for {t.name}")
                    self.integer_ranges = new_integer_ranges

            # require_instance
            _require_instance = t.require_instance
            if _require_instance is not None:
                if _require_instance:
                    self.require_instance = True
                else:
                    base_require_instance = self.require_instance
                    if base_require_instance is not None:
                        if base_require_instance:
                            raise ValueError("The require-instance=true of a base-type may not be redefined to false in sub-type \"{t.name}\"")
                    else:
                        self.require_instance = False

# -------------------------------------------------------------------------------

def split_prefix_name(name: str) -> (?str, str):
    if ":" in name:
        parts = name.split(":", 1)
        return (parts[0], parts[1])
    return None, name

# -------------------------------------------------------------------------------

class ModRev(object):
    modname: str
    rev: ?str

    def __init__(self, modname: str, rev: ?str):
        self.modname = modname
        self.rev = rev

extension ModRev (Hashable):
    def __eq__(self, other: ModRev) -> bool:
        return self.modname == other.modname and self.rev == other.rev

    def hash(self, hasher):
        self.modname.hash(hasher)
        selfrev = self.rev
        if selfrev is not None:
            selfrev.hash(hasher)
        else:
            # Hash empty string for None revision to distinguish from modules with revision
            "".hash(hasher)

class Context(object):
    """Compilation context
    """
    modules: dict[ModRev, Module]

    def __init__(self, modules: list[Module]=[]):
        self.modules = {}
        for thing in modules:
            self.add_module(thing)

    def add_module(self, module: Module):
        latest_revision = module.get_revision()
        mod_rev = ModRev(module.name, latest_revision.date if latest_revision is not None else None)
        self.modules[mod_rev] = module

        # Now also add the module itself without revision
        no_rev_mod = ModRev(module.name, None)
        if no_rev_mod in self.modules:
            existing_revision = self.modules[no_rev_mod].get_revision()
            if existing_revision is not None and latest_revision is not None:
                if latest_revision.date > existing_revision.date:
                    # Currently added module has a revision that is newer, so it
                    # should replace the existing module
                    self.modules[no_rev_mod] = module
                # Otherwise, the existing module is newer, so we should keep it
                return
            elif existing_revision is None and latest_revision is not None:
                # Currently added module has a revision, but existing module does not
                # so we presume that we're adding a newer version of the module
                self.modules[no_rev_mod] = module
            # Otherwise, both modules have no revision, so we keep the existing one
            return
        else: # No module with this name exists yet
            self.modules[no_rev_mod] = module

    def get_module(self, modname: str, rev: ?str) -> Module:
        mod_rev = ModRev(modname, rev)
        try:
            mod = self.modules[mod_rev]
            return mod
        except KeyError:
            raise ValueError("Module {modname} rev {rev} not found in compilation context")

    def get_modules(self) -> list[Module]:
        return list(self.modules.values())


class SchemaNode(object):
    parent: ?SchemaNode
    mod: ?str
    ns: ?str
    pfx: ?str
    exts: list[Ext]
    _yname: str

    def _get_argname(self) -> ?str:
        raise NotImplementedError('SchemaNode _get_argname')

    def _get_arg(self) -> ?str:
        raise NotImplementedError('SchemaNode _get_arg')

    def get_attrs(self) -> list[(str, ?value)]:
        raise NotImplementedError('SchemaNode get_attrs')

    _get_class_name: pure() -> str

    def prsrc(self, indent=0):
        """Print Acton source code for this schema node and its subnodes
        """
        res = []
        self_arg = self._get_arg()
        if self_arg is not None:
            args = [repr(self_arg)]
        else:
            args = []
        attrs_text = _prsrc_attrs(indent, self.get_attrs())
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, self.get_attrs()))
        have_children = True if isinstance(self, SchemaNodeInner) and len(self.children) > 0 else False
        if have_children:
            args.append("children=[")
        args_text = ", ".join(args)
        text_line = "{_ind(indent)}{self._get_class_name()}({args_text}"
        if not have_children:
            text_line += ')'
        res.append(text_line)
        if isinstance(self, SchemaNodeInner) and have_children:
            child_res = [child.prsrc(indent+1) for child in self.children]
            res.append(",\n".join(child_res))
            res.append(_ind(indent) + "])")
        return "\n".join(res)

    def prdaclass(self, loose=False, top=True, set_ns=True, schema_ns=set(), include_state=False) -> str:
        """Print the data class for this schema node
        """
        raise NotImplementedError('SchemaNode pdc')

    mut def to_dnode(self) -> DNode:
        raise NotImplementedError('SchemaNode to_dschema not implemented for {type(self)}')

    def get_dnode_children(self, in_choice: bool=False):
        mut def unset_mandatory(node):
            """Unset the mandatory attribute if present
            """
            if isinstance(node, DLeaf):
                node.mandatory = False
            elif isinstance(node, DAnydata):
                node.mandatory = None
            elif isinstance(node, DAnyxml):
                node.mandatory = None

        if isinstance(self, SchemaNodeInner):
            new_children = []
            for child in self.children:
                if isinstance(child, Case):
                    # Direct descendants of case are data nodes, where we must
                    # unset mandatory
                    new_children.extend(child.get_dnode_children(in_choice=True))
                    continue
                if isinstance(child, Choice):
                    # Direct descendants of choice are either case or data node,
                    # like leaf, container, etc. We unset mandatory on these to
                    # avoid ending up with invalid mutually exclusive
                    # constraints in the data tree. Of course we then have no constraints ...
                    new_children.extend(child.get_dnode_children(in_choice=True))
                    continue
                if isinstance(child, Grouping):
                    continue
                if isinstance(child, Identity):
                    continue
                if isinstance(child, Typedef):
                    continue
                if isinstance(child, Uses):
                    continue
                dnode_child = child.to_dnode()
                if in_choice:
                    unset_mandatory(dnode_child)
                new_children.append(dnode_child)
            return new_children
        raise ValueError("get_dnode_children() called on non-inner node {type(self)}")

    def get_module_name(self) -> str:
        # TODO: return belongs_to.name for submodule??
        n = self
        for i in range(RECURSION_LIMIT+1):
            nmod = n.mod
            if nmod is not None:
                return nmod
            nparent = n.parent
            if nparent is not None:
                n = nparent
                continue
            else:
                raise ValueError("Unable to find module")
            if i > RECURSION_LIMIT:
                raise ValueError("Recursion limit reached")
        raise ValueError("Unable to find module")

    def get_namespace(self) -> str:
        n = self
        for i in range(RECURSION_LIMIT+1):
            nnamespace = n.ns
            if nnamespace is not None:
                return nnamespace
            nparent = n.parent
            if nparent is not None:
                n = nparent
                continue
            else:
                raise ValueError("Unable to find namespace")
            if i > RECURSION_LIMIT:
                raise ValueError("Recursion limit reached")
        raise ValueError("Unable to find namespace")

    def get_prefix(self) -> str:
        n = self
        for i in range(RECURSION_LIMIT+1):
            nprefix = n.pfx
            if nprefix is not None:
                return nprefix
            nparent = n.parent
            if nparent is not None:
                n = nparent
                continue
            else:
                raise ValueError("Unable to find prefix")
            if i > RECURSION_LIMIT:
                raise ValueError("Recursion limit reached")
        raise ValueError("Unable to find prefix")

    def is_config(self) -> bool:
        n = self
        for i in range(RECURSION_LIMIT+1):
            if (isinstance(n, Action)
                or isinstance(n, Anydata)
                or isinstance(n, Anyxml)
                or isinstance(n, Case)
                or isinstance(n, Choice)
                or isinstance(n, Container)
                or isinstance(n, Input)
                or isinstance(n, Module)
                or isinstance(n, Leaf)
                or isinstance(n, LeafList)
                or isinstance(n, List)
                or isinstance(n, Notification)
                or isinstance(n, Output)
                or isinstance(n, Rpc)):
                found_config = True
                if isinstance(n, Action):
                    return False
                elif isinstance(n, Anydata):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, Anyxml):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, Case):
                    found_config = False
                elif isinstance(n, Choice):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, Container):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, Input):
                    return False
                elif isinstance(n, Leaf):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, LeafList):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, List):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, Module):
                    return True
                elif isinstance(n, Notification):
                    return False
                elif isinstance(n, Output):
                    return False
                elif isinstance(n, Rpc):
                    return False

                if not found_config:
                    nparent = n.parent
                    if nparent is not None:
                        n = nparent
                        continue
                    else:
                        if isinstance(n, Module):
                            return True
                        else:
                            raise ValueError("Reached some top data node of type {type(n)}")
            else:
                raise ValueError("Non-data node {type(n)} does not have config statements")
            if i > RECURSION_LIMIT:
                raise ValueError("Recursion limit reached")
        raise ValueError("Unable to find config attribute")

    def get_parent(self) -> SchemaNode:
        p = self.parent
        if p is not None:
            return p
        raise ValueError("No parent found")

    def get(self, name: str, ns: ?str=None) -> SchemaNode:
        """Get child node by name
        """
        if isinstance(self, SchemaNodeInner):
            # If no namespace specified, use current node's namespace
            tns = ns if ns is not None else self.get_namespace()

            for child in self.children:
                # Always check namespace, even for unqualified lookups
                child_ns = child.get_namespace()
                if child_ns != tns:
                    continue

                if isinstance(child, Action) and child.name == name:
                    return child
                elif isinstance(child, Anydata) and child.name == name:
                    return child
                elif isinstance(child, Anyxml) and child.name == name:
                    return child
                elif isinstance(child, Case) and child.name == name:
                    return child
                elif isinstance(child, Choice) and child.name == name:
                    return child
                elif isinstance(child, Container) and child.name == name:
                    return child
                elif isinstance(child, Input) and name == 'input':
                    return child
                elif isinstance(child, Leaf) and child.name == name:
                    return child
                elif isinstance(child, LeafList) and child.name == name:
                    return child
                elif isinstance(child, List) and child.name == name:
                    return child
                elif isinstance(child, Notification) and child.name == name:
                    return child
                elif isinstance(child, Output) and name == 'output':
                    return child
                elif isinstance(child, Rpc) and child.name == name:
                    return child
            # Check extension with argument
            for ext in self.exts:
                ext_arg = ext.arg
                if ext_arg is not None and ext_arg == name:
                    return ext
            raise ValueError("Child {name} not found")

        raise ValueError("Unable to get child {name} from non-inner node")

    def get_module(self) -> Module:
        """Get the Module for the local module

        That is, climb up the ladder of parents from the current node until we
        reach the top Module.
        """
        n = self
        while True:
            if isinstance(n, Module):
                return n
            nparent = n.parent
            if nparent is not None:
                n = nparent
                continue
            break
        raise ValueError("Unable to find Module")

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None) -> SchemaNode:
        """Compile an abstract YANG into a concrete one
        - expand uses / groupings
        - handle augments
        - resolve types to base types
        """
        raise NotImplementedError('SchemaNode compile')

    def expand_augments(self, context: Context, target_base: SchemaNode=self, in_uses=False):
        """Expand augment node"""
        def get_target(target_base, target: str) -> SchemaNode:

            parts = target.lstrip("/").split("/")
            current_node = target_base
            if target[0] == "/":
                if in_uses:
                    raise ValueError("Absolute path in augment under uses is not valid")

                for idx, part in enumerate(parts):
                    prefix, name = split_prefix_name(part)
                    if idx == 0:
                        if prefix is not None: # Handle augment targetting another module.
                            current_node = current_node.get_module_by_prefix(prefix, context)
                        else:
                            current_node = self.get_module()

                    if prefix is not None:
                        target_ns = self.get_module_by_prefix(prefix, context).get_namespace()
                    else:
                        # Use the augmenting module's namespace for unprefixed segments
                        target_ns =  self.get_namespace()
                    current_node = current_node.get(name, ns=target_ns)

            else: # augment under uses
                if not in_uses:
                    raise ValueError("Relative path in augment under (sub-)module is not valid")

                for part in parts:
                    prefix, name = split_prefix_name(part)
                    if prefix is not None:
                        # TODO: or is prefix OK when it is the local prefix?
                        raise ValueError("Relative path in augment under uses cannot have prefixes")
                    # Use the augmenting module's namespace for unprefixed segments
                    current_node = current_node.get(name, ns=self.get_namespace())

            return current_node

        def expand_augment(augments: list[Augment], target_base, context: Context):
            # There can be multiple augments which might have dependencies on
            # each other, for example:
            # container c1 {}
            # augment /c1/c2 { leaf l1 { type string; } }
            # augment /c1 { container c2 {} }
            #
            # The first augment targets /c1/c2 which depends on the second
            # augment below, so we must apply these augments in the right order.
            # We do this by looking at the length of the target path and
            # applying the augments in order of increasing path length.

            augments_by_path_length: dict[int, list[Augment]] = {}
            for augment in augments:
                parts = augment.target_node.lstrip("/").split("/")
                plen = len(parts)
                if plen not in augments_by_path_length:
                    augments_by_path_length[plen] = []
                augments_by_path_length[plen].append(augment)

            for plen in sorted(augments_by_path_length.keys()):
                plen_augments = augments_by_path_length[plen]
                for aug in plen_augments:
                    target = get_target(target_base, aug.target_node)
                    if isinstance(target, SchemaNodeInner):
                        # Just move the child to the target
                        aug.expand_children(context, target, new_mod=aug.get_module_name(), new_ns=aug.get_namespace(), new_pfx=aug.get_prefix())
                        target.exts.extend(aug.exts)
                    else:
                        raise ValueError("Augment target {target} is not an inner node")

        # Look if node is of a type that has augment substatements
        if isinstance(self, Module):
            expand_augment(self.augment, self, context)
        elif isinstance(self, Submodule):
            expand_augment(self.augment, self, context)
        elif isinstance(self, Uses):
            expand_augment(self.augment, target_base, context)
        else:
            raise ValueError("Node type does not have augment substatements")

    def expand_children(self, context: Context, target: SchemaNodeInner, new_mod: ?str = None, new_ns: ?str = None, new_pfx: ?str = None):
        """Expand abstract children into concrete nodes
        """
        if isinstance(self, SchemaNodeInner):
            for child in self.children:
                if isinstance(child, Uses):
                    grouping = child.get_grouping(child.name, context)
                    grouping.expand_children(context, target, new_mod if new_mod is not None else target.mod, new_ns if new_ns is not None else target.ns, new_pfx if new_pfx is not None else target.pfx)
                    child.expand_augments(context, target, in_uses=True)
                    child.expand_refines(target)
                else:
                    c_child = child.compile(context, new_mod, new_ns, new_pfx)
                    c_child.parent = target
                    target.children.append(c_child)
        else:
            raise ValueError("expand_children() called on non-inner node {type(self)}")

    mut def apply_refine(self, refine: Refine):
        raise NotImplementedError('SchemaNode apply_refine not implemented for {type(self)}')

    def get_module_by_prefix(self, prefix: str, context: Context) -> Module:
        """Get a Module from the import prefix in the local module"""
        local_module = self.get_module()
        local_module_prefix = local_module.prefix
        if local_module_prefix is not None and local_module_prefix == prefix:
            return local_module
        imp = local_module.get_import_by_prefix(prefix)
        return context.get_module(imp.module, imp.revision_date)

    def get_grouping(self, name: str, context: Context) -> Grouping:
        """Find a grouping in the local module or an imported module
        """
        prefix, group_name = split_prefix_name(name)
        if prefix is not None:
            imported_module = self.get_module_by_prefix(prefix, context)
            return imported_module.get_grouping(group_name, context)
        else: # local module
            return self.get_grouping_in_module(group_name)

    def get_grouping_in_module(self, name: str) -> Grouping:
        """Find a grouping in the current module
        """
        n = self
        for i in range(RECURSION_LIMIT+1):
            if isinstance(n, SchemaNodeInner):
                for child in n.children:
                    if isinstance(child, Grouping) and child.name == name:
                        return child
            nparent = n.parent
            if nparent is not None:
                n = nparent
                continue
            else:
                break
            if i == RECURSION_LIMIT:
                raise ValueError("Recursion limit reached")
        raise ValueError("Unable to find grouping '{name}'")

    def get_typedef(self, name: str, context: Context) -> Typedef:
        """Find a typedef in the local module or an imported module
        """
        prefix, typedef_name = split_prefix_name(name)
        if prefix is not None:
            imported_module = self.get_module_by_prefix(prefix, context)
            return imported_module.get_typedef(typedef_name, context)
        else:
            return self.get_typedef_in_module(typedef_name)

    def get_typedef_in_module(self, name: str) -> Typedef:
        """Find a typedef in the current module
        """
        n = self
        for i in range(RECURSION_LIMIT+1):
            typedefs: list[Typedef] = []
            if isinstance(n, SchemaNodeInner):
                for child in n.children:
                    if isinstance(child, Typedef) and child.name == name:
                        return child
            nparent = n.parent
            if nparent is not None:
                n = nparent
                continue
            else:
                break
            if i == RECURSION_LIMIT:
                raise ValueError("Recursion limit reached")
        raise ValueError("Unable to find typedef '{name}'")

    def get_identity(self, name: str, context: Context) -> Identity:
        """Find a identity in the local module or an imported module
        """
        prefix, identity_name = split_prefix_name(name)
        if prefix is not None:
            imported_module = self.get_module_by_prefix(prefix, context)
            return imported_module.get_identity(identity_name, context)
        else:
            return self.get_identity_in_module(identity_name)

    def get_identity_in_module(self, name: str) -> Identity:
        """Find a identity in the current module
        """
        n = self
        for i in range(RECURSION_LIMIT+1):
            identitys: list[Identity] = []
            if isinstance(n, Module):
                for child in n.children:
                    if isinstance(child, Identity) and child.name == name:
                        return child
            nparent = n.parent
            if nparent is not None:
                n = nparent
                continue
            else:
                break
            if i == RECURSION_LIMIT:
                raise ValueError("Recursion limit reached")
        raise ValueError("Unable to find identity '{name}' in module '{self.get_module_name()}'")

    def to_statement(self) -> Statement:
        """Convert this schema node to a Statement
        """
        stmt = Statement(self._yname, self._get_arg())
        for attr_name, attr_value in self.get_attrs():
            if attr_value is not None:
                if isinstance(attr_value, SchemaNode):
                    stmt.substatements.append(attr_value.to_statement())
                elif isinstance(attr_value, list):
                    for av in attr_value:
                        if isinstance(av, str):
                            stmt.substatements.append(Statement(attr_name, av))
                        elif isinstance(av, SchemaNode):
                            stmt.substatements.append(av.to_statement())
                        else:
                            raise ValueError("Unexpected type in list: {type(av)}")
                elif isinstance(attr_value, bool):
                    stmt.substatements.append(Statement(attr_name, "true" if attr_value else "false"))
                else:
                    stmt.substatements.append(Statement(attr_name, str(attr_value)))

        if isinstance(self, SchemaNodeInner):
            for c in self.children:
                stmt.substatements.append(c.to_statement())

        return stmt

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        raise NotImplementedError("SchemaNode.update_namespace_qualifiers")

    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """
        raise NotImplementedError("SchemaNode.remap_prefix_references")

    def print_tree(self, include_grouping=False) -> str:
        r"""Print the tree representation for this schema node

        For example, the module

        module foo {
          prefix "f";
          namespace "http://example.com/foo";
          container c1 {
            leaf l1 {
              type string;
            }
            container c2 {
              presence "foo";
              leaf l2 {
                type int32;
              }
            }
            list list1 {
              key "k1 k2";
              leaf k1 {
                type string;
              }
              leaf k2 {
                type int32;
              }
            }
          }
        }

        would be printed as:

        module: junos-conf-protocols
            +--rw c1
               +--rw l1 string
               +--rw c2!
               |  +--rw l2 int32
               +--rw list1* [k1 k2]
                  +--rw k1 string
                  +--rw k2 int32
        """

        def get_path(path: list[SchemaNode]) -> str:
            pn = [""]
            for node in path:
                name = node._get_arg()
                if name is not None:
                    pn.append(name)
                else:
                    raise ValueError("No name in {type(node)} in {repr(pn)}")
            return "/".join(pn)

        def print_node(node: SchemaNode, prefix: str, has_siblings: bool=False, in_grouping: bool=False, path: list[SchemaNode]=[]):
            res = []
            res_g: dict[str, list[str]] = {}
            if isinstance(node, Typedef) or \
               isinstance(node, Grouping) and not include_grouping:
                return res, res_g

            # If we're in a grouping, there is no config/operational distinction
            if isinstance(node, Grouping):
                node_prefix = ""
                in_grouping = True
            elif isinstance(node, Uses):
                node_prefix = prefix + "+---u"
            else:
                if in_grouping:
                    node_prefix = prefix + "+--"
                else:
                    node_prefix = prefix + "+--r"
                    if node.is_config():
                        node_prefix += "w"
                    else:
                        node_prefix += "o"
            if isinstance(node, Leaf):
                optional = "?" if node.mandatory == False else ""
                res.append("{node_prefix} {node.name}{optional} {node.type_.name}")
            elif isinstance(node, LeafList):
                res.append("{node_prefix} {node.name}* {node.type_.name}")
            elif isinstance(node, Container):
                presence = node.presence
                res.append("{node_prefix} {node.name}{'!' if presence is not None else ''}")
            elif isinstance(node, List):
                key = node.key
                res.append("{node_prefix} {node.name}* [{key if key is not None else ''}]")
            elif isinstance(node, Module):
                res.append("module: {node.name}")
            elif isinstance(node, Grouping):
                res_g[get_path(path + [node])] = ["grouping: {node.name} ({get_path(path + [node])})"]
            elif isinstance(node, Uses):
                res.append("{node_prefix} {node.name}")
            else:
                res.append("{node_prefix} {node.prsrc()}")
            if isinstance(node, SchemaNodeInner):
                new_has_siblings = len(node.children) > 1
                for i, child in enumerate(node.children):
                    if isinstance(node, Grouping):
                        new_prefix = prefix
                    else:
                        if has_siblings:
                            new_prefix = prefix + "|  "
                        else:
                            new_prefix = prefix + "   "
                    if i == len(node.children) - 1:
                        new_has_siblings = False
                    if node._get_argname() == "name":
                        name = node._get_arg()
                        if name is not None:
                            r, rg = print_node(child, new_prefix, new_has_siblings, in_grouping, path + [node])
                            if isinstance(node, Grouping):
                                res_g[get_path(path + [node])].extend(r)
                            else:
                                res.extend(r)
                            res_g.update(rg.items())
                        else:
                            raise ValueError("No name in {type(node)} in {path}")

            return res, res_g

        res, res_g = print_node(self, "")
        txt = ""
        for gg in res_g.values():
            txt += "\n".join(gg) + "\n"
        txt += "\n".join(res)
        return txt


class SchemaNodeInner(SchemaNode):
    children: list[SchemaNode]

class SchemaNodeOuter(SchemaNode):
    pass

class Ext(SchemaNode):
    """An extension statement

    This is not the definition of an extension, e.g. the "extension" keyword,
    but an instance of an extension, like "foo:bar 'test';"
    """
    prefix: str
    name: str
    arg: ?str

    def __init__(self, prefix: str, name: str, arg: ?str=None, exts=[]):
        self.parent = None
        self.mod = None
        self.ns = None
        self.pfx = None
        self._yname = ""
        self.prefix = prefix
        self.name = name
        self.arg = arg
        self.exts = exts

    def __repr__(self):
        return "Ext(prefix={repr(self.prefix)}, name={repr(self.name)}, arg={repr(self.arg)}, exts={repr(self.exts)})"

    @staticmethod
    def from_fullname(fullname: str, arg: ?str=None, exts=[]) -> Ext:
        parts = fullname.split(":", 1)
        if len(parts) != 2:
            raise ValueError("Invalid extension name {fullname}, extensions must always have a prefix like: foo:bar 'test';")
        return Ext(parts[0], parts[1], None)

    def _get_class_name(self):
        return "Ext"

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("arg", self.arg),
            ("exts", self.exts),
            ]
        prefix = self.prefix
        args = []
        if prefix is not None:
            args = ["'{prefix}', '{self.name}'"]
        else:
            raise ValueError("No prefix in Ext.prsrc, this should never happen")
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(attrs_text)
        args_text = ", ".join(args)
        text_line = "{_ind(indent)}Ext({args_text})"
        res.append(text_line)
        return "\n".join(res)

    def to_statement(self) -> Statement:
        res = Statement(self.name, self.arg, self.prefix)
        for ext in self.exts:
            res.substatements.append(ext.to_statement())
        return res

    def __str__(self):
        self_arg = self.arg
        return "Ext {self.name}{(' ' + self_arg if self_arg is not None else '')}"

extension Ext (Ord):
    def __eq__(self, other: Ext) -> bool:
        self_arg = self.arg
        other_arg = other.arg
        return self.name == other.name and (self_arg is None and other_arg is None or (self_arg is not None and other_arg is not None and self_arg == other_arg))

    def __lt__(self, other: Ext) -> bool:
        return self.name < other.name

def parse_int_range_stmt(range_str: str, base_ranges: Ranges[int]) -> Ranges[int]:
    builder = RangesBuilder()
    for r in parse_range_constraint(range_str):
        ls = r.min_str
        us = r.max_str

        l = None if ls == "min" else int(ls)
        u = None if us == "max" else int(us)

        RangesBuilder.append_range_restriction_of(builder, l, u, base_ranges)
    return RangesBuilder.into_ranges(builder)

def parse_bigint_range_stmt(range_str: str, base_ranges: Ranges[bigint]) -> Ranges[bigint]:
    builder = RangesBuilder()
    for r in parse_range_constraint(range_str):
        ls = r.min_str
        us = r.max_str

        l = None if ls == "min" else bigint(ls)
        u = None if us == "max" else bigint(us)

        RangesBuilder.append_range_restriction_of(builder, l, u, base_ranges)
    return RangesBuilder.into_ranges(builder)

def parse_decimal_range_stmt(range_str: str, base_ranges: Ranges[Decimal]) -> Ranges[Decimal]:
    builder = RangesBuilder()
    for r in parse_range_constraint(range_str):
        ls = r.min_str
        us = r.max_str

        l = None if ls == "min" else Decimal.parse(ls)
        u = None if us == "max" else Decimal.parse(us)

        RangesBuilder.append_range_restriction_of(builder, l, u, base_ranges)
    return RangesBuilder.into_ranges(builder)

def parse_range_constraint(range_str: str) -> list[(min_str: str, max_str: str)]:
    intervals = []
    parts = range_str.split("|")
    for part in parts:
        part = part.strip()
        if ".." in part:
            range_parts = part.split("..")
            if len(range_parts) == 2:
                min_str = range_parts[0].strip()
                max_str = range_parts[1].strip()
                intervals.append((min_str=min_str, max_str=max_str))
        elif part != "":
            # Singleton range token, e.g., "5" => [5,5]
            intervals.append((min_str=part, max_str=part))
    return intervals

def take_opt_bool(stmts: list[Statement], kw: str) -> ?bool:
    v = take_opt_str(stmts, kw)
    if v is not None:
        if v == "true":
            return True
        elif v == "false":
            return False

def take_bool(stmts: list[Statement], kw: str) -> bool:
    v = take_opt_str(stmts, kw)
    if v is not None:
        if v == "true":
            return True
        elif v == "false":
            return False
    raise ValueError("No {kw} in stmts")

def take_opt_int(stmts: list[Statement], kw: str) -> ?int:
    v = take_opt_str(stmts, kw)
    if v is not None:
        return int(v)

def take_int(stmts: list[Statement], kw: str) -> int:
    v = take_opt_str(stmts, kw)
    if v is not None:
        return int(v)
    raise ValueError("No {kw} in stmts")

def take_opt_str(stmts: list[Statement], kw: str) -> ?str:
    for i in range(len(stmts)):
        if stmts[i].kw == kw:
            arg = stmts[i].arg
            if arg is not None:
                del stmts[i]
                return arg

def take_str(stmts: list[Statement], kw: str) -> str:
    for i in range(len(stmts)):
        if stmts[i].kw == kw:
            arg = stmts[i].arg
            if arg is not None:
                del stmts[i]
                return arg
    raise ValueError("No {kw} in stmts")

def take_yang_version(stmts: list[Statement]) -> float:
    v = take_opt_str(stmts, "yang-version")
    if v is not None:
        return float(v)
    return 1.0

def take_strlist(stmts: list[Statement], kw: str) -> list[str]:
    res = []
    todel = []
    for i in range(len(stmts)):
        if stmts[i].kw == kw:
            arg = stmts[i].arg
            if arg is not None:
                todel.append(i)
                res.append(arg)
    for d in reversed(todel):
        del stmts[d]
    return res

def take_node(stmts: list[Statement], kw: str, parent: ?SchemaNode=None) -> ?SchemaNode:
    for i in range(len(stmts)):
        if stmts[i].kw == kw:
            n = stmt_to_snode(stmts[i], parent=parent)
            del stmts[i]
            return n

def take_nodes(stmts: list[Statement], kw: list[str], parent: ?SchemaNode=None) -> list[SchemaNode]:
    res = []
    todel = []
    for i in range(len(stmts)):
        if stmts[i].kw in kw:
            res.append(stmt_to_snode(stmts[i], parent=parent))
            todel.append(i)
    for i in reversed(todel):
        del stmts[i]
    return res

def take_exts(stmts: list[Statement]) -> list[Ext]:
    """Take all extension statements from a list of statements

    Extension statements always follow the form:

    prefix:extension arg;
    """
    res = []
    todel = []
    for i in range(len(stmts)):
        prefix = stmts[i].prefix
        name = stmts[i].kw
        arg = stmts[i].arg
        # TODO: I think prefix should be None, not "", right? prefix should be
        # the prefix of the statement and not the prefix of the module, like the
        # namespace prefix
        if prefix is not None and len(prefix) > 0:
            res.append(Ext(prefix, name, arg, exts=take_exts(stmts[i].substatements)))
            todel.append(i)
    for i in reversed(todel):
        del stmts[i]
    return res

def _attr_name(name: str):
    res = ""
    i = 0
    while True:
        if name[i] == "-":
            res += "_"
        else:
            res += name[i]
        i += 1
        if i == len(name):
            break
    if res in {"extension", "import", "range", "type"}:
        res = res + "_"

    return res

def _prsrc_attrs(indent, attrs):
    """Print source code for a list of SchemaNode attributes"""
    res = []
    for attr in attrs:
        raw_name, value = attr
        name = _attr_name(raw_name)
        if value is not None:
            if isinstance(value, list):
                if len(value) == 0:
                    continue
                else:
                    list_val = []
                    content_is_snode = False
                    for e in value:
                        if isinstance(e, SchemaNode):
                            list_val.append(e.prsrc(indent+2))
                        elif isinstance(e, DNode):
                            list_val.append(e.prsrc(indent+2))
                        else:
                            list_val.append(repr(e))
                    list_val_str = "[]"
                    if len(list_val) == 1 and list_val[0][0] != " " and len(list_val[0]) < 20:
                        list_val_str = "[{list_val[0]}]"
                    else:
                        list_val_str = "[\n{',\n'.join(list_val)}\n{_ind(indent + 1)}]"
                    res.append("{name}={list_val_str}")
            elif isinstance(value, SchemaNode):
                res.append("{name}={value.prsrc(0)}")
            elif isinstance(value, DNode):
                res.append("{name}={value.prsrc(0)}")
            elif isinstance(value, DType):
                res.append("{name}={value.prtyinst()}")
            else:
                res.append("{name}={repr(value)}")
    return ", ".join(res)


def is_optional_yang_leaf(leaf: DNodeLeaf, key_names: ?list[str], loose: bool=False) -> bool:
    """Maps YANG leaf optionality to Acton type
    """
    optional = True

    if isinstance(leaf, DLeaf):
        # Mandatory leaf in YANG model are non-optional in Acton
        mandatory = False
        leafmandatory = leaf.mandatory
        if leafmandatory is not None:
            mandatory = leafmandatory

        has_default = False
        if isinstance(leaf, DLeaf):
            if leaf.default is not None:
                has_default = True

        optional = not (mandatory or has_default)

    elif isinstance(leaf, DLeafList):
        if leaf.min_elements > 0:
            optional = False

    # But with loose validation, even mandatory YANG leaves are optional!
    if loose:
        optional = True
    # ... although being part of a key always makes it non-optional
    if key_names is not None:
        if leaf.name in key_names:
            optional = False
    return optional

def is_optional_arg_yang_leaf(leaf: DNodeLeaf, key_names: ?list[str], loose: bool=False) -> bool:
    r"""Maps YANG leaf optionality to Acton type for object constructor arg

    This is different from the is_optional_yang_leaf because for YANG leafs with
    a default value, we require a difference depending on where the type is used.

    leaf foo {
      type string;
      default "banana";
    }

    the type is str, since even if we do not provide a value, it will get its
    default 'banana', so it is never optional. However, in the constructor
    argument, it is optional. This method is used to determine if the argument
    type should be optional.
    """
    optional = is_optional_yang_leaf(leaf, key_names, loose)

    if isinstance(leaf, DLeaf):
        if leaf.default is not None:
            optional = True

    return optional

def yang_leaf_to_acton_type(leaf: DNodeLeaf, key_names: ?list[str], loose: bool=False) -> str:
    optional = is_optional_yang_leaf(leaf, key_names, loose)
    optional_str = "?" if optional else ""
    t = yang_type_to_acton_type(leaf.type_)
    return optional_str + t

def yang_leaf_to_acton_arg_type(leaf: DNodeLeaf, key_names: ?list[str], loose: bool=False) -> str:
    optional = is_optional_yang_leaf(leaf, key_names, loose)
    if isinstance(leaf, DLeaf):
        if leaf.default is not None:
            optional = True
    optional_str = "?" if optional else ""
    t = yang_type_to_acton_type(leaf.type_)
    return optional_str + t

def taker_name(n: DNode, key_names: ?list[str], loose: bool=False) -> str:
    taker_prefix = "get_"
    if isinstance(n, DContainer):
        optional = loose or n.presence or optional_subtree(n)
        optional_str = "opt_" if optional else ""
        return taker_prefix + optional_str + "cnt"
    if isinstance(n, DList):
        optional = loose or n.min_elements == 0
        optional_str = "opt_" if optional else ""
        return taker_prefix + optional_str + "list"
    if isinstance(n, DLeaf):
        optional = is_optional_arg_yang_leaf(n, key_names, loose)
        optional_str = "opt_" if optional else ""
        if n.type_.builtin_type == "empty":
            return taker_prefix + optional_str + "empty"
        return taker_prefix + optional_str + yang_type_to_acton_type(n.type_)
    if isinstance(n, DLeafList):
        optional = loose or n.min_elements == 0
        optional_str = "opt_" if optional else ""
        return taker_prefix + optional_str + yang_type_to_acton_type(n.type_) + "s"
    raise ValueError("unreachable - unknown node type {type(n)}")

def yang_leaflist_to_acton_type(leaf: DLeafList) -> str:
    t = yang_type_to_acton_type(leaf.type_)
    return "list[{t}]"


def yang_typename_to_acton_type(type_name: str) -> str:
    if type_name == "binary":
        return "bytes"
    elif type_name == "bits":
        raise NotImplementedError('bits not supported')
    elif type_name == "boolean":
        return "bool"
    elif type_name == "decimal64":
        # TODO: do something better
        return "Decimal"
    elif type_name == "empty":
        # TODO: is this right?
        return "bool"
    elif type_name == "enumeration":
        # TODO: use acton unions of fixed strings!?
        return "str"
    elif type_name == "identityref":
        return "Identityref"
    elif type_name == "instance-identifier":
        return "str"
    elif type_name in {"int8", "int16", "int32", "int64", "uint8", "uint16", "uint32", "uint64"}:
        return "bigint"
    elif type_name == "leafref":
        return "str"
    elif type_name == "string":
        return "str"
    elif type_name == "union":
        # You should use yang_type_to_acton_type which can expand the union type for you!
        raise ValueError("Union type not supported")
    raise ValueError("Unknown YANG type: {type_name}")

def yang_type_to_acton_type(t: ?DType) -> str:
    # +---------------------+-------------------------------------+
    # | Name                | Description                         |
    # +---------------------+-------------------------------------+
    # | binary              | Any binary data                     |
    # | bits                | A set of bits or flags              |
    # | boolean             | "true" or "false"                   |
    # | decimal64           | 64-bit signed decimal number        |
    # | empty               | A leaf that does not have any value |
    # | enumeration         | One of an enumerated set of strings |
    # | identityref         | A reference to an abstract identity |
    # | instance-identifier | A reference to a data tree node     |
    # | int8                | 8-bit signed integer                |
    # | int16               | 16-bit signed integer               |
    # | int32               | 32-bit signed integer               |
    # | int64               | 64-bit signed integer               |
    # | leafref             | A reference to a leaf instance      |
    # | string              | A character string                  |
    # | uint8               | 8-bit unsigned integer              |
    # | uint16              | 16-bit unsigned integer             |
    # | uint32              | 32-bit unsigned integer             |
    # | uint64              | 64-bit unsigned integer             |
    # | union               | Choice of member types              |
    # +---------------------+-------------------------------------+
    if t is not None:
        if isinstance(t, DTypeUnion):
            def get_unique_types(tys: list[DType]) -> set[str]:
                """Recursively expand union to the base types"""
                res = set()
                for ty in tys:
                    if isinstance(ty, DTypeUnion):
                        res.update(get_unique_types(ty.types))
                    else:
                        res.add(ty.builtin_type)
                return res

            # Recursively find unique base types, if they all map down to the
            # same base type, we can just use that as the Acton type
            unique_base_types = list(get_unique_types(t.types))
            if len(unique_base_types) == 1:
                return yang_typename_to_acton_type(unique_base_types[0])

            # TODO: should we map in union of say u32 and i32 into i64?
            if all(map(lambda x: x in {"int8", "int16", "int32", "int64"}, unique_base_types)):
                max_size = max(list(map(lambda x: int(x[3:]), unique_base_types)))
                # TODO: once we have integer subtyping, return largest necessary iXX type
                #return "i{max_size}"
                return "bigint"
            elif all(map(lambda x: x in {"uint8", "uint16", "uint32", "uint64"}, unique_base_types)):
                max_size = max(list(map(lambda x: int(x[4:]), unique_base_types)))
                # TODO: once we have integer subtyping, return largest necessary uXX type
                #return "u{max_size}"
                return "bigint"
            elif all(map(lambda x: x in {"int8", "int16", "int32", "int64", "uint8", "uint16", "uint32", "uint64"}, unique_base_types)):
                # We have a union of a mix of signed and unsigned integers, so let's find the largest
                int_sizes = filter(lambda x: x in {"int8", "int16", "int32", "int64"}, unique_base_types)
                max_int_size = max(list(map(lambda x: int(x[3:]), int_sizes)))
                uint_sizes = filter(lambda x: x in {"uint8", "uint16", "uint32", "uint64"}, unique_base_types)
                max_uint_size = max(list(map(lambda x: int(x[4:]), uint_sizes)))
                # To map a uint into an signed int, we need twice the number of
                # bits, i.e. uint8 fits in int16 or uint32 fits in int64, so
                # just double the max size...
                max_int_mapped_uint_size = max_uint_size * 2
                # Total max size is the max between signed int and
                # integer-mapped-uint (which is already 2*uint max)
                max_size = max([max_int_size, max_int_mapped_uint_size])
                if max_size > 64:
                    # Need to use our int (a.k.a. "bigint")
                    return "bigint"
                # TODO: once we have integer subtyping, return largest necessary iXX type
                #return "i{max_size}"
                return "bigint"

            # TODO: use atom when union consists of types that we represent with Acton built-in types
            # TODO: use Acton union
            return "value"
        else:
            return yang_typename_to_acton_type(t.builtin_type)
    raise ValueError("type not defined")

def prsrc_literal(ytype: str, value: str) -> str:
    if ytype == "boolean":
        if value.lower() == "true":
            return "True"
        return "False"
    elif ytype == "enumeration":
        return '"' + value + '"'
    elif ytype == "identityref":
        return value
    elif ytype in {"int8", "int16", "int32", "int64", "uint8", "uint16", "uint32", "uint64"}:
        return "bigint(" + value + ")"
    elif ytype == "binary":
        # Binary values are encoded as base64 strings in YANG and NETCONF, but
        # stored as Acton bytes, so we need to decode it first
        return "base64.decode('{value}'.encode())"
    elif ytype == "string":
        return '"' + value.replace('"', '\\"') + '"'
    elif ytype == "union":
        # Attempt to convert the default to one of Acton built-in types;
        # numeric types can be converted to float, pass verbatim
        # TODO: binary and other types?? The correct thing to do is to instead
        # pass the entire list of resolved types from the union and try to
        # convert to each in the order they are defined in the YANG model?
        a = Decimal.try_parse(value)
        if a is not None:
            return value
        # true, false is boolean,
        if value.lower() == "true":
            return str(True)
        elif value.lower() == "false":
            return str(False)
        # otherwise it is a string
        return '"' + value.replace('"', '\\"') + '"'
    raise ValueError("Unhandled prsrc literal of type {ytype}")

def _safe_name(name: str, safe_kw=True) -> str:
    new = name.replace("-", "_").replace(".", "_")
    if safe_kw and new in {"action",
                           "actor",
                           "as",
                           "class",
                           "del",
                           "except",
                           "for",
                           "from",
                           "import",
                           "in",
                           "mut",
                           "None",
                           "proc",
                           "protocol",
                           "pure",
                           "with",
                           "yield",
                           }:
        new += "_"
    return new


pure def _mut_avoider(node: DNodeInner):
    # Even with "pure" comprehensions, the "mut" effect leaks out of _UniqueNamer.__init__ if this function is inlined?!
    names = [child.name for child in node.children]
    def count(n):
        # TODO: refactor this to use list.count() once implemented in Acton
        c = 0
        for e in names:
            if e == n:
                c += 1
        return c
    return {name for name in names if count(name) > 1}

class _UniqueNamer(object):

    def __init__(self, node: DNodeInner):
        self._name_conflicts = _mut_avoider(node)

    def unique_name(self, name, prefix):
        if name not in self._name_conflicts:
            return name
        return "{prefix}:{name}"

    def unique_safe_name(self, name, prefix, safe_kw=True):
        unique_name = self.unique_name(name, prefix)
        return _safe_name(unique_name, safe_kw).replace(":", "_")

    def is_unique(self, name):
        return name not in self._name_conflicts


def get_path_name(path: list[DNode]) -> str:
    r"""Build the adata path name for a data node

    For example, for the following YANG model:

    module foo {
      prefix foo;
      container bar {
        leaf baz {
          type string;
        }
      }
    }

    the path name for the baz leaf is "foo__bar__baz".

    This function detects conflicting names across sibling nodes. If we add
    another module that augments a conflicting node like this:

    module m2 {
      import foo { prefix foo; }
      augment /foo:bar {
        leaf baz {
          type string;
        }
      }
    }

    Then the path name for the baz leaves in the two modules is:
    - foo__bar__foo_baz
    - foo__bar__m2_baz

    We do not rewrite the builtin keywords here (see _safe_name()) because it is
    not necessary. An exception to this is if we are the top node without
    children - then the path is just our name.
    """
    return "__".join(get_path_usnames(path))


def get_path_usnames(path: list[DNode]) -> list[str]:
    if len(path) == 1:
        return [_safe_name(path[0].name, safe_kw=False)]

    res = []
    for i, node in enumerate(path):
        if i > 0:
            prev = path[i-1]
            if isinstance(prev, DRoot):
                res.append(_safe_name(node.module, safe_kw=False))
            if isinstance(prev, DNodeInner):
                un = _UniqueNamer(prev)
                res.append(un.unique_safe_name(node.name, node.prefix, safe_kw=False))
        elif isinstance(node, DRoot):
            continue
        else:
            # Relative path
            res.append(_safe_name(node.name, safe_kw=False))
    return res


def get_path(path: list[DNode]) -> str:
    r"""Get the path of a data node

    The path is the absolute path in the YANG model, e.g. for the following
    YANG model:

    module foo {
      prefix foo;
      container bar {
        leaf baz {
          type string;
        }
      }
    }

    the path for the baz leaf is "/foo:bar/baz".

    This function detects conflicting names across sibling nodes. If we add
    another module that augments a conflicting node like this:

    module m2 {
      import foo { prefix foo; }
      augment /foo:bar {
        leaf baz {
          type string;
        }
      }
    }

    Then the path for the baz leaves in the two modules is:
    - /foo:bar/foo:baz
    - /foo:bar/m2:baz
    """
    return "/".join(get_path_unames(path))


def get_path_unames(path: list[DNode]) -> list[str]:
    if len(path) == 1 and isinstance(path[0], DRoot):
        return ["/"]

    res = []
    for i, node in enumerate(path):
        if i > 0:
            prev = path[i-1]
            if isinstance(prev, DNodeInner):
                un = _UniqueNamer(prev)
                res.append(un.unique_name(node.name, node.prefix))
        elif isinstance(node, DRoot):
            res.append("")
        else:
            # Relative path
            res.append(node.name)
    return res

# -- end of manually defined schema functions, automatically generated code follows

extension SchemaNode (Eq):
    def __eq__(self, other: SchemaNode) -> bool:
        if type(self) != type(other):
            return False
        elif isinstance(self, Action) and isinstance(other, Action):
            return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.input == other.input and self.output == other.output and self.reference == other.reference and self.status == other.status
        elif isinstance(self, Anydata) and isinstance(other, Anydata):
            return self.name == other.name and self.config == other.config and self.description == other.description and self.if_feature == other.if_feature and self.mandatory == other.mandatory and self.must == other.must and self.reference == other.reference and self.status == other.status and self.when == other.when
        elif isinstance(self, Anyxml) and isinstance(other, Anyxml):
            return self.name == other.name and self.config == other.config and self.description == other.description and self.if_feature == other.if_feature and self.mandatory == other.mandatory and self.must == other.must and self.reference == other.reference and self.status == other.status and self.when == other.when
        elif isinstance(self, Augment) and isinstance(other, Augment):
            return self.target_node == other.target_node and self.description == other.description and self.if_feature == other.if_feature and self.reference == other.reference and self.status == other.status and self.when == other.when
        elif isinstance(self, BelongsTo) and isinstance(other, BelongsTo):
            return self.module == other.module and self.prefix == other.prefix
        elif isinstance(self, Bit) and isinstance(other, Bit):
            return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.position == other.position and self.reference == other.reference and self.status == other.status
        elif isinstance(self, Case) and isinstance(other, Case):
            return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.reference == other.reference and self.status == other.status and self.when == other.when
        elif isinstance(self, Choice) and isinstance(other, Choice):
            return self.name == other.name and self.config == other.config and self.default == other.default and self.description == other.description and self.if_feature == other.if_feature and self.mandatory == other.mandatory and self.reference == other.reference and self.status == other.status and self.when == other.when
        elif isinstance(self, Container) and isinstance(other, Container):
            return self.name == other.name and self.config == other.config and self.description == other.description and self.if_feature == other.if_feature and self.must == other.must and self.presence == other.presence and self.reference == other.reference and self.status == other.status and self.when == other.when
        elif isinstance(self, Enum) and isinstance(other, Enum):
            return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.reference == other.reference and self.status == other.status and self.value == other.value
        elif isinstance(self, Extension) and isinstance(other, Extension):
            return self.name == other.name and self.argument == other.argument and self.description == other.description and self.reference == other.reference and self.status == other.status
        elif isinstance(self, Feature) and isinstance(other, Feature):
            return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.reference == other.reference and self.status == other.status
        elif isinstance(self, Grouping) and isinstance(other, Grouping):
            return self.name == other.name and self.description == other.description and self.reference == other.reference and self.status == other.status
        elif isinstance(self, Identity) and isinstance(other, Identity):
            return self.name == other.name and self.base == other.base and self.description == other.description and self.if_feature == other.if_feature and self.reference == other.reference and self.status == other.status
        elif isinstance(self, Import) and isinstance(other, Import):
            return self.module == other.module and self.description == other.description and self.prefix == other.prefix and self.reference == other.reference and self.revision_date == other.revision_date
        elif isinstance(self, Include) and isinstance(other, Include):
            return self.module == other.module and self.description == other.description and self.reference == other.reference and self.revision_date == other.revision_date
        elif isinstance(self, Input) and isinstance(other, Input):
            return self.must == other.must
        elif isinstance(self, Leaf) and isinstance(other, Leaf):
            return self.name == other.name and self.config == other.config and self.default == other.default and self.description == other.description and self.if_feature == other.if_feature and self.mandatory == other.mandatory and self.must == other.must and self.reference == other.reference and self.status == other.status and self.type_ == other.type_ and self.units == other.units and self.when == other.when
        elif isinstance(self, LeafList) and isinstance(other, LeafList):
            return self.name == other.name and self.config == other.config and self.default == other.default and self.description == other.description and self.if_feature == other.if_feature and self.max_elements == other.max_elements and self.min_elements == other.min_elements and self.must == other.must and self.ordered_by == other.ordered_by and self.reference == other.reference and self.status == other.status and self.type_ == other.type_ and self.units == other.units and self.when == other.when
        elif isinstance(self, Length) and isinstance(other, Length):
            return self.value == other.value and self.description == other.description and self.error_app_tag == other.error_app_tag and self.error_message == other.error_message and self.reference == other.reference
        elif isinstance(self, List) and isinstance(other, List):
            return self.name == other.name and self.config == other.config and self.description == other.description and self.if_feature == other.if_feature and self.key == other.key and self.max_elements == other.max_elements and self.min_elements == other.min_elements and self.must == other.must and self.ordered_by == other.ordered_by and self.reference == other.reference and self.status == other.status and self.unique == other.unique and self.when == other.when
        elif isinstance(self, Module) and isinstance(other, Module):
            return self.name == other.name and self.augment == other.augment and self.contact == other.contact and self.description == other.description and self.deviation == other.deviation and self.extension_ == other.extension_ and self.feature == other.feature and self.import_ == other.import_ and self.include == other.include and self.namespace == other.namespace and self.organization == other.organization and self.prefix == other.prefix and self.reference == other.reference and self.revision == other.revision and self.yang_version == other.yang_version
        elif isinstance(self, Must) and isinstance(other, Must):
            return self.condition == other.condition and self.description == other.description and self.error_app_tag == other.error_app_tag and self.error_message == other.error_message and self.reference == other.reference
        elif isinstance(self, Notification) and isinstance(other, Notification):
            return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.must == other.must and self.reference == other.reference and self.status == other.status
        elif isinstance(self, Output) and isinstance(other, Output):
            return self.must == other.must
        elif isinstance(self, Pattern) and isinstance(other, Pattern):
            return self.value == other.value and self.description == other.description and self.error_app_tag == other.error_app_tag and self.error_message == other.error_message and self.modifier == other.modifier and self.reference == other.reference
        elif isinstance(self, Range) and isinstance(other, Range):
            return self.value == other.value and self.description == other.description and self.error_app_tag == other.error_app_tag and self.error_message == other.error_message and self.reference == other.reference
        elif isinstance(self, Refine) and isinstance(other, Refine):
            return self.target_node == other.target_node and self.config == other.config and self.default == other.default and self.description == other.description and self.if_feature == other.if_feature and self.mandatory == other.mandatory and self.max_elements == other.max_elements and self.min_elements == other.min_elements and self.must == other.must and self.presence == other.presence and self.reference == other.reference
        elif isinstance(self, Revision) and isinstance(other, Revision):
            return self.date == other.date and self.description == other.description and self.reference == other.reference
        elif isinstance(self, Rpc) and isinstance(other, Rpc):
            return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.input == other.input and self.output == other.output and self.reference == other.reference and self.status == other.status
        elif isinstance(self, Submodule) and isinstance(other, Submodule):
            return self.name == other.name and self.augment == other.augment and self.belongs_to == other.belongs_to and self.contact == other.contact and self.description == other.description and self.deviation == other.deviation and self.extension_ == other.extension_ and self.feature == other.feature and self.import_ == other.import_ and self.include == other.include and self.organization == other.organization and self.reference == other.reference and self.revision == other.revision and self.yang_version == other.yang_version
        elif isinstance(self, Type) and isinstance(other, Type):
            return self.name == other.name and self.base == other.base and self.bit == other.bit and self.enum == other.enum and self.fraction_digits == other.fraction_digits and self.length == other.length and self.path == other.path and self.pattern == other.pattern and self.range_ == other.range_ and self.require_instance == other.require_instance and self.type_ == other.type_
        elif isinstance(self, Typedef) and isinstance(other, Typedef):
            return self.name == other.name and self.default == other.default and self.description == other.description and self.reference == other.reference and self.status == other.status and self.type_ == other.type_ and self.units == other.units
        elif isinstance(self, Uses) and isinstance(other, Uses):
            return self.name == other.name and self.augment == other.augment and self.description == other.description and self.if_feature == other.if_feature and self.reference == other.reference and self.refine == other.refine and self.status == other.status and self.when == other.when
        return False

def snode_name(sn: SchemaNode) -> str:
    if isinstance(sn, Action):
        return sn.name
    if isinstance(sn, Anydata):
        return sn.name
    if isinstance(sn, Anyxml):
        return sn.name
    if isinstance(sn, Augment):
        return sn.target_node
    if isinstance(sn, BelongsTo):
        return sn.module
    if isinstance(sn, Bit):
        return sn.name
    if isinstance(sn, Case):
        return sn.name
    if isinstance(sn, Choice):
        return sn.name
    if isinstance(sn, Container):
        return sn.name
    if isinstance(sn, Enum):
        return sn.name
    if isinstance(sn, Extension):
        return sn.name
    if isinstance(sn, Feature):
        return sn.name
    if isinstance(sn, Grouping):
        return sn.name
    if isinstance(sn, Identity):
        return sn.name
    if isinstance(sn, Import):
        return sn.module
    if isinstance(sn, Include):
        return sn.module
    if isinstance(sn, Leaf):
        return sn.name
    if isinstance(sn, LeafList):
        return sn.name
    if isinstance(sn, Length):
        return sn.value
    if isinstance(sn, List):
        return sn.name
    if isinstance(sn, Module):
        return sn.name
    if isinstance(sn, Must):
        return sn.condition
    if isinstance(sn, Notification):
        return sn.name
    if isinstance(sn, Pattern):
        return sn.value
    if isinstance(sn, Range):
        return sn.value
    if isinstance(sn, Refine):
        return sn.target_node
    if isinstance(sn, Revision):
        return sn.date
    if isinstance(sn, Rpc):
        return sn.name
    if isinstance(sn, Submodule):
        return sn.name
    if isinstance(sn, Type):
        return sn.name
    if isinstance(sn, Typedef):
        return sn.name
    if isinstance(sn, Uses):
        return sn.name
    raise ValueError("Unknown SchemaNode type in snode_name")

def snode_type_name(sn: SchemaNode) -> str:
    if isinstance(sn, Action):
        return "Action"
    if isinstance(sn, Anydata):
        return "Anydata"
    if isinstance(sn, Anyxml):
        return "Anyxml"
    if isinstance(sn, Augment):
        return "Augment"
    if isinstance(sn, BelongsTo):
        return "BelongsTo"
    if isinstance(sn, Bit):
        return "Bit"
    if isinstance(sn, Case):
        return "Case"
    if isinstance(sn, Choice):
        return "Choice"
    if isinstance(sn, Container):
        return "Container"
    if isinstance(sn, Enum):
        return "Enum"
    if isinstance(sn, Extension):
        return "Extension"
    if isinstance(sn, Feature):
        return "Feature"
    if isinstance(sn, Grouping):
        return "Grouping"
    if isinstance(sn, Identity):
        return "Identity"
    if isinstance(sn, Import):
        return "Import"
    if isinstance(sn, Include):
        return "Include"
    if isinstance(sn, Leaf):
        return "Leaf"
    if isinstance(sn, LeafList):
        return "LeafList"
    if isinstance(sn, Length):
        return "Length"
    if isinstance(sn, List):
        return "List"
    if isinstance(sn, Module):
        return "Module"
    if isinstance(sn, Must):
        return "Must"
    if isinstance(sn, Notification):
        return "Notification"
    if isinstance(sn, Pattern):
        return "Pattern"
    if isinstance(sn, Range):
        return "Range"
    if isinstance(sn, Refine):
        return "Refine"
    if isinstance(sn, Revision):
        return "Revision"
    if isinstance(sn, Rpc):
        return "Rpc"
    if isinstance(sn, Submodule):
        return "Submodule"
    if isinstance(sn, Type):
        return "Type"
    if isinstance(sn, Typedef):
        return "Typedef"
    if isinstance(sn, Uses):
        return "Uses"
    raise ValueError("Unknown SchemaNode type in snode_type_name")

class Action(SchemaNodeInner):
    """YANG action

    https://tools.ietf.org/html/rfc7950#section-7.15.1
    """
    name: str
    description: ?str
    if_feature: list[str]
    input: ?Input
    output: ?Output
    reference: ?str
    status: ?str

    def __init__(self, name: str, description: ?str=None, if_feature: list[str]=[], input: ?Input=None, output: ?Output=None, reference: ?str=None, status: ?str=None, exts=[], children=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "action"
        self.name = name
        self.description = description
        self.if_feature = if_feature
        self.input = input
        self.output = output
        self.reference = reference
        self.status = status
        self.exts = exts
        self.children = children
        self_input = self.input
        if self_input is not None:
            self_input.parent = self
            n_mod = self_input.mod
            if n_mod is None:
                self_input.mod = self.mod
            n_ns = self_input.ns
            if n_ns is None:
                self_input.ns = self.ns
            n_pfx = self_input.pfx
            if n_pfx is None:
                self_input.pfx = self.pfx
        self_output = self.output
        if self_output is not None:
            self_output.parent = self
            n_mod = self_output.mod
            if n_mod is None:
                self_output.mod = self.mod
            n_ns = self_output.ns
            if n_ns is None:
                self_output.ns = self.ns
            n_pfx = self_output.pfx
            if n_pfx is None:
                self_output.pfx = self.pfx
        for n in self.children:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("input", self.input),
            ("output", self.output),
            ("reference", self.reference),
            ("status", self.status),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        for ref_if_feature in refine.if_feature:
            if ref_if_feature not in self.if_feature:
                self.if_feature.append(ref_if_feature)
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def get(self, name: str, ns: ?str=None) -> SchemaNode:
        # TODO: support looking up qualified by namespace
        #tns = ns if ns is not None else self.get_namespace()
        if name == 'input':
            _input = self.input
            if _input is not None:
                return _input
        if name == 'output':
            _output = self.output
            if _output is not None:
                return _output
        return SchemaNode.get(self, name, ns)

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        self_input = self.input
        self_output = self.output
        # new_input = self_input.compile(context) if self_input is not None else None # actonc codegen pre-evaluates before None-check
        new_input = None
        if self_input is not None:
            new_input = self_input.compile(context, new_ns)
        # new_output = self_output.compile(context) if self_output is not None else None # actonc codegen pre-evaluates before None-check
        new_output = None
        if self_output is not None:
            new_output = self_output.compile(context, new_ns)
        new = Action(self.name,
                     description=self.description,
                     if_feature=self.if_feature,
                     input=new_input if new_input is not None and isinstance(new_input, Input) else Input(),
                     output=new_output if new_output is not None and isinstance(new_output, Output) else Output(),
                     reference=self.reference,
                     status=self.status,
                     exts=self.exts,
                     mod=new_mod if new_mod is not None else self.mod,
                     ns=new_ns if new_ns is not None else self.ns,
                     pfx=new_pfx if new_pfx is not None else self.pfx)
        self.expand_children(context, new, new_ns, new_pfx)
        return new

    def to_dnode(self) -> DAction:
        dnode_children = []
        self_input = self.input
        if self_input is not None:
            input_dnode = self_input.to_dnode()
            dnode_children.append(input_dnode)
        self_output = self.output
        if self_output is not None:
            output_dnode = self_output.to_dnode()
            dnode_children.append(output_dnode)

        new_dnode = DAction(
            module=self.get_module_name(),
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            description=self.description,
            if_feature=self.if_feature,
            reference=self.reference,
            status=self.status,
            exts=self.exts,
            children=dnode_children
        )
        return new_dnode

    def is_config(self) -> bool:
        return False

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod

        # Recursively update children
        for child in self.children:
            child.update_namespace_qualifiers(new_ns, new_pfx, new_mod)


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        for child in self.children:
            child.remap_prefix_references(old_pfx, new_pfx)

        self.if_feature = [_remap_path_prefix(f, old_pfx, new_pfx) for f in self.if_feature]

    def __str__(self):
        return "Action {self.name}"

    def _get_class_name(self) -> str:
        return "Action"

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Action (Ord):
    def __eq__(self, other: Action):
        return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.input == other.input and self.output == other.output and self.reference == other.reference and self.status == other.status

    def __lt__(a, b):
        return a.name < b.name

class Anydata(SchemaNodeOuter):
    """YANG anydata

    https://tools.ietf.org/html/rfc7950#section-7.10.1
    """
    name: str
    config: ?bool
    description: ?str
    if_feature: list[str]
    mandatory: ?bool
    must: list[Must]
    reference: ?str
    status: ?str
    when: ?str

    def __init__(self, name: str, config: ?bool=None, description: ?str=None, if_feature: list[str]=[], mandatory: ?bool=None, must: list[Must]=[], reference: ?str=None, status: ?str=None, when: ?str=None, exts=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "anydata"
        self.name = name
        self.config = config
        self.description = description
        self.if_feature = if_feature
        self.mandatory = mandatory
        self.must = must
        self.reference = reference
        self.status = status
        self.when = when
        self.exts = exts
        for n in self.must:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("config", self.config),
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("mandatory", self.mandatory),
            ("must", self.must),
            ("reference", self.reference),
            ("status", self.status),
            ("when", self.when),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_config = refine.config
        if ref_config is not None:
            self.config = ref_config
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        for ref_if_feature in refine.if_feature:
            if ref_if_feature not in self.if_feature:
                self.if_feature.append(ref_if_feature)
        ref_mandatory = refine.mandatory
        if ref_mandatory is not None:
            self.mandatory = ref_mandatory
        for ref_must in refine.must:
            if ref_must not in self.must:
                self.must.append(ref_must)
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def to_dnode(self) -> DAnydata:
        return DAnydata(
            module=self.get_module_name(),
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            config=self.is_config(),
            description=self.description,
            if_feature=self.if_feature,
            mandatory=self.mandatory,
            must=self.must,
            reference=self.reference,
            status=self.status,
            when=self.when,
            exts=self.exts
        )

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Anydata(self.name,
                      config=self.config,
                      description=self.description,
                      if_feature=self.if_feature,
                      mandatory=self.mandatory,
                      must=self.must,
                      reference=self.reference,
                      status=self.status,
                      when=self.when,
                      exts=self.exts,
                      mod=new_mod if new_mod is not None else self.mod,
                      ns=new_ns if new_ns is not None else self.ns,
                      pfx=new_pfx if new_pfx is not None else self.pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        self.if_feature = [_remap_path_prefix(f, old_pfx, new_pfx) for f in self.if_feature]
        for must in self.must:
            must.condition = _remap_path_prefix(must.condition, old_pfx, new_pfx)
        self_when = self.when
        if self_when is not None:
            self.when = _remap_path_prefix(self_when, old_pfx, new_pfx)

    def __str__(self):
        return "Anydata {self.name}"

    def _get_class_name(self) -> str:
        return "Anydata"

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Anydata (Ord):
    def __eq__(self, other: Anydata):
        return self.name == other.name and self.config == other.config and self.description == other.description and self.if_feature == other.if_feature and self.mandatory == other.mandatory and self.must == other.must and self.reference == other.reference and self.status == other.status and self.when == other.when

    def __lt__(a, b):
        return a.name < b.name

class Anyxml(SchemaNodeOuter):
    """YANG anyxml

    https://tools.ietf.org/html/rfc7950#section-7.11.1
    """
    name: str
    config: ?bool
    description: ?str
    if_feature: list[str]
    mandatory: ?bool
    must: list[Must]
    reference: ?str
    status: ?str
    when: ?str

    def __init__(self, name: str, config: ?bool=None, description: ?str=None, if_feature: list[str]=[], mandatory: ?bool=None, must: list[Must]=[], reference: ?str=None, status: ?str=None, when: ?str=None, exts=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "anyxml"
        self.name = name
        self.config = config
        self.description = description
        self.if_feature = if_feature
        self.mandatory = mandatory
        self.must = must
        self.reference = reference
        self.status = status
        self.when = when
        self.exts = exts
        for n in self.must:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("config", self.config),
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("mandatory", self.mandatory),
            ("must", self.must),
            ("reference", self.reference),
            ("status", self.status),
            ("when", self.when),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_config = refine.config
        if ref_config is not None:
            self.config = ref_config
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        for ref_if_feature in refine.if_feature:
            if ref_if_feature not in self.if_feature:
                self.if_feature.append(ref_if_feature)
        ref_mandatory = refine.mandatory
        if ref_mandatory is not None:
            self.mandatory = ref_mandatory
        for ref_must in refine.must:
            if ref_must not in self.must:
                self.must.append(ref_must)
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def to_dnode(self) -> DAnyxml:
        return DAnyxml(
            module=self.get_module_name(),
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            config=self.is_config(),
            description=self.description,
            if_feature=self.if_feature,
            mandatory=self.mandatory,
            must=self.must,
            reference=self.reference,
            status=self.status,
            when=self.when,
            exts=self.exts
        )

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Anyxml(self.name,
                     config=self.config,
                     description=self.description,
                     if_feature=self.if_feature,
                     mandatory=self.mandatory,
                     must=self.must,
                     reference=self.reference,
                     status=self.status,
                     when=self.when,
                     exts=self.exts,
                     mod=new_mod if new_mod is not None else self.mod,
                     ns=new_ns if new_ns is not None else self.ns,
                     pfx=new_pfx if new_pfx is not None else self.pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        self.if_feature = [_remap_path_prefix(f, old_pfx, new_pfx) for f in self.if_feature]
        for must in self.must:
            must.condition = _remap_path_prefix(must.condition, old_pfx, new_pfx)
        self_when = self.when
        if self_when is not None:
            self.when = _remap_path_prefix(self_when, old_pfx, new_pfx)

    def __str__(self):
        return "Anyxml {self.name}"

    def _get_class_name(self) -> str:
        return "Anyxml"

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Anyxml (Ord):
    def __eq__(self, other: Anyxml):
        return self.name == other.name and self.config == other.config and self.description == other.description and self.if_feature == other.if_feature and self.mandatory == other.mandatory and self.must == other.must and self.reference == other.reference and self.status == other.status and self.when == other.when

    def __lt__(a, b):
        return a.name < b.name

class Augment(SchemaNodeInner):
    """YANG augment

    https://tools.ietf.org/html/rfc7950#section-7.17.1
    """
    target_node: str
    description: ?str
    if_feature: list[str]
    reference: ?str
    status: ?str
    when: ?str

    def __init__(self, target_node: str, description: ?str=None, if_feature: list[str]=[], reference: ?str=None, status: ?str=None, when: ?str=None, exts=[], children=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "augment"
        self.target_node = target_node
        self.description = description
        self.if_feature = if_feature
        self.reference = reference
        self.status = status
        self.when = when
        self.exts = exts
        self.children = children
        for n in self.children:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("reference", self.reference),
            ("status", self.status),
            ("when", self.when),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        for ref_if_feature in refine.if_feature:
            if ref_if_feature not in self.if_feature:
                self.if_feature.append(ref_if_feature)
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Augment(self.target_node,
                      description=self.description,
                      if_feature=self.if_feature,
                      reference=self.reference,
                      status=self.status,
                      when=self.when,
                      exts=self.exts,
                      mod=new_mod if new_mod is not None else self.mod,
                      ns=new_ns if new_ns is not None else self.ns,
                      pfx=new_pfx if new_pfx is not None else self.pfx)
        self.expand_children(context, new, new_mod, new_ns, new_pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod

        # Recursively update children
        for child in self.children:
            child.update_namespace_qualifiers(new_ns, new_pfx, new_mod)


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        for child in self.children:
            child.remap_prefix_references(old_pfx, new_pfx)

        self.if_feature = [_remap_path_prefix(f, old_pfx, new_pfx) for f in self.if_feature]
        self_when = self.when
        if self_when is not None:
            self.when = _remap_path_prefix(self_when, old_pfx, new_pfx)
        self.target_node = _remap_path_prefix(self.target_node, old_pfx, new_pfx)

    def __str__(self):
        return "Augment {self.target_node}"

    def _get_class_name(self) -> str:
        return "Augment"

    def _get_argname(self) -> ?str:
        return 'target_node'

    def _get_arg(self) -> ?str:
        return self.target_node

extension Augment (Ord):
    def __eq__(self, other: Augment):
        return self.target_node == other.target_node and self.description == other.description and self.if_feature == other.if_feature and self.reference == other.reference and self.status == other.status and self.when == other.when

    def __lt__(a, b):
        return a.target_node < b.target_node

class BelongsTo(SchemaNodeOuter):
    """YANG belongs-to

    https://tools.ietf.org/html/rfc7950#section-7.2.2
    """
    module: str
    prefix: str

    def __init__(self, module: str, prefix: str, exts=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "belongs-to"
        self.module = module
        self.prefix = prefix
        self.exts = exts

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("prefix", self.prefix),
            ("exts", self.exts),
        ]

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = BelongsTo(self.module,
                        prefix=self.prefix,
                        exts=self.exts,
                        mod=new_mod if new_mod is not None else self.mod,
                        ns=new_ns if new_ns is not None else self.ns,
                        pfx=new_pfx if new_pfx is not None else self.pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """


    def __str__(self):
        return "BelongsTo {self.module}"

    def _get_class_name(self) -> str:
        return "BelongsTo"

    def _get_argname(self) -> ?str:
        return 'module'

    def _get_arg(self) -> ?str:
        return self.module

extension BelongsTo (Ord):
    def __eq__(self, other: BelongsTo):
        return self.module == other.module and self.prefix == other.prefix

    def __lt__(a, b):
        return a.module < b.module

class Bit(SchemaNodeOuter):
    """YANG bit

    https://tools.ietf.org/html/rfc7950#section-9.7.4.1
    """
    name: str
    description: ?str
    if_feature: list[str]
    position: ?int
    reference: ?str
    status: ?str

    def __init__(self, name: str, description: ?str=None, if_feature: list[str]=[], position: ?int=None, reference: ?str=None, status: ?str=None, exts=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "bit"
        self.name = name
        self.description = description
        self.if_feature = if_feature
        self.position = position
        self.reference = reference
        self.status = status
        self.exts = exts

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("position", self.position),
            ("reference", self.reference),
            ("status", self.status),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        for ref_if_feature in refine.if_feature:
            if ref_if_feature not in self.if_feature:
                self.if_feature.append(ref_if_feature)
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Bit(self.name,
                  description=self.description,
                  if_feature=self.if_feature,
                  position=self.position,
                  reference=self.reference,
                  status=self.status,
                  exts=self.exts,
                  mod=new_mod if new_mod is not None else self.mod,
                  ns=new_ns if new_ns is not None else self.ns,
                  pfx=new_pfx if new_pfx is not None else self.pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        self.if_feature = [_remap_path_prefix(f, old_pfx, new_pfx) for f in self.if_feature]

    def __str__(self):
        return "Bit {self.name}"

    def _get_class_name(self) -> str:
        return "Bit"

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Bit (Ord):
    def __eq__(self, other: Bit):
        return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.position == other.position and self.reference == other.reference and self.status == other.status

    def __lt__(a, b):
        return a.name < b.name

class Case(SchemaNodeInner):
    """YANG case

    https://tools.ietf.org/html/rfc7950#section-7.9.2.1
    """
    name: str
    description: ?str
    if_feature: list[str]
    reference: ?str
    status: ?str
    when: ?str

    def __init__(self, name: str, description: ?str=None, if_feature: list[str]=[], reference: ?str=None, status: ?str=None, when: ?str=None, exts=[], children=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "case"
        self.name = name
        self.description = description
        self.if_feature = if_feature
        self.reference = reference
        self.status = status
        self.when = when
        self.exts = exts
        self.children = children
        for n in self.children:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("reference", self.reference),
            ("status", self.status),
            ("when", self.when),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        for ref_if_feature in refine.if_feature:
            if ref_if_feature not in self.if_feature:
                self.if_feature.append(ref_if_feature)
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Case(self.name,
                   description=self.description,
                   if_feature=self.if_feature,
                   reference=self.reference,
                   status=self.status,
                   when=self.when,
                   exts=self.exts,
                   mod=new_mod if new_mod is not None else self.mod,
                   ns=new_ns if new_ns is not None else self.ns,
                   pfx=new_pfx if new_pfx is not None else self.pfx)
        self.expand_children(context, new, new_mod, new_ns, new_pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod

        # Recursively update children
        for child in self.children:
            child.update_namespace_qualifiers(new_ns, new_pfx, new_mod)


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        for child in self.children:
            child.remap_prefix_references(old_pfx, new_pfx)

        self.if_feature = [_remap_path_prefix(f, old_pfx, new_pfx) for f in self.if_feature]
        self_when = self.when
        if self_when is not None:
            self.when = _remap_path_prefix(self_when, old_pfx, new_pfx)

    def __str__(self):
        return "Case {self.name}"

    def _get_class_name(self) -> str:
        return "Case"

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Case (Ord):
    def __eq__(self, other: Case):
        return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.reference == other.reference and self.status == other.status and self.when == other.when

    def __lt__(a, b):
        return a.name < b.name

class Choice(SchemaNodeInner):
    """YANG choice

    https://tools.ietf.org/html/rfc7950#section-7.9.1
    """
    name: str
    config: ?bool
    default: ?str
    description: ?str
    if_feature: list[str]
    mandatory: ?bool
    reference: ?str
    status: ?str
    when: ?str

    def __init__(self, name: str, config: ?bool=None, default: ?str=None, description: ?str=None, if_feature: list[str]=[], mandatory: ?bool=None, reference: ?str=None, status: ?str=None, when: ?str=None, exts=[], children=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "choice"
        self.name = name
        self.config = config
        self.default = default
        self.description = description
        self.if_feature = if_feature
        self.mandatory = mandatory
        self.reference = reference
        self.status = status
        self.when = when
        self.exts = exts
        self.children = children
        for n in self.children:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("config", self.config),
            ("default", self.default),
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("mandatory", self.mandatory),
            ("reference", self.reference),
            ("status", self.status),
            ("when", self.when),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_config = refine.config
        if ref_config is not None:
            self.config = ref_config
        if len(refine.default) == 1:
            self.default = refine.default[0]
        elif len(refine.default) > 1:
            raise ValueError("Attempting to refine default with multiple values")
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        for ref_if_feature in refine.if_feature:
            if ref_if_feature not in self.if_feature:
                self.if_feature.append(ref_if_feature)
        ref_mandatory = refine.mandatory
        if ref_mandatory is not None:
            self.mandatory = ref_mandatory
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Choice(self.name,
                     config=self.config,
                     default=self.default,
                     description=self.description,
                     if_feature=self.if_feature,
                     mandatory=self.mandatory,
                     reference=self.reference,
                     status=self.status,
                     when=self.when,
                     exts=self.exts,
                     mod=new_mod if new_mod is not None else self.mod,
                     ns=new_ns if new_ns is not None else self.ns,
                     pfx=new_pfx if new_pfx is not None else self.pfx)
        self.expand_children(context, new, new_mod, new_ns, new_pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod

        # Recursively update children
        for child in self.children:
            child.update_namespace_qualifiers(new_ns, new_pfx, new_mod)


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        for child in self.children:
            child.remap_prefix_references(old_pfx, new_pfx)

        self.if_feature = [_remap_path_prefix(f, old_pfx, new_pfx) for f in self.if_feature]
        self_when = self.when
        if self_when is not None:
            self.when = _remap_path_prefix(self_when, old_pfx, new_pfx)

    def __str__(self):
        return "Choice {self.name}"

    def _get_class_name(self) -> str:
        return "Choice"

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Choice (Ord):
    def __eq__(self, other: Choice):
        return self.name == other.name and self.config == other.config and self.default == other.default and self.description == other.description and self.if_feature == other.if_feature and self.mandatory == other.mandatory and self.reference == other.reference and self.status == other.status and self.when == other.when

    def __lt__(a, b):
        return a.name < b.name

class Container(SchemaNodeInner):
    """YANG container

    https://tools.ietf.org/html/rfc7950#section-7.5.2
    """
    name: str
    config: ?bool
    description: ?str
    if_feature: list[str]
    must: list[Must]
    presence: ?str
    reference: ?str
    status: ?str
    when: ?str

    def __init__(self, name: str, config: ?bool=None, description: ?str=None, if_feature: list[str]=[], must: list[Must]=[], presence: ?str=None, reference: ?str=None, status: ?str=None, when: ?str=None, exts=[], children=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "container"
        self.name = name
        self.config = config
        self.description = description
        self.if_feature = if_feature
        self.must = must
        self.presence = presence
        self.reference = reference
        self.status = status
        self.when = when
        self.exts = exts
        self.children = children
        for n in self.must:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx
        for n in self.children:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("config", self.config),
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("must", self.must),
            ("presence", self.presence),
            ("reference", self.reference),
            ("status", self.status),
            ("when", self.when),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_config = refine.config
        if ref_config is not None:
            self.config = ref_config
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        for ref_if_feature in refine.if_feature:
            if ref_if_feature not in self.if_feature:
                self.if_feature.append(ref_if_feature)
        for ref_must in refine.must:
            if ref_must not in self.must:
                self.must.append(ref_must)
        ref_presence = refine.presence
        if ref_presence is not None:
            self.presence = ref_presence
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def is_presence(self) -> bool:
        selfpresence = self.presence
        if selfpresence is not None:
            return True
        return False

    def to_dnode(self) -> DContainer:
        new_dnode = DContainer(
            module=self.get_module_name(),
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            config=self.is_config(),
            description=self.description,
            if_feature=self.if_feature,
            must=self.must,
            presence=self.is_presence(),
            reference=self.reference,
            status=self.status,
            when=self.when,
            exts=self.exts,
            children=self.get_dnode_children()
        )
        return new_dnode

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Container(self.name,
                        config=self.config,
                        description=self.description,
                        if_feature=self.if_feature,
                        must=self.must,
                        presence=self.presence,
                        reference=self.reference,
                        status=self.status,
                        when=self.when,
                        exts=self.exts,
                        mod=new_mod if new_mod is not None else self.mod,
                        ns=new_ns if new_ns is not None else self.ns,
                        pfx=new_pfx if new_pfx is not None else self.pfx)
        self.expand_children(context, new, new_mod, new_ns, new_pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod

        # Recursively update children
        for child in self.children:
            child.update_namespace_qualifiers(new_ns, new_pfx, new_mod)


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        for child in self.children:
            child.remap_prefix_references(old_pfx, new_pfx)

        self.if_feature = [_remap_path_prefix(f, old_pfx, new_pfx) for f in self.if_feature]
        for must in self.must:
            must.condition = _remap_path_prefix(must.condition, old_pfx, new_pfx)
        self_when = self.when
        if self_when is not None:
            self.when = _remap_path_prefix(self_when, old_pfx, new_pfx)

    def __str__(self):
        return "Container {self.name}"

    def _get_class_name(self) -> str:
        return "Container"

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Container (Ord):
    def __eq__(self, other: Container):
        return self.name == other.name and self.config == other.config and self.description == other.description and self.if_feature == other.if_feature and self.must == other.must and self.presence == other.presence and self.reference == other.reference and self.status == other.status and self.when == other.when

    def __lt__(a, b):
        return a.name < b.name

class Enum(SchemaNodeOuter):
    """YANG enum

    https://tools.ietf.org/html/rfc7950#section-9.6.4.1
    """
    name: str
    description: ?str
    if_feature: list[str]
    reference: ?str
    status: ?str
    value: ?str

    def __init__(self, name: str, description: ?str=None, if_feature: list[str]=[], reference: ?str=None, status: ?str=None, value: ?str=None, exts=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "enum"
        self.name = name
        self.description = description
        self.if_feature = if_feature
        self.reference = reference
        self.status = status
        self.value = value
        self.exts = exts

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("reference", self.reference),
            ("status", self.status),
            ("value", self.value),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        for ref_if_feature in refine.if_feature:
            if ref_if_feature not in self.if_feature:
                self.if_feature.append(ref_if_feature)
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Enum(self.name,
                   description=self.description,
                   if_feature=self.if_feature,
                   reference=self.reference,
                   status=self.status,
                   value=self.value,
                   exts=self.exts,
                   mod=new_mod if new_mod is not None else self.mod,
                   ns=new_ns if new_ns is not None else self.ns,
                   pfx=new_pfx if new_pfx is not None else self.pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        self.if_feature = [_remap_path_prefix(f, old_pfx, new_pfx) for f in self.if_feature]

    def __str__(self):
        return "Enum {self.name}"

    def _get_class_name(self) -> str:
        return "Enum"

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Enum (Ord):
    def __eq__(self, other: Enum):
        return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.reference == other.reference and self.status == other.status and self.value == other.value

    def __lt__(a, b):
        return a.name < b.name

class Extension(SchemaNodeOuter):
    """YANG extension

    https://tools.ietf.org/html/rfc7950#section-7.19.1
    """
    name: str
    argument: ?str
    description: ?str
    reference: ?str
    status: ?str

    def __init__(self, name: str, argument: ?str=None, description: ?str=None, reference: ?str=None, status: ?str=None, exts=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "extension"
        self.name = name
        self.argument = argument
        self.description = description
        self.reference = reference
        self.status = status
        self.exts = exts

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("argument", self.argument),
            ("description", self.description),
            ("reference", self.reference),
            ("status", self.status),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Extension(self.name,
                        argument=self.argument,
                        description=self.description,
                        reference=self.reference,
                        status=self.status,
                        exts=self.exts,
                        mod=new_mod if new_mod is not None else self.mod,
                        ns=new_ns if new_ns is not None else self.ns,
                        pfx=new_pfx if new_pfx is not None else self.pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """


    def __str__(self):
        return "Extension {self.name}"

    def _get_class_name(self) -> str:
        return "Extension"

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Extension (Ord):
    def __eq__(self, other: Extension):
        return self.name == other.name and self.argument == other.argument and self.description == other.description and self.reference == other.reference and self.status == other.status

    def __lt__(a, b):
        return a.name < b.name

class Feature(SchemaNodeOuter):
    """YANG feature

    https://tools.ietf.org/html/rfc7950#section-7.20.1.1
    """
    name: str
    description: ?str
    if_feature: list[str]
    reference: ?str
    status: ?str

    def __init__(self, name: str, description: ?str=None, if_feature: list[str]=[], reference: ?str=None, status: ?str=None, exts=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "feature"
        self.name = name
        self.description = description
        self.if_feature = if_feature
        self.reference = reference
        self.status = status
        self.exts = exts

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("reference", self.reference),
            ("status", self.status),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        for ref_if_feature in refine.if_feature:
            if ref_if_feature not in self.if_feature:
                self.if_feature.append(ref_if_feature)
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Feature(self.name,
                      description=self.description,
                      if_feature=self.if_feature,
                      reference=self.reference,
                      status=self.status,
                      exts=self.exts,
                      mod=new_mod if new_mod is not None else self.mod,
                      ns=new_ns if new_ns is not None else self.ns,
                      pfx=new_pfx if new_pfx is not None else self.pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        self.if_feature = [_remap_path_prefix(f, old_pfx, new_pfx) for f in self.if_feature]

    def __str__(self):
        return "Feature {self.name}"

    def _get_class_name(self) -> str:
        return "Feature"

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Feature (Ord):
    def __eq__(self, other: Feature):
        return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.reference == other.reference and self.status == other.status

    def __lt__(a, b):
        return a.name < b.name

class Grouping(SchemaNodeInner):
    """YANG grouping

    https://tools.ietf.org/html/rfc7950#section-7.12.1
    """
    name: str
    description: ?str
    reference: ?str
    status: ?str

    def __init__(self, name: str, description: ?str=None, reference: ?str=None, status: ?str=None, exts=[], children=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "grouping"
        self.name = name
        self.description = description
        self.reference = reference
        self.status = status
        self.exts = exts
        self.children = children
        for n in self.children:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("description", self.description),
            ("reference", self.reference),
            ("status", self.status),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Grouping(self.name,
                       description=self.description,
                       reference=self.reference,
                       status=self.status,
                       exts=self.exts,
                       mod=new_mod if new_mod is not None else self.mod,
                       ns=new_ns if new_ns is not None else self.ns,
                       pfx=new_pfx if new_pfx is not None else self.pfx)
        self.expand_children(context, new, new_mod, new_ns, new_pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod

        # Recursively update children
        for child in self.children:
            child.update_namespace_qualifiers(new_ns, new_pfx, new_mod)


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        for child in self.children:
            child.remap_prefix_references(old_pfx, new_pfx)


    def __str__(self):
        return "Grouping {self.name}"

    def _get_class_name(self) -> str:
        return "Grouping"

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Grouping (Ord):
    def __eq__(self, other: Grouping):
        return self.name == other.name and self.description == other.description and self.reference == other.reference and self.status == other.status

    def __lt__(a, b):
        return a.name < b.name

class Identity(SchemaNodeOuter):
    """YANG identity

    https://tools.ietf.org/html/rfc7950#section-7.18.1
    """
    name: str
    base: list[str]
    description: ?str
    if_feature: list[str]
    reference: ?str
    status: ?str

    def __init__(self, name: str, base: list[str]=[], description: ?str=None, if_feature: list[str]=[], reference: ?str=None, status: ?str=None, exts=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "identity"
        self.name = name
        self.base = base
        self.description = description
        self.if_feature = if_feature
        self.reference = reference
        self.status = status
        self.exts = exts

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("base", self.base),
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("reference", self.reference),
            ("status", self.status),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        for ref_if_feature in refine.if_feature:
            if ref_if_feature not in self.if_feature:
                self.if_feature.append(ref_if_feature)
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        # Normalize identity base to always include the module prefix. In doing
        # so we make it easier to later look up bases in DIdentity.
        fq_base = []
        for base in self.base:
            if ":" not in base:
                base_identity = self.get_identity(base, context)
                fq_base.append("{base_identity.pfx}:{base_identity.name}")
            else:
                fq_base.append(base)

        new = Identity(self.name,
                       base=fq_base,
                       description=self.description,
                       if_feature=self.if_feature,
                       reference=self.reference,
                       status=self.status,
                       exts=self.exts,
                       mod=new_mod if new_mod is not None else self.mod,
                       ns=new_ns if new_ns is not None else self.ns,
                       pfx=new_pfx if new_pfx is not None else self.pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        self.base = [_remap_path_prefix(b, old_pfx, new_pfx) for b in self.base]
        self.if_feature = [_remap_path_prefix(f, old_pfx, new_pfx) for f in self.if_feature]

    def __str__(self):
        return "Identity {self.name}"

    def _get_class_name(self) -> str:
        return "Identity"

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Identity (Ord):
    def __eq__(self, other: Identity):
        return self.name == other.name and self.base == other.base and self.description == other.description and self.if_feature == other.if_feature and self.reference == other.reference and self.status == other.status

    def __lt__(a, b):
        return a.name < b.name

class Import(SchemaNodeOuter):
    """YANG import

    https://tools.ietf.org/html/rfc7950#section-7.1.5
    """
    module: str
    prefix: str
    description: ?str
    reference: ?str
    revision_date: ?str

    def __init__(self, module: str, prefix: str, description: ?str=None, reference: ?str=None, revision_date: ?str=None, exts=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "import"
        self.module = module
        self.description = description
        self.prefix = prefix
        self.reference = reference
        self.revision_date = revision_date
        self.exts = exts

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("prefix", self.prefix),
            ("description", self.description),
            ("reference", self.reference),
            ("revision-date", self.revision_date),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Import(self.module,
                     prefix=self.prefix,
                     description=self.description,
                     reference=self.reference,
                     revision_date=self.revision_date,
                     exts=self.exts,
                     mod=new_mod if new_mod is not None else self.mod,
                     ns=new_ns if new_ns is not None else self.ns,
                     pfx=new_pfx if new_pfx is not None else self.pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """


    def __str__(self):
        return "Import {self.module}"

    def _get_class_name(self) -> str:
        return "Import"

    def _get_argname(self) -> ?str:
        return 'module'

    def _get_arg(self) -> ?str:
        return self.module

extension Import (Ord):
    def __eq__(self, other: Import):
        return self.module == other.module and self.description == other.description and self.prefix == other.prefix and self.reference == other.reference and self.revision_date == other.revision_date

    def __lt__(a, b):
        return a.module < b.module

class Include(SchemaNodeOuter):
    """YANG include

    https://tools.ietf.org/html/rfc7950#section-7.1.6
    """
    module: str
    description: ?str
    reference: ?str
    revision_date: ?str

    def __init__(self, module: str, description: ?str=None, reference: ?str=None, revision_date: ?str=None, exts=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "include"
        self.module = module
        self.description = description
        self.reference = reference
        self.revision_date = revision_date
        self.exts = exts

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("description", self.description),
            ("reference", self.reference),
            ("revision-date", self.revision_date),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Include(self.module,
                      description=self.description,
                      reference=self.reference,
                      revision_date=self.revision_date,
                      exts=self.exts,
                      mod=new_mod if new_mod is not None else self.mod,
                      ns=new_ns if new_ns is not None else self.ns,
                      pfx=new_pfx if new_pfx is not None else self.pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """


    def __str__(self):
        return "Include {self.module}"

    def _get_class_name(self) -> str:
        return "Include"

    def _get_argname(self) -> ?str:
        return 'module'

    def _get_arg(self) -> ?str:
        return self.module

extension Include (Ord):
    def __eq__(self, other: Include):
        return self.module == other.module and self.description == other.description and self.reference == other.reference and self.revision_date == other.revision_date

    def __lt__(a, b):
        return a.module < b.module

class Input(SchemaNodeInner):
    """YANG input

    https://tools.ietf.org/html/rfc7950#section-7.14.2.1
    """
    must: list[Must]

    def __init__(self, must: list[Must]=[], exts=[], children=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "input"
        self.must = must
        self.exts = exts
        self.children = children
        for n in self.must:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx
        for n in self.children:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("must", self.must),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        for ref_must in refine.must:
            if ref_must not in self.must:
                self.must.append(ref_must)
        self.exts.extend(refine.exts)

    def to_dnode(self) -> DInput:
        new_dnode = DInput(
            module=self.get_module_name(),
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            must=self.must,
            exts=self.exts,
            children=self.get_dnode_children()
        )
        return new_dnode

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Input(must=self.must,
                    exts=self.exts,
                    mod=new_mod if new_mod is not None else self.mod,
                    ns=new_ns if new_ns is not None else self.ns,
                    pfx=new_pfx if new_pfx is not None else self.pfx)
        self.expand_children(context, new, new_mod, new_ns, new_pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod

        # Recursively update children
        for child in self.children:
            child.update_namespace_qualifiers(new_ns, new_pfx, new_mod)


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        for child in self.children:
            child.remap_prefix_references(old_pfx, new_pfx)

        for must in self.must:
            must.condition = _remap_path_prefix(must.condition, old_pfx, new_pfx)

    def __str__(self):
        return "Input"

    def _get_class_name(self) -> str:
        return "Input"

    def _get_argname(self) -> ?str:
        return None

    def _get_arg(self) -> ?str:
        return None

extension Input (Ord):
    def __eq__(self, other: Input):
        return self.must == other.must

    def __lt__(a, b):
        return True

class Leaf(SchemaNodeOuter):
    """YANG leaf

    https://tools.ietf.org/html/rfc7950#section-7.6.2
    """
    name: str
    type_: Type
    config: ?bool
    default: ?str
    description: ?str
    if_feature: list[str]
    mandatory: ?bool
    must: list[Must]
    reference: ?str
    status: ?str
    units: ?str
    when: ?str

    def __init__(self, name: str, type_: Type, config: ?bool=None, default: ?str=None, description: ?str=None, if_feature: list[str]=[], mandatory: ?bool=None, must: list[Must]=[], reference: ?str=None, status: ?str=None, units: ?str=None, when: ?str=None, exts=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "leaf"
        self.name = name
        self.config = config
        self.default = default
        self.description = description
        self.if_feature = if_feature
        self.mandatory = mandatory
        self.must = must
        self.reference = reference
        self.status = status
        self.type_ = type_
        self.units = units
        self.when = when
        self.exts = exts
        for n in self.must:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx
        self.type_.parent = self
        n_mod = self.type_.mod
        if n_mod is None:
            self.type_.mod = self.mod
        n_ns = self.type_.ns
        if n_ns is None:
            self.type_.ns = self.ns
        n_pfx = self.type_.pfx
        if n_pfx is None:
            self.type_.pfx = self.pfx

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("type", self.type_),
            ("config", self.config),
            ("default", self.default),
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("mandatory", self.mandatory),
            ("must", self.must),
            ("reference", self.reference),
            ("status", self.status),
            ("units", self.units),
            ("when", self.when),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_config = refine.config
        if ref_config is not None:
            self.config = ref_config
        if len(refine.default) == 1:
            self.default = refine.default[0]
        elif len(refine.default) > 1:
            raise ValueError("Attempting to refine default with multiple values")
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        for ref_if_feature in refine.if_feature:
            if ref_if_feature not in self.if_feature:
                self.if_feature.append(ref_if_feature)
        ref_mandatory = refine.mandatory
        if ref_mandatory is not None:
            self.mandatory = ref_mandatory
        for ref_must in refine.must:
            if ref_must not in self.must:
                self.must.append(ref_must)
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        resolved_type = self.type_.resolve_type(context, new_mod, new_ns, new_pfx)

        new = Leaf(self.name,
                   config=self.config,
                   default=self.default,
                   description=self.description,
                   if_feature=self.if_feature,
                   mandatory=self.mandatory,
                   must=self.must,
                   reference=self.reference,
                   status=self.status,
                   type_=resolved_type,
                   units=self.units,
                   when=self.when,
                   exts=self.exts,
                   mod=new_mod if new_mod is not None else self.mod,
                   ns=new_ns if new_ns is not None else self.ns,
                   pfx=new_pfx if new_pfx is not None else self.pfx)

        resolved_type.parent = new

        return new

    def to_dnode(self) -> DLeaf:
        dtype = self.type_.to_dtype()

        new_default = self.default
        if new_default is None:
            new_default = dtype.default

        new_units = self.units
        if new_units is None:
            new_units = dtype.units

        new_dnode = DLeaf(
            module=self.get_module_name(),
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            config=self.is_config(),
            default=self.default,
            description=self.description,
            if_feature=self.if_feature,
            mandatory=self.mandatory,
            must=self.must,
            reference=self.reference,
            status=self.status,
            type_=dtype,
            units=self.units,
            when=self.when,
            exts=self.exts
        )
        dtype.parent = new_dnode
        return new_dnode

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod

        self.type_.update_namespace_qualifiers(new_ns, new_pfx, new_mod)

    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        if self.type_.name == 'identityref':
            self_default = self.default
            if self_default is not None:
                self.default = _remap_path_prefix(self_default, old_pfx, new_pfx)
        self.if_feature = [_remap_path_prefix(f, old_pfx, new_pfx) for f in self.if_feature]
        for must in self.must:
            must.condition = _remap_path_prefix(must.condition, old_pfx, new_pfx)
        self.type_.remap_prefix_references(old_pfx, new_pfx)
        self_when = self.when
        if self_when is not None:
            self.when = _remap_path_prefix(self_when, old_pfx, new_pfx)

    def __str__(self):
        return "Leaf {self.name}"

    def _get_class_name(self) -> str:
        return "Leaf"

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Leaf (Ord):
    def __eq__(self, other: Leaf):
        return self.name == other.name and self.config == other.config and self.default == other.default and self.description == other.description and self.if_feature == other.if_feature and self.mandatory == other.mandatory and self.must == other.must and self.reference == other.reference and self.status == other.status and self.type_ == other.type_ and self.units == other.units and self.when == other.when

    def __lt__(a, b):
        return a.name < b.name

class LeafList(SchemaNodeOuter):
    """YANG leaf-list

    https://tools.ietf.org/html/rfc7950#section-7.7.3
    """
    name: str
    type_: Type
    config: ?bool
    default: list[str]
    description: ?str
    if_feature: list[str]
    max_elements: ?str
    min_elements: ?str
    must: list[Must]
    ordered_by: ?str
    reference: ?str
    status: ?str
    units: ?str
    when: ?str

    def __init__(self, name: str, type_: Type, config: ?bool=None, default: list[str]=[], description: ?str=None, if_feature: list[str]=[], max_elements: ?str=None, min_elements: ?str=None, must: list[Must]=[], ordered_by: ?str=None, reference: ?str=None, status: ?str=None, units: ?str=None, when: ?str=None, exts=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "leaf-list"
        self.name = name
        self.config = config
        self.default = default
        self.description = description
        self.if_feature = if_feature
        self.max_elements = max_elements
        self.min_elements = min_elements
        self.must = must
        self.ordered_by = ordered_by
        self.reference = reference
        self.status = status
        self.type_ = type_
        self.units = units
        self.when = when
        self.exts = exts
        for n in self.must:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx
        self.type_.parent = self
        n_mod = self.type_.mod
        if n_mod is None:
            self.type_.mod = self.mod
        n_ns = self.type_.ns
        if n_ns is None:
            self.type_.ns = self.ns
        n_pfx = self.type_.pfx
        if n_pfx is None:
            self.type_.pfx = self.pfx

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("type", self.type_),
            ("config", self.config),
            ("default", self.default),
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("max-elements", self.max_elements),
            ("min-elements", self.min_elements),
            ("must", self.must),
            ("ordered-by", self.ordered_by),
            ("reference", self.reference),
            ("status", self.status),
            ("units", self.units),
            ("when", self.when),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_config = refine.config
        if ref_config is not None:
            self.config = ref_config
        for ref_default in refine.default:
            if ref_default not in self.default:
                self.default.append(ref_default)
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        for ref_if_feature in refine.if_feature:
            if ref_if_feature not in self.if_feature:
                self.if_feature.append(ref_if_feature)
        ref_max_elements = refine.max_elements
        if ref_max_elements is not None:
            self.max_elements = ref_max_elements
        ref_min_elements = refine.min_elements
        if ref_min_elements is not None:
            self.min_elements = ref_min_elements
        for ref_must in refine.must:
            if ref_must not in self.must:
                self.must.append(ref_must)
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        resolved_type = self.type_.resolve_type(context, new_mod, new_ns, new_pfx)

        new = LeafList(self.name,
                       config=self.config,
                       default=self.default,
                       description=self.description,
                       if_feature=self.if_feature,
                       max_elements=self.max_elements,
                       min_elements=self.min_elements,
                       must=self.must,
                       ordered_by=self.ordered_by,
                       reference=self.reference,
                       status=self.status,
                       type_=resolved_type,
                       units=self.units,
                       when=self.when,
                       exts=self.exts,
                       mod=new_mod if new_mod is not None else self.mod,
                       ns=new_ns if new_ns is not None else self.ns,
                       pfx=new_pfx if new_pfx is not None else self.pfx)

        resolved_type.parent = new

        return new

    def get_max_elements(self) -> ?int:
        selfmax_elements = self.max_elements
        if selfmax_elements is not None and selfmax_elements != "unbounded":
            return int(selfmax_elements)
        return None

    def get_min_elements(self) -> int:
        selfmin_elements = self.min_elements
        if selfmin_elements is not None:
            return int(selfmin_elements)
        return 0

    def to_dnode(self) -> DLeafList:
        dtype = self.type_.to_dtype()

        new_units = self.units
        if new_units is None:
            new_units = dtype.units

        new_dnode = DLeafList(
            module=self.get_module_name(),
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            config=self.is_config(),
            default=self.default,
            description=self.description,
            if_feature=self.if_feature,
            max_elements=self.get_max_elements(),
            min_elements=self.get_min_elements(),
            must=self.must,
            ordered_by=self.ordered_by,
            reference=self.reference,
            status=self.status,
            type_=dtype,
            units=self.units,
            when=self.when,
            exts=self.exts
        )
        dtype.parent = new_dnode
        return new_dnode

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod

        self.type_.update_namespace_qualifiers(new_ns, new_pfx, new_mod)

    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        if self.type_.name == 'identityref':
            self.default = [_remap_path_prefix(d, old_pfx, new_pfx) for d in self.default]
        self.if_feature = [_remap_path_prefix(f, old_pfx, new_pfx) for f in self.if_feature]
        for must in self.must:
            must.condition = _remap_path_prefix(must.condition, old_pfx, new_pfx)
        self.type_.remap_prefix_references(old_pfx, new_pfx)
        self_when = self.when
        if self_when is not None:
            self.when = _remap_path_prefix(self_when, old_pfx, new_pfx)

    def __str__(self):
        return "LeafList {self.name}"

    def _get_class_name(self) -> str:
        return "LeafList"

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension LeafList (Ord):
    def __eq__(self, other: LeafList):
        return self.name == other.name and self.config == other.config and self.default == other.default and self.description == other.description and self.if_feature == other.if_feature and self.max_elements == other.max_elements and self.min_elements == other.min_elements and self.must == other.must and self.ordered_by == other.ordered_by and self.reference == other.reference and self.status == other.status and self.type_ == other.type_ and self.units == other.units and self.when == other.when

    def __lt__(a, b):
        return a.name < b.name

class Length(SchemaNodeOuter):
    """YANG length

    https://tools.ietf.org/html/rfc7950#section-9.4.4.1
    """
    value: str
    description: ?str
    error_app_tag: ?str
    error_message: ?str
    reference: ?str

    def __init__(self, value: str, description: ?str=None, error_app_tag: ?str=None, error_message: ?str=None, reference: ?str=None, exts=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "length"
        self.value = value
        self.description = description
        self.error_app_tag = error_app_tag
        self.error_message = error_message
        self.reference = reference
        self.exts = exts

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("description", self.description),
            ("error-app-tag", self.error_app_tag),
            ("error-message", self.error_message),
            ("reference", self.reference),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Length(self.value,
                     description=self.description,
                     error_app_tag=self.error_app_tag,
                     error_message=self.error_message,
                     reference=self.reference,
                     exts=self.exts,
                     mod=new_mod if new_mod is not None else self.mod,
                     ns=new_ns if new_ns is not None else self.ns,
                     pfx=new_pfx if new_pfx is not None else self.pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """


    def __str__(self):
        return "Length {self.value}"

    def _get_class_name(self) -> str:
        return "Length"

    def _get_argname(self) -> ?str:
        return 'value'

    def _get_arg(self) -> ?str:
        return self.value

extension Length (Ord):
    def __eq__(self, other: Length):
        return self.value == other.value and self.description == other.description and self.error_app_tag == other.error_app_tag and self.error_message == other.error_message and self.reference == other.reference

    def __lt__(a, b):
        return a.value < b.value

class List(SchemaNodeInner):
    """YANG list

    https://tools.ietf.org/html/rfc7950#section-7.8.1
    """
    name: str
    config: ?bool
    description: ?str
    if_feature: list[str]
    key: ?str
    max_elements: ?str
    min_elements: ?str
    must: list[Must]
    ordered_by: ?str
    reference: ?str
    status: ?str
    unique: list[str]
    when: ?str

    def __init__(self, name: str, config: ?bool=None, description: ?str=None, if_feature: list[str]=[], key: ?str=None, max_elements: ?str=None, min_elements: ?str=None, must: list[Must]=[], ordered_by: ?str=None, reference: ?str=None, status: ?str=None, unique: list[str]=[], when: ?str=None, exts=[], children=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "list"
        self.name = name
        self.config = config
        self.description = description
        self.if_feature = if_feature
        self.key = key
        self.max_elements = max_elements
        self.min_elements = min_elements
        self.must = must
        self.ordered_by = ordered_by
        self.reference = reference
        self.status = status
        self.unique = unique
        self.when = when
        self.exts = exts
        self.children = children
        for n in self.must:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx
        for n in self.children:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("config", self.config),
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("key", self.key),
            ("max-elements", self.max_elements),
            ("min-elements", self.min_elements),
            ("must", self.must),
            ("ordered-by", self.ordered_by),
            ("reference", self.reference),
            ("status", self.status),
            ("unique", self.unique),
            ("when", self.when),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_config = refine.config
        if ref_config is not None:
            self.config = ref_config
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        for ref_if_feature in refine.if_feature:
            if ref_if_feature not in self.if_feature:
                self.if_feature.append(ref_if_feature)
        ref_max_elements = refine.max_elements
        if ref_max_elements is not None:
            self.max_elements = ref_max_elements
        ref_min_elements = refine.min_elements
        if ref_min_elements is not None:
            self.min_elements = ref_min_elements
        for ref_must in refine.must:
            if ref_must not in self.must:
                self.must.append(ref_must)
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def keys(self) -> list[str]:
        selfkey = self.key
        if selfkey is not None:
            return selfkey.split(" ")
        return []

    def get_max_elements(self) -> ?int:
        selfmax_elements = self.max_elements
        if selfmax_elements is not None and selfmax_elements != "unbounded":
            return int(selfmax_elements)
        return None

    def get_min_elements(self) -> int:
        selfmin_elements = self.min_elements
        if selfmin_elements is not None:
            return int(selfmin_elements)
        return 0

    def to_dnode(self) -> DList:
        new_dnode = DList(
            module=self.get_module_name(),
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            key=self.keys(),
            config=self.is_config(),
            description=self.description,
            if_feature=self.if_feature,
            max_elements=self.get_max_elements(),
            min_elements=self.get_min_elements(),
            must=self.must,
            ordered_by=self.ordered_by,
            reference=self.reference,
            status=self.status,
            when=self.when,
            exts=self.exts,
            children=self.get_dnode_children()
        )
        return new_dnode

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = List(self.name,
                   config=self.config,
                   description=self.description,
                   if_feature=self.if_feature,
                   key=self.key,
                   max_elements=self.max_elements,
                   min_elements=self.min_elements,
                   must=self.must,
                   ordered_by=self.ordered_by,
                   reference=self.reference,
                   status=self.status,
                   unique=self.unique,
                   when=self.when,
                   exts=self.exts,
                   mod=new_mod if new_mod is not None else self.mod,
                   ns=new_ns if new_ns is not None else self.ns,
                   pfx=new_pfx if new_pfx is not None else self.pfx)
        self.expand_children(context, new, new_mod, new_ns, new_pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod

        # Recursively update children
        for child in self.children:
            child.update_namespace_qualifiers(new_ns, new_pfx, new_mod)


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        for child in self.children:
            child.remap_prefix_references(old_pfx, new_pfx)

        self.if_feature = [_remap_path_prefix(f, old_pfx, new_pfx) for f in self.if_feature]
        for must in self.must:
            must.condition = _remap_path_prefix(must.condition, old_pfx, new_pfx)
        self.unique = [_remap_path_prefix(u, old_pfx, new_pfx) for u in self.unique]
        self_when = self.when
        if self_when is not None:
            self.when = _remap_path_prefix(self_when, old_pfx, new_pfx)

    def __str__(self):
        return "List {self.name}"

    def _get_class_name(self) -> str:
        return "List"

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension List (Ord):
    def __eq__(self, other: List):
        return self.name == other.name and self.config == other.config and self.description == other.description and self.if_feature == other.if_feature and self.key == other.key and self.max_elements == other.max_elements and self.min_elements == other.min_elements and self.must == other.must and self.ordered_by == other.ordered_by and self.reference == other.reference and self.status == other.status and self.unique == other.unique and self.when == other.when

    def __lt__(a, b):
        return a.name < b.name

class Module(SchemaNodeInner):
    """YANG module

    https://tools.ietf.org/html/rfc7950#section-7.1.1
    """
    name: str
    yang_version: float
    namespace: str
    prefix: str
    import_: list[Import]
    include: list[Include]
    organization: ?str
    contact: ?str
    description: ?str
    reference: ?str
    revision: list[Revision]
    augment: list[Augment]
    deviation: list[str]
    extension_: list[Extension]
    feature: list[Feature]

    def __init__(self, name: str, namespace: str, prefix: str, yang_version: float=1.1, augment: list[Augment]=[], contact: ?str=None, description: ?str=None, deviation: list[str]=[], extension_: list[Extension]=[], feature: list[Feature]=[], import_: list[Import]=[], include: list[Include]=[], organization: ?str=None, reference: ?str=None, revision: list[Revision]=[], exts=[], children=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None:
            new_mod = name
        if new_ns is None:
            new_ns = namespace
        if new_pfx is None:
            new_pfx = prefix
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "module"
        self.name = name
        self.augment = augment
        self.contact = contact
        self.description = description
        self.deviation = deviation
        self.extension_ = extension_
        self.feature = feature
        self.import_ = import_
        self.include = include
        self.namespace = namespace
        self.organization = organization
        self.prefix = prefix
        self.reference = reference
        self.revision = revision
        self.yang_version = yang_version
        self.exts = exts
        self.children = children
        for n in self.augment:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx
        for n in self.extension_:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx
        for n in self.feature:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx
        for n in self.import_:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx
        for n in self.include:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx
        for n in self.revision:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx
        for n in self.children:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("yang-version", self.yang_version),
            ("namespace", self.namespace),
            ("prefix", self.prefix),
            ("import", self.import_),
            ("include", self.include),
            ("organization", self.organization),
            ("contact", self.contact),
            ("description", self.description),
            ("reference", self.reference),
            ("revision", self.revision),
            ("augment", self.augment),
            ("deviation", self.deviation),
            ("extension", self.extension_),
            ("feature", self.feature),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def get_import_by_prefix(self, prefix: str) -> Import:
        for imp in self.import_:
            if imp.prefix == prefix:
                return imp
        raise ValueError("No import with prefix {prefix} in module {self.name}")

    def get_modrev(self) -> ModRev:
        rev = self.get_revision()
        rev_date = rev.date if rev is not None else None
        return ModRev(self.name, rev_date)

    def get_namespace(self) -> str:
        self_ns = self.ns
        if self_ns is not None:
            return self_ns
        selfnamespace = self.namespace
        if selfnamespace is not None:
            return selfnamespace
        raise ValueError("Module {self.name} has no namespace")

    def get_prefix(self) -> str:
        self_pfx = self.pfx
        if self_pfx is not None:
            return self_pfx
        selfprefix = self.prefix
        if selfprefix is not None:
            return selfprefix
        raise ValueError("Module {self.name} has no prefix")

    def get_revision(self) -> ?Revision:
        latest = None
        for rev in self.revision:
            if latest is None or (latest is not None and rev.date > latest.date):
                latest = rev
        return latest

    def to_dnode(self) -> DModule:
        new_dnode = DModule(
            module=self.get_module_name(),
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            description=self.description,
            identity=[c for c in self.children if isinstance(c, Identity)],
            revision=self.revision,
            reference=self.reference,
            exts=self.exts,
            children=self.get_dnode_children()
        )
        return new_dnode

    def is_config(self) -> bool:
        return False

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Module(self.name,
                     yang_version=self.yang_version,
                     namespace=self.namespace,
                     prefix=self.prefix,
                     import_=self.import_,
                     include=self.include,
                     organization=self.organization,
                     contact=self.contact,
                     description=self.description,
                     reference=self.reference,
                     revision=self.revision,
                     augment=self.augment,
                     deviation=self.deviation,
                     extension_=self.extension_,
                     feature=self.feature,
                     exts=self.exts)
        self.expand_children(context, new, new_mod, new_ns, new_pfx)
        new.expand_augments(context)

        # Normalize import prefixes at compile time
        # When a module imports another module with a different prefix than its actual prefix,
        # we need to normalize all references to use the actual prefix
        for import_ in self.import_:
            try:
                imported_module = context.get_module(import_.module, import_.revision_date)
            except ValueError as e:
                # TODO: import a non-existant module? error!
                print(e.error_message, err=True)
            else:
                if import_.prefix != imported_module.prefix:
                    new.remap_prefix_references(import_.prefix, imported_module.prefix)

        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod

        # Recursively update children
        for child in self.children:
            child.update_namespace_qualifiers(new_ns, new_pfx, new_mod)


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        for child in self.children:
            child.remap_prefix_references(old_pfx, new_pfx)

        self.deviation = [_remap_path_prefix(d, old_pfx, new_pfx) for d in self.deviation]

    def __str__(self):
        return "Module {self.name}"

    def _get_class_name(self) -> str:
        return "Module"

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Module (Hashable):
    def hash(self, hasher):
        self.get_namespace().hash(hasher)
        rev = self.get_revision()
        if rev is not None:
            rev.date.hash(hasher)
        else:
            # Hash empty string for None revision
            "".hash(hasher)

    def __eq__(self, other: Module):
        return self.name == other.name and self.augment == other.augment and self.contact == other.contact and self.description == other.description and self.deviation == other.deviation and self.extension_ == other.extension_ and self.feature == other.feature and self.import_ == other.import_ and self.include == other.include and self.namespace == other.namespace and self.organization == other.organization and self.prefix == other.prefix and self.reference == other.reference and self.revision == other.revision and self.yang_version == other.yang_version

extension Module (Ord):
    def __lt__(a, b):
        return a.name < b.name

class Must(SchemaNodeOuter):
    """YANG must

    https://tools.ietf.org/html/rfc7950#section-7.5.4
    """
    condition: str
    description: ?str
    error_app_tag: ?str
    error_message: ?str
    reference: ?str

    def __init__(self, condition: str, description: ?str=None, error_app_tag: ?str=None, error_message: ?str=None, reference: ?str=None, exts=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "must"
        self.condition = condition
        self.description = description
        self.error_app_tag = error_app_tag
        self.error_message = error_message
        self.reference = reference
        self.exts = exts

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("description", self.description),
            ("error-app-tag", self.error_app_tag),
            ("error-message", self.error_message),
            ("reference", self.reference),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Must(self.condition,
                   description=self.description,
                   error_app_tag=self.error_app_tag,
                   error_message=self.error_message,
                   reference=self.reference,
                   exts=self.exts,
                   mod=new_mod if new_mod is not None else self.mod,
                   ns=new_ns if new_ns is not None else self.ns,
                   pfx=new_pfx if new_pfx is not None else self.pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """


    def __str__(self):
        return "Must {self.condition}"

    def _get_class_name(self) -> str:
        return "Must"

    def _get_argname(self) -> ?str:
        return 'condition'

    def _get_arg(self) -> ?str:
        return self.condition

extension Must (Ord):
    def __eq__(self, other: Must):
        return self.condition == other.condition and self.description == other.description and self.error_app_tag == other.error_app_tag and self.error_message == other.error_message and self.reference == other.reference

    def __lt__(a, b):
        return a.condition < b.condition

class Notification(SchemaNodeInner):
    """YANG notification

    https://tools.ietf.org/html/rfc7950#section-7.16.1
    """
    name: str
    description: ?str
    if_feature: list[str]
    must: list[Must]
    reference: ?str
    status: ?str

    def __init__(self, name: str, description: ?str=None, if_feature: list[str]=[], must: list[Must]=[], reference: ?str=None, status: ?str=None, exts=[], children=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "notification"
        self.name = name
        self.description = description
        self.if_feature = if_feature
        self.must = must
        self.reference = reference
        self.status = status
        self.exts = exts
        self.children = children
        for n in self.must:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx
        for n in self.children:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("must", self.must),
            ("reference", self.reference),
            ("status", self.status),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        for ref_if_feature in refine.if_feature:
            if ref_if_feature not in self.if_feature:
                self.if_feature.append(ref_if_feature)
        for ref_must in refine.must:
            if ref_must not in self.must:
                self.must.append(ref_must)
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def to_dnode(self) -> DNotification:
        new_dnode = DNotification(
            module=self.get_module_name(),
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            description=self.description,
            if_feature=self.if_feature,
            reference=self.reference,
            status=self.status,
            exts=self.exts,
            children=self.get_dnode_children()
        )
        return new_dnode

    def is_config(self) -> bool:
        return False

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Notification(self.name,
                           description=self.description,
                           if_feature=self.if_feature,
                           must=self.must,
                           reference=self.reference,
                           status=self.status,
                           exts=self.exts,
                           mod=new_mod if new_mod is not None else self.mod,
                           ns=new_ns if new_ns is not None else self.ns,
                           pfx=new_pfx if new_pfx is not None else self.pfx)
        self.expand_children(context, new, new_mod, new_ns, new_pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod

        # Recursively update children
        for child in self.children:
            child.update_namespace_qualifiers(new_ns, new_pfx, new_mod)


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        for child in self.children:
            child.remap_prefix_references(old_pfx, new_pfx)

        self.if_feature = [_remap_path_prefix(f, old_pfx, new_pfx) for f in self.if_feature]
        for must in self.must:
            must.condition = _remap_path_prefix(must.condition, old_pfx, new_pfx)

    def __str__(self):
        return "Notification {self.name}"

    def _get_class_name(self) -> str:
        return "Notification"

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Notification (Ord):
    def __eq__(self, other: Notification):
        return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.must == other.must and self.reference == other.reference and self.status == other.status

    def __lt__(a, b):
        return a.name < b.name

class Output(SchemaNodeInner):
    """YANG output

    https://tools.ietf.org/html/rfc7950#section-7.14.3.1
    """
    must: list[Must]

    def __init__(self, must: list[Must]=[], exts=[], children=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "output"
        self.must = must
        self.exts = exts
        self.children = children
        for n in self.must:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx
        for n in self.children:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("must", self.must),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        for ref_must in refine.must:
            if ref_must not in self.must:
                self.must.append(ref_must)
        self.exts.extend(refine.exts)

    def to_dnode(self) -> DOutput:
        new_dnode = DOutput(
            module=self.get_module_name(),
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            must=self.must,
            exts=self.exts,
            children=self.get_dnode_children()
        )
        return new_dnode

    def is_config(self) -> bool:
        return False

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Output(must=self.must,
                     exts=self.exts,
                     mod=new_mod if new_mod is not None else self.mod,
                     ns=new_ns if new_ns is not None else self.ns,
                     pfx=new_pfx if new_pfx is not None else self.pfx)
        self.expand_children(context, new, new_mod, new_ns, new_pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod

        # Recursively update children
        for child in self.children:
            child.update_namespace_qualifiers(new_ns, new_pfx, new_mod)


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        for child in self.children:
            child.remap_prefix_references(old_pfx, new_pfx)

        for must in self.must:
            must.condition = _remap_path_prefix(must.condition, old_pfx, new_pfx)

    def __str__(self):
        return "Output"

    def _get_class_name(self) -> str:
        return "Output"

    def _get_argname(self) -> ?str:
        return None

    def _get_arg(self) -> ?str:
        return None

extension Output (Ord):
    def __eq__(self, other: Output):
        return self.must == other.must

    def __lt__(a, b):
        return True

class Pattern(SchemaNodeOuter):
    """YANG pattern

    https://tools.ietf.org/html/rfc7950#section-9.4.5.1
    """
    value: str
    description: ?str
    error_app_tag: ?str
    error_message: ?str
    modifier: ?str
    reference: ?str

    def __init__(self, value: str, description: ?str=None, error_app_tag: ?str=None, error_message: ?str=None, modifier: ?str=None, reference: ?str=None, exts=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "pattern"
        self.value = value
        self.description = description
        self.error_app_tag = error_app_tag
        self.error_message = error_message
        self.modifier = modifier
        self.reference = reference
        self.exts = exts

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("description", self.description),
            ("error-app-tag", self.error_app_tag),
            ("error-message", self.error_message),
            ("modifier", self.modifier),
            ("reference", self.reference),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Pattern(self.value,
                      description=self.description,
                      error_app_tag=self.error_app_tag,
                      error_message=self.error_message,
                      modifier=self.modifier,
                      reference=self.reference,
                      exts=self.exts,
                      mod=new_mod if new_mod is not None else self.mod,
                      ns=new_ns if new_ns is not None else self.ns,
                      pfx=new_pfx if new_pfx is not None else self.pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """


    def __str__(self):
        return "Pattern {self.value}"

    def _get_class_name(self) -> str:
        return "Pattern"

    def _get_argname(self) -> ?str:
        return 'value'

    def _get_arg(self) -> ?str:
        return self.value

extension Pattern (Ord):
    def __eq__(self, other: Pattern):
        return self.value == other.value and self.description == other.description and self.error_app_tag == other.error_app_tag and self.error_message == other.error_message and self.modifier == other.modifier and self.reference == other.reference

    def __lt__(a, b):
        return a.value < b.value

class Range(SchemaNodeOuter):
    """YANG range

    https://tools.ietf.org/html/rfc7950#section-9.2.4.1
    """
    value: str
    description: ?str
    error_app_tag: ?str
    error_message: ?str
    reference: ?str

    def __init__(self, value: str, description: ?str=None, error_app_tag: ?str=None, error_message: ?str=None, reference: ?str=None, exts=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "range"
        self.value = value
        self.description = description
        self.error_app_tag = error_app_tag
        self.error_message = error_message
        self.reference = reference
        self.exts = exts

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("description", self.description),
            ("error-app-tag", self.error_app_tag),
            ("error-message", self.error_message),
            ("reference", self.reference),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Range(self.value,
                    description=self.description,
                    error_app_tag=self.error_app_tag,
                    error_message=self.error_message,
                    reference=self.reference,
                    exts=self.exts,
                    mod=new_mod if new_mod is not None else self.mod,
                    ns=new_ns if new_ns is not None else self.ns,
                    pfx=new_pfx if new_pfx is not None else self.pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """


    def __str__(self):
        return "Range {self.value}"

    def _get_class_name(self) -> str:
        return "Range"

    def _get_argname(self) -> ?str:
        return 'value'

    def _get_arg(self) -> ?str:
        return self.value

extension Range (Ord):
    def __eq__(self, other: Range):
        return self.value == other.value and self.description == other.description and self.error_app_tag == other.error_app_tag and self.error_message == other.error_message and self.reference == other.reference

    def __lt__(a, b):
        return a.value < b.value

class Refine(SchemaNodeOuter):
    """YANG refine

    https://tools.ietf.org/html/rfc7950#section-7.13.999
    """
    target_node: str
    config: ?bool
    default: list[str]
    description: ?str
    if_feature: list[str]
    mandatory: ?bool
    max_elements: ?str
    min_elements: ?str
    must: list[Must]
    presence: ?str
    reference: ?str

    def __init__(self, target_node: str, config: ?bool=None, default: list[str]=[], description: ?str=None, if_feature: list[str]=[], mandatory: ?bool=None, max_elements: ?str=None, min_elements: ?str=None, must: list[Must]=[], presence: ?str=None, reference: ?str=None, exts=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "refine"
        self.target_node = target_node
        self.config = config
        self.default = default
        self.description = description
        self.if_feature = if_feature
        self.mandatory = mandatory
        self.max_elements = max_elements
        self.min_elements = min_elements
        self.must = must
        self.presence = presence
        self.reference = reference
        self.exts = exts
        for n in self.must:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("config", self.config),
            ("default", self.default),
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("mandatory", self.mandatory),
            ("max-elements", self.max_elements),
            ("min-elements", self.min_elements),
            ("must", self.must),
            ("presence", self.presence),
            ("reference", self.reference),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_config = refine.config
        if ref_config is not None:
            self.config = ref_config
        for ref_default in refine.default:
            if ref_default not in self.default:
                self.default.append(ref_default)
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        for ref_if_feature in refine.if_feature:
            if ref_if_feature not in self.if_feature:
                self.if_feature.append(ref_if_feature)
        ref_mandatory = refine.mandatory
        if ref_mandatory is not None:
            self.mandatory = ref_mandatory
        ref_max_elements = refine.max_elements
        if ref_max_elements is not None:
            self.max_elements = ref_max_elements
        ref_min_elements = refine.min_elements
        if ref_min_elements is not None:
            self.min_elements = ref_min_elements
        for ref_must in refine.must:
            if ref_must not in self.must:
                self.must.append(ref_must)
        ref_presence = refine.presence
        if ref_presence is not None:
            self.presence = ref_presence
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Refine(self.target_node,
                     config=self.config,
                     default=self.default,
                     description=self.description,
                     if_feature=self.if_feature,
                     mandatory=self.mandatory,
                     max_elements=self.max_elements,
                     min_elements=self.min_elements,
                     must=self.must,
                     presence=self.presence,
                     reference=self.reference,
                     exts=self.exts,
                     mod=new_mod if new_mod is not None else self.mod,
                     ns=new_ns if new_ns is not None else self.ns,
                     pfx=new_pfx if new_pfx is not None else self.pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        self.if_feature = [_remap_path_prefix(f, old_pfx, new_pfx) for f in self.if_feature]
        for must in self.must:
            must.condition = _remap_path_prefix(must.condition, old_pfx, new_pfx)
        self.target_node = _remap_path_prefix(self.target_node, old_pfx, new_pfx)

    def __str__(self):
        return "Refine {self.target_node}"

    def _get_class_name(self) -> str:
        return "Refine"

    def _get_argname(self) -> ?str:
        return 'target_node'

    def _get_arg(self) -> ?str:
        return self.target_node

extension Refine (Ord):
    def __eq__(self, other: Refine):
        return self.target_node == other.target_node and self.config == other.config and self.default == other.default and self.description == other.description and self.if_feature == other.if_feature and self.mandatory == other.mandatory and self.max_elements == other.max_elements and self.min_elements == other.min_elements and self.must == other.must and self.presence == other.presence and self.reference == other.reference

    def __lt__(a, b):
        return a.target_node < b.target_node

class Revision(SchemaNodeOuter):
    """YANG revision

    https://tools.ietf.org/html/rfc7950#section-7.1.9.1
    """
    date: str
    description: ?str
    reference: ?str

    def __init__(self, date: str, description: ?str=None, reference: ?str=None, exts=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "revision"
        self.date = date
        self.description = description
        self.reference = reference
        self.exts = exts

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("description", self.description),
            ("reference", self.reference),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Revision(self.date,
                       description=self.description,
                       reference=self.reference,
                       exts=self.exts,
                       mod=new_mod if new_mod is not None else self.mod,
                       ns=new_ns if new_ns is not None else self.ns,
                       pfx=new_pfx if new_pfx is not None else self.pfx)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """


    def __str__(self):
        return "Revision {self.date}"

    def _get_class_name(self) -> str:
        return "Revision"

    def _get_argname(self) -> ?str:
        return 'date'

    def _get_arg(self) -> ?str:
        return self.date

extension Revision (Ord):
    def __eq__(self, other: Revision):
        return self.date == other.date and self.description == other.description and self.reference == other.reference

    def __lt__(a, b):
        return a.date < b.date

class Rpc(SchemaNodeInner):
    """YANG rpc

    https://tools.ietf.org/html/rfc7950#section-7.14.1
    """
    name: str
    description: ?str
    if_feature: list[str]
    input: ?Input
    output: ?Output
    reference: ?str
    status: ?str

    def __init__(self, name: str, description: ?str=None, if_feature: list[str]=[], input: ?Input=None, output: ?Output=None, reference: ?str=None, status: ?str=None, exts=[], children=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "rpc"
        self.name = name
        self.description = description
        self.if_feature = if_feature
        self.input = input
        self.output = output
        self.reference = reference
        self.status = status
        self.exts = exts
        self.children = children
        self_input = self.input
        if self_input is not None:
            self_input.parent = self
            n_mod = self_input.mod
            if n_mod is None:
                self_input.mod = self.mod
            n_ns = self_input.ns
            if n_ns is None:
                self_input.ns = self.ns
            n_pfx = self_input.pfx
            if n_pfx is None:
                self_input.pfx = self.pfx
        self_output = self.output
        if self_output is not None:
            self_output.parent = self
            n_mod = self_output.mod
            if n_mod is None:
                self_output.mod = self.mod
            n_ns = self_output.ns
            if n_ns is None:
                self_output.ns = self.ns
            n_pfx = self_output.pfx
            if n_pfx is None:
                self_output.pfx = self.pfx
        for n in self.children:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("input", self.input),
            ("output", self.output),
            ("reference", self.reference),
            ("status", self.status),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        for ref_if_feature in refine.if_feature:
            if ref_if_feature not in self.if_feature:
                self.if_feature.append(ref_if_feature)
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def get(self, name: str, ns: ?str=None) -> SchemaNode:
        # TODO: support looking up qualified by namespace
        #tns = ns if ns is not None else self.get_namespace()
        if name == 'input':
            _input = self.input
            if _input is not None:
                return _input
        if name == 'output':
            _output = self.output
            if _output is not None:
                return _output
        return SchemaNode.get(self, name, ns)

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        self_input = self.input
        self_output = self.output
        # new_input = self_input.compile(context) if self_input is not None else None # actonc codegen pre-evaluates before None-check
        new_input = None
        if self_input is not None:
            new_input = self_input.compile(context)
        # new_output = self_output.compile(context) if self_output is not None else None # actonc codegen pre-evaluates before None-check
        new_output = None
        if self_output is not None:
            new_output = self_output.compile(context)
        new = Rpc(self.name,
                  description=self.description,
                  if_feature=self.if_feature,
                  input=new_input if new_input is not None and isinstance(new_input, Input) else Input(),
                  output=new_output if new_output is not None and isinstance(new_output, Output) else Output(),
                  reference=self.reference,
                  status=self.status,
                  exts=self.exts,
                  mod=new_mod if new_mod is not None else self.mod,
                  ns=new_ns if new_ns is not None else self.ns,
                  pfx=new_pfx if new_pfx is not None else self.pfx)
        self.expand_children(context, new, new_ns, new_pfx)
        return new

    def to_dnode(self) -> DRpc:
        # Convert SchemaNode Rpc.input/output to DRpc.input/output and add to
        # its children, but only if Input and Output actually contain data
        # nodes.
        dnode_children = []
        self_input = self.input
        if self_input is not None and len(self_input.children) > 0:
            input_dnode = self_input.to_dnode()
            dnode_children.append(input_dnode)
        else:
            input_dnode = None
        self_output = self.output
        if self_output is not None and len(self_output.children) > 0:
            output_dnode = self_output.to_dnode()
            dnode_children.append(output_dnode)
        else:
            output_dnode = None

        new_dnode = DRpc(
            module=self.get_module_name(),
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            description=self.description,
            if_feature=self.if_feature,
            input=input_dnode if isinstance(input_dnode, DInput) else None,
            output=output_dnode if isinstance(output_dnode, DOutput) else None,
            reference=self.reference,
            status=self.status,
            exts=self.exts,
            children=dnode_children
        )
        return new_dnode

    def is_config(self) -> bool:
        return False

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod

        # Recursively update children
        for child in self.children:
            child.update_namespace_qualifiers(new_ns, new_pfx, new_mod)


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        for child in self.children:
            child.remap_prefix_references(old_pfx, new_pfx)

        self.if_feature = [_remap_path_prefix(f, old_pfx, new_pfx) for f in self.if_feature]

    def __str__(self):
        return "Rpc {self.name}"

    def _get_class_name(self) -> str:
        return "Rpc"

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Rpc (Ord):
    def __eq__(self, other: Rpc):
        return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.input == other.input and self.output == other.output and self.reference == other.reference and self.status == other.status

    def __lt__(a, b):
        return a.name < b.name

class Submodule(SchemaNodeInner):
    """YANG submodule

    https://tools.ietf.org/html/rfc7950#section-7.2.1
    """
    name: str
    yang_version: float
    import_: list[Import]
    include: list[Include]
    organization: ?str
    contact: ?str
    description: ?str
    reference: ?str
    revision: list[Revision]
    belongs_to: BelongsTo
    augment: list[Augment]
    deviation: list[str]
    extension_: list[Extension]
    feature: list[Feature]

    def __init__(self, name: str, belongs_to: BelongsTo, yang_version: float=1.1, augment: list[Augment]=[], contact: ?str=None, description: ?str=None, deviation: list[str]=[], extension_: list[Extension]=[], feature: list[Feature]=[], import_: list[Import]=[], include: list[Include]=[], organization: ?str=None, reference: ?str=None, revision: list[Revision]=[], exts=[], children=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "submodule"
        self.name = name
        self.augment = augment
        self.belongs_to = belongs_to
        self.contact = contact
        self.description = description
        self.deviation = deviation
        self.extension_ = extension_
        self.feature = feature
        self.import_ = import_
        self.include = include
        self.organization = organization
        self.reference = reference
        self.revision = revision
        self.yang_version = yang_version
        self.exts = exts
        self.children = children
        for n in self.augment:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx
        self.belongs_to.parent = self
        n_mod = self.belongs_to.mod
        if n_mod is None:
            self.belongs_to.mod = self.mod
        n_ns = self.belongs_to.ns
        if n_ns is None:
            self.belongs_to.ns = self.ns
        n_pfx = self.belongs_to.pfx
        if n_pfx is None:
            self.belongs_to.pfx = self.pfx
        for n in self.extension_:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx
        for n in self.feature:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx
        for n in self.import_:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx
        for n in self.include:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx
        for n in self.revision:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx
        for n in self.children:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("yang-version", self.yang_version),
            ("import", self.import_),
            ("include", self.include),
            ("organization", self.organization),
            ("contact", self.contact),
            ("description", self.description),
            ("reference", self.reference),
            ("revision", self.revision),
            ("belongs-to", self.belongs_to),
            ("augment", self.augment),
            ("deviation", self.deviation),
            ("extension", self.extension_),
            ("feature", self.feature),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def get_modrev(self) -> ModRev:
        rev = self.get_revision()
        rev_date = rev.date if rev is not None else None
        return ModRev(self.name, rev_date)

    def get_revision(self) -> ?Revision:
        latest = None
        for rev in self.revision:
            if latest is None or (latest is not None and rev.date > latest.date):
                latest = rev
        return latest

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Submodule(self.name,
                        yang_version=self.yang_version,
                        import_=self.import_,
                        include=self.include,
                        organization=self.organization,
                        contact=self.contact,
                        description=self.description,
                        reference=self.reference,
                        revision=self.revision,
                        belongs_to=self.belongs_to,
                        augment=self.augment,
                        deviation=self.deviation,
                        extension_=self.extension_,
                        feature=self.feature,
                        exts=self.exts)
        self.expand_children(context, new, new_mod, new_ns, new_pfx)
        new.expand_augments(context)
        return new

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod

        # Recursively update children
        for child in self.children:
            child.update_namespace_qualifiers(new_ns, new_pfx, new_mod)


    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        for child in self.children:
            child.remap_prefix_references(old_pfx, new_pfx)

        self.deviation = [_remap_path_prefix(d, old_pfx, new_pfx) for d in self.deviation]

    def __str__(self):
        return "Submodule {self.name}"

    def _get_class_name(self) -> str:
        return "Submodule"

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Submodule (Ord):
    def __eq__(self, other: Submodule):
        return self.name == other.name and self.augment == other.augment and self.belongs_to == other.belongs_to and self.contact == other.contact and self.description == other.description and self.deviation == other.deviation and self.extension_ == other.extension_ and self.feature == other.feature and self.import_ == other.import_ and self.include == other.include and self.organization == other.organization and self.reference == other.reference and self.revision == other.revision and self.yang_version == other.yang_version

    def __lt__(a, b):
        return a.name < b.name

class Type(SchemaNodeOuter):
    """YANG type

    https://tools.ietf.org/html/rfc7950#section-7.4.1
    """
    name: str
    base: list[str]
    bit: list[Bit]
    enum: list[Enum]
    fraction_digits: ?int
    length: ?Length
    path: ?str
    pattern: list[Pattern]
    range_: ?Range
    require_instance: ?bool
    type_: list[Type]

    def __init__(self, name: str, base: list[str]=[], bit: list[Bit]=[], enum: list[Enum]=[], fraction_digits: ?int=None, length: ?Length=None, path: ?str=None, pattern: list[Pattern]=[], range_: ?Range=None, require_instance: ?bool=None, type_: list[Type]=[], exts=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "type"
        self.name = name
        self.base = base
        self.bit = bit
        self.enum = enum
        self.fraction_digits = fraction_digits
        self.length = length
        self.path = path
        self.pattern = pattern
        self.range_ = range_
        self.require_instance = require_instance
        self.type_ = type_
        self.exts = exts
        for n in self.bit:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx
        for n in self.enum:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx
        self_length = self.length
        if self_length is not None:
            self_length.parent = self
            n_mod = self_length.mod
            if n_mod is None:
                self_length.mod = self.mod
            n_ns = self_length.ns
            if n_ns is None:
                self_length.ns = self.ns
            n_pfx = self_length.pfx
            if n_pfx is None:
                self_length.pfx = self.pfx
        for n in self.pattern:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx
        self_range_ = self.range_
        if self_range_ is not None:
            self_range_.parent = self
            n_mod = self_range_.mod
            if n_mod is None:
                self_range_.mod = self.mod
            n_ns = self_range_.ns
            if n_ns is None:
                self_range_.ns = self.ns
            n_pfx = self_range_.pfx
            if n_pfx is None:
                self_range_.pfx = self.pfx
        for n in self.type_:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("base", self.base),
            ("bit", self.bit),
            ("enum", self.enum),
            ("fraction-digits", self.fraction_digits),
            ("length", self.length),
            ("path", self.path),
            ("pattern", self.pattern),
            ("range", self.range_),
            ("require-instance", self.require_instance),
            ("type", self.type_),
            ("exts", self.exts),
        ]

    def resolve_type(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None, recursion_level=0, _top_name: ?str=None):
        top_name = _top_name if _top_name is not None else self.name
        if recursion_level >= RECURSION_LIMIT:
            raise ValueError("Recursion limit reached for typedef {top_name}")

        if self.name in _builtin_types:
            if self.name == "identityref":
                # Normalize identity base to always include the origin module prefix. In doing
                # so we make it easier to later look up bases in DIdentity.
                fq_base = []
                for base in self.base:
                    base_identity = self.get_identity(base, context)
                    fq_base.append("{base_identity.pfx}:{base_identity.name}")

                return ResolvedType(
                        self.name,
                        base=fq_base,
                        require_instance=self.require_instance,
                        exts=self.exts,
                        mod=self.mod,
                        ns=self.ns,
                        pfx=self.pfx)

            elif self.name == "union":
                # Resolve union types
                resolved_union_types = [ut.resolve_type(context, new_mod, new_ns, new_pfx, recursion_level + 1, top_name) for ut in self.type_]
                return ResolvedType(self.name,
                        base=self.base,
                        type_=resolved_union_types,
                        mod=self.mod,
                        ns=self.ns,
                        pfx=self.pfx)

            # Remaining builtin types
            return ResolvedType(
                    self.name,
                    base=self.base,
                    bit=self.bit,
                    enum=self.enum,
                    fraction_digits=self.fraction_digits,
                    length=self.length,
                    path=self.path,
                    pattern=self.pattern,
                    range_=self.range_,
                    require_instance=self.require_instance,
                    type_=self.type_,
                    exts=self.exts,
                    mod=self.mod,
                    ns=self.ns,
                    pfx=self.pfx)

        new_name = self.name
        orig_prefix = self.get_prefix()
        if new_pfx is not None and new_pfx != orig_prefix:
            # Add explicit prefix when part of grouping expanded into other module
            prefix, name = split_prefix_name(self.name)
            if prefix is None:
                new_name = "{orig_prefix}:{name}"

        found_typedef = self.get_typedef(new_name, context)
        resolved_typedef = found_typedef.resolve_typedef(context, new_mod, new_ns, new_pfx, recursion_level + 1, top_name)

        return ResolvedType(
                new_name,
                base=self.base,
                bit=self.bit,
                enum=self.enum,
                fraction_digits=self.fraction_digits,
                length=self.length,
                path=self.path,
                pattern=self.pattern,
                range_=self.range_,
                require_instance=self.require_instance,
                type_=self.type_,
                exts=self.exts,
                mod=self.mod,
                ns=self.ns,
                pfx=self.pfx,
                resolved_base_typedef=resolved_typedef)

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        return self.resolve_type(context, new_mod, new_ns, new_pfx)

    def to_dtype(self) -> DType:
        raise NotImplementedError("Type.to_dtype: expect call to ResolvedType instead")

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod

        for nested_type in self.type_:
            nested_type.update_namespace_qualifiers(new_ns, new_pfx, new_mod)

    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        self.base = [_remap_path_prefix(b, old_pfx, new_pfx) for b in self.base]
        self_path = self.path
        if self_path is not None:
            self.path = _remap_path_prefix(self_path, old_pfx, new_pfx)
        self.name = _remap_path_prefix(self.name, old_pfx, new_pfx)
        for nested_type in self.type_:
            nested_type.remap_prefix_references(old_pfx, new_pfx)

    def __str__(self):
        return "Type {self.name}"

    def _get_class_name(self) -> str:
        return "Type"

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Type (Ord):
    def __eq__(self, other: Type):
        return self.name == other.name and self.base == other.base and self.bit == other.bit and self.enum == other.enum and self.fraction_digits == other.fraction_digits and self.length == other.length and self.path == other.path and self.pattern == other.pattern and self.range_ == other.range_ and self.require_instance == other.require_instance and self.type_ == other.type_

    def __lt__(a, b):
        return a.name < b.name

class Typedef(SchemaNodeOuter):
    """YANG typedef

    https://tools.ietf.org/html/rfc7950#section-7.3.1
    """
    name: str
    type_: Type
    default: ?str
    description: ?str
    reference: ?str
    status: ?str
    units: ?str

    def __init__(self, name: str, type_: Type, default: ?str=None, description: ?str=None, reference: ?str=None, status: ?str=None, units: ?str=None, exts=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "typedef"
        self.name = name
        self.default = default
        self.description = description
        self.reference = reference
        self.status = status
        self.type_ = type_
        self.units = units
        self.exts = exts
        self.type_.parent = self
        n_mod = self.type_.mod
        if n_mod is None:
            self.type_.mod = self.mod
        n_ns = self.type_.ns
        if n_ns is None:
            self.type_.ns = self.ns
        n_pfx = self.type_.pfx
        if n_pfx is None:
            self.type_.pfx = self.pfx

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("type", self.type_),
            ("default", self.default),
            ("description", self.description),
            ("reference", self.reference),
            ("status", self.status),
            ("units", self.units),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        if len(refine.default) == 1:
            self.default = refine.default[0]
        elif len(refine.default) > 1:
            raise ValueError("Attempting to refine default with multiple values")
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def resolve_typedef(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None, recursion_level=0, _top_name: ?str=None):
        top_name = _top_name if _top_name is not None else self.name
        if recursion_level >= RECURSION_LIMIT:
            raise ValueError("Recursion limit reached for typedef {top_name}")

        resolved_base_type = self.type_.resolve_type(context, new_mod, new_ns, new_pfx)

        new = Typedef(self.name,
                      default=self.default,
                      description=self.description,
                      reference=self.reference,
                      status=self.status,
                      type_=resolved_base_type,
                      units=self.units,
                      exts=self.exts)

        resolved_base_type.parent = new

        return new

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        return self.resolve_typedef(context)

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod

        self.type_.update_namespace_qualifiers(new_ns, new_pfx, new_mod)

    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        if self.type_.name == 'identityref':
            self_default = self.default
            if self_default is not None:
                self.default = _remap_path_prefix(self_default, old_pfx, new_pfx)
        self.type_.remap_prefix_references(old_pfx, new_pfx)

    def __str__(self):
        return "Typedef {self.name}"

    def _get_class_name(self) -> str:
        return "Typedef"

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Typedef (Ord):
    def __eq__(self, other: Typedef):
        return self.name == other.name and self.default == other.default and self.description == other.description and self.reference == other.reference and self.status == other.status and self.type_ == other.type_ and self.units == other.units

    def __lt__(a, b):
        return a.name < b.name

class Uses(SchemaNodeOuter):
    """YANG uses

    https://tools.ietf.org/html/rfc7950#section-7.13.1
    """
    name: str
    augment: list[Augment]
    description: ?str
    if_feature: list[str]
    reference: ?str
    refine: list[Refine]
    status: ?str
    when: ?str

    def __init__(self, name: str, augment: list[Augment]=[], description: ?str=None, if_feature: list[str]=[], reference: ?str=None, refine: list[Refine]=[], status: ?str=None, when: ?str=None, exts=[], parent=None, mod=None, ns=None, pfx=None):
        self.parent = parent
        new_mod = mod
        new_ns = ns
        new_pfx = pfx
        if new_mod is None and parent is not None:
            new_mod = parent.mod
        if new_ns is None and parent is not None:
            new_ns = parent.ns
        if new_pfx is None and parent is not None:
            new_pfx = parent.pfx
        self.mod = new_mod
        self.ns = new_ns
        self.pfx = new_pfx
        self._yname = "uses"
        self.name = name
        self.augment = augment
        self.description = description
        self.if_feature = if_feature
        self.reference = reference
        self.refine = refine
        self.status = status
        self.when = when
        self.exts = exts
        for n in self.augment:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx
        for n in self.refine:
            n.parent = self
            n_mod = n.mod
            if n_mod is None:
                n.mod = self.mod
            n_ns = n.ns
            if n_ns is None:
                n.ns = self.ns
            n_pfx = n.pfx
            if n_pfx is None:
                n.pfx = self.pfx

    def get_attrs(self) -> list[(str, ?value)]:
        return [
            ("augment", self.augment),
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("reference", self.reference),
            ("refine", self.refine),
            ("status", self.status),
            ("when", self.when),
            ("exts", self.exts),
        ]

    mut def apply_refine(self, refine: Refine):
        ref_description = refine.description
        if ref_description is not None:
            self.description = ref_description
        for ref_if_feature in refine.if_feature:
            if ref_if_feature not in self.if_feature:
                self.if_feature.append(ref_if_feature)
        ref_reference = refine.reference
        if ref_reference is not None:
            self.reference = ref_reference
        self.exts.extend(refine.exts)

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        raise ValueError("Cannot compile 'uses'")

    mut def expand_refines(self, target_base: SchemaNode):
        """Expand refinements in the uses statement to the target nodes

        target_base is the SchemaNode where this uses statement is located
        """
        def get_target(target_base, target: str):
            parts = target.lstrip("/").split("/")
            current_node = target_base
            for part in parts:
                prefix, name = split_prefix_name(part)
                if prefix is not None:
                    # TODO: or is prefix OK when it is the local prefix?
                    raise ValueError("Relative path in refine under uses cannot have prefixes")
                # Must use the Uses statement namespace (self.get_namespace()),
                # not default match with target (current_node).
                # In cross-module augments (Module A augments Module B), the
                # groupings expanded children have Module A namespace while the
                # target has Module B. Without an explicit namespace,
                # current_node.get() would search Module B namespace and fail.
                current_node = current_node.get(name, ns=self.get_namespace())
            return current_node

        for refine in self.refine:
            target = get_target(target_base, refine.target_node)
            target.apply_refine(refine)

    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:
        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.
        """
        self.ns = new_ns
        self.pfx = new_pfx
        self.mod = new_mod

        for refine in self.refine:
            refine.update_namespace_qualifiers(new_ns, new_pfx, new_mod)
        for aug in self.augment:
            aug.update_namespace_qualifiers(new_ns, new_pfx, new_mod)

    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        self.if_feature = [_remap_path_prefix(f, old_pfx, new_pfx) for f in self.if_feature]
        self_when = self.when
        if self_when is not None:
            self.when = _remap_path_prefix(self_when, old_pfx, new_pfx)
        self.name = _remap_path_prefix(self.name, old_pfx, new_pfx)
        for refine in self.refine:
            refine.target_node = _remap_path_prefix(refine.target_node, old_pfx, new_pfx)
            refine.remap_prefix_references(old_pfx, new_pfx)
        for aug in self.augment:
            aug.target_node = _remap_path_prefix(aug.target_node, old_pfx, new_pfx)
            aug.remap_prefix_references(old_pfx, new_pfx)

    def __str__(self):
        return "Uses {self.name}"

    def _get_class_name(self) -> str:
        return "Uses"

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Uses (Ord):
    def __eq__(self, other: Uses):
        return self.name == other.name and self.augment == other.augment and self.description == other.description and self.if_feature == other.if_feature and self.reference == other.reference and self.refine == other.refine and self.status == other.status and self.when == other.when

    def __lt__(a, b):
        return a.name < b.name

def take_opt_action(stmts: list[Statement]) -> ?Action:
    for node in take_nodes(stmts, ["action"]):
        if isinstance(node, Action):
            return node

def take_action(stmts: list[Statement]) -> Action:
    for node in take_nodes(stmts, ["action"]):
        if isinstance(node, Action):
            return node
    raise ValueError("No action in stmts")

def take_actions(stmts: list[Statement]) -> list[Action]:
    res = []
    for node in take_nodes(stmts, ["action"]):
        if isinstance(node, Action):
            res.append(node)
    return res

def take_opt_anydata(stmts: list[Statement]) -> ?Anydata:
    for node in take_nodes(stmts, ["anydata"]):
        if isinstance(node, Anydata):
            return node

def take_anydata(stmts: list[Statement]) -> Anydata:
    for node in take_nodes(stmts, ["anydata"]):
        if isinstance(node, Anydata):
            return node
    raise ValueError("No anydata in stmts")

def take_anydatas(stmts: list[Statement]) -> list[Anydata]:
    res = []
    for node in take_nodes(stmts, ["anydata"]):
        if isinstance(node, Anydata):
            res.append(node)
    return res

def take_opt_anyxml(stmts: list[Statement]) -> ?Anyxml:
    for node in take_nodes(stmts, ["anyxml"]):
        if isinstance(node, Anyxml):
            return node

def take_anyxml(stmts: list[Statement]) -> Anyxml:
    for node in take_nodes(stmts, ["anyxml"]):
        if isinstance(node, Anyxml):
            return node
    raise ValueError("No anyxml in stmts")

def take_anyxmls(stmts: list[Statement]) -> list[Anyxml]:
    res = []
    for node in take_nodes(stmts, ["anyxml"]):
        if isinstance(node, Anyxml):
            res.append(node)
    return res

def take_opt_augment(stmts: list[Statement]) -> ?Augment:
    for node in take_nodes(stmts, ["augment"]):
        if isinstance(node, Augment):
            return node

def take_augment(stmts: list[Statement]) -> Augment:
    for node in take_nodes(stmts, ["augment"]):
        if isinstance(node, Augment):
            return node
    raise ValueError("No augment in stmts")

def take_augments(stmts: list[Statement]) -> list[Augment]:
    res = []
    for node in take_nodes(stmts, ["augment"]):
        if isinstance(node, Augment):
            res.append(node)
    return res

def take_opt_belongs_to(stmts: list[Statement]) -> ?BelongsTo:
    for node in take_nodes(stmts, ["belongs-to"]):
        if isinstance(node, BelongsTo):
            return node

def take_belongs_to(stmts: list[Statement]) -> BelongsTo:
    for node in take_nodes(stmts, ["belongs-to"]):
        if isinstance(node, BelongsTo):
            return node
    raise ValueError("No belongs-to in stmts")

def take_belongs_tos(stmts: list[Statement]) -> list[BelongsTo]:
    res = []
    for node in take_nodes(stmts, ["belongs-to"]):
        if isinstance(node, BelongsTo):
            res.append(node)
    return res

def take_opt_bit(stmts: list[Statement]) -> ?Bit:
    for node in take_nodes(stmts, ["bit"]):
        if isinstance(node, Bit):
            return node

def take_bit(stmts: list[Statement]) -> Bit:
    for node in take_nodes(stmts, ["bit"]):
        if isinstance(node, Bit):
            return node
    raise ValueError("No bit in stmts")

def take_bits(stmts: list[Statement]) -> list[Bit]:
    res = []
    for node in take_nodes(stmts, ["bit"]):
        if isinstance(node, Bit):
            res.append(node)
    return res

def take_opt_case(stmts: list[Statement]) -> ?Case:
    for node in take_nodes(stmts, ["case"]):
        if isinstance(node, Case):
            return node

def take_case(stmts: list[Statement]) -> Case:
    for node in take_nodes(stmts, ["case"]):
        if isinstance(node, Case):
            return node
    raise ValueError("No case in stmts")

def take_cases(stmts: list[Statement]) -> list[Case]:
    res = []
    for node in take_nodes(stmts, ["case"]):
        if isinstance(node, Case):
            res.append(node)
    return res

def take_opt_choice(stmts: list[Statement]) -> ?Choice:
    for node in take_nodes(stmts, ["choice"]):
        if isinstance(node, Choice):
            return node

def take_choice(stmts: list[Statement]) -> Choice:
    for node in take_nodes(stmts, ["choice"]):
        if isinstance(node, Choice):
            return node
    raise ValueError("No choice in stmts")

def take_choices(stmts: list[Statement]) -> list[Choice]:
    res = []
    for node in take_nodes(stmts, ["choice"]):
        if isinstance(node, Choice):
            res.append(node)
    return res

def take_opt_container(stmts: list[Statement]) -> ?Container:
    for node in take_nodes(stmts, ["container"]):
        if isinstance(node, Container):
            return node

def take_container(stmts: list[Statement]) -> Container:
    for node in take_nodes(stmts, ["container"]):
        if isinstance(node, Container):
            return node
    raise ValueError("No container in stmts")

def take_containers(stmts: list[Statement]) -> list[Container]:
    res = []
    for node in take_nodes(stmts, ["container"]):
        if isinstance(node, Container):
            res.append(node)
    return res

def take_opt_enum(stmts: list[Statement]) -> ?Enum:
    for node in take_nodes(stmts, ["enum"]):
        if isinstance(node, Enum):
            return node

def take_enum(stmts: list[Statement]) -> Enum:
    for node in take_nodes(stmts, ["enum"]):
        if isinstance(node, Enum):
            return node
    raise ValueError("No enum in stmts")

def take_enums(stmts: list[Statement]) -> list[Enum]:
    res = []
    for node in take_nodes(stmts, ["enum"]):
        if isinstance(node, Enum):
            res.append(node)
    return res

def take_opt_extension(stmts: list[Statement]) -> ?Extension:
    for node in take_nodes(stmts, ["extension"]):
        if isinstance(node, Extension):
            return node

def take_extension(stmts: list[Statement]) -> Extension:
    for node in take_nodes(stmts, ["extension"]):
        if isinstance(node, Extension):
            return node
    raise ValueError("No extension in stmts")

def take_extensions(stmts: list[Statement]) -> list[Extension]:
    res = []
    for node in take_nodes(stmts, ["extension"]):
        if isinstance(node, Extension):
            res.append(node)
    return res

def take_opt_feature(stmts: list[Statement]) -> ?Feature:
    for node in take_nodes(stmts, ["feature"]):
        if isinstance(node, Feature):
            return node

def take_feature(stmts: list[Statement]) -> Feature:
    for node in take_nodes(stmts, ["feature"]):
        if isinstance(node, Feature):
            return node
    raise ValueError("No feature in stmts")

def take_features(stmts: list[Statement]) -> list[Feature]:
    res = []
    for node in take_nodes(stmts, ["feature"]):
        if isinstance(node, Feature):
            res.append(node)
    return res

def take_opt_grouping(stmts: list[Statement]) -> ?Grouping:
    for node in take_nodes(stmts, ["grouping"]):
        if isinstance(node, Grouping):
            return node

def take_grouping(stmts: list[Statement]) -> Grouping:
    for node in take_nodes(stmts, ["grouping"]):
        if isinstance(node, Grouping):
            return node
    raise ValueError("No grouping in stmts")

def take_groupings(stmts: list[Statement]) -> list[Grouping]:
    res = []
    for node in take_nodes(stmts, ["grouping"]):
        if isinstance(node, Grouping):
            res.append(node)
    return res

def take_opt_identity(stmts: list[Statement]) -> ?Identity:
    for node in take_nodes(stmts, ["identity"]):
        if isinstance(node, Identity):
            return node

def take_identity(stmts: list[Statement]) -> Identity:
    for node in take_nodes(stmts, ["identity"]):
        if isinstance(node, Identity):
            return node
    raise ValueError("No identity in stmts")

def take_identitys(stmts: list[Statement]) -> list[Identity]:
    res = []
    for node in take_nodes(stmts, ["identity"]):
        if isinstance(node, Identity):
            res.append(node)
    return res

def take_opt_import(stmts: list[Statement]) -> ?Import:
    for node in take_nodes(stmts, ["import"]):
        if isinstance(node, Import):
            return node

def take_import(stmts: list[Statement]) -> Import:
    for node in take_nodes(stmts, ["import"]):
        if isinstance(node, Import):
            return node
    raise ValueError("No import in stmts")

def take_imports(stmts: list[Statement]) -> list[Import]:
    res = []
    for node in take_nodes(stmts, ["import"]):
        if isinstance(node, Import):
            res.append(node)
    return res

def take_opt_include(stmts: list[Statement]) -> ?Include:
    for node in take_nodes(stmts, ["include"]):
        if isinstance(node, Include):
            return node

def take_include(stmts: list[Statement]) -> Include:
    for node in take_nodes(stmts, ["include"]):
        if isinstance(node, Include):
            return node
    raise ValueError("No include in stmts")

def take_includes(stmts: list[Statement]) -> list[Include]:
    res = []
    for node in take_nodes(stmts, ["include"]):
        if isinstance(node, Include):
            res.append(node)
    return res

def take_opt_input(stmts: list[Statement]) -> ?Input:
    for node in take_nodes(stmts, ["input"]):
        if isinstance(node, Input):
            return node

def take_input(stmts: list[Statement]) -> Input:
    for node in take_nodes(stmts, ["input"]):
        if isinstance(node, Input):
            return node
    raise ValueError("No input in stmts")

def take_inputs(stmts: list[Statement]) -> list[Input]:
    res = []
    for node in take_nodes(stmts, ["input"]):
        if isinstance(node, Input):
            res.append(node)
    return res

def take_opt_leaf(stmts: list[Statement]) -> ?Leaf:
    for node in take_nodes(stmts, ["leaf"]):
        if isinstance(node, Leaf):
            return node

def take_leaf(stmts: list[Statement]) -> Leaf:
    for node in take_nodes(stmts, ["leaf"]):
        if isinstance(node, Leaf):
            return node
    raise ValueError("No leaf in stmts")

def take_leafs(stmts: list[Statement]) -> list[Leaf]:
    res = []
    for node in take_nodes(stmts, ["leaf"]):
        if isinstance(node, Leaf):
            res.append(node)
    return res

def take_opt_leaf_list(stmts: list[Statement]) -> ?LeafList:
    for node in take_nodes(stmts, ["leaf-list"]):
        if isinstance(node, LeafList):
            return node

def take_leaf_list(stmts: list[Statement]) -> LeafList:
    for node in take_nodes(stmts, ["leaf-list"]):
        if isinstance(node, LeafList):
            return node
    raise ValueError("No leaf-list in stmts")

def take_leaf_lists(stmts: list[Statement]) -> list[LeafList]:
    res = []
    for node in take_nodes(stmts, ["leaf-list"]):
        if isinstance(node, LeafList):
            res.append(node)
    return res

def take_opt_length(stmts: list[Statement]) -> ?Length:
    for node in take_nodes(stmts, ["length"]):
        if isinstance(node, Length):
            return node

def take_length(stmts: list[Statement]) -> Length:
    for node in take_nodes(stmts, ["length"]):
        if isinstance(node, Length):
            return node
    raise ValueError("No length in stmts")

def take_lengths(stmts: list[Statement]) -> list[Length]:
    res = []
    for node in take_nodes(stmts, ["length"]):
        if isinstance(node, Length):
            res.append(node)
    return res

def take_opt_list(stmts: list[Statement]) -> ?List:
    for node in take_nodes(stmts, ["list"]):
        if isinstance(node, List):
            return node

def take_list(stmts: list[Statement]) -> List:
    for node in take_nodes(stmts, ["list"]):
        if isinstance(node, List):
            return node
    raise ValueError("No list in stmts")

def take_lists(stmts: list[Statement]) -> list[List]:
    res = []
    for node in take_nodes(stmts, ["list"]):
        if isinstance(node, List):
            res.append(node)
    return res

def take_opt_module(stmts: list[Statement]) -> ?Module:
    for node in take_nodes(stmts, ["module"]):
        if isinstance(node, Module):
            return node

def take_module(stmts: list[Statement]) -> Module:
    for node in take_nodes(stmts, ["module"]):
        if isinstance(node, Module):
            return node
    raise ValueError("No module in stmts")

def take_modules(stmts: list[Statement]) -> list[Module]:
    res = []
    for node in take_nodes(stmts, ["module"]):
        if isinstance(node, Module):
            res.append(node)
    return res

def take_opt_must(stmts: list[Statement]) -> ?Must:
    for node in take_nodes(stmts, ["must"]):
        if isinstance(node, Must):
            return node

def take_must(stmts: list[Statement]) -> Must:
    for node in take_nodes(stmts, ["must"]):
        if isinstance(node, Must):
            return node
    raise ValueError("No must in stmts")

def take_musts(stmts: list[Statement]) -> list[Must]:
    res = []
    for node in take_nodes(stmts, ["must"]):
        if isinstance(node, Must):
            res.append(node)
    return res

def take_opt_notification(stmts: list[Statement]) -> ?Notification:
    for node in take_nodes(stmts, ["notification"]):
        if isinstance(node, Notification):
            return node

def take_notification(stmts: list[Statement]) -> Notification:
    for node in take_nodes(stmts, ["notification"]):
        if isinstance(node, Notification):
            return node
    raise ValueError("No notification in stmts")

def take_notifications(stmts: list[Statement]) -> list[Notification]:
    res = []
    for node in take_nodes(stmts, ["notification"]):
        if isinstance(node, Notification):
            res.append(node)
    return res

def take_opt_output(stmts: list[Statement]) -> ?Output:
    for node in take_nodes(stmts, ["output"]):
        if isinstance(node, Output):
            return node

def take_output(stmts: list[Statement]) -> Output:
    for node in take_nodes(stmts, ["output"]):
        if isinstance(node, Output):
            return node
    raise ValueError("No output in stmts")

def take_outputs(stmts: list[Statement]) -> list[Output]:
    res = []
    for node in take_nodes(stmts, ["output"]):
        if isinstance(node, Output):
            res.append(node)
    return res

def take_opt_pattern(stmts: list[Statement]) -> ?Pattern:
    for node in take_nodes(stmts, ["pattern"]):
        if isinstance(node, Pattern):
            return node

def take_pattern(stmts: list[Statement]) -> Pattern:
    for node in take_nodes(stmts, ["pattern"]):
        if isinstance(node, Pattern):
            return node
    raise ValueError("No pattern in stmts")

def take_patterns(stmts: list[Statement]) -> list[Pattern]:
    res = []
    for node in take_nodes(stmts, ["pattern"]):
        if isinstance(node, Pattern):
            res.append(node)
    return res

def take_opt_range(stmts: list[Statement]) -> ?Range:
    for node in take_nodes(stmts, ["range"]):
        if isinstance(node, Range):
            return node

def take_range(stmts: list[Statement]) -> Range:
    for node in take_nodes(stmts, ["range"]):
        if isinstance(node, Range):
            return node
    raise ValueError("No range in stmts")

def take_ranges(stmts: list[Statement]) -> list[Range]:
    res = []
    for node in take_nodes(stmts, ["range"]):
        if isinstance(node, Range):
            res.append(node)
    return res

def take_opt_refine(stmts: list[Statement]) -> ?Refine:
    for node in take_nodes(stmts, ["refine"]):
        if isinstance(node, Refine):
            return node

def take_refine(stmts: list[Statement]) -> Refine:
    for node in take_nodes(stmts, ["refine"]):
        if isinstance(node, Refine):
            return node
    raise ValueError("No refine in stmts")

def take_refines(stmts: list[Statement]) -> list[Refine]:
    res = []
    for node in take_nodes(stmts, ["refine"]):
        if isinstance(node, Refine):
            res.append(node)
    return res

def take_opt_revision(stmts: list[Statement]) -> ?Revision:
    for node in take_nodes(stmts, ["revision"]):
        if isinstance(node, Revision):
            return node

def take_revision(stmts: list[Statement]) -> Revision:
    for node in take_nodes(stmts, ["revision"]):
        if isinstance(node, Revision):
            return node
    raise ValueError("No revision in stmts")

def take_revisions(stmts: list[Statement]) -> list[Revision]:
    res = []
    for node in take_nodes(stmts, ["revision"]):
        if isinstance(node, Revision):
            res.append(node)
    return res

def take_opt_rpc(stmts: list[Statement]) -> ?Rpc:
    for node in take_nodes(stmts, ["rpc"]):
        if isinstance(node, Rpc):
            return node

def take_rpc(stmts: list[Statement]) -> Rpc:
    for node in take_nodes(stmts, ["rpc"]):
        if isinstance(node, Rpc):
            return node
    raise ValueError("No rpc in stmts")

def take_rpcs(stmts: list[Statement]) -> list[Rpc]:
    res = []
    for node in take_nodes(stmts, ["rpc"]):
        if isinstance(node, Rpc):
            res.append(node)
    return res

def take_opt_submodule(stmts: list[Statement]) -> ?Submodule:
    for node in take_nodes(stmts, ["submodule"]):
        if isinstance(node, Submodule):
            return node

def take_submodule(stmts: list[Statement]) -> Submodule:
    for node in take_nodes(stmts, ["submodule"]):
        if isinstance(node, Submodule):
            return node
    raise ValueError("No submodule in stmts")

def take_submodules(stmts: list[Statement]) -> list[Submodule]:
    res = []
    for node in take_nodes(stmts, ["submodule"]):
        if isinstance(node, Submodule):
            res.append(node)
    return res

def take_opt_type(stmts: list[Statement]) -> ?Type:
    for node in take_nodes(stmts, ["type"]):
        if isinstance(node, Type):
            return node

def take_type(stmts: list[Statement]) -> Type:
    for node in take_nodes(stmts, ["type"]):
        if isinstance(node, Type):
            return node
    raise ValueError("No type in stmts")

def take_types(stmts: list[Statement]) -> list[Type]:
    res = []
    for node in take_nodes(stmts, ["type"]):
        if isinstance(node, Type):
            res.append(node)
    return res

def take_opt_typedef(stmts: list[Statement]) -> ?Typedef:
    for node in take_nodes(stmts, ["typedef"]):
        if isinstance(node, Typedef):
            return node

def take_typedef(stmts: list[Statement]) -> Typedef:
    for node in take_nodes(stmts, ["typedef"]):
        if isinstance(node, Typedef):
            return node
    raise ValueError("No typedef in stmts")

def take_typedefs(stmts: list[Statement]) -> list[Typedef]:
    res = []
    for node in take_nodes(stmts, ["typedef"]):
        if isinstance(node, Typedef):
            res.append(node)
    return res

def take_opt_uses(stmts: list[Statement]) -> ?Uses:
    for node in take_nodes(stmts, ["uses"]):
        if isinstance(node, Uses):
            return node

def take_uses(stmts: list[Statement]) -> Uses:
    for node in take_nodes(stmts, ["uses"]):
        if isinstance(node, Uses):
            return node
    raise ValueError("No uses in stmts")

def take_usess(stmts: list[Statement]) -> list[Uses]:
    res = []
    for node in take_nodes(stmts, ["uses"]):
        if isinstance(node, Uses):
            res.append(node)
    return res

def stmt_to_snode(stmt: Statement, parent: ?SchemaNode=None) -> SchemaNode:
    arg = stmt.arg
    ss = stmt.substatements.copy()
    if stmt.kw == "action":
        if arg is not None:
            n = Action(arg,
                       description=take_opt_str(ss, "description"),
                       if_feature=take_strlist(ss, "if-feature"),
                       input=take_opt_input(ss),
                       output=take_opt_output(ss),
                       reference=take_opt_str(ss, "reference"),
                       status=take_opt_str(ss, "status"),
                       exts=take_exts(ss),
                       parent=parent
                       )
            n.children=take_nodes(ss, ["grouping", "typedef"], n)
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under action: {name}")
            return n
    if stmt.kw == "anydata":
        if arg is not None:
            n = Anydata(arg,
                        config=take_opt_bool(ss, "config"),
                        description=take_opt_str(ss, "description"),
                        if_feature=take_strlist(ss, "if-feature"),
                        mandatory=take_opt_bool(ss, "mandatory"),
                        must=take_musts(ss),
                        reference=take_opt_str(ss, "reference"),
                        status=take_opt_str(ss, "status"),
                        when=take_opt_str(ss, "when"),
                        exts=take_exts(ss),
                        parent=parent
                        )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under anydata: {name}")
            return n
    if stmt.kw == "anyxml":
        if arg is not None:
            n = Anyxml(arg,
                       config=take_opt_bool(ss, "config"),
                       description=take_opt_str(ss, "description"),
                       if_feature=take_strlist(ss, "if-feature"),
                       mandatory=take_opt_bool(ss, "mandatory"),
                       must=take_musts(ss),
                       reference=take_opt_str(ss, "reference"),
                       status=take_opt_str(ss, "status"),
                       when=take_opt_str(ss, "when"),
                       exts=take_exts(ss),
                       parent=parent
                       )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under anyxml: {name}")
            return n
    if stmt.kw == "augment":
        if arg is not None:
            n = Augment(arg,
                        description=take_opt_str(ss, "description"),
                        if_feature=take_strlist(ss, "if-feature"),
                        reference=take_opt_str(ss, "reference"),
                        status=take_opt_str(ss, "status"),
                        when=take_opt_str(ss, "when"),
                        exts=take_exts(ss),
                        parent=parent
                        )
            n.children=take_nodes(ss, ["action", "anydata", "anyxml", "case", "choice", "container", "leaf", "leaf-list", "list", "notification", "uses"], n)
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under augment: {name}")
            return n
    if stmt.kw == "belongs-to":
        if arg is not None:
            n = BelongsTo(arg,
                          prefix=take_str(ss, "prefix"),
                          exts=take_exts(ss),
                          parent=parent
                          )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under belongs-to: {name}")
            return n
    if stmt.kw == "bit":
        if arg is not None:
            n = Bit(arg,
                    description=take_opt_str(ss, "description"),
                    if_feature=take_strlist(ss, "if-feature"),
                    position=take_opt_int(ss, "position"),
                    reference=take_opt_str(ss, "reference"),
                    status=take_opt_str(ss, "status"),
                    exts=take_exts(ss),
                    parent=parent
                    )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under bit: {name}")
            return n
    if stmt.kw == "case":
        if arg is not None:
            n = Case(arg,
                     description=take_opt_str(ss, "description"),
                     if_feature=take_strlist(ss, "if-feature"),
                     reference=take_opt_str(ss, "reference"),
                     status=take_opt_str(ss, "status"),
                     when=take_opt_str(ss, "when"),
                     exts=take_exts(ss),
                     parent=parent
                     )
            n.children=take_nodes(ss, ["anydata", "anyxml", "choice", "container", "leaf", "leaf-list", "list", "uses"], n)
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under case: {name}")
            return n
    if stmt.kw == "choice":
        if arg is not None:
            n = Choice(arg,
                       config=take_opt_bool(ss, "config"),
                       default=take_opt_str(ss, "default"),
                       description=take_opt_str(ss, "description"),
                       if_feature=take_strlist(ss, "if-feature"),
                       mandatory=take_opt_bool(ss, "mandatory"),
                       reference=take_opt_str(ss, "reference"),
                       status=take_opt_str(ss, "status"),
                       when=take_opt_str(ss, "when"),
                       exts=take_exts(ss),
                       parent=parent
                       )
            n.children=take_nodes(ss, ["anydata", "anyxml", "case", "choice", "container", "leaf", "leaf-list", "list"], n)
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under choice: {name}")
            return n
    if stmt.kw == "container":
        if arg is not None:
            n = Container(arg,
                          config=take_opt_bool(ss, "config"),
                          description=take_opt_str(ss, "description"),
                          if_feature=take_strlist(ss, "if-feature"),
                          must=take_musts(ss),
                          presence=take_opt_str(ss, "presence"),
                          reference=take_opt_str(ss, "reference"),
                          status=take_opt_str(ss, "status"),
                          when=take_opt_str(ss, "when"),
                          exts=take_exts(ss),
                          parent=parent
                          )
            n.children=take_nodes(ss, ["action", "anydata", "anyxml", "choice", "container", "grouping", "leaf", "leaf-list", "list", "notification", "typedef", "uses"], n)
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under container: {name}")
            return n
    if stmt.kw == "enum":
        if arg is not None:
            n = Enum(arg,
                     description=take_opt_str(ss, "description"),
                     if_feature=take_strlist(ss, "if-feature"),
                     reference=take_opt_str(ss, "reference"),
                     status=take_opt_str(ss, "status"),
                     value=take_opt_str(ss, "value"),
                     exts=take_exts(ss),
                     parent=parent
                     )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under enum: {name}")
            return n
    if stmt.kw == "extension":
        if arg is not None:
            n = Extension(arg,
                          argument=take_opt_str(ss, "argument"),
                          description=take_opt_str(ss, "description"),
                          reference=take_opt_str(ss, "reference"),
                          status=take_opt_str(ss, "status"),
                          exts=take_exts(ss),
                          parent=parent
                          )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under extension: {name}")
            return n
    if stmt.kw == "feature":
        if arg is not None:
            n = Feature(arg,
                        description=take_opt_str(ss, "description"),
                        if_feature=take_strlist(ss, "if-feature"),
                        reference=take_opt_str(ss, "reference"),
                        status=take_opt_str(ss, "status"),
                        exts=take_exts(ss),
                        parent=parent
                        )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under feature: {name}")
            return n
    if stmt.kw == "grouping":
        if arg is not None:
            n = Grouping(arg,
                         description=take_opt_str(ss, "description"),
                         reference=take_opt_str(ss, "reference"),
                         status=take_opt_str(ss, "status"),
                         exts=take_exts(ss),
                         parent=parent
                         )
            n.children=take_nodes(ss, ["action", "anydata", "anyxml", "choice", "container", "grouping", "leaf", "leaf-list", "list", "notification", "typedef", "uses"], n)
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under grouping: {name}")
            return n
    if stmt.kw == "identity":
        if arg is not None:
            n = Identity(arg,
                         base=take_strlist(ss, "base"),
                         description=take_opt_str(ss, "description"),
                         if_feature=take_strlist(ss, "if-feature"),
                         reference=take_opt_str(ss, "reference"),
                         status=take_opt_str(ss, "status"),
                         exts=take_exts(ss),
                         parent=parent
                         )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under identity: {name}")
            return n
    if stmt.kw == "import":
        if arg is not None:
            n = Import(arg,
                       description=take_opt_str(ss, "description"),
                       prefix=take_str(ss, "prefix"),
                       reference=take_opt_str(ss, "reference"),
                       revision_date=take_opt_str(ss, "revision-date"),
                       exts=take_exts(ss),
                       parent=parent
                       )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under import: {name}")
            return n
    if stmt.kw == "include":
        if arg is not None:
            n = Include(arg,
                        description=take_opt_str(ss, "description"),
                        reference=take_opt_str(ss, "reference"),
                        revision_date=take_opt_str(ss, "revision-date"),
                        exts=take_exts(ss),
                        parent=parent
                        )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under include: {name}")
            return n
    if stmt.kw == "input":
        if arg is None:
            n = Input(must=take_musts(ss),
                      exts=take_exts(ss),
                      parent=parent
                      )
            n.children=take_nodes(ss, ["anydata", "anyxml", "choice", "container", "grouping", "leaf", "leaf-list", "list", "typedef", "uses"], n)
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under input: {name}")
            return n
    if stmt.kw == "leaf":
        if arg is not None:
            n = Leaf(arg,
                     config=take_opt_bool(ss, "config"),
                     default=take_opt_str(ss, "default"),
                     description=take_opt_str(ss, "description"),
                     if_feature=take_strlist(ss, "if-feature"),
                     mandatory=take_opt_bool(ss, "mandatory"),
                     must=take_musts(ss),
                     reference=take_opt_str(ss, "reference"),
                     status=take_opt_str(ss, "status"),
                     type_=take_type(ss),
                     units=take_opt_str(ss, "units"),
                     when=take_opt_str(ss, "when"),
                     exts=take_exts(ss),
                     parent=parent
                     )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under leaf: {name}")
            return n
    if stmt.kw == "leaf-list":
        if arg is not None:
            n = LeafList(arg,
                         config=take_opt_bool(ss, "config"),
                         default=take_strlist(ss, "default"),
                         description=take_opt_str(ss, "description"),
                         if_feature=take_strlist(ss, "if-feature"),
                         max_elements=take_opt_str(ss, "max-elements"),
                         min_elements=take_opt_str(ss, "min-elements"),
                         must=take_musts(ss),
                         ordered_by=take_opt_str(ss, "ordered-by"),
                         reference=take_opt_str(ss, "reference"),
                         status=take_opt_str(ss, "status"),
                         type_=take_type(ss),
                         units=take_opt_str(ss, "units"),
                         when=take_opt_str(ss, "when"),
                         exts=take_exts(ss),
                         parent=parent
                         )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under leaf-list: {name}")
            return n
    if stmt.kw == "length":
        if arg is not None:
            n = Length(arg,
                       description=take_opt_str(ss, "description"),
                       error_app_tag=take_opt_str(ss, "error-app-tag"),
                       error_message=take_opt_str(ss, "error-message"),
                       reference=take_opt_str(ss, "reference"),
                       exts=take_exts(ss),
                       parent=parent
                       )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under length: {name}")
            return n
    if stmt.kw == "list":
        if arg is not None:
            n = List(arg,
                     config=take_opt_bool(ss, "config"),
                     description=take_opt_str(ss, "description"),
                     if_feature=take_strlist(ss, "if-feature"),
                     key=take_opt_str(ss, "key"),
                     max_elements=take_opt_str(ss, "max-elements"),
                     min_elements=take_opt_str(ss, "min-elements"),
                     must=take_musts(ss),
                     ordered_by=take_opt_str(ss, "ordered-by"),
                     reference=take_opt_str(ss, "reference"),
                     status=take_opt_str(ss, "status"),
                     unique=take_strlist(ss, "unique"),
                     when=take_opt_str(ss, "when"),
                     exts=take_exts(ss),
                     parent=parent
                     )
            n.children=take_nodes(ss, ["action", "anydata", "anyxml", "choice", "container", "grouping", "leaf", "leaf-list", "list", "notification", "typedef", "uses"], n)
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under list: {name}")
            return n
    if stmt.kw == "module":
        if arg is not None:
            n = Module(arg,
                       augment=take_augments(ss),
                       contact=take_opt_str(ss, "contact"),
                       description=take_opt_str(ss, "description"),
                       deviation=take_strlist(ss, "deviation"),
                       extension_=take_extensions(ss),
                       feature=take_features(ss),
                       import_=take_imports(ss),
                       include=take_includes(ss),
                       namespace=take_str(ss, "namespace"),
                       organization=take_opt_str(ss, "organization"),
                       prefix=take_str(ss, "prefix"),
                       reference=take_opt_str(ss, "reference"),
                       revision=take_revisions(ss),
                       yang_version=take_yang_version(ss),
                       exts=take_exts(ss),
                       parent=parent
                       )
            n.children=take_nodes(ss, ["anydata", "anyxml", "choice", "container", "grouping", "identity", "leaf", "leaf-list", "list", "notification", "rpc", "typedef", "uses"], n)
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under module: {name}")
            return n
    if stmt.kw == "must":
        if arg is not None:
            n = Must(arg,
                     description=take_opt_str(ss, "description"),
                     error_app_tag=take_opt_str(ss, "error-app-tag"),
                     error_message=take_opt_str(ss, "error-message"),
                     reference=take_opt_str(ss, "reference"),
                     exts=take_exts(ss),
                     parent=parent
                     )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under must: {name}")
            return n
    if stmt.kw == "notification":
        if arg is not None:
            n = Notification(arg,
                             description=take_opt_str(ss, "description"),
                             if_feature=take_strlist(ss, "if-feature"),
                             must=take_musts(ss),
                             reference=take_opt_str(ss, "reference"),
                             status=take_opt_str(ss, "status"),
                             exts=take_exts(ss),
                             parent=parent
                             )
            n.children=take_nodes(ss, ["anydata", "anyxml", "choice", "container", "grouping", "leaf", "leaf-list", "list", "typedef", "uses"], n)
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under notification: {name}")
            return n
    if stmt.kw == "output":
        if arg is None:
            n = Output(must=take_musts(ss),
                       exts=take_exts(ss),
                       parent=parent
                       )
            n.children=take_nodes(ss, ["anydata", "anyxml", "choice", "container", "grouping", "leaf", "leaf-list", "list", "typedef", "uses"], n)
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under output: {name}")
            return n
    if stmt.kw == "pattern":
        if arg is not None:
            n = Pattern(arg,
                        description=take_opt_str(ss, "description"),
                        error_app_tag=take_opt_str(ss, "error-app-tag"),
                        error_message=take_opt_str(ss, "error-message"),
                        modifier=take_opt_str(ss, "modifier"),
                        reference=take_opt_str(ss, "reference"),
                        exts=take_exts(ss),
                        parent=parent
                        )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under pattern: {name}")
            return n
    if stmt.kw == "range":
        if arg is not None:
            n = Range(arg,
                      description=take_opt_str(ss, "description"),
                      error_app_tag=take_opt_str(ss, "error-app-tag"),
                      error_message=take_opt_str(ss, "error-message"),
                      reference=take_opt_str(ss, "reference"),
                      exts=take_exts(ss),
                      parent=parent
                      )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under range: {name}")
            return n
    if stmt.kw == "refine":
        if arg is not None:
            n = Refine(arg,
                       config=take_opt_bool(ss, "config"),
                       default=take_strlist(ss, "default"),
                       description=take_opt_str(ss, "description"),
                       if_feature=take_strlist(ss, "if-feature"),
                       mandatory=take_opt_bool(ss, "mandatory"),
                       max_elements=take_opt_str(ss, "max-elements"),
                       min_elements=take_opt_str(ss, "min-elements"),
                       must=take_musts(ss),
                       presence=take_opt_str(ss, "presence"),
                       reference=take_opt_str(ss, "reference"),
                       exts=take_exts(ss),
                       parent=parent
                       )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under refine: {name}")
            return n
    if stmt.kw == "revision":
        if arg is not None:
            n = Revision(arg,
                         description=take_opt_str(ss, "description"),
                         reference=take_opt_str(ss, "reference"),
                         exts=take_exts(ss),
                         parent=parent
                         )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under revision: {name}")
            return n
    if stmt.kw == "rpc":
        if arg is not None:
            n = Rpc(arg,
                    description=take_opt_str(ss, "description"),
                    if_feature=take_strlist(ss, "if-feature"),
                    input=take_opt_input(ss),
                    output=take_opt_output(ss),
                    reference=take_opt_str(ss, "reference"),
                    status=take_opt_str(ss, "status"),
                    exts=take_exts(ss),
                    parent=parent
                    )
            n.children=take_nodes(ss, ["grouping", "typedef"], n)
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under rpc: {name}")
            return n
    if stmt.kw == "submodule":
        if arg is not None:
            n = Submodule(arg,
                          augment=take_augments(ss),
                          belongs_to=take_belongs_to(ss),
                          contact=take_opt_str(ss, "contact"),
                          description=take_opt_str(ss, "description"),
                          deviation=take_strlist(ss, "deviation"),
                          extension_=take_extensions(ss),
                          feature=take_features(ss),
                          import_=take_imports(ss),
                          include=take_includes(ss),
                          organization=take_opt_str(ss, "organization"),
                          reference=take_opt_str(ss, "reference"),
                          revision=take_revisions(ss),
                          yang_version=take_yang_version(ss),
                          exts=take_exts(ss),
                          parent=parent
                          )
            n.children=take_nodes(ss, ["anydata", "anyxml", "choice", "container", "grouping", "identity", "leaf", "leaf-list", "list", "notification", "rpc", "typedef", "uses"], n)
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under submodule: {name}")
            return n
    if stmt.kw == "type":
        if arg is not None:
            n = Type(arg,
                     base=take_strlist(ss, "base"),
                     bit=take_bits(ss),
                     enum=take_enums(ss),
                     fraction_digits=take_opt_int(ss, "fraction-digits"),
                     length=take_opt_length(ss),
                     path=take_opt_str(ss, "path"),
                     pattern=take_patterns(ss),
                     range_=take_opt_range(ss),
                     require_instance=take_opt_bool(ss, "require-instance"),
                     type_=take_types(ss),
                     exts=take_exts(ss),
                     parent=parent
                     )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under type: {name}")
            return n
    if stmt.kw == "typedef":
        if arg is not None:
            n = Typedef(arg,
                        default=take_opt_str(ss, "default"),
                        description=take_opt_str(ss, "description"),
                        reference=take_opt_str(ss, "reference"),
                        status=take_opt_str(ss, "status"),
                        type_=take_type(ss),
                        units=take_opt_str(ss, "units"),
                        exts=take_exts(ss),
                        parent=parent
                        )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under typedef: {name}")
            return n
    if stmt.kw == "uses":
        if arg is not None:
            n = Uses(arg,
                     augment=take_augments(ss),
                     description=take_opt_str(ss, "description"),
                     if_feature=take_strlist(ss, "if-feature"),
                     reference=take_opt_str(ss, "reference"),
                     refine=take_refines(ss),
                     status=take_opt_str(ss, "status"),
                     when=take_opt_str(ss, "when"),
                     exts=take_exts(ss),
                     parent=parent
                     )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under uses: {name}")
            return n
    raise ValueError("Unknown statement: {stmt.kw}")


class ResolvedType(Type):
    resolved_base_typedef: ?Typedef

    def __init__(self, name: str, base: list[str]=[], bit: list[Bit]=[], enum: list[Enum]=[], fraction_digits: ?int=None, length: ?Length=None, path: ?str=None, pattern: list[Pattern]=[], range_: ?Range=None, require_instance: ?bool=None, type_: list[Type]=[], exts=[], parent=None, mod=None, ns=None, pfx=None, resolved_base_typedef=None):
        Type.__init__(self, name, base, bit, enum, fraction_digits, length, path, pattern, range_, require_instance, type_, exts, parent, mod, ns, pfx)
        self.resolved_base_typedef = resolved_base_typedef

    def resolve_type(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None, recursion_level=0, _top_name: ?str=None):
        new_name = self.name

        if self.name not in _builtin_types:
            orig_prefix = self.get_prefix()
            if new_pfx is not None and new_pfx != orig_prefix:
                # Add explicit prefix when part of grouping expanded into other module
                prefix, name = split_prefix_name(self.name)
                if prefix is None:
                    new_name = "{orig_prefix}:{name}"

        new = ResolvedType(new_name,
                   base=self.base,
                   bit=self.bit,
                   enum=self.enum,
                   fraction_digits=self.fraction_digits,
                   length=self.length,
                   path=self.path,
                   pattern=self.pattern,
                   range_=self.range_,
                   require_instance=self.require_instance,
                   type_=self.type_,
                   exts=self.exts,
                   mod=new_mod if new_mod is not None else self.mod,
                   ns=new_ns if new_ns is not None else self.ns,
                   pfx=new_pfx if new_pfx is not None else self.pfx,
                   resolved_base_typedef=self.resolved_base_typedef)
        return new

    def to_dtype(self) -> DType:
        return DType.from_resolved_type(self)


def find_identity_by_ref(identities: list[DIdentity], name: str, namespace: ?str=None, module: ?str=None, prefix: ?str=None) -> ?DIdentity:
    """Find an identity by name and optionally namespace or module"""
    for identity in identities:
        if identity.name == name:
            if namespace is not None and identity.namespace == namespace:
                return identity
            elif module is not None and identity.module == module:
                return identity
            elif prefix is not None and identity.prefix == prefix:
                return identity
    return None


def complete_identityref(partial: value, identities: list[DIdentity], current_module: str) -> (?Identityref, ?DIdentity, ?str):
    """Complete an Identityref by filling in missing namespace or module, if only one is set"""
    if isinstance(partial, Identityref):
        identity = find_identity_by_ref(identities, partial.val, namespace=partial.ns, module=partial.mod, prefix=partial.pfx)
        if identity is not None:
            return partial, identity, None
        else:
            return None, None, "Identityref {partial.val} not found in namespace={partial.ns} module={partial.mod} prefix={partial.pfx}"
    elif isinstance(partial, PartialIdentityref):
        partial_ns = partial.ns
        partial_mod = partial.mod
        partial_pfx = partial.pfx
        if partial_ns is None and partial_mod is None and partial_pfx is None:
            identity = find_identity_by_ref(identities, partial.val, module=current_module)
            if identity is not None:
                complete = Identityref(partial.val, identity.namespace, identity.module, identity.prefix)
                return complete, identity, None
            else:
                return None, None, "Identityref {partial.val} not found in current module {current_module}"
        else:
            # Have namespace or module (also both, but that doesn't happen when we parse XML / JSON)
            identity = find_identity_by_ref(identities, partial.val, namespace=partial_ns, module=partial_mod, prefix=partial_pfx)
            if identity is not None:
                complete = Identityref(partial.val, identity.namespace, identity.module, identity.prefix)
                return complete, identity, None
            else:
                return None, None, "Identityref {partial.val} not found in namespace={partial.ns} module={partial.mod} prefix={partial.pfx}"
    else:
        raise ValueError('"partial" argument type is a union of Identityref, PartialIdentityref')


def is_derived_from(identity: DIdentity, bases: list[DIdentity]) -> bool:
    """Check if an identity is derived from any of the given base identities"""
    for b in bases:
        if b.module == identity.module and b.name == identity.name:
            return True

    for base in identity.base:
        # Check direct match
        for b in bases:
            if b.module == base.module and b.name == base.name:
                return True
        # Check recursive derivation
        if is_derived_from(base, bases):
            return True
    return False


# partial is a union of Identityref, PartialIdentityref
def complete_and_validate_identityref(partial: value, identities: list[DIdentity], bases: list[DIdentity], current_module: str) -> (?Identityref, ?str):
    identityref, identity, error = complete_identityref(partial, identities, current_module)
    if identity is not None:
        if is_derived_from(identity, bases):
            return identityref, None
        else:
            return None, "Identityref {identityref} not derived from any of the valid bases: {bases}"
    return None, error


def list_keys(node: DNodeInner) -> ?list[str]:
    if isinstance(node, DList):
        return node.key


def _remap_path_prefix(path: str, old_prefix: str, new_prefix: str) -> str:
    """Remap prefix in augment/deviation paths from old to new prefix

    Example: "/old:foo/old:bar/baz" -> "/new:foo/new:bar/baz"
    """
    if old_prefix == new_prefix:
        return path
    elif old_prefix not in path:
        return path

    # Split path into segments
    segments = path.split("/")
    result = []

    for segment in segments:
        sp = segment.split(":", 1)
        if len(sp) > 1:
            prefix = sp[0]
            name = sp[1]
            if prefix == old_prefix:
                result.append(new_prefix + ":" + name)
            else:
                result.append(segment)
        else:
            result.append(segment)

    return "/".join(result)


def stmt_to_smodule(stmt):
    m = stmt_to_snode(stmt)
    if isinstance(m, Module):
        return m
    raise ValueError("Expected a module, got {type(m)}")


def escape_as_fstr(s: str) -> str:
    parts = []
    s_len = len(s)
    b = 0

    def copy_until(b, i):
        if i > b:
           parts.append(s[b:i])
        return i

    def replace(b, i, p, skip=1):
        new_b = copy_until(b, i)
        parts.append(p)
        return new_b + skip

    for i in range(0, s_len):
        c = s[i]
        if c == '\\':
            b = replace(b, i, "\\\\")
        elif c == '{{':
            b = replace(b, i, "{{{{")
        elif c == '}}':
            b = replace(b, i, "}}}}")
        elif c == '\'':
            b = replace(b, i, "\\\'")
        elif c == '%':
            b = replace(b, i, "\\x25") # Workaround ...

    copy_until(b, s_len)

    return "".join(parts)

