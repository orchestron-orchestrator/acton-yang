# schema.act module.
#
# YANG schema
#
# This is an object model for YANG schema, based on YANG 1.1 although it should
# mostly work for YANG 1.0 just fine. There is no logic for either schema or
# data validation, so it is possible to represent an invalid schema using this
# model.
#
# There are two levels of object representation. The first level is that of
# statements and is represented by the Statement class. Everything in a YANG
# model is pretty much a statement, so this is a representation fairly close to
# the YANG source code. For example, the order of all statements is preserved,
# so this model:
#
#    module foo {
#      prefix "f";
#      namespace "http://example.com/foo";
#    }
#
# Would become:
#
#   Statement("module", "foo", substatements=[
#     Statement("prefix", "f"),
#     Statement("namespace", "http://example.com/foo")
#   ])
#
# Whitespace, indentation and comments are not preserved but all parsed
# statements are. Thus if the Statements are rendered back to YANG source, it
# would look exactly like the original source code, presuming the use of
# canonical YANG formatting.
#
# The second level is that of schema nodes and is represented by the SchemaNode
# class. The SchemaNode class is a base class for all schema node types, such as
# Module, Container, List, Leaf, etc. Different statements are modeled using
# discrete classes and statements that relate to a particular statement are
# attributes of that object class rather than being seen as just a tree of
# statements. For example, the following model:
#
#    module foo {
#      prefix "f";
#      namespace "http://example.com/foo";
#      container c1 {
#        leaf l1 {
#          type string;
#        }
#      }
#    }
#
# Would become:
#
#   Module("foo", namespace="http://example.com/foo", prefix="f", children=[
#     Container("c1", children=[
#       Leaf("l1", type_="string")
#     ])
#   ])
#
# Rendering that back to YANG source code will render the namespace & prefix
# statements in the canonical order specified by the YANG RFC, thus rendering
# the following:
#
#    module foo {
#      prefix "f";
#      namespace "http://example.com/foo";
#      container c1 {
#        leaf l1 {
#          type string;
#        }
#      }
#    }
#
# This higher layer SchemaNode representation is not suitable if it is desirable
# to keep statement order from the original source document (be aware that even
# with the lower leve Statement representation, whitespace & comments are still
# lost).

RECURSION_LIMIT = 100

def _yind(n):
    return "  " * n

def _ind(n):
    return "    " * n

_builtin_types = {
    "binary",
    "bits",
    "boolean",
    "decimal64",
    "empty",
    "enumeration",
    "identityref",
    "instance-identifier",
    "int8",
    "int16",
    "int32",
    "int64",
    "leafref",
    "string",
    "uint8",
    "uint16",
    "uint32",
    "uint64",
    "union"
}

_quoted_arg_keywords = set([
    "argument",
    "augment",
    "contact",
    "description",
    "if-feature",
    "namespace",
    "organization",
    "prefix",
    "reference",
    "refine",
    "yang-version",
])

class Statement(object):
    kw: str
    arg: ?str
    prefix: ?str
    substatements: list[Statement]
    def __init__(self, kw: str, arg: ?str=None, prefix: ?str=None):
        self.kw = kw
        self.arg = arg
        self.prefix = prefix
        self.substatements = []

    def get_subarg(self, kw: str) -> ?str:
        for substatement in self.substatements:
            if substatement.kw == kw:
                return substatement.arg

    def get_subarg_bool(self, kw: str) -> ?bool:
        for substatement in self.substatements:
            if substatement.kw == kw:
                arg = substatement.arg
                if arg is not None:
                    return bool(arg)

    def pryang(self, indent=0):
        """Print YANG source code for this statement and its substatements
        """
        res = _yind(indent) + self.kw
        arg = self.arg
        if arg is not None:
            quoted_arg = True if self.kw in _quoted_arg_keywords else False
            res += " "
            if quoted_arg:
                res += '"'
            res += arg
            if quoted_arg:
                res += '"'
        if len(self.substatements) == 0:
            res += ";\n"
        else:
            res += " {\n"
            for substatement in self.substatements:
                res += substatement.pryang(indent+1)
            res += _yind(indent) + "}\n"
        return res


# Yang schema for data
#
# This module provides a concrete YANG schema representation of a data tree.
# Unlike the yang.schema module, which has a focus on properly representing the
# YANG schema document itself, including abstract concepts like imports, inherited
# types, groupings and augments, this module focuses on the statements relevant
# for representing a YANG modeled data tree. The data nodes in YANG are:
# - container, list, leaf, leaf-list, anydata, anyxml and the module itself can be
#   considered a form of container
# A YANG schema can be expanded into these data nodes, for example by expanding
# uses statements with the relevant groupings into the actual nodes and by
# applying augment statements to the relevant nodes.
#
# Similarly, concepts like config is represented as a boolean here, since all
# nodes are either config or not config, whereas in yang.schema, config is a
# tri-state value, since it can be None, meaning that the value is inherited from
# the parent node. Things like this makes it easier to work with the data tree
# from this module.
#
# Another concept is DTree which is a special node that acts as the virtual root
# of the data tree which can contain multiple YANG modules.

def optional_subtree(node: DNodeInner) -> bool:
    """Checks if a subtree is optional

    Returns True if the subtree is optional or False if any child node (or
    grandchild etc) is mandatory.
    """
    for child in node.children:
        if isinstance(child, DLeaf):
            if child.mandatory:
                return False
        elif isinstance(child, DLeafList):
            if child.min_elements > 0:
                return False
        elif isinstance(child, DContainer):
            if not optional_subtree(child):
                return False
        elif isinstance(child, DList):
            if child.min_elements > 0:
                return False
    return True


class DNode(object):
    parent: ?DNode
    dname: str
    name: str
    config: bool
    description: ?str
    reference: ?str
    exts: list[Ext]

    def prdaclass(self, loose=False, top=True) -> str:
        """Print the data class for this schema node
        """
        raise NotImplementedError('SchemaNode pdc')

class DNodeInner(DNode):
    children: list[DNode]

    def prdaclass(self, loose=False, top=True) -> str:
        """Print the data class for this schema node
        """
#        stmt_arg = self._get_arg()
        res = []
        if top:
            res.append("import xml")
            res.append("import yang.adata")
            res.append("import yang.gdata")
            res.append("")
            res.append("# == This file is generated ==")
            res.append("")
            res.append("")

        # Reorder children so that positional arguments, like list keys, come first
        new_children = []
        pos_child_idx = 0
        for child in self.children:
            if isinstance(child, DLeaf) and child.is_key():
                new_children.insert(pos_child_idx, child)
                pos_child_idx += 1
            else:
                new_children.append(child)
        self.children = new_children

        for child in self.children:
            if isinstance(child, DNodeInner):
                res.append(child.prdaclass(loose=loose, top=False))

        if isinstance(self, DList):
            # List has special handling as it actually results in two classes:
            # - the list itself
            # - the list entry class
            # Here we create the list entry class, the list itself comes later
            res.append("class %s_entry(yang.adata.MNode):" % _get_full_name(self))
        else:
            res.append("class %s(yang.adata.MNode):" % _get_full_name(self))
        for child in self.children:
            if isinstance(child, DLeaf):
                res.append("    %s: %s" % (_safe_name(child.name), yang_leaf_to_acton_type(child, loose)))
            elif isinstance(child, DLeafList):
                res.append("    %s: %s" % (_safe_name(child.name), yang_leaflist_to_acton_type(child)))
            elif isinstance(child, DNodeInner):
                res.append("    %s: %s" % (_safe_name(child.name), _get_full_name(child)))
            else:
                raise ValueError("unreachable, unknown child type: " + str(type(child)))
        res.append("")
        init_args = ["self"]
        for child in self.children:
            if isinstance(child, DContainer):
                if loose or child.presence or optional_subtree(child):
                    init_args.append("%s: ?%s=None" % (_safe_name(child.name), _get_full_name(child)))
                else:
                    init_args.append("%s: %s" % (_safe_name(child.name), _get_full_name(child)))
            elif isinstance(child, DLeaf):
                init_args.append("%s: %s" % (_safe_name(child.name), yang_leaf_to_acton_type(child, loose)))
            elif isinstance(child, DLeafList):
                init_args.append("%s: ?%s=None" % (_safe_name(child.name), yang_leaflist_to_acton_type(child)))
            elif isinstance(child, DList):
                init_args.append("%s: list[%s_entry]=[]" % (_safe_name(child.name), _get_full_name(child)))

        init_args_str = ", ".join(init_args)
        res.append("    def __init__(%s):" % init_args_str)

        for child in self.children:
            if isinstance(child, DContainer):
                # TODO: presence?
                if loose or child.presence or optional_subtree(child):
                    res.append("        if %s is not None:" % (_safe_name(child.name)))
                    res.append("            self.%s = %s" % (_safe_name(child.name), _safe_name(child.name)))
                    res.append("        else:")
                    res.append("            self.%s = %s()" % (_safe_name(child.name), _get_full_name(child)))
                else:
                    res.append("        self.%s = %s" % (_safe_name(child.name), _safe_name(child.name)))
            elif isinstance(child, DLeaf):
                res.append("        self.%s = %s" % (_safe_name(child.name), _safe_name(child.name)))
            elif isinstance(child, DLeafList):
                #res.append("        self.%s = %s" % (_safe_name(child.name), _safe_name(child.name)))
                res.append("        if %s is not None:" % (_safe_name(child.name)))
                res.append("            self.%s = %s" % (_safe_name(child.name), _safe_name(child.name)))
                res.append("        else:")
                # TODO: this is where we can set the leaf-list to a default value
                res.append("            self.%s = []" % (_safe_name(child.name)))
            elif isinstance(child, DList):
                res.append("        self.%s = %s(elements=%s)" % (_safe_name(child.name), _get_full_name(child), _safe_name(child.name)))
        if len(self.children) == 0:
            res.append("        pass")
        res.append("")

#        # == .create_XXX() methods
#        for child in self.children:
#            if isinstance(child, Container_) and child.is_presence():
#                res.append("    def create_%s(self):" % (_safe_name(child.name)))
#                res.append("        _%s = %s()" % (_safe_name(child.name), _get_full_name(child)))
#                res.append("        self.%s = _%s" % (_safe_name(child.name), _safe_name(child.name)))
#                res.append("        return _%s" % (_safe_name(child.name)))
#                res.append("")
#        res.append("")

        # .to_gdata()
        res.append("    def to_gdata(self) -> yang.gdata.Node:")
        if isinstance(self, DList):
            # keys contains a yang spec of the keys, like "k1 k2"
            # which are modeled as attributes of the list entry class and accessed via self.k1, self.k2
            list_keys_str = ", ".join(map(lambda x: "str(self.%s)" % _safe_name(x), self.key))
            res.append("        res = yang.gdata.ListElement([%s])" % (list_keys_str))
        elif isinstance(self, DRoot):
            res.append("        res = yang.gdata.%s()" % (self.dname))
        else:
            res.append("        res = yang.gdata.%s('%s')" % (self.dname, self.name))

        for child in self.children:
            if not isinstance(child, DLeafList):
                res.append("        _%s = self.%s" % (_safe_name(child.name), _safe_name(child.name)))
        for child in self.children:
            if isinstance(child, DLeafList):
                res.append("        res.children['%s'] = yang.gdata.LeafList('%s', self.%s)" % (child.name, child.name, _safe_name(child.name)))
            else:
                res.append("        if _%s is not None:" % _safe_name(child.name))
                if isinstance(child, DLeaf):
                    res.append("            res.children['%s'] = yang.gdata.Leaf('%s', _%s)" % (child.name, child.name, _safe_name(child.name)))
                elif isinstance(child, DContainer):
                    res.append("            res.children['%s'] = self.%s.to_gdata()" % (child.name, _safe_name(child.name)))
                elif isinstance(child, DList):
                    res.append("            res.children['%s'] = self.%s.to_gdata()" % (child.name, _safe_name(child.name)))
        res.append("        return res")
        res.append("")
#
        # .from_gdata()
        # TODO: should .from_gdata() not take a specific data node instead, like Container_ instead of yang.gdata.Node?
        from_gdata_args_list = []
        from_xml_args_list = []
        for child in self.children:
            if isinstance(child, DLeaf):
                from_gdata_args_list.append("%s=n.get_%s(\"%s\")" % (_safe_name(child.name), yang_leaf_to_getval(child), child.name))
                from_xml_args_list.append("%s=yang.gdata.from_xml_%s(n, \"%s\")" % (_safe_name(child.name), yang_leaf_to_getval(child), child.name))
            elif isinstance(child, DLeafList):
                from_gdata_args_list.append("%s=n.get_%ss(\"%s\")" % (_safe_name(child.name), yang_leaf_to_getval(child), child.name))
                from_xml_args_list.append("%s=yang.gdata.from_xml_%ss(n, \"%s\")" % (_safe_name(child.name), yang_leaf_to_getval(child), child.name))
            elif isinstance(child, DContainer):
                # TODO: handle presence containers
                from_gdata_args_list.append("%s=%s.from_gdata(n.get_container(\"%s\"))" % (_safe_name(child.name), _get_full_name(child), child.name))
                # TODO: handle presence containers
                from_xml_args_list.append("%s=%s.from_xml(yang.gdata.get_xml_child(n, \"%s\"))" % (_safe_name(child.name), _get_full_name(child), child.name))
            elif isinstance(child, DList):
                from_gdata_args_list.append("%s=%s.from_gdata(n.get_list(\"%s\"))" % (_safe_name(child.name), _get_full_name(child), child.name))
                from_xml_args_list.append("%s=%s.from_xml(yang.gdata.get_xml_children(n, \"%s\"))" % (_safe_name(child.name), _get_full_name(child), child.name))
        from_gdata_args = ", ".join(from_gdata_args_list)
        from_xml_args = ", ".join(from_xml_args_list)
        res.append("    @staticmethod")
        if isinstance(self, DList):
            res.append("    def from_gdata(n: yang.gdata.Node) -> %s_entry:" % _get_full_name(self))
            res.append("        return %s_entry(%s)" % (_get_full_name(self), from_gdata_args))
        else:
            res.append("    def from_gdata(n: yang.gdata.Node) -> %s:" % _get_full_name(self))
            res.append("        return %s(%s)" % (_get_full_name(self), from_gdata_args))
        res.append("")

        res.append("    @staticmethod")
        if isinstance(self, DList):
            res.append("    def from_xml(n: xml.Node) -> %s_entry:" % _get_full_name(self))
            res.append("        return %s_entry(%s)" % (_get_full_name(self), from_xml_args))
        else:
            res.append("    def from_xml(n: xml.Node) -> %s:" % _get_full_name(self))
            res.append("        return %s(%s)" % (_get_full_name(self), from_xml_args))
        res.append("")

        if isinstance(self, DList):
            # List has special handling as it actually results in two classes:
            # - the list itself
            # - the list entry class
            # Here we create the list entry class, the list itself comes later
            res.append("class %s(yang.adata.MNode):" % _get_full_name(self))
            res.append("    elements: list[%s_entry]" % _get_full_name(self))

            init_args = ["self"]
            init_args.append("elements=[]")
            init_args_str: str = ", ".join(init_args)
            res.append("    def __init__(%s):" % init_args_str)
            res.append("        self._name = " + repr(self.name))
            res.append("        self.elements = elements")
            res.append("")

            list_key_args = list(map(lambda x: _safe_name(x), self.key))
            for child in self.children:
                if isinstance(child, DLeaf):
                    pass
                elif isinstance(child, DContainer):
                    if not (optional_subtree(child)):
                        list_key_args.append(_safe_name(child.name))
            list_create_args = ["self"] + list_key_args
            res.append("    def create(%s):" % (", ".join(list_create_args)))
            res.append("        res = %s_entry(%s)" % (_get_full_name(self), ", ".join(list_key_args)))
            res.append("        self.elements.append(res)")
            res.append("        return res")
            res.append("")

            res.append("    def to_gdata(self):" % ())
            res.append("        res = yang.gdata.List('%s', %s)" % (self.name, repr(self.key)))
            res.append("        for e in self.elements:")
            res.append("            e_gdata = e.to_gdata()")
            res.append("            if isinstance(e_gdata, yang.gdata.ListElement):")
            res.append("                res.elements.append(e_gdata)")
            res.append("        return res")
            res.append("")

#            # .from_gdata()
#            # TODO: should .from_gdata() not take a specific data node instead, like Container_ instead of yang.gdata.Node?
            from_gdata_args_list = []
            for child in self.children:
                if isinstance(child, DLeaf):
                    from_gdata_args_list.append("%s=n.get_%s(\"%s\")" % (_safe_name(child.name), yang_leaf_to_getval(child), child.name))
                elif isinstance(child, DContainer):
                    from_gdata_args_list.append("%s=%s.from_gdata(n.get_container(\"%s\"))" % (_safe_name(child.name), _get_full_name(child), child.name))
                elif isinstance(child, DList):
                    from_gdata_args_list.append("%s=%s.from_gdata(n.get_list(\"%s\"))" % (_safe_name(child.name), _get_full_name(child), child.name))
#                elif isinstance(child, ListElement):
#                    from_gdata_args_list.append("%s=%s.from_gdata(n.get_list(\"%s\"))" % (_safe_name(child.name), _get_full_name(child), child.name))
            from_gdata_args = ", ".join(from_gdata_args_list)
            res.append("    @staticmethod")
            res.append("    def from_gdata(n: yang.gdata.List) -> list[%s_entry]:" % _get_full_name(self))
            res.append("        res = []")
            res.append("        for e in n.elements:")
            res.append("            res.append(%s_entry.from_gdata(e))" % _get_full_name(self))
            res.append("        return res")
            #res.append("        return list(map(lambda x: %s_entry.from_gdata(x), n.elements))" % _get_full_name(self))
            res.append("")
            res.append("    @staticmethod")
            res.append("    def from_xml(nodes: list[xml.Node]) -> list[%s_entry]:" % _get_full_name(self))
            res.append("        res = []")
            res.append("        for node in nodes:")
            res.append("            res.append(%s_entry.from_xml(node))" % _get_full_name(self))
            res.append("        return res")
            # TODO: trying to use list(map(lambda)) here results in an error,
            # why? Above code that iterates over n.elements works fine... Error is:
            # ERROR: Error when compiling y_cfs module: Type error
            # mut must be a subclass of pure
            #
            #res.append("        return list(map(lambda x: %s_entry.from_xml(x), nodes))" % _get_full_name(self))
            res.append("")
        res.append("")

        return "\n".join(res)


class DNodeLeaf(DNode):
    if_feature: list[str]
    mandatory: bool
    must: list[Must]
    status: ?str
    type_: Type
    when: ?str

class DAnydata(DNodeLeaf):
    pass

class DAnyxml(DNodeLeaf):
    pass

class DContainer(DNodeInner):
    if_feature: list[str]
    must: list[Must]
    presence: bool

    def __init__(self, name: str, config: bool, description: ?str=None, if_feature=[], must=[], presence: bool, reference=None, status=None, when=None, exts=[], children=[]):
        self.name = name
        self.dname = "Container_"
        self.config = config
        self.description = description
        self.if_feature = if_feature
        self.must = must
        self.presence = presence
        self.reference = reference
        self.status = status
        self.exts = exts
        self.children = children

class DModule(DNodeInner):
    augment: list[Augment]
    contact: ?str
    deviation: list[str]
    extension_: list[Extension]
    feature: list[Feature]
    import_: list[Import]
    include: list[Include]
    namespace: str
    organization: ?str
    prefix: str
    revision: list[Revision]
    yang_version: float

    def __init__(self, name: str, namespace: str, prefix: str, yang_version: ?float, description: ?str=None, contact=None, deviation=[], extension_=[], feature=[], import_=[], include=[], organization=None, reference=None, revision=[], exts=[], children=[]):
        self.name = name
        self.dname = "Module"
        self.namespace = namespace
        self.prefix = prefix
        if yang_version is not None:
            self.yang_version = yang_version
        else:
            self.yang_version = 1.1
        self.config = True # module is not config in itself, but it is the root
                           # of the data tree and the default is config=True, so
                           # we set it here
        self.description = description
        self.contact = contact
        self.deviation = deviation
        self.extension_ = extension_
        self.feature = feature
        self.import_ = import_
        self.include = include
        self.organization = organization
        self.reference = reference
        self.revision = revision
        self.exts = exts
        self.children = children

class DList(DNodeInner):
    if_feature: list[str]
    key: list[str]
    max_elements: ?int
    min_elements: int
    must: list[Must]
    ordered_by: str
    status: ?str
    unique: list[str]
    when: ?str

    def __init__(self, name: str, key: list[str], config: bool, description: ?str=None, if_feature=[], max_elements: ?int=None, min_elements=0, must=[], ordered_by="system", reference=None, status=None, unique=[], when=None, exts=[], children=[]):
        self.name = name
        self.dname = "List"
        self.key = key
        self.config = config
        self.description = description
        self.if_feature = if_feature
        self.max_elements = max_elements
        self.min_elements = min_elements
        self.must = must
        self.ordered_by = ordered_by
        self.reference = reference
        self.status = status
        self.unique = unique
        self.when = when
        self.exts = exts
        self.children = children

class DLeaf(DNodeLeaf):
    default: ?str
    units: ?str

    def __init__(self, name: str, config: bool, description: ?str=None, default=None, if_feature=[], mandatory=False, must=[], reference=None, status=None, type_: Type, units=None, when=None, exts=[]):
        self.name = name
        self.dname = "Leaf"
        self.config = config
        self.description = description
        self.default = default
        self.if_feature = if_feature
        self.mandatory = mandatory
        self.must = must
        self.reference = reference
        self.status = status
        self.type_ = type_
        self.units = units
        self.when = when
        self.exts = exts

    def is_key(self) -> bool:
        parent = self.parent
        if isinstance(parent, DList):
            if self.name in parent.key:
                return True
        return False

class DLeafList(DNodeLeaf):
    default: list[str]
    max_elements: ?int
    min_elements: int
    ordered_by: str
    units: ?str

    def __init__(self, name: str, config: bool, description: ?str=None, default=[], if_feature=[], max_elements: ?int=None, min_elements=0, must=[], ordered_by="system", reference=None, status=None, type_: Type, units=None, when=None, exts=[]):
        self.name = name
        self.dname = "LeafList"
        self.config = config
        self.description = description
        self.default = default
        self.if_feature = if_feature
        self.max_elements = max_elements
        self.min_elements = min_elements
        self.must = must
        self.ordered_by = ordered_by
        self.reference = reference
        self.status = status
        self.type_ = type_
        self.units = units
        self.when = when
        self.exts = exts

class DRoot(DNodeInner):
    def __init__(self, modules: list[DNode]=[]):
        self.name = "root"
        self.dname = "Root"
        self.config = True
        self.children=[]
        for module in modules:
            if isinstance(module, DModule):
                for child in module.children:
                    self.children.append(child)
            else:
                raise ValueError("DRoot can only contain DModule")


# TODO: how to work with input / output for RPCs and actions?

# -------------------------------------------------------------------------------

def split_prefix_name(name: str) -> (?str, str):
    if name.find(":") != -1:
        parts = name.split(":", 1)
        return (parts[0], parts[1])
    return None, name

# -------------------------------------------------------------------------------

class ModRev(object):
    modname: str
    rev: ?str

    def __init__(self, modname: str, rev: ?str):
        self.modname = modname
        self.rev = rev

extension ModRev (Hashable):
    def __eq__(self, other: ModRev) -> bool:
        return self.modname == other.modname and self.rev == other.rev

    def __hash__(self) -> int:
        selfrev = self.rev
        revstr = selfrev if selfrev is not None else ""
        # TODO: actually include revision in hash
        #return self.modname.__hash__() + revstr.__hash__()
        return self.modname.__hash__()

class Context(object):
    """Compilation context
    """
    modules: dict[ModRev, Module]

    def __init__(self, modules: list[Module]=[]):
        self.modules = {}
        for module in modules:
            self.add_module(module)

    def add_module(self, module: Module):
        # TODO: handle revision
        latest_revision = module.get_revision()
        self.modules[ModRev(module.name, latest_revision.date if latest_revision is not None else None)] = module
        # Now also add the module itself without revision
        no_rev_mod = ModRev(module.name, None)
        if no_rev_mod in self.modules:
            existing_revision = self.modules[no_rev_mod].get_revision()
            if existing_revision is not None and latest_revision is not None:
                if latest_revision.date > existing_revision.date:
                    # Currently added module has a revision that is newer, so it
                    # should replace the existing module
                    self.modules[no_rev_mod] = module
                # Otherwise, the existing module is newer, so we should keep it
                return
            elif existing_revision is None and latest_revision is not None:
                # Currently added module has a revision, but existing module does not
                # so we presume that we're adding a newer version of the module
                self.modules[no_rev_mod] = module
            # Otherwise, both modules have no revision, so we keep the existing one
            return
        else: # No module with this name exists yet
            self.modules[no_rev_mod] = module

    def get_module(self, modname: str, rev: ?str) -> Module:
        for mod in self.modules:
            modrev = mod.rev
        try:
            mod = self.modules[ModRev(modname, rev)]
            return mod
        except KeyError:
            raise ValueError("Module %s rev %s not found in compilation context" % (modname, rev if rev is not None else ""))


class SchemaNode(object):
    parent: ?SchemaNode
    namespace: ?str
    prefix: ?str
    exts: list[Ext]

    def _get_argname(self) -> ?str:
        raise NotImplementedError('SchemaNode _get_argname')

    def _get_arg(self) -> ?str:
        raise NotImplementedError('SchemaNode _get_arg')

    def prsrc(self, indent=0) -> str:
        """Print Acton source code for this schema node and its subnodes
        """
        raise NotImplementedError('SchemaNode prsrc')

    def prdaclass(self, loose=False, top=True) -> str:
        """Print the data class for this schema node
        """
        raise NotImplementedError('SchemaNode pdc')

    mut def to_dnode(self) -> DNode:
        raise NotImplementedError('SchemaNode to_dschema not implemented for %s' % type(self))

    def get_dnode_children(self):
        if isinstance(self, SchemaNodeInner):
            new_children = []
            for child in self.children:
                if isinstance(child, Grouping):
                    continue
                if isinstance(child, Identity_):
                    continue
                if isinstance(child, Typedef):
                    continue
                new_children.append(child.to_dnode())
            return new_children
        raise ValueError("get_dnode_children() called on non-inner node %s" % type(self))

    def get_namespace(self) -> str:
        n = self
        for i in range(RECURSION_LIMIT+1):
            nnamespace = n.namespace
            if nnamespace is not None:
                return nnamespace
            nparent = n.parent
            if nparent is not None:
                n = nparent
                continue
            if i > RECURSION_LIMIT:
                raise ValueError("Recursion limit reached")
        raise ValueError("Unable to find namespace")

    def get_prefix(self) -> str:
        n = self
        for i in range(RECURSION_LIMIT+1):
            nprefix = n.prefix
            if nprefix is not None:
                return nprefix
            nparent = n.parent
            if nparent is not None:
                n = nparent
                continue
            if i > RECURSION_LIMIT:
                raise ValueError("Recursion limit reached")
        raise ValueError("Unable to find namespace")

    def is_config(self) -> bool:
        n = self
        for i in range(RECURSION_LIMIT+1):
            if (isinstance(n, Anydata)
                or isinstance(n, Anyxml)
                or isinstance(n, Container_)
                or isinstance(n, Module)
                or isinstance(n, Leaf)
                or isinstance(n, LeafList)
                or isinstance(n, List)):
                found_config = True
                if isinstance(n, Anydata):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, Anyxml):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, Container_):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, Module):
                    return True
                elif isinstance(n, Leaf):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, LeafList):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, List):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False

                if not found_config:
                    nparent = n.parent
                    if nparent is not None:
                        n = nparent
                        continue
                    else:
                        if isinstance(n, Module):
                            return True
                        else:
                            raise ValueError("Reached some top data node of type %s" % type(n))
            else:
                raise ValueError("Non-data node %s does not have config statements" % type(n))
            if i > RECURSION_LIMIT:
                raise ValueError("Recursion limit reached")
        raise ValueError("Unable to find config attribute")

    def get_parent(self) -> SchemaNode:
        p = self.parent
        if p is not None:
            return p
        raise ValueError("No parent found")

    def get(self, name: str) -> SchemaNode:
        """Get child node with name
        """
        if isinstance(self, SchemaNodeInner):
            for child in self.children:
                if isinstance(child, Anydata) and _safe_name(child.name) == name:
                    return child
                elif isinstance(child, Anyxml) and _safe_name(child.name) == name:
                    return child
                elif isinstance(child, Container_) and _safe_name(child.name) == name:
                    return child
                elif isinstance(child, Leaf) and _safe_name(child.name) == name:
                    return child
                elif isinstance(child, LeafList) and _safe_name(child.name) == name:
                    return child
                elif isinstance(child, List) and _safe_name(child.name) == name:
                    return child
            raise ValueError("Child %s not found" % name)

        raise ValueError("Unable to get child from non-inner node")

    def get_module(self) -> Module:
        """Get the Module for the local module

        That is, climb up the ladder of parents from the current node until we
        reach the top Module.
        """
        n = self
        while True:
            if isinstance(n, Module):
                return n
            nparent = n.parent
            if nparent is not None:
                n = nparent
                continue
            break
        raise ValueError("Unable to find Module")

    def compile(self, context: Context) -> SchemaNode:
        """Compile an abstract YANG into a concrete one
        - expand uses / groupings
        - handle augments
        - resolve types to base types
        """
        raise NotImplementedError('SchemaNode compile')

    def expand_augments(self, context: Context, target_base: SchemaNode=self, in_uses=False):
        """Expand augment node"""
        def get_target(target_base, target: str) -> SchemaNode:
            if in_uses and target[0] == "/":
                raise ValueError("Absolute path in augment under uses is not valid")
            elif not in_uses and target[0] != "/":
                raise ValueError("Relative path in augment under (sub-)module is not valid")
            parts = target.lstrip("/").split("/")
            current_prefix = None
            current_node = target_base
            for part in parts:
                prefix, name = split_prefix_name(part)
                if prefix is not None and prefix != current_prefix:
                    current_prefix = prefix
                    current_node = current_node.get_module_by_prefix(prefix, context)
                current_node = current_node.get(name)
            return current_node

        def expand_augment(augments: list[Augment], target_base, context: Context):
            for aug in augments:
                target = get_target(target_base, aug.target_node)
                if isinstance(target, SchemaNodeInner):
                    # Just move the child to the target
                    new_children = aug.expand_children(context)
                    target.children.extend(new_children)
                    for new_child in new_children:
                        new_child.parent = target
                else:
                    raise ValueError("Augment target is not an inner node")

        # Look if node is of a type that has augment substatements
        if isinstance(self, Module):
            expand_augment(self.augment, self, context)
        elif isinstance(self, Submodule):
            expand_augment(self.augment, self, context)
        elif isinstance(self, Uses):
            expand_augment(self.augment, target_base, context)
        else:
            raise ValueError("Node type does not have augment substatements")

    def expand_children(self, context: Context) -> list[SchemaNode]:
        """Expand abstract children into concrete nodes
        """
        if isinstance(self, SchemaNodeInner):
            res = []
            for child in self.children:
                if isinstance(child, Case):
                    new_children = child.expand_children(context)
                    for new_child in new_children:
                        new_child.parent = self
                    res.extend(new_children)
                elif isinstance(child, Choice):
                    new_children = child.expand_children(context)
                    for new_child in new_children:
                        new_child.parent = self
                    res.extend(new_children)
                elif isinstance(child, Uses):
                    grouping = child.get_grouping(_safe_name(child.name), context)
                    grouping_children = grouping.expand_children(context)
                    for new_child in grouping_children:
                        new_child.parent = self
                    res.extend(grouping_children)
                    dummy = Container_(name=grouping.name, children=res)
                    child.expand_augments(context, dummy, in_uses=True)
                else:
                    res.append(child.compile(context))
            return res
        raise ValueError("expand_children() called on non-inner node %s" % type(self))

    def get_module_by_prefix(self, prefix: str, context: Context) -> Module:
        """Get a Module from the import prefix in the local module"""
        local_module = self.get_module()
        local_module_prefix = local_module.prefix
        if local_module_prefix is not None and local_module_prefix == prefix:
            return local_module
        imp = local_module.get_import_by_prefix(prefix)
        return context.get_module(imp.module, imp.revision_date)

    def get_grouping(self, name: str, context: Context) -> Grouping:
        """Find a grouping in the local module or an imported module
        """
        prefix, group_name = split_prefix_name(name)
        if prefix is not None:
            imported_module = self.get_module_by_prefix(prefix, context)
            return imported_module.get_grouping(group_name, context)
        else: # local module
            return self.get_grouping_in_module(group_name)

    def get_grouping_in_module(self, name: str) -> Grouping:
        """Find a grouping in the current module
        """
        n = self
        for i in range(RECURSION_LIMIT+1):
            if isinstance(n, SchemaNodeInner):
                for child in n.children:
                    if isinstance(child, Grouping) and _safe_name(child.name) == name:
                        return child
            nparent = n.parent
            if nparent is not None:
                n = nparent
                continue
            else:
                break
            if i == RECURSION_LIMIT:
                raise ValueError("Recursion limit reached")
        raise ValueError("Unable to find grouping '%s'" % name)

    def get_typedef(self, name: str, context: Context) -> Typedef:
        """Find a typedef in the local module or an imported module
        """
        prefix, typedef_name = split_prefix_name(name)
        if prefix is not None:
            imported_module = self.get_module_by_prefix(prefix, context)
            return imported_module.get_typedef(typedef_name, context)
        else:
            return self.get_typedef_in_module(typedef_name)

    def get_typedef_in_module(self, name: str) -> Typedef:
        """Find a typedef in the current module
        """
        n = self
        for i in range(RECURSION_LIMIT+1):
            typedefs: list[Typedef] = []
            if isinstance(n, SchemaNodeInner):
                for child in n.children:
                    if isinstance(child, Typedef) and child.name == name:
                        return child
            nparent = n.parent
            if nparent is not None:
                n = nparent
                continue
            else:
                break
            if i == RECURSION_LIMIT:
                raise ValueError("Recursion limit reached")
        raise ValueError("Unable to find typedef '%s'" % name)


class SchemaNodeInner(SchemaNode):
    children: list[SchemaNode]

class SchemaNodeOuter(SchemaNode):
    pass

class Ext(SchemaNode):
    """An extension statement

    This is not the definition of an extension, e.g. the "extension" keyword,
    but an instance of an extension, like "foo:bar 'test';"
    """
    name: str
    arg: ?str

    def __init__(self, prefix: str, name: str, arg: ?str=None, exts=[]):
        self.prefix = prefix
        self.name = name
        self.arg = arg
        self.exts = exts

    @staticmethod
    def from_fullname(fullname: str, arg: ?str=None, exts=[]) -> Ext:
        parts = fullname.split(":", 1)
        if len(parts) != 2:
            raise ValueError("Invalid extension name %s, extensions must always have a prefix like: foo:bar 'test';" % fullname)
        return Ext(parts[0], parts[1], None)

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("arg", self.arg),
            ("exts", self.exts),
            ]
        prefix = self.prefix
        args = []
        if prefix is not None:
            args = ["'" + str(prefix) + "', '" + str(self.name) + "'"]
        else:
            raise ValueError("No prefix in Ext.prsrc, this should never happen")
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(attrs_text)
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Ext(" + args_text + ")"
        res.append(text_line)
        return "\n".join(res)



def take_opt_bool(stmts: list[Statement], kw: str) -> ?bool:
    v = take_opt_str(stmts, kw)
    if v is not None:
        if v == "true":
            return True
        elif v == "false":
            return False

def take_bool(stmts: list[Statement], kw: str) -> bool:
    v = take_opt_str(stmts, kw)
    if v is not None:
        if v == "true":
            return True
        elif v == "false":
            return False
    raise ValueError("No %s in stmts" % kw)

def take_opt_int(stmts: list[Statement], kw: str) -> ?int:
    v = take_opt_str(stmts, kw)
    if v is not None:
        return int(v)

def take_int(stmts: list[Statement], kw: str) -> int:
    v = take_opt_str(stmts, kw)
    if v is not None:
        return int(v)
    raise ValueError("No %s in stmts" % kw)

def take_opt_str(stmts: list[Statement], kw: str) -> ?str:
    for i in range(len(stmts)):
        if stmts[i].kw == kw:
            arg = stmts[i].arg
            if arg is not None:
                del stmts[i]
                return arg

def take_str(stmts: list[Statement], kw: str) -> str:
    for i in range(len(stmts)):
        if stmts[i].kw == kw:
            arg = stmts[i].arg
            if arg is not None:
                del stmts[i]
                return arg
    raise ValueError("No %s in stmts" % kw)

def take_yang_version(stmts: list[Statement]) -> float:
    v = take_opt_str(stmts, "yang-version")
    if v is not None:
        # TODO: this should just be: return float(v)
        # but a compiler bug prevents that from working
        f = float(v)
        return f
    return 1.0

def take_strlist(stmts: list[Statement], kw: str) -> list[str]:
    res = []
    todel = []
    for i in range(len(stmts)):
        if stmts[i].kw == kw:
            arg = stmts[i].arg
            if arg is not None:
                todel.append(i)
                res.append(arg)
    for d in reversed(todel):
        del stmts[d]
    return res

def take_node(stmts: list[Statement], kw: str) -> ?SchemaNode:
    for i in range(len(stmts)):
        if stmts[i].kw == kw:
            n = stmt_to_snode(stmts[i])
            del stmts[i]
            return n

def take_nodes(stmts: list[Statement], kw: list[str]) -> list[SchemaNode]:
    res = []
    todel = []
    for i in range(len(stmts)):
        if stmts[i].kw in kw:
            res.append(stmt_to_snode(stmts[i]))
            todel.append(i)
    for i in reversed(todel):
        del stmts[i]
    return res

def take_exts(stmts: list[Statement]) -> list[Ext]:
    """Take all extension statements from a list of statements

    Extension statements always follow the form:

    prefix:extension arg;
    """
    res = []
    todel = []
    for i in range(len(stmts)):
        prefix = stmts[i].prefix
        name = stmts[i].kw
        arg = stmts[i].arg
        # TODO: I think prefix should be None, not "", right? prefix should be
        # the prefix of the statement and not the prefix of the module, like the
        # namespace prefix
        if prefix is not None and len(prefix) > 0:
            res.append(Ext(prefix, name, arg, exts=take_exts(stmts[i].substatements)))
            todel.append(i)
    for i in reversed(todel):
        del stmts[i]
    return res

def _attr_name(name: str):
    res = ""
    i = 0
    while True:
        if name[i] == "-":
            res += "_"
        else:
            res += name[i]
        i += 1
        if i == len(name):
            break
    if res in {"extension", "import", "type"}:
        res = res + "_"

    return res

def _prsrc_attrs(indent, attrs):
    """Print source code for a list of SchemaNode attributes"""
    res = []
    for attr in attrs:
        raw_name, value = attr
        name = _attr_name(raw_name)
        if value is not None:
            if isinstance(value, list):
                if len(value) == 0:
                    continue
                else:
                    list_val = []
                    content_is_snode = False
                    for e in value:
                        if isinstance(e, SchemaNode):
                            list_val.append(e.prsrc(indent+2))
                        else:
                            list_val.append(repr(e))
                    list_val_str = "[]"
                    if len(list_val) == 1 and list_val[0][0] != " " and len(list_val[0]) < 20:
                        list_val_str = "[" + list_val[0] + "]"
                    else:
                        list_val_str = "[\n" + ",\n".join(list_val) + "\n" + _ind(indent + 1) + "]"
                    res.append(name + "=" + list_val_str)
            elif isinstance(value, SchemaNode):
                res.append(name + "=" + value.prsrc(0))
            else:
                res.append(name + "=" + repr(value))
    return ", ".join(res)


def yang_leaf_to_acton_type(leaf: DNodeLeaf, loose: bool=False) -> str:
    optional = True
    # Mandatory leaf in YANG model are non-optional in Acton
    leafmandatory = leaf.mandatory
    if leafmandatory is not None:
        optional = not leafmandatory
    # But with loose validation, even mandatory YANG leaves are optional!
    if loose:
        optional = True
    # ... although being part of a key always makes it non-optional
    parent = leaf.parent
    if isinstance(parent, DList):
        if leaf.name in parent.key:
            optional = False
    optional_str = "?" if optional else ""
    t = yang_type_to_acton_type(leaf.type_)
    return optional_str + t

def yang_leaf_to_getval(leaf: DNodeLeaf) -> str:
    # TODO: uh, do we need loose arg?
    optional = True
    leafmandatory = leaf.mandatory
    if leafmandatory is not None:
        optional = not leafmandatory
    parent = leaf.parent
    if isinstance(parent, DList):
        if leaf.name in parent.key:
            optional = False
    optional_str = "opt_" if optional else ""
    t = yang_type_to_acton_type(leaf.type_)
    return optional_str + t

def yang_leaflist_to_acton_type(leaf: DLeafList) -> str:
    t = yang_type_to_acton_type(leaf.type_)
    return "list[%s]" % t


def yang_type_to_acton_type(t: ?Type) -> str:
    # +---------------------+-------------------------------------+
    # | Name                | Description                         |
    # +---------------------+-------------------------------------+
    # | binary              | Any binary data                     |
    # | bits                | A set of bits or flags              |
    # | boolean             | "true" or "false"                   |
    # | decimal64           | 64-bit signed decimal number        |
    # | empty               | A leaf that does not have any value |
    # | enumeration         | One of an enumerated set of strings |
    # | identityref         | A reference to an abstract identity |
    # | instance-identifier | A reference to a data tree node     |
    # | int8                | 8-bit signed integer                |
    # | int16               | 16-bit signed integer               |
    # | int32               | 32-bit signed integer               |
    # | int64               | 64-bit signed integer               |
    # | leafref             | A reference to a leaf instance      |
    # | string              | A character string                  |
    # | uint8               | 8-bit unsigned integer              |
    # | uint16              | 16-bit unsigned integer             |
    # | uint32              | 32-bit unsigned integer             |
    # | uint64              | 64-bit unsigned integer             |
    # | union               | Choice of member types              |
    # +---------------------+-------------------------------------+
    if t is not None:
        if t.name == "binary":
            return "bytes"
        elif t.name == "bits":
            raise NotImplementedError('bits not supported')
        elif t.name == "boolean":
            return "bool"
        elif t.name == "decimal64":
            # TODO: do something better
            return "float"
        elif t.name == "empty":
            # TODO: is this right?
            return "bool"
        elif t.name == "enumeration":
            # TODO: use acton unions of fixed strings!?
            return "str"
        elif t.name == "identityref":
            return "str"
        elif t.name == "instance-identifier":
            return "str"
        elif t.name in {"int8", "int16", "int32", "int64", "uint8", "uint16", "uint32", "uint64"}:
            return "int"
        elif t.name == "leafref":
            return "str"
        elif t.name == "string":
            return "str"
        elif t.name == "union":
            # TODO: use atom when union consists of types that we represent with Acton built-in types
            # TODO: use Acton union
            return "value"
        else:
            raise ValueError("Unknown YANG type: " + t.name)
    raise ValueError("type not defined")


def _safe_name(name: str) -> str:
    new = name.replace("-", "_")
    if new in {"action",
               "class",
               "except",
               "from",
               "protocol",
               }:
        new += "_"
    return new

def _get_full_name(dnode: DNode) -> str:
    """
    """
    path = []
    while True:
        path.append(dnode.name.replace("-", "_"))
        parent = dnode.parent
        if parent is not None:
            dnode = parent
        else:
            break
    if len(path) == 0:
        raise ValueError("No path for DNode" + str(dnode))
    return "__".join(reversed(path))


# -- end of manually defined schema functions, automatically generated code follows


extension SchemaNode (Eq):
    def __eq__(self, other: SchemaNode) -> bool:
        if type(self) != type(other):
            return False
        elif isinstance(self, Action) and isinstance(other, Action):
            return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.input == other.input and self.output == other.output and self.reference == other.reference and self.status == other.status
        elif isinstance(self, Anydata) and isinstance(other, Anydata):
            return self.name == other.name and self.config == other.config and self.description == other.description and self.if_feature == other.if_feature and self.mandatory == other.mandatory and self.must == other.must and self.reference == other.reference and self.status == other.status and self.when == other.when
        elif isinstance(self, Anyxml) and isinstance(other, Anyxml):
            return self.name == other.name and self.config == other.config and self.description == other.description and self.if_feature == other.if_feature and self.mandatory == other.mandatory and self.must == other.must and self.reference == other.reference and self.status == other.status and self.when == other.when
        elif isinstance(self, Augment) and isinstance(other, Augment):
            return self.target_node == other.target_node and self.description == other.description and self.if_feature == other.if_feature and self.reference == other.reference and self.status == other.status and self.when == other.when
        elif isinstance(self, BelongsTo) and isinstance(other, BelongsTo):
            return self.module == other.module and self.prefix == other.prefix
        elif isinstance(self, Bit) and isinstance(other, Bit):
            return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.position == other.position and self.reference == other.reference and self.status == other.status
        elif isinstance(self, Case) and isinstance(other, Case):
            return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.reference == other.reference and self.status == other.status and self.when == other.when
        elif isinstance(self, Choice) and isinstance(other, Choice):
            return self.name == other.name and self.config == other.config and self.default == other.default and self.description == other.description and self.if_feature == other.if_feature and self.mandatory == other.mandatory and self.reference == other.reference and self.status == other.status and self.when == other.when
        elif isinstance(self, Container_) and isinstance(other, Container_):
            return self.name == other.name and self.config == other.config and self.description == other.description and self.if_feature == other.if_feature and self.must == other.must and self.presence == other.presence and self.reference == other.reference and self.status == other.status and self.when == other.when
        elif isinstance(self, Enum) and isinstance(other, Enum):
            return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.reference == other.reference and self.status == other.status and self.value == other.value
        elif isinstance(self, Extension) and isinstance(other, Extension):
            return self.name == other.name and self.argument == other.argument and self.description == other.description and self.reference == other.reference and self.status == other.status
        elif isinstance(self, Feature) and isinstance(other, Feature):
            return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.reference == other.reference and self.status == other.status
        elif isinstance(self, Grouping) and isinstance(other, Grouping):
            return self.name == other.name and self.description == other.description and self.reference == other.reference and self.status == other.status
        elif isinstance(self, Identity_) and isinstance(other, Identity_):
            return self.name == other.name and self.base == other.base and self.description == other.description and self.if_feature == other.if_feature and self.reference == other.reference and self.status == other.status
        elif isinstance(self, Import) and isinstance(other, Import):
            return self.module == other.module and self.description == other.description and self.prefix == other.prefix and self.reference == other.reference and self.revision_date == other.revision_date
        elif isinstance(self, Include) and isinstance(other, Include):
            return self.module == other.module and self.description == other.description and self.reference == other.reference and self.revision_date == other.revision_date
        elif isinstance(self, Input) and isinstance(other, Input):
            return self.must == other.must
        elif isinstance(self, Leaf) and isinstance(other, Leaf):
            return self.name == other.name and self.config == other.config and self.default == other.default and self.description == other.description and self.if_feature == other.if_feature and self.mandatory == other.mandatory and self.must == other.must and self.reference == other.reference and self.status == other.status and self.type_ == other.type_ and self.units == other.units and self.when == other.when
        elif isinstance(self, LeafList) and isinstance(other, LeafList):
            return self.name == other.name and self.config == other.config and self.default == other.default and self.description == other.description and self.if_feature == other.if_feature and self.max_elements == other.max_elements and self.min_elements == other.min_elements and self.must == other.must and self.ordered_by == other.ordered_by and self.reference == other.reference and self.status == other.status and self.type_ == other.type_ and self.units == other.units and self.when == other.when
        elif isinstance(self, Length) and isinstance(other, Length):
            return self.value == other.value and self.description == other.description and self.error_app_tag == other.error_app_tag and self.error_message == other.error_message and self.reference == other.reference
        elif isinstance(self, List) and isinstance(other, List):
            return self.name == other.name and self.config == other.config and self.description == other.description and self.if_feature == other.if_feature and self.key == other.key and self.max_elements == other.max_elements and self.min_elements == other.min_elements and self.must == other.must and self.ordered_by == other.ordered_by and self.reference == other.reference and self.status == other.status and self.unique == other.unique and self.when == other.when
        elif isinstance(self, Module) and isinstance(other, Module):
            return self.name == other.name and self.augment == other.augment and self.contact == other.contact and self.description == other.description and self.deviation == other.deviation and self.extension_ == other.extension_ and self.feature == other.feature and self.import_ == other.import_ and self.include == other.include and self.namespace == other.namespace and self.organization == other.organization and self.prefix == other.prefix and self.reference == other.reference and self.revision == other.revision and self.yang_version == other.yang_version
        elif isinstance(self, Must) and isinstance(other, Must):
            return self.condition == other.condition and self.description == other.description and self.error_app_tag == other.error_app_tag and self.error_message == other.error_message and self.reference == other.reference
        elif isinstance(self, Notification) and isinstance(other, Notification):
            return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.must == other.must and self.reference == other.reference and self.status == other.status
        elif isinstance(self, Output) and isinstance(other, Output):
            return self.must == other.must
        elif isinstance(self, Pattern) and isinstance(other, Pattern):
            return self.value == other.value and self.description == other.description and self.error_app_tag == other.error_app_tag and self.error_message == other.error_message and self.modifier == other.modifier and self.reference == other.reference
        elif isinstance(self, Range) and isinstance(other, Range):
            return self.value == other.value and self.description == other.description and self.error_app_tag == other.error_app_tag and self.error_message == other.error_message and self.reference == other.reference
        elif isinstance(self, Refine) and isinstance(other, Refine):
            return self.target_node == other.target_node and self.config == other.config and self.default == other.default and self.description == other.description and self.if_feature == other.if_feature and self.mandatory == other.mandatory and self.max_elements == other.max_elements and self.min_elements == other.min_elements and self.must == other.must and self.presence == other.presence and self.reference == other.reference
        elif isinstance(self, Revision) and isinstance(other, Revision):
            return self.date == other.date and self.description == other.description and self.reference == other.reference
        elif isinstance(self, Rpc) and isinstance(other, Rpc):
            return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.input == other.input and self.output == other.output and self.reference == other.reference and self.status == other.status
        elif isinstance(self, Submodule) and isinstance(other, Submodule):
            return self.name == other.name and self.augment == other.augment and self.belongs_to == other.belongs_to and self.contact == other.contact and self.description == other.description and self.deviation == other.deviation and self.extension_ == other.extension_ and self.feature == other.feature and self.import_ == other.import_ and self.include == other.include and self.organization == other.organization and self.reference == other.reference and self.revision == other.revision and self.yang_version == other.yang_version
        elif isinstance(self, Type) and isinstance(other, Type):
            return self.name == other.name and self.base == other.base and self.bit == other.bit and self.enum == other.enum and self.fraction_digits == other.fraction_digits and self.length == other.length and self.path == other.path and self.pattern == other.pattern and self.range_ == other.range_ and self.require_instance == other.require_instance and self.type_ == other.type_
        elif isinstance(self, Typedef) and isinstance(other, Typedef):
            return self.name == other.name and self.default == other.default and self.description == other.description and self.reference == other.reference and self.status == other.status and self.type_ == other.type_ and self.units == other.units
        elif isinstance(self, Uses) and isinstance(other, Uses):
            return self.name == other.name and self.augment == other.augment and self.description == other.description and self.if_feature == other.if_feature and self.reference == other.reference and self.refine == other.refine and self.status == other.status and self.when == other.when
        return False

def snode_name(sn: SchemaNode) -> str:
    if isinstance(sn, Action):
        return sn.name
    if isinstance(sn, Anydata):
        return sn.name
    if isinstance(sn, Anyxml):
        return sn.name
    if isinstance(sn, Augment):
        return sn.target_node
    if isinstance(sn, BelongsTo):
        return sn.module
    if isinstance(sn, Bit):
        return sn.name
    if isinstance(sn, Case):
        return sn.name
    if isinstance(sn, Choice):
        return sn.name
    if isinstance(sn, Container_):
        return sn.name
    if isinstance(sn, Enum):
        return sn.name
    if isinstance(sn, Extension):
        return sn.name
    if isinstance(sn, Feature):
        return sn.name
    if isinstance(sn, Grouping):
        return sn.name
    if isinstance(sn, Identity_):
        return sn.name
    if isinstance(sn, Import):
        return sn.module
    if isinstance(sn, Include):
        return sn.module
    if isinstance(sn, Leaf):
        return sn.name
    if isinstance(sn, LeafList):
        return sn.name
    if isinstance(sn, Length):
        return sn.value
    if isinstance(sn, List):
        return sn.name
    if isinstance(sn, Module):
        return sn.name
    if isinstance(sn, Must):
        return sn.condition
    if isinstance(sn, Notification):
        return sn.name
    if isinstance(sn, Pattern):
        return sn.value
    if isinstance(sn, Range):
        return sn.value
    if isinstance(sn, Refine):
        return sn.target_node
    if isinstance(sn, Revision):
        return sn.date
    if isinstance(sn, Rpc):
        return sn.name
    if isinstance(sn, Submodule):
        return sn.name
    if isinstance(sn, Type):
        return sn.name
    if isinstance(sn, Typedef):
        return sn.name
    if isinstance(sn, Uses):
        return sn.name
    raise ValueError("Unknown SchemaNode type in snode_name")

def snode_type_name(sn: SchemaNode) -> str:
    if isinstance(sn, Action):
        return "Action"
    if isinstance(sn, Anydata):
        return "Anydata"
    if isinstance(sn, Anyxml):
        return "Anyxml"
    if isinstance(sn, Augment):
        return "Augment"
    if isinstance(sn, BelongsTo):
        return "BelongsTo"
    if isinstance(sn, Bit):
        return "Bit"
    if isinstance(sn, Case):
        return "Case"
    if isinstance(sn, Choice):
        return "Choice"
    if isinstance(sn, Container_):
        return "Container_"
    if isinstance(sn, Enum):
        return "Enum"
    if isinstance(sn, Extension):
        return "Extension"
    if isinstance(sn, Feature):
        return "Feature"
    if isinstance(sn, Grouping):
        return "Grouping"
    if isinstance(sn, Identity_):
        return "Identity_"
    if isinstance(sn, Import):
        return "Import"
    if isinstance(sn, Include):
        return "Include"
    if isinstance(sn, Leaf):
        return "Leaf"
    if isinstance(sn, LeafList):
        return "LeafList"
    if isinstance(sn, Length):
        return "Length"
    if isinstance(sn, List):
        return "List"
    if isinstance(sn, Module):
        return "Module"
    if isinstance(sn, Must):
        return "Must"
    if isinstance(sn, Notification):
        return "Notification"
    if isinstance(sn, Pattern):
        return "Pattern"
    if isinstance(sn, Range):
        return "Range"
    if isinstance(sn, Refine):
        return "Refine"
    if isinstance(sn, Revision):
        return "Revision"
    if isinstance(sn, Rpc):
        return "Rpc"
    if isinstance(sn, Submodule):
        return "Submodule"
    if isinstance(sn, Type):
        return "Type"
    if isinstance(sn, Typedef):
        return "Typedef"
    if isinstance(sn, Uses):
        return "Uses"
    raise ValueError("Unknown SchemaNode type in snode_type_name")

class Action(SchemaNodeInner):
    """YANG action

    https://tools.ietf.org/html/rfc7950#section-7.15.1
    """
    name: str
    description: ?str
    if_feature: list[str]
    input: ?Input
    output: ?Output
    reference: ?str
    status: ?str

    def __init__(self, name: str, description: ?str=None, if_feature: list[str]=[], input: ?Input=None, output: ?Output=None, reference: ?str=None, status: ?str=None, exts=[], children=[], namespace=None, prefix=None):
        self.parent = None
        if input is not None:
            input.parent = self
        if output is not None:
            output.parent = self
        for n in children:
            n.parent = self
        self.name = name
        self.description = description
        self.if_feature = if_feature
        self.input = input
        self.output = output
        self.reference = reference
        self.status = status
        self.exts = exts
        self.children = children
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("input", self.input),
            ("output", self.output),
            ("reference", self.reference),
            ("status", self.status),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.name) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        if len(self.children) > 0:
            args.append("children=[")
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Action(" + args_text
        if len(self.children) == 0:
            text_line += ')'
        res.append(text_line)
        if len(self.children) > 0:
            child_res = []
            for child in self.children:
                child_res.append(child.prsrc(indent+1))
            res.append(",\n".join(child_res))
            res.append(_ind(indent) + "])")
        return "\n".join(res)

    def compile(self, context: Context):
        new = Action(self.name,
                     description=self.description,
                     if_feature=self.if_feature,
                     input=self.input,
                     output=self.output,
                     reference=self.reference,
                     status=self.status,
                     children=self.expand_children(context))
        return new

    def __str__(self):
        return "Action " + self.name

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Action (Ord):
    def __eq__(self, other: Action):
        return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.input == other.input and self.output == other.output and self.reference == other.reference and self.status == other.status

    def __lt__(a, b):
        return a.name < b.name

class Anydata(SchemaNodeOuter):
    """YANG anydata

    https://tools.ietf.org/html/rfc7950#section-7.10.1
    """
    name: str
    config: ?bool
    description: ?str
    if_feature: list[str]
    mandatory: ?bool
    must: list[Must]
    reference: ?str
    status: ?str
    when: ?str

    def __init__(self, name: str, config: ?bool=None, description: ?str=None, if_feature: list[str]=[], mandatory: ?bool=None, must: list[Must]=[], reference: ?str=None, status: ?str=None, when: ?str=None, exts=[], namespace=None, prefix=None):
        self.parent = None
        for n in must:
            n.parent = self
        self.name = name
        self.config = config
        self.description = description
        self.if_feature = if_feature
        self.mandatory = mandatory
        self.must = must
        self.reference = reference
        self.status = status
        self.when = when
        self.exts = exts
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("config", self.config),
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("mandatory", self.mandatory),
            ("must", self.must),
            ("reference", self.reference),
            ("status", self.status),
            ("when", self.when),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.name) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Anydata(" + args_text + ")"
        res.append(text_line)
        return "\n".join(res)

    def compile(self, context: Context):
        new = Anydata(self.name,
                      config=self.config,
                      description=self.description,
                      if_feature=self.if_feature,
                      mandatory=self.mandatory,
                      must=self.must,
                      reference=self.reference,
                      status=self.status,
                      when=self.when)
        return new

    def __str__(self):
        return "Anydata " + self.name

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Anydata (Ord):
    def __eq__(self, other: Anydata):
        return self.name == other.name and self.config == other.config and self.description == other.description and self.if_feature == other.if_feature and self.mandatory == other.mandatory and self.must == other.must and self.reference == other.reference and self.status == other.status and self.when == other.when

    def __lt__(a, b):
        return a.name < b.name

class Anyxml(SchemaNodeOuter):
    """YANG anyxml

    https://tools.ietf.org/html/rfc7950#section-7.11.1
    """
    name: str
    config: ?bool
    description: ?str
    if_feature: list[str]
    mandatory: ?bool
    must: list[Must]
    reference: ?str
    status: ?str
    when: ?str

    def __init__(self, name: str, config: ?bool=None, description: ?str=None, if_feature: list[str]=[], mandatory: ?bool=None, must: list[Must]=[], reference: ?str=None, status: ?str=None, when: ?str=None, exts=[], namespace=None, prefix=None):
        self.parent = None
        for n in must:
            n.parent = self
        self.name = name
        self.config = config
        self.description = description
        self.if_feature = if_feature
        self.mandatory = mandatory
        self.must = must
        self.reference = reference
        self.status = status
        self.when = when
        self.exts = exts
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("config", self.config),
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("mandatory", self.mandatory),
            ("must", self.must),
            ("reference", self.reference),
            ("status", self.status),
            ("when", self.when),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.name) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Anyxml(" + args_text + ")"
        res.append(text_line)
        return "\n".join(res)

    def compile(self, context: Context):
        new = Anyxml(self.name,
                     config=self.config,
                     description=self.description,
                     if_feature=self.if_feature,
                     mandatory=self.mandatory,
                     must=self.must,
                     reference=self.reference,
                     status=self.status,
                     when=self.when)
        return new

    def __str__(self):
        return "Anyxml " + self.name

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Anyxml (Ord):
    def __eq__(self, other: Anyxml):
        return self.name == other.name and self.config == other.config and self.description == other.description and self.if_feature == other.if_feature and self.mandatory == other.mandatory and self.must == other.must and self.reference == other.reference and self.status == other.status and self.when == other.when

    def __lt__(a, b):
        return a.name < b.name

class Augment(SchemaNodeInner):
    """YANG augment

    https://tools.ietf.org/html/rfc7950#section-7.17.1
    """
    target_node: str
    description: ?str
    if_feature: list[str]
    reference: ?str
    status: ?str
    when: ?str

    def __init__(self, target_node: str, description: ?str=None, if_feature: list[str]=[], reference: ?str=None, status: ?str=None, when: ?str=None, exts=[], children=[], namespace=None, prefix=None):
        self.parent = None
        for n in children:
            n.parent = self
        self.target_node = target_node
        self.description = description
        self.if_feature = if_feature
        self.reference = reference
        self.status = status
        self.when = when
        self.exts = exts
        self.children = children
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("reference", self.reference),
            ("status", self.status),
            ("when", self.when),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.target_node) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        if len(self.children) > 0:
            args.append("children=[")
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Augment(" + args_text
        if len(self.children) == 0:
            text_line += ')'
        res.append(text_line)
        if len(self.children) > 0:
            child_res = []
            for child in self.children:
                child_res.append(child.prsrc(indent+1))
            res.append(",\n".join(child_res))
            res.append(_ind(indent) + "])")
        return "\n".join(res)

    def compile(self, context: Context):
        new = Augment(self.target_node,
                      description=self.description,
                      if_feature=self.if_feature,
                      reference=self.reference,
                      status=self.status,
                      when=self.when,
                      children=self.expand_children(context))
        return new

    def __str__(self):
        return "Augment " + self.target_node

    def _get_argname(self) -> ?str:
        return 'target_node'

    def _get_arg(self) -> ?str:
        return self.target_node

extension Augment (Ord):
    def __eq__(self, other: Augment):
        return self.target_node == other.target_node and self.description == other.description and self.if_feature == other.if_feature and self.reference == other.reference and self.status == other.status and self.when == other.when

    def __lt__(a, b):
        return a.target_node < b.target_node

class BelongsTo(SchemaNodeOuter):
    """YANG belongs-to

    https://tools.ietf.org/html/rfc7950#section-7.2.2
    """
    module: str

    def __init__(self, module: str, prefix: ?str=None, exts=[], namespace=None):
        self.parent = None
        self.module = module
        self.prefix = prefix
        self.exts = exts
        self.namespace = namespace

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("prefix", self.prefix),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.module) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        args_text = ", ".join(args)
        text_line = _ind(indent) + "BelongsTo(" + args_text + ")"
        res.append(text_line)
        return "\n".join(res)

    def compile(self, context: Context):
        new = BelongsTo(self.module,
                        prefix=self.prefix)
        return new

    def __str__(self):
        return "BelongsTo " + self.module

    def _get_argname(self) -> ?str:
        return 'module'

    def _get_arg(self) -> ?str:
        return self.module

extension BelongsTo (Ord):
    def __eq__(self, other: BelongsTo):
        return self.module == other.module and self.prefix == other.prefix

    def __lt__(a, b):
        return a.module < b.module

class Bit(SchemaNodeOuter):
    """YANG bit

    https://tools.ietf.org/html/rfc7950#section-9.7.4.1
    """
    name: str
    description: ?str
    if_feature: list[str]
    position: ?int
    reference: ?str
    status: ?str

    def __init__(self, name: str, description: ?str=None, if_feature: list[str]=[], position: ?int=None, reference: ?str=None, status: ?str=None, exts=[], namespace=None, prefix=None):
        self.parent = None
        self.name = name
        self.description = description
        self.if_feature = if_feature
        self.position = position
        self.reference = reference
        self.status = status
        self.exts = exts
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("position", self.position),
            ("reference", self.reference),
            ("status", self.status),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.name) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Bit(" + args_text + ")"
        res.append(text_line)
        return "\n".join(res)

    def compile(self, context: Context):
        new = Bit(self.name,
                  description=self.description,
                  if_feature=self.if_feature,
                  position=self.position,
                  reference=self.reference,
                  status=self.status)
        return new

    def __str__(self):
        return "Bit " + self.name

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Bit (Ord):
    def __eq__(self, other: Bit):
        return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.position == other.position and self.reference == other.reference and self.status == other.status

    def __lt__(a, b):
        return a.name < b.name

class Case(SchemaNodeInner):
    """YANG case

    https://tools.ietf.org/html/rfc7950#section-7.9.2.1
    """
    name: str
    description: ?str
    if_feature: list[str]
    reference: ?str
    status: ?str
    when: ?str

    def __init__(self, name: str, description: ?str=None, if_feature: list[str]=[], reference: ?str=None, status: ?str=None, when: ?str=None, exts=[], children=[], namespace=None, prefix=None):
        self.parent = None
        for n in children:
            n.parent = self
        self.name = name
        self.description = description
        self.if_feature = if_feature
        self.reference = reference
        self.status = status
        self.when = when
        self.exts = exts
        self.children = children
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("reference", self.reference),
            ("status", self.status),
            ("when", self.when),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.name) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        if len(self.children) > 0:
            args.append("children=[")
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Case(" + args_text
        if len(self.children) == 0:
            text_line += ')'
        res.append(text_line)
        if len(self.children) > 0:
            child_res = []
            for child in self.children:
                child_res.append(child.prsrc(indent+1))
            res.append(",\n".join(child_res))
            res.append(_ind(indent) + "])")
        return "\n".join(res)

    def compile(self, context: Context):
        new = Case(self.name,
                   description=self.description,
                   if_feature=self.if_feature,
                   reference=self.reference,
                   status=self.status,
                   when=self.when,
                   children=self.expand_children(context))
        return new

    def __str__(self):
        return "Case " + self.name

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Case (Ord):
    def __eq__(self, other: Case):
        return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.reference == other.reference and self.status == other.status and self.when == other.when

    def __lt__(a, b):
        return a.name < b.name

class Choice(SchemaNodeInner):
    """YANG choice

    https://tools.ietf.org/html/rfc7950#section-7.9.1
    """
    name: str
    config: ?bool
    default: ?str
    description: ?str
    if_feature: list[str]
    mandatory: ?bool
    reference: ?str
    status: ?str
    when: ?str

    def __init__(self, name: str, config: ?bool=None, default: ?str=None, description: ?str=None, if_feature: list[str]=[], mandatory: ?bool=None, reference: ?str=None, status: ?str=None, when: ?str=None, exts=[], children=[], namespace=None, prefix=None):
        self.parent = None
        for n in children:
            n.parent = self
        self.name = name
        self.config = config
        self.default = default
        self.description = description
        self.if_feature = if_feature
        self.mandatory = mandatory
        self.reference = reference
        self.status = status
        self.when = when
        self.exts = exts
        self.children = children
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("config", self.config),
            ("default", self.default),
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("mandatory", self.mandatory),
            ("reference", self.reference),
            ("status", self.status),
            ("when", self.when),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.name) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        if len(self.children) > 0:
            args.append("children=[")
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Choice(" + args_text
        if len(self.children) == 0:
            text_line += ')'
        res.append(text_line)
        if len(self.children) > 0:
            child_res = []
            for child in self.children:
                child_res.append(child.prsrc(indent+1))
            res.append(",\n".join(child_res))
            res.append(_ind(indent) + "])")
        return "\n".join(res)

    def compile(self, context: Context):
        new = Choice(self.name,
                     config=self.config,
                     default=self.default,
                     description=self.description,
                     if_feature=self.if_feature,
                     mandatory=self.mandatory,
                     reference=self.reference,
                     status=self.status,
                     when=self.when,
                     children=self.expand_children(context))
        return new

    def __str__(self):
        return "Choice " + self.name

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Choice (Ord):
    def __eq__(self, other: Choice):
        return self.name == other.name and self.config == other.config and self.default == other.default and self.description == other.description and self.if_feature == other.if_feature and self.mandatory == other.mandatory and self.reference == other.reference and self.status == other.status and self.when == other.when

    def __lt__(a, b):
        return a.name < b.name

class Container_(SchemaNodeInner):
    """YANG container

    https://tools.ietf.org/html/rfc7950#section-7.5.2
    """
    name: str
    config: ?bool
    description: ?str
    if_feature: list[str]
    must: list[Must]
    presence: ?str
    reference: ?str
    status: ?str
    when: ?str

    def __init__(self, name: str, config: ?bool=None, description: ?str=None, if_feature: list[str]=[], must: list[Must]=[], presence: ?str=None, reference: ?str=None, status: ?str=None, when: ?str=None, exts=[], children=[], namespace=None, prefix=None):
        self.parent = None
        for n in must:
            n.parent = self
        for n in children:
            n.parent = self
        self.name = name
        self.config = config
        self.description = description
        self.if_feature = if_feature
        self.must = must
        self.presence = presence
        self.reference = reference
        self.status = status
        self.when = when
        self.exts = exts
        self.children = children
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("config", self.config),
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("must", self.must),
            ("presence", self.presence),
            ("reference", self.reference),
            ("status", self.status),
            ("when", self.when),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.name) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        if len(self.children) > 0:
            args.append("children=[")
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Container_(" + args_text
        if len(self.children) == 0:
            text_line += ')'
        res.append(text_line)
        if len(self.children) > 0:
            child_res = []
            for child in self.children:
                child_res.append(child.prsrc(indent+1))
            res.append(",\n".join(child_res))
            res.append(_ind(indent) + "])")
        return "\n".join(res)

    def is_presence(self) -> bool:
        selfpresence = self.presence
        if selfpresence is not None:
            return True
        return False

    def to_dnode(self) -> DContainer:
        new_dnode = DContainer(
            name=self.name,
            config=self.is_config(),
            description=self.description,
            if_feature=self.if_feature,
            must=self.must,
            presence=self.is_presence(),
            reference=self.reference,
            status=self.status,
            when=self.when,
            exts=self.exts,
            children=self.get_dnode_children()
        )
        for child in new_dnode.children:
            child.parent = new_dnode
        return new_dnode

    def compile(self, context: Context):
        new = Container_(self.name,
                         config=self.config,
                         description=self.description,
                         if_feature=self.if_feature,
                         must=self.must,
                         presence=self.presence,
                         reference=self.reference,
                         status=self.status,
                         when=self.when,
                         children=self.expand_children(context))
        return new

    def __str__(self):
        return "Container_ " + self.name

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Container_ (Ord):
    def __eq__(self, other: Container_):
        return self.name == other.name and self.config == other.config and self.description == other.description and self.if_feature == other.if_feature and self.must == other.must and self.presence == other.presence and self.reference == other.reference and self.status == other.status and self.when == other.when

    def __lt__(a, b):
        return a.name < b.name

class Enum(SchemaNodeOuter):
    """YANG enum

    https://tools.ietf.org/html/rfc7950#section-9.6.4.1
    """
    name: str
    description: ?str
    if_feature: list[str]
    reference: ?str
    status: ?str
    value: ?str

    def __init__(self, name: str, description: ?str=None, if_feature: list[str]=[], reference: ?str=None, status: ?str=None, value: ?str=None, exts=[], namespace=None, prefix=None):
        self.parent = None
        self.name = name
        self.description = description
        self.if_feature = if_feature
        self.reference = reference
        self.status = status
        self.value = value
        self.exts = exts
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("reference", self.reference),
            ("status", self.status),
            ("value", self.value),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.name) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Enum(" + args_text + ")"
        res.append(text_line)
        return "\n".join(res)

    def compile(self, context: Context):
        new = Enum(self.name,
                   description=self.description,
                   if_feature=self.if_feature,
                   reference=self.reference,
                   status=self.status,
                   value=self.value)
        return new

    def __str__(self):
        return "Enum " + self.name

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Enum (Ord):
    def __eq__(self, other: Enum):
        return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.reference == other.reference and self.status == other.status and self.value == other.value

    def __lt__(a, b):
        return a.name < b.name

class Extension(SchemaNodeOuter):
    """YANG extension

    https://tools.ietf.org/html/rfc7950#section-7.19.1
    """
    name: str
    argument: ?str
    description: ?str
    reference: ?str
    status: ?str

    def __init__(self, name: str, argument: ?str=None, description: ?str=None, reference: ?str=None, status: ?str=None, exts=[], namespace=None, prefix=None):
        self.parent = None
        self.name = name
        self.argument = argument
        self.description = description
        self.reference = reference
        self.status = status
        self.exts = exts
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("argument", self.argument),
            ("description", self.description),
            ("reference", self.reference),
            ("status", self.status),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.name) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Extension(" + args_text + ")"
        res.append(text_line)
        return "\n".join(res)

    def compile(self, context: Context):
        new = Extension(self.name,
                        argument=self.argument,
                        description=self.description,
                        reference=self.reference,
                        status=self.status)
        return new

    def __str__(self):
        return "Extension " + self.name

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Extension (Ord):
    def __eq__(self, other: Extension):
        return self.name == other.name and self.argument == other.argument and self.description == other.description and self.reference == other.reference and self.status == other.status

    def __lt__(a, b):
        return a.name < b.name

class Feature(SchemaNodeOuter):
    """YANG feature

    https://tools.ietf.org/html/rfc7950#section-7.20.1.1
    """
    name: str
    description: ?str
    if_feature: list[str]
    reference: ?str
    status: ?str

    def __init__(self, name: str, description: ?str=None, if_feature: list[str]=[], reference: ?str=None, status: ?str=None, exts=[], namespace=None, prefix=None):
        self.parent = None
        self.name = name
        self.description = description
        self.if_feature = if_feature
        self.reference = reference
        self.status = status
        self.exts = exts
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("reference", self.reference),
            ("status", self.status),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.name) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Feature(" + args_text + ")"
        res.append(text_line)
        return "\n".join(res)

    def compile(self, context: Context):
        new = Feature(self.name,
                      description=self.description,
                      if_feature=self.if_feature,
                      reference=self.reference,
                      status=self.status)
        return new

    def __str__(self):
        return "Feature " + self.name

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Feature (Ord):
    def __eq__(self, other: Feature):
        return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.reference == other.reference and self.status == other.status

    def __lt__(a, b):
        return a.name < b.name

class Grouping(SchemaNodeInner):
    """YANG grouping

    https://tools.ietf.org/html/rfc7950#section-7.12.1
    """
    name: str
    description: ?str
    reference: ?str
    status: ?str

    def __init__(self, name: str, description: ?str=None, reference: ?str=None, status: ?str=None, exts=[], children=[], namespace=None, prefix=None):
        self.parent = None
        for n in children:
            n.parent = self
        self.name = name
        self.description = description
        self.reference = reference
        self.status = status
        self.exts = exts
        self.children = children
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("description", self.description),
            ("reference", self.reference),
            ("status", self.status),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.name) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        if len(self.children) > 0:
            args.append("children=[")
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Grouping(" + args_text
        if len(self.children) == 0:
            text_line += ')'
        res.append(text_line)
        if len(self.children) > 0:
            child_res = []
            for child in self.children:
                child_res.append(child.prsrc(indent+1))
            res.append(",\n".join(child_res))
            res.append(_ind(indent) + "])")
        return "\n".join(res)

    def compile(self, context: Context):
        new = Grouping(self.name,
                       description=self.description,
                       reference=self.reference,
                       status=self.status,
                       children=self.expand_children(context))
        return new

    def __str__(self):
        return "Grouping " + self.name

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Grouping (Ord):
    def __eq__(self, other: Grouping):
        return self.name == other.name and self.description == other.description and self.reference == other.reference and self.status == other.status

    def __lt__(a, b):
        return a.name < b.name

class Identity_(SchemaNodeOuter):
    """YANG identity

    https://tools.ietf.org/html/rfc7950#section-7.18.1
    """
    name: str
    base: list[str]
    description: ?str
    if_feature: list[str]
    reference: ?str
    status: ?str

    def __init__(self, name: str, base: list[str]=[], description: ?str=None, if_feature: list[str]=[], reference: ?str=None, status: ?str=None, exts=[], namespace=None, prefix=None):
        self.parent = None
        self.name = name
        self.base = base
        self.description = description
        self.if_feature = if_feature
        self.reference = reference
        self.status = status
        self.exts = exts
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("base", self.base),
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("reference", self.reference),
            ("status", self.status),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.name) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Identity_(" + args_text + ")"
        res.append(text_line)
        return "\n".join(res)

    def compile(self, context: Context):
        new = Identity_(self.name,
                        base=self.base,
                        description=self.description,
                        if_feature=self.if_feature,
                        reference=self.reference,
                        status=self.status)
        return new

    def __str__(self):
        return "Identity_ " + self.name

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Identity_ (Ord):
    def __eq__(self, other: Identity_):
        return self.name == other.name and self.base == other.base and self.description == other.description and self.if_feature == other.if_feature and self.reference == other.reference and self.status == other.status

    def __lt__(a, b):
        return a.name < b.name

class Import(SchemaNodeOuter):
    """YANG import

    https://tools.ietf.org/html/rfc7950#section-7.1.5
    """
    module: str
    description: ?str
    reference: ?str
    revision_date: ?str

    def __init__(self, module: str, prefix: ?str=None, description: ?str=None, reference: ?str=None, revision_date: ?str=None, exts=[], namespace=None):
        self.parent = None
        self.module = module
        self.description = description
        self.prefix = prefix
        self.reference = reference
        self.revision_date = revision_date
        self.exts = exts
        self.namespace = namespace

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("description", self.description),
            ("prefix", self.prefix),
            ("reference", self.reference),
            ("revision-date", self.revision_date),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.module) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Import(" + args_text + ")"
        res.append(text_line)
        return "\n".join(res)

    def compile(self, context: Context):
        new = Import(self.module,
                     description=self.description,
                     prefix=self.prefix,
                     reference=self.reference,
                     revision_date=self.revision_date)
        return new

    def __str__(self):
        return "Import " + self.module

    def _get_argname(self) -> ?str:
        return 'module'

    def _get_arg(self) -> ?str:
        return self.module

extension Import (Ord):
    def __eq__(self, other: Import):
        return self.module == other.module and self.description == other.description and self.prefix == other.prefix and self.reference == other.reference and self.revision_date == other.revision_date

    def __lt__(a, b):
        return a.module < b.module

class Include(SchemaNodeOuter):
    """YANG include

    https://tools.ietf.org/html/rfc7950#section-7.1.6
    """
    module: str
    description: ?str
    reference: ?str
    revision_date: ?str

    def __init__(self, module: str, description: ?str=None, reference: ?str=None, revision_date: ?str=None, exts=[], namespace=None, prefix=None):
        self.parent = None
        self.module = module
        self.description = description
        self.reference = reference
        self.revision_date = revision_date
        self.exts = exts
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("description", self.description),
            ("reference", self.reference),
            ("revision-date", self.revision_date),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.module) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Include(" + args_text + ")"
        res.append(text_line)
        return "\n".join(res)

    def compile(self, context: Context):
        new = Include(self.module,
                      description=self.description,
                      reference=self.reference,
                      revision_date=self.revision_date)
        return new

    def __str__(self):
        return "Include " + self.module

    def _get_argname(self) -> ?str:
        return 'module'

    def _get_arg(self) -> ?str:
        return self.module

extension Include (Ord):
    def __eq__(self, other: Include):
        return self.module == other.module and self.description == other.description and self.reference == other.reference and self.revision_date == other.revision_date

    def __lt__(a, b):
        return a.module < b.module

class Input(SchemaNodeInner):
    """YANG input

    https://tools.ietf.org/html/rfc7950#section-7.14.2.1
    """
    must: list[Must]

    def __init__(self, must: list[Must]=[], exts=[], children=[], namespace=None, prefix=None):
        self.parent = None
        for n in must:
            n.parent = self
        for n in children:
            n.parent = self
        self.must = must
        self.exts = exts
        self.children = children
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("must", self.must),
            ("exts", self.exts),
        ]
        args = []
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        if len(self.children) > 0:
            args.append("children=[")
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Input(" + args_text
        if len(self.children) == 0:
            text_line += ')'
        res.append(text_line)
        if len(self.children) > 0:
            child_res = []
            for child in self.children:
                child_res.append(child.prsrc(indent+1))
            res.append(",\n".join(child_res))
            res.append(_ind(indent) + "])")
        return "\n".join(res)

    def compile(self, context: Context):
        new = Input(must=self.must,
                    children=self.expand_children(context))
        return new

    def __str__(self):
        return "Input"

    def _get_argname(self) -> ?str:
        return None

    def _get_arg(self) -> ?str:
        return None

extension Input (Ord):
    def __eq__(self, other: Input):
        return self.must == other.must

    def __lt__(a, b):
        return True

class Leaf(SchemaNodeOuter):
    """YANG leaf

    https://tools.ietf.org/html/rfc7950#section-7.6.2
    """
    name: str
    config: ?bool
    default: ?str
    description: ?str
    if_feature: list[str]
    mandatory: ?bool
    must: list[Must]
    reference: ?str
    status: ?str
    type_: Type
    units: ?str
    when: ?str

    def __init__(self, name: str, type_: Type, config: ?bool=None, default: ?str=None, description: ?str=None, if_feature: list[str]=[], mandatory: ?bool=None, must: list[Must]=[], reference: ?str=None, status: ?str=None, units: ?str=None, when: ?str=None, exts=[], namespace=None, prefix=None):
        self.parent = None
        for n in must:
            n.parent = self
        if type_ is not None:
            type_.parent = self
        self.name = name
        self.config = config
        self.default = default
        self.description = description
        self.if_feature = if_feature
        self.mandatory = mandatory
        self.must = must
        self.reference = reference
        self.status = status
        self.type_ = type_
        self.units = units
        self.when = when
        self.exts = exts
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("config", self.config),
            ("default", self.default),
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("mandatory", self.mandatory),
            ("must", self.must),
            ("reference", self.reference),
            ("status", self.status),
            ("type", self.type_),
            ("units", self.units),
            ("when", self.when),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.name) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Leaf(" + args_text + ")"
        res.append(text_line)
        return "\n".join(res)

    def compile(self, context: Context):
        base_typedef = self.type_.resolve_typedef(context)

        new_default = self.default
        if new_default is None:
            new_default = base_typedef.default

        new_units = self.units
        if new_units is None:
            new_units = base_typedef.units

        new = Leaf(self.name,
                   config=self.config,
                   default=new_default,
                   description=self.description,
                   if_feature=self.if_feature,
                   mandatory=self.mandatory,
                   must=self.must,
                   reference=self.reference,
                   status=self.status,
                   type_=base_typedef.type_,
                   units=new_units,
                   when=self.when)
        return new

    def to_dnode(self) -> DLeaf:
        return DLeaf(
            name=self.name,
            config=self.is_config(),
            description=self.description,
            if_feature=self.if_feature,
            mandatory=self.mandatory,
            must=self.must,
            reference=self.reference,
            status=self.status,
            type_=self.type_,
            units=self.units,
            when=self.when,
            exts=self.exts
        )

    def __str__(self):
        return "Leaf " + self.name

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Leaf (Ord):
    def __eq__(self, other: Leaf):
        return self.name == other.name and self.config == other.config and self.default == other.default and self.description == other.description and self.if_feature == other.if_feature and self.mandatory == other.mandatory and self.must == other.must and self.reference == other.reference and self.status == other.status and self.type_ == other.type_ and self.units == other.units and self.when == other.when

    def __lt__(a, b):
        return a.name < b.name

class LeafList(SchemaNodeOuter):
    """YANG leaf-list

    https://tools.ietf.org/html/rfc7950#section-7.7.3
    """
    name: str
    config: ?bool
    default: list[str]
    description: ?str
    if_feature: list[str]
    max_elements: ?str
    min_elements: ?str
    must: list[Must]
    ordered_by: ?str
    reference: ?str
    status: ?str
    type_: Type
    units: ?str
    when: ?str

    def __init__(self, name: str, type_: Type, config: ?bool=None, default: list[str]=[], description: ?str=None, if_feature: list[str]=[], max_elements: ?str=None, min_elements: ?str=None, must: list[Must]=[], ordered_by: ?str=None, reference: ?str=None, status: ?str=None, units: ?str=None, when: ?str=None, exts=[], namespace=None, prefix=None):
        self.parent = None
        for n in must:
            n.parent = self
        if type_ is not None:
            type_.parent = self
        self.name = name
        self.config = config
        self.default = default
        self.description = description
        self.if_feature = if_feature
        self.max_elements = max_elements
        self.min_elements = min_elements
        self.must = must
        self.ordered_by = ordered_by
        self.reference = reference
        self.status = status
        self.type_ = type_
        self.units = units
        self.when = when
        self.exts = exts
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("config", self.config),
            ("default", self.default),
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("max-elements", self.max_elements),
            ("min-elements", self.min_elements),
            ("must", self.must),
            ("ordered-by", self.ordered_by),
            ("reference", self.reference),
            ("status", self.status),
            ("type", self.type_),
            ("units", self.units),
            ("when", self.when),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.name) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        args_text = ", ".join(args)
        text_line = _ind(indent) + "LeafList(" + args_text + ")"
        res.append(text_line)
        return "\n".join(res)

    def compile(self, context: Context):
        base_typedef = self.type_.resolve_typedef(context)

        new_units = self.units
        if new_units is None:
            new_units = base_typedef.units

        new = LeafList(self.name,
                       config=self.config,
                       default=self.default,
                       description=self.description,
                       if_feature=self.if_feature,
                       max_elements=self.max_elements,
                       min_elements=self.min_elements,
                       must=self.must,
                       ordered_by=self.ordered_by,
                       reference=self.reference,
                       status=self.status,
                       type_=base_typedef.type_,
                       units=new_units,
                       when=self.when)
        return new

    def get_max_elements(self) -> ?int:
        selfmax_elements = self.max_elements
        if selfmax_elements is not None:
            return int(selfmax_elements)
        return None

    def get_min_elements(self) -> int:
        selfmin_elements = self.min_elements
        if selfmin_elements is not None:
            return int(selfmin_elements)
        return 0

    def to_dnode(self) -> DLeafList:
        return DLeafList(
            name=self.name,
            config=self.is_config(),
            description=self.description,
            if_feature=self.if_feature,
            max_elements=self.get_max_elements(),
            min_elements=self.get_min_elements(),
            must=self.must,
            reference=self.reference,
            status=self.status,
            type_=self.type_,
            units=self.units,
            when=self.when,
            exts=self.exts
        )

    def __str__(self):
        return "LeafList " + self.name

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension LeafList (Ord):
    def __eq__(self, other: LeafList):
        return self.name == other.name and self.config == other.config and self.default == other.default and self.description == other.description and self.if_feature == other.if_feature and self.max_elements == other.max_elements and self.min_elements == other.min_elements and self.must == other.must and self.ordered_by == other.ordered_by and self.reference == other.reference and self.status == other.status and self.type_ == other.type_ and self.units == other.units and self.when == other.when

    def __lt__(a, b):
        return a.name < b.name

class Length(SchemaNodeOuter):
    """YANG length

    https://tools.ietf.org/html/rfc7950#section-9.4.4.1
    """
    value: str
    description: ?str
    error_app_tag: ?str
    error_message: ?str
    reference: ?str

    def __init__(self, value: str, description: ?str=None, error_app_tag: ?str=None, error_message: ?str=None, reference: ?str=None, exts=[], namespace=None, prefix=None):
        self.parent = None
        self.value = value
        self.description = description
        self.error_app_tag = error_app_tag
        self.error_message = error_message
        self.reference = reference
        self.exts = exts
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("description", self.description),
            ("error-app-tag", self.error_app_tag),
            ("error-message", self.error_message),
            ("reference", self.reference),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.value) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Length(" + args_text + ")"
        res.append(text_line)
        return "\n".join(res)

    def compile(self, context: Context):
        new = Length(self.value,
                     description=self.description,
                     error_app_tag=self.error_app_tag,
                     error_message=self.error_message,
                     reference=self.reference)
        return new

    def __str__(self):
        return "Length " + self.value

    def _get_argname(self) -> ?str:
        return 'value'

    def _get_arg(self) -> ?str:
        return self.value

extension Length (Ord):
    def __eq__(self, other: Length):
        return self.value == other.value and self.description == other.description and self.error_app_tag == other.error_app_tag and self.error_message == other.error_message and self.reference == other.reference

    def __lt__(a, b):
        return a.value < b.value

class List(SchemaNodeInner):
    """YANG list

    https://tools.ietf.org/html/rfc7950#section-7.8.1
    """
    name: str
    config: ?bool
    description: ?str
    if_feature: list[str]
    key: ?str
    max_elements: ?str
    min_elements: ?str
    must: list[Must]
    ordered_by: ?str
    reference: ?str
    status: ?str
    unique: list[str]
    when: ?str

    def __init__(self, name: str, config: ?bool=None, description: ?str=None, if_feature: list[str]=[], key: ?str=None, max_elements: ?str=None, min_elements: ?str=None, must: list[Must]=[], ordered_by: ?str=None, reference: ?str=None, status: ?str=None, unique: list[str]=[], when: ?str=None, exts=[], children=[], namespace=None, prefix=None):
        self.parent = None
        for n in must:
            n.parent = self
        for n in children:
            n.parent = self
        self.name = name
        self.config = config
        self.description = description
        self.if_feature = if_feature
        self.key = key
        self.max_elements = max_elements
        self.min_elements = min_elements
        self.must = must
        self.ordered_by = ordered_by
        self.reference = reference
        self.status = status
        self.unique = unique
        self.when = when
        self.exts = exts
        self.children = children
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("config", self.config),
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("key", self.key),
            ("max-elements", self.max_elements),
            ("min-elements", self.min_elements),
            ("must", self.must),
            ("ordered-by", self.ordered_by),
            ("reference", self.reference),
            ("status", self.status),
            ("unique", self.unique),
            ("when", self.when),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.name) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        if len(self.children) > 0:
            args.append("children=[")
        args_text = ", ".join(args)
        text_line = _ind(indent) + "List(" + args_text
        if len(self.children) == 0:
            text_line += ')'
        res.append(text_line)
        if len(self.children) > 0:
            child_res = []
            for child in self.children:
                child_res.append(child.prsrc(indent+1))
            res.append(",\n".join(child_res))
            res.append(_ind(indent) + "])")
        return "\n".join(res)

    def keys(self) -> list[str]:
        selfkey = self.key
        if selfkey is not None:
            return selfkey.split(" ")
        return []

    def get_max_elements(self) -> ?int:
        selfmax_elements = self.max_elements
        if selfmax_elements is not None:
            return int(selfmax_elements)
        return None

    def get_min_elements(self) -> int:
        selfmin_elements = self.min_elements
        if selfmin_elements is not None:
            return int(selfmin_elements)
        return 0

    def to_dnode(self) -> DList:
        new_dnode = DList(
            name=self.name,
            key=self.keys(),
            config=self.is_config(),
            description=self.description,
            if_feature=self.if_feature,
            max_elements=self.get_max_elements(),
            min_elements=self.get_min_elements(),
            must=self.must,
            reference=self.reference,
            status=self.status,
            when=self.when,
            exts=self.exts,
            children=self.get_dnode_children()
        )
        for child in new_dnode.children:
            child.parent = new_dnode
        return new_dnode

    def compile(self, context: Context):
        new = List(self.name,
                   config=self.config,
                   description=self.description,
                   if_feature=self.if_feature,
                   key=self.key,
                   max_elements=self.max_elements,
                   min_elements=self.min_elements,
                   must=self.must,
                   ordered_by=self.ordered_by,
                   reference=self.reference,
                   status=self.status,
                   unique=self.unique,
                   when=self.when,
                   children=self.expand_children(context))
        return new

    def __str__(self):
        return "List " + self.name

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension List (Ord):
    def __eq__(self, other: List):
        return self.name == other.name and self.config == other.config and self.description == other.description and self.if_feature == other.if_feature and self.key == other.key and self.max_elements == other.max_elements and self.min_elements == other.min_elements and self.must == other.must and self.ordered_by == other.ordered_by and self.reference == other.reference and self.status == other.status and self.unique == other.unique and self.when == other.when

    def __lt__(a, b):
        return a.name < b.name

class Module(SchemaNodeInner):
    """YANG module

    https://tools.ietf.org/html/rfc7950#section-7.1.1
    """
    name: str
    augment: list[Augment]
    contact: ?str
    description: ?str
    deviation: list[str]
    extension_: list[Extension]
    feature: list[Feature]
    import_: list[Import]
    include: list[Include]
    organization: ?str
    reference: ?str
    revision: list[Revision]
    yang_version: float

    def __init__(self, name: str, namespace: ?str=None, prefix: ?str=None, yang_version: float=1.1, augment: list[Augment]=[], contact: ?str=None, description: ?str=None, deviation: list[str]=[], extension_: list[Extension]=[], feature: list[Feature]=[], import_: list[Import]=[], include: list[Include]=[], organization: ?str=None, reference: ?str=None, revision: list[Revision]=[], exts=[], children=[]):
        self.parent = None
        for n in augment:
            n.parent = self
        for n in extension_:
            n.parent = self
        for n in feature:
            n.parent = self
        for n in import_:
            n.parent = self
        for n in include:
            n.parent = self
        for n in revision:
            n.parent = self
        for n in children:
            n.parent = self
        self.name = name
        self.augment = augment
        self.contact = contact
        self.description = description
        self.deviation = deviation
        self.extension_ = extension_
        self.feature = feature
        self.import_ = import_
        self.include = include
        self.namespace = namespace
        self.organization = organization
        self.prefix = prefix
        self.reference = reference
        self.revision = revision
        self.yang_version = yang_version
        self.exts = exts
        self.children = children

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("augment", self.augment),
            ("contact", self.contact),
            ("description", self.description),
            ("deviation", self.deviation),
            ("extension", self.extension_),
            ("feature", self.feature),
            ("import", self.import_),
            ("include", self.include),
            ("namespace", self.namespace),
            ("organization", self.organization),
            ("prefix", self.prefix),
            ("reference", self.reference),
            ("revision", self.revision),
            ("yang-version", self.yang_version),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.name) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        if len(self.children) > 0:
            args.append("children=[")
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Module(" + args_text
        if len(self.children) == 0:
            text_line += ')'
        res.append(text_line)
        if len(self.children) > 0:
            child_res = []
            for child in self.children:
                child_res.append(child.prsrc(indent+1))
            res.append(",\n".join(child_res))
            res.append(_ind(indent) + "])")
        return "\n".join(res)

    def get_import_by_prefix(self, prefix: str) -> Import:
        for imp in self.import_:
            if imp.prefix == prefix:
                return imp
        raise ValueError("No import with prefix %s in module %s" % (prefix, self.name))

    def get_namespace(self) -> str:
        selfnamespace = self.namespace
        if selfnamespace is not None:
            return selfnamespace
        raise ValueError("Module %s has no namespace" % self.name)

    def get_prefix(self) -> str:
        selfprefix = self.prefix
        if selfprefix is not None:
            return selfprefix
        raise ValueError("Module %s has no prefix" % self.name)

    def get_revision(self) -> ?Revision:
        latest = None
        for rev in self.revision:
            if latest is None or (latest is not None and rev.date > latest.date):
                latest = rev
        return latest

    def to_dnode(self) -> DModule:
        new_dnode = DModule(
            name=self.name,
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            description=self.description,
            revision=self.revision,
            reference=self.reference,
            exts=self.exts,
            children=self.get_dnode_children()
        )
        for child in new_dnode.children:
            child.parent = new_dnode
        return new_dnode

    def compile(self, context: Context):
        new = Module(self.name,
                     augment=self.augment,
                     contact=self.contact,
                     description=self.description,
                     deviation=self.deviation,
                     extension_=self.extension_,
                     feature=self.feature,
                     import_=self.import_,
                     include=self.include,
                     namespace=self.namespace,
                     organization=self.organization,
                     prefix=self.prefix,
                     reference=self.reference,
                     revision=self.revision,
                     yang_version=self.yang_version,
                     children=self.expand_children(context))
        new.expand_augments(context)
        return new

    def __str__(self):
        return "Module " + self.name

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Module (Ord):
    def __eq__(self, other: Module):
        return self.name == other.name and self.augment == other.augment and self.contact == other.contact and self.description == other.description and self.deviation == other.deviation and self.extension_ == other.extension_ and self.feature == other.feature and self.import_ == other.import_ and self.include == other.include and self.namespace == other.namespace and self.organization == other.organization and self.prefix == other.prefix and self.reference == other.reference and self.revision == other.revision and self.yang_version == other.yang_version

    def __lt__(a, b):
        return a.name < b.name

class Must(SchemaNodeOuter):
    """YANG must

    https://tools.ietf.org/html/rfc7950#section-7.5.4
    """
    condition: str
    description: ?str
    error_app_tag: ?str
    error_message: ?str
    reference: ?str

    def __init__(self, condition: str, description: ?str=None, error_app_tag: ?str=None, error_message: ?str=None, reference: ?str=None, exts=[], namespace=None, prefix=None):
        self.parent = None
        self.condition = condition
        self.description = description
        self.error_app_tag = error_app_tag
        self.error_message = error_message
        self.reference = reference
        self.exts = exts
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("description", self.description),
            ("error-app-tag", self.error_app_tag),
            ("error-message", self.error_message),
            ("reference", self.reference),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.condition) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Must(" + args_text + ")"
        res.append(text_line)
        return "\n".join(res)

    def compile(self, context: Context):
        new = Must(self.condition,
                   description=self.description,
                   error_app_tag=self.error_app_tag,
                   error_message=self.error_message,
                   reference=self.reference)
        return new

    def __str__(self):
        return "Must " + self.condition

    def _get_argname(self) -> ?str:
        return 'condition'

    def _get_arg(self) -> ?str:
        return self.condition

extension Must (Ord):
    def __eq__(self, other: Must):
        return self.condition == other.condition and self.description == other.description and self.error_app_tag == other.error_app_tag and self.error_message == other.error_message and self.reference == other.reference

    def __lt__(a, b):
        return a.condition < b.condition

class Notification(SchemaNodeInner):
    """YANG notification

    https://tools.ietf.org/html/rfc7950#section-7.16.1
    """
    name: str
    description: ?str
    if_feature: list[str]
    must: list[Must]
    reference: ?str
    status: ?str

    def __init__(self, name: str, description: ?str=None, if_feature: list[str]=[], must: list[Must]=[], reference: ?str=None, status: ?str=None, exts=[], children=[], namespace=None, prefix=None):
        self.parent = None
        for n in must:
            n.parent = self
        for n in children:
            n.parent = self
        self.name = name
        self.description = description
        self.if_feature = if_feature
        self.must = must
        self.reference = reference
        self.status = status
        self.exts = exts
        self.children = children
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("must", self.must),
            ("reference", self.reference),
            ("status", self.status),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.name) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        if len(self.children) > 0:
            args.append("children=[")
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Notification(" + args_text
        if len(self.children) == 0:
            text_line += ')'
        res.append(text_line)
        if len(self.children) > 0:
            child_res = []
            for child in self.children:
                child_res.append(child.prsrc(indent+1))
            res.append(",\n".join(child_res))
            res.append(_ind(indent) + "])")
        return "\n".join(res)

    def compile(self, context: Context):
        new = Notification(self.name,
                           description=self.description,
                           if_feature=self.if_feature,
                           must=self.must,
                           reference=self.reference,
                           status=self.status,
                           children=self.expand_children(context))
        return new

    def __str__(self):
        return "Notification " + self.name

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Notification (Ord):
    def __eq__(self, other: Notification):
        return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.must == other.must and self.reference == other.reference and self.status == other.status

    def __lt__(a, b):
        return a.name < b.name

class Output(SchemaNodeInner):
    """YANG output

    https://tools.ietf.org/html/rfc7950#section-7.14.3.1
    """
    must: list[Must]

    def __init__(self, must: list[Must]=[], exts=[], children=[], namespace=None, prefix=None):
        self.parent = None
        for n in must:
            n.parent = self
        for n in children:
            n.parent = self
        self.must = must
        self.exts = exts
        self.children = children
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("must", self.must),
            ("exts", self.exts),
        ]
        args = []
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        if len(self.children) > 0:
            args.append("children=[")
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Output(" + args_text
        if len(self.children) == 0:
            text_line += ')'
        res.append(text_line)
        if len(self.children) > 0:
            child_res = []
            for child in self.children:
                child_res.append(child.prsrc(indent+1))
            res.append(",\n".join(child_res))
            res.append(_ind(indent) + "])")
        return "\n".join(res)

    def compile(self, context: Context):
        new = Output(must=self.must,
                     children=self.expand_children(context))
        return new

    def __str__(self):
        return "Output"

    def _get_argname(self) -> ?str:
        return None

    def _get_arg(self) -> ?str:
        return None

extension Output (Ord):
    def __eq__(self, other: Output):
        return self.must == other.must

    def __lt__(a, b):
        return True

class Pattern(SchemaNodeOuter):
    """YANG pattern

    https://tools.ietf.org/html/rfc7950#section-9.4.5.1
    """
    value: str
    description: ?str
    error_app_tag: ?str
    error_message: ?str
    modifier: ?str
    reference: ?str

    def __init__(self, value: str, description: ?str=None, error_app_tag: ?str=None, error_message: ?str=None, modifier: ?str=None, reference: ?str=None, exts=[], namespace=None, prefix=None):
        self.parent = None
        self.value = value
        self.description = description
        self.error_app_tag = error_app_tag
        self.error_message = error_message
        self.modifier = modifier
        self.reference = reference
        self.exts = exts
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("description", self.description),
            ("error-app-tag", self.error_app_tag),
            ("error-message", self.error_message),
            ("modifier", self.modifier),
            ("reference", self.reference),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.value) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Pattern(" + args_text + ")"
        res.append(text_line)
        return "\n".join(res)

    def compile(self, context: Context):
        new = Pattern(self.value,
                      description=self.description,
                      error_app_tag=self.error_app_tag,
                      error_message=self.error_message,
                      modifier=self.modifier,
                      reference=self.reference)
        return new

    def __str__(self):
        return "Pattern " + self.value

    def _get_argname(self) -> ?str:
        return 'value'

    def _get_arg(self) -> ?str:
        return self.value

extension Pattern (Ord):
    def __eq__(self, other: Pattern):
        return self.value == other.value and self.description == other.description and self.error_app_tag == other.error_app_tag and self.error_message == other.error_message and self.modifier == other.modifier and self.reference == other.reference

    def __lt__(a, b):
        return a.value < b.value

class Range(SchemaNodeOuter):
    """YANG range

    https://tools.ietf.org/html/rfc7950#section-9.2.4.1
    """
    value: str
    description: ?str
    error_app_tag: ?str
    error_message: ?str
    reference: ?str

    def __init__(self, value: str, description: ?str=None, error_app_tag: ?str=None, error_message: ?str=None, reference: ?str=None, exts=[], namespace=None, prefix=None):
        self.parent = None
        self.value = value
        self.description = description
        self.error_app_tag = error_app_tag
        self.error_message = error_message
        self.reference = reference
        self.exts = exts
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("description", self.description),
            ("error-app-tag", self.error_app_tag),
            ("error-message", self.error_message),
            ("reference", self.reference),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.value) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Range(" + args_text + ")"
        res.append(text_line)
        return "\n".join(res)

    def compile(self, context: Context):
        new = Range(self.value,
                    description=self.description,
                    error_app_tag=self.error_app_tag,
                    error_message=self.error_message,
                    reference=self.reference)
        return new

    def __str__(self):
        return "Range " + self.value

    def _get_argname(self) -> ?str:
        return 'value'

    def _get_arg(self) -> ?str:
        return self.value

extension Range (Ord):
    def __eq__(self, other: Range):
        return self.value == other.value and self.description == other.description and self.error_app_tag == other.error_app_tag and self.error_message == other.error_message and self.reference == other.reference

    def __lt__(a, b):
        return a.value < b.value

class Refine(SchemaNodeOuter):
    """YANG refine

    https://tools.ietf.org/html/rfc7950#section-7.13.999
    """
    target_node: str
    config: ?bool
    default: ?str
    description: ?str
    if_feature: list[str]
    mandatory: ?bool
    max_elements: ?str
    min_elements: ?str
    must: list[Must]
    presence: ?str
    reference: ?str

    def __init__(self, target_node: str, config: ?bool=None, default: ?str=None, description: ?str=None, if_feature: list[str]=[], mandatory: ?bool=None, max_elements: ?str=None, min_elements: ?str=None, must: list[Must]=[], presence: ?str=None, reference: ?str=None, exts=[], namespace=None, prefix=None):
        self.parent = None
        for n in must:
            n.parent = self
        self.target_node = target_node
        self.config = config
        self.default = default
        self.description = description
        self.if_feature = if_feature
        self.mandatory = mandatory
        self.max_elements = max_elements
        self.min_elements = min_elements
        self.must = must
        self.presence = presence
        self.reference = reference
        self.exts = exts
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("config", self.config),
            ("default", self.default),
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("mandatory", self.mandatory),
            ("max-elements", self.max_elements),
            ("min-elements", self.min_elements),
            ("must", self.must),
            ("presence", self.presence),
            ("reference", self.reference),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.target_node) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Refine(" + args_text + ")"
        res.append(text_line)
        return "\n".join(res)

    def compile(self, context: Context):
        new = Refine(self.target_node,
                     config=self.config,
                     default=self.default,
                     description=self.description,
                     if_feature=self.if_feature,
                     mandatory=self.mandatory,
                     max_elements=self.max_elements,
                     min_elements=self.min_elements,
                     must=self.must,
                     presence=self.presence,
                     reference=self.reference)
        return new

    def __str__(self):
        return "Refine " + self.target_node

    def _get_argname(self) -> ?str:
        return 'target_node'

    def _get_arg(self) -> ?str:
        return self.target_node

extension Refine (Ord):
    def __eq__(self, other: Refine):
        return self.target_node == other.target_node and self.config == other.config and self.default == other.default and self.description == other.description and self.if_feature == other.if_feature and self.mandatory == other.mandatory and self.max_elements == other.max_elements and self.min_elements == other.min_elements and self.must == other.must and self.presence == other.presence and self.reference == other.reference

    def __lt__(a, b):
        return a.target_node < b.target_node

class Revision(SchemaNodeOuter):
    """YANG revision

    https://tools.ietf.org/html/rfc7950#section-7.1.9.1
    """
    date: str
    description: ?str
    reference: ?str

    def __init__(self, date: str, description: ?str=None, reference: ?str=None, exts=[], namespace=None, prefix=None):
        self.parent = None
        self.date = date
        self.description = description
        self.reference = reference
        self.exts = exts
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("description", self.description),
            ("reference", self.reference),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.date) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Revision(" + args_text + ")"
        res.append(text_line)
        return "\n".join(res)

    def compile(self, context: Context):
        new = Revision(self.date,
                       description=self.description,
                       reference=self.reference)
        return new

    def __str__(self):
        return "Revision " + self.date

    def _get_argname(self) -> ?str:
        return 'date'

    def _get_arg(self) -> ?str:
        return self.date

extension Revision (Ord):
    def __eq__(self, other: Revision):
        return self.date == other.date and self.description == other.description and self.reference == other.reference

    def __lt__(a, b):
        return a.date < b.date

class Rpc(SchemaNodeInner):
    """YANG rpc

    https://tools.ietf.org/html/rfc7950#section-7.14.1
    """
    name: str
    description: ?str
    if_feature: list[str]
    input: ?Input
    output: ?Output
    reference: ?str
    status: ?str

    def __init__(self, name: str, description: ?str=None, if_feature: list[str]=[], input: ?Input=None, output: ?Output=None, reference: ?str=None, status: ?str=None, exts=[], children=[], namespace=None, prefix=None):
        self.parent = None
        if input is not None:
            input.parent = self
        if output is not None:
            output.parent = self
        for n in children:
            n.parent = self
        self.name = name
        self.description = description
        self.if_feature = if_feature
        self.input = input
        self.output = output
        self.reference = reference
        self.status = status
        self.exts = exts
        self.children = children
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("input", self.input),
            ("output", self.output),
            ("reference", self.reference),
            ("status", self.status),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.name) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        if len(self.children) > 0:
            args.append("children=[")
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Rpc(" + args_text
        if len(self.children) == 0:
            text_line += ')'
        res.append(text_line)
        if len(self.children) > 0:
            child_res = []
            for child in self.children:
                child_res.append(child.prsrc(indent+1))
            res.append(",\n".join(child_res))
            res.append(_ind(indent) + "])")
        return "\n".join(res)

    def compile(self, context: Context):
        new = Rpc(self.name,
                  description=self.description,
                  if_feature=self.if_feature,
                  input=self.input,
                  output=self.output,
                  reference=self.reference,
                  status=self.status,
                  children=self.expand_children(context))
        return new

    def __str__(self):
        return "Rpc " + self.name

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Rpc (Ord):
    def __eq__(self, other: Rpc):
        return self.name == other.name and self.description == other.description and self.if_feature == other.if_feature and self.input == other.input and self.output == other.output and self.reference == other.reference and self.status == other.status

    def __lt__(a, b):
        return a.name < b.name

class Submodule(SchemaNodeInner):
    """YANG submodule

    https://tools.ietf.org/html/rfc7950#section-7.2.1
    """
    name: str
    augment: list[Augment]
    belongs_to: BelongsTo
    contact: ?str
    description: ?str
    deviation: list[str]
    extension_: list[Extension]
    feature: list[Feature]
    import_: list[Import]
    include: list[Include]
    organization: ?str
    reference: ?str
    revision: list[Revision]
    yang_version: float

    def __init__(self, name: str, belongs_to: BelongsTo, yang_version: float=1.1, augment: list[Augment]=[], contact: ?str=None, description: ?str=None, deviation: list[str]=[], extension_: list[Extension]=[], feature: list[Feature]=[], import_: list[Import]=[], include: list[Include]=[], organization: ?str=None, reference: ?str=None, revision: list[Revision]=[], exts=[], children=[], namespace=None, prefix=None):
        self.parent = None
        for n in augment:
            n.parent = self
        if belongs_to is not None:
            belongs_to.parent = self
        for n in extension_:
            n.parent = self
        for n in feature:
            n.parent = self
        for n in import_:
            n.parent = self
        for n in include:
            n.parent = self
        for n in revision:
            n.parent = self
        for n in children:
            n.parent = self
        self.name = name
        self.augment = augment
        self.belongs_to = belongs_to
        self.contact = contact
        self.description = description
        self.deviation = deviation
        self.extension_ = extension_
        self.feature = feature
        self.import_ = import_
        self.include = include
        self.organization = organization
        self.reference = reference
        self.revision = revision
        self.yang_version = yang_version
        self.exts = exts
        self.children = children
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("augment", self.augment),
            ("belongs-to", self.belongs_to),
            ("contact", self.contact),
            ("description", self.description),
            ("deviation", self.deviation),
            ("extension", self.extension_),
            ("feature", self.feature),
            ("import", self.import_),
            ("include", self.include),
            ("organization", self.organization),
            ("reference", self.reference),
            ("revision", self.revision),
            ("yang-version", self.yang_version),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.name) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        if len(self.children) > 0:
            args.append("children=[")
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Submodule(" + args_text
        if len(self.children) == 0:
            text_line += ')'
        res.append(text_line)
        if len(self.children) > 0:
            child_res = []
            for child in self.children:
                child_res.append(child.prsrc(indent+1))
            res.append(",\n".join(child_res))
            res.append(_ind(indent) + "])")
        return "\n".join(res)

    def compile(self, context: Context):
        new = Submodule(self.name,
                        augment=self.augment,
                        belongs_to=self.belongs_to,
                        contact=self.contact,
                        description=self.description,
                        deviation=self.deviation,
                        extension_=self.extension_,
                        feature=self.feature,
                        import_=self.import_,
                        include=self.include,
                        organization=self.organization,
                        reference=self.reference,
                        revision=self.revision,
                        yang_version=self.yang_version,
                        children=self.expand_children(context))
        new.expand_augments(context)
        return new

    def __str__(self):
        return "Submodule " + self.name

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Submodule (Ord):
    def __eq__(self, other: Submodule):
        return self.name == other.name and self.augment == other.augment and self.belongs_to == other.belongs_to and self.contact == other.contact and self.description == other.description and self.deviation == other.deviation and self.extension_ == other.extension_ and self.feature == other.feature and self.import_ == other.import_ and self.include == other.include and self.organization == other.organization and self.reference == other.reference and self.revision == other.revision and self.yang_version == other.yang_version

    def __lt__(a, b):
        return a.name < b.name

class Type(SchemaNodeOuter):
    """YANG type

    https://tools.ietf.org/html/rfc7950#section-7.4.1
    """
    name: str
    base: list[str]
    bit: list[Bit]
    enum: list[Enum]
    fraction_digits: ?int
    length: ?Length
    path: ?str
    pattern: list[Pattern]
    range_: ?Range
    require_instance: ?bool
    type_: list[Type]

    def __init__(self, name: str, base: list[str]=[], bit: list[Bit]=[], enum: list[Enum]=[], fraction_digits: ?int=None, length: ?Length=None, path: ?str=None, pattern: list[Pattern]=[], range_: ?Range=None, require_instance: ?bool=None, type_: list[Type]=[], exts=[], namespace=None, prefix=None):
        self.parent = None
        for n in bit:
            n.parent = self
        for n in enum:
            n.parent = self
        if length is not None:
            length.parent = self
        for n in pattern:
            n.parent = self
        if range_ is not None:
            range_.parent = self
        for n in type_:
            n.parent = self
        self.name = name
        self.base = base
        self.bit = bit
        self.enum = enum
        self.fraction_digits = fraction_digits
        self.length = length
        self.path = path
        self.pattern = pattern
        self.range_ = range_
        self.require_instance = require_instance
        self.type_ = type_
        self.exts = exts
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("base", self.base),
            ("bit", self.bit),
            ("enum", self.enum),
            ("fraction-digits", self.fraction_digits),
            ("length", self.length),
            ("path", self.path),
            ("pattern", self.pattern),
            ("range", self.range_),
            ("require-instance", self.require_instance),
            ("type", self.type_),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.name) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Type(" + args_text + ")"
        res.append(text_line)
        return "\n".join(res)

    def resolve_union_types(self, context: Context) -> Type:
        if self.name == "union":
            resolved_union_types = []
            # Resolve union types
            for ut in self.type_:
                resolved_ut = ut.resolve_typedef(context).type_
                resolved_union_types.append(resolved_ut)
            self.type_ = resolved_union_types
            return self
        else:
            return self

    def resolve_typedef(self, context: Context) -> Typedef:
        if self.name in _builtin_types:
            return Typedef(self.name, type_=self.resolve_union_types(context))
        td = self.get_typedef(self.name, context)
        for i in range(RECURSION_LIMIT+1):
            if td.type_.name in _builtin_types:
                new_t = td.type_.resolve_union_types(context)
                td.type_ = new_t
                return td
            td = td.type_.resolve_typedef(context)
            if i == RECURSION_LIMIT:
                raise ValueError("Recursion limit reached for typedef %s" % self.name)
        raise ValueError("Unable to resolve typedef %s" % self.name)

    def compile(self, context: Context):
        new = Type(self.name,
                   base=self.base,
                   bit=self.bit,
                   enum=self.enum,
                   fraction_digits=self.fraction_digits,
                   length=self.length,
                   path=self.path,
                   pattern=self.pattern,
                   range_=self.range_,
                   require_instance=self.require_instance,
                   type_=self.type_)
        return new

    def __str__(self):
        return "Type " + self.name

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Type (Ord):
    def __eq__(self, other: Type):
        return self.name == other.name and self.base == other.base and self.bit == other.bit and self.enum == other.enum and self.fraction_digits == other.fraction_digits and self.length == other.length and self.path == other.path and self.pattern == other.pattern and self.range_ == other.range_ and self.require_instance == other.require_instance and self.type_ == other.type_

    def __lt__(a, b):
        return a.name < b.name

class Typedef(SchemaNodeOuter):
    """YANG typedef

    https://tools.ietf.org/html/rfc7950#section-7.3.1
    """
    name: str
    default: ?str
    description: ?str
    reference: ?str
    status: ?str
    type_: Type
    units: ?str

    def __init__(self, name: str, type_: Type, default: ?str=None, description: ?str=None, reference: ?str=None, status: ?str=None, units: ?str=None, exts=[], namespace=None, prefix=None):
        self.parent = None
        if type_ is not None:
            type_.parent = self
        self.name = name
        self.default = default
        self.description = description
        self.reference = reference
        self.status = status
        self.type_ = type_
        self.units = units
        self.exts = exts
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("default", self.default),
            ("description", self.description),
            ("reference", self.reference),
            ("status", self.status),
            ("type", self.type_),
            ("units", self.units),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.name) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Typedef(" + args_text + ")"
        res.append(text_line)
        return "\n".join(res)

    def compile(self, context: Context):
        base_typedef = self.type_.resolve_typedef(context)

        new_default = self.default
        if new_default is None:
            new_default = base_typedef.default

        new_units = self.units
        if new_units is None:
            new_units = base_typedef.units

        new = Typedef(self.name,
                      default=new_default,
                      description=self.description,
                      reference=self.reference,
                      status=self.status,
                      type_=base_typedef.type_,
                      units=new_units)
        return new

    def __str__(self):
        return "Typedef " + self.name

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Typedef (Ord):
    def __eq__(self, other: Typedef):
        return self.name == other.name and self.default == other.default and self.description == other.description and self.reference == other.reference and self.status == other.status and self.type_ == other.type_ and self.units == other.units

    def __lt__(a, b):
        return a.name < b.name

class Uses(SchemaNodeOuter):
    """YANG uses

    https://tools.ietf.org/html/rfc7950#section-7.13.1
    """
    name: str
    augment: list[Augment]
    description: ?str
    if_feature: list[str]
    reference: ?str
    refine: list[Refine]
    status: ?str
    when: ?str

    def __init__(self, name: str, augment: list[Augment]=[], description: ?str=None, if_feature: list[str]=[], reference: ?str=None, refine: list[Refine]=[], status: ?str=None, when: ?str=None, exts=[], namespace=None, prefix=None):
        self.parent = None
        for n in augment:
            n.parent = self
        for n in refine:
            n.parent = self
        self.name = name
        self.augment = augment
        self.description = description
        self.if_feature = if_feature
        self.reference = reference
        self.refine = refine
        self.status = status
        self.when = when
        self.exts = exts
        self.namespace = namespace
        self.prefix = prefix

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("augment", self.augment),
            ("description", self.description),
            ("if-feature", self.if_feature),
            ("reference", self.reference),
            ("refine", self.refine),
            ("status", self.status),
            ("when", self.when),
            ("exts", self.exts),
        ]
        args = ["'" + str(self.name) + "'"]
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, attrs))
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Uses(" + args_text + ")"
        res.append(text_line)
        return "\n".join(res)

    def compile(self, context: Context):
        raise ValueError("Cannot compile 'uses'")

    def __str__(self):
        return "Uses " + self.name

    def _get_argname(self) -> ?str:
        return 'name'

    def _get_arg(self) -> ?str:
        return self.name

extension Uses (Ord):
    def __eq__(self, other: Uses):
        return self.name == other.name and self.augment == other.augment and self.description == other.description and self.if_feature == other.if_feature and self.reference == other.reference and self.refine == other.refine and self.status == other.status and self.when == other.when

    def __lt__(a, b):
        return a.name < b.name

def take_opt_action(stmts: list[Statement]) -> ?Action:
    for node in take_nodes(stmts, ["action"]):
        if isinstance(node, Action):
            return node

def take_action(stmts: list[Statement]) -> Action:
    for node in take_nodes(stmts, ["action"]):
        if isinstance(node, Action):
            return node
    raise ValueError("No action in stmts")

def take_actions(stmts: list[Statement]) -> list[Action]:
    res = []
    for node in take_nodes(stmts, ["action"]):
        if isinstance(node, Action):
            res.append(node)
    return res

def take_opt_anydata(stmts: list[Statement]) -> ?Anydata:
    for node in take_nodes(stmts, ["anydata"]):
        if isinstance(node, Anydata):
            return node

def take_anydata(stmts: list[Statement]) -> Anydata:
    for node in take_nodes(stmts, ["anydata"]):
        if isinstance(node, Anydata):
            return node
    raise ValueError("No anydata in stmts")

def take_anydatas(stmts: list[Statement]) -> list[Anydata]:
    res = []
    for node in take_nodes(stmts, ["anydata"]):
        if isinstance(node, Anydata):
            res.append(node)
    return res

def take_opt_anyxml(stmts: list[Statement]) -> ?Anyxml:
    for node in take_nodes(stmts, ["anyxml"]):
        if isinstance(node, Anyxml):
            return node

def take_anyxml(stmts: list[Statement]) -> Anyxml:
    for node in take_nodes(stmts, ["anyxml"]):
        if isinstance(node, Anyxml):
            return node
    raise ValueError("No anyxml in stmts")

def take_anyxmls(stmts: list[Statement]) -> list[Anyxml]:
    res = []
    for node in take_nodes(stmts, ["anyxml"]):
        if isinstance(node, Anyxml):
            res.append(node)
    return res

def take_opt_augment(stmts: list[Statement]) -> ?Augment:
    for node in take_nodes(stmts, ["augment"]):
        if isinstance(node, Augment):
            return node

def take_augment(stmts: list[Statement]) -> Augment:
    for node in take_nodes(stmts, ["augment"]):
        if isinstance(node, Augment):
            return node
    raise ValueError("No augment in stmts")

def take_augments(stmts: list[Statement]) -> list[Augment]:
    res = []
    for node in take_nodes(stmts, ["augment"]):
        if isinstance(node, Augment):
            res.append(node)
    return res

def take_opt_belongs_to(stmts: list[Statement]) -> ?BelongsTo:
    for node in take_nodes(stmts, ["belongs-to"]):
        if isinstance(node, BelongsTo):
            return node

def take_belongs_to(stmts: list[Statement]) -> BelongsTo:
    for node in take_nodes(stmts, ["belongs-to"]):
        if isinstance(node, BelongsTo):
            return node
    raise ValueError("No belongs-to in stmts")

def take_belongs_tos(stmts: list[Statement]) -> list[BelongsTo]:
    res = []
    for node in take_nodes(stmts, ["belongs-to"]):
        if isinstance(node, BelongsTo):
            res.append(node)
    return res

def take_opt_bit(stmts: list[Statement]) -> ?Bit:
    for node in take_nodes(stmts, ["bit"]):
        if isinstance(node, Bit):
            return node

def take_bit(stmts: list[Statement]) -> Bit:
    for node in take_nodes(stmts, ["bit"]):
        if isinstance(node, Bit):
            return node
    raise ValueError("No bit in stmts")

def take_bits(stmts: list[Statement]) -> list[Bit]:
    res = []
    for node in take_nodes(stmts, ["bit"]):
        if isinstance(node, Bit):
            res.append(node)
    return res

def take_opt_case(stmts: list[Statement]) -> ?Case:
    for node in take_nodes(stmts, ["case"]):
        if isinstance(node, Case):
            return node

def take_case(stmts: list[Statement]) -> Case:
    for node in take_nodes(stmts, ["case"]):
        if isinstance(node, Case):
            return node
    raise ValueError("No case in stmts")

def take_cases(stmts: list[Statement]) -> list[Case]:
    res = []
    for node in take_nodes(stmts, ["case"]):
        if isinstance(node, Case):
            res.append(node)
    return res

def take_opt_choice(stmts: list[Statement]) -> ?Choice:
    for node in take_nodes(stmts, ["choice"]):
        if isinstance(node, Choice):
            return node

def take_choice(stmts: list[Statement]) -> Choice:
    for node in take_nodes(stmts, ["choice"]):
        if isinstance(node, Choice):
            return node
    raise ValueError("No choice in stmts")

def take_choices(stmts: list[Statement]) -> list[Choice]:
    res = []
    for node in take_nodes(stmts, ["choice"]):
        if isinstance(node, Choice):
            res.append(node)
    return res

def take_opt_container(stmts: list[Statement]) -> ?Container_:
    for node in take_nodes(stmts, ["container"]):
        if isinstance(node, Container_):
            return node

def take_container(stmts: list[Statement]) -> Container_:
    for node in take_nodes(stmts, ["container"]):
        if isinstance(node, Container_):
            return node
    raise ValueError("No container in stmts")

def take_containers(stmts: list[Statement]) -> list[Container_]:
    res = []
    for node in take_nodes(stmts, ["container"]):
        if isinstance(node, Container_):
            res.append(node)
    return res

def take_opt_enum(stmts: list[Statement]) -> ?Enum:
    for node in take_nodes(stmts, ["enum"]):
        if isinstance(node, Enum):
            return node

def take_enum(stmts: list[Statement]) -> Enum:
    for node in take_nodes(stmts, ["enum"]):
        if isinstance(node, Enum):
            return node
    raise ValueError("No enum in stmts")

def take_enums(stmts: list[Statement]) -> list[Enum]:
    res = []
    for node in take_nodes(stmts, ["enum"]):
        if isinstance(node, Enum):
            res.append(node)
    return res

def take_opt_extension(stmts: list[Statement]) -> ?Extension:
    for node in take_nodes(stmts, ["extension"]):
        if isinstance(node, Extension):
            return node

def take_extension(stmts: list[Statement]) -> Extension:
    for node in take_nodes(stmts, ["extension"]):
        if isinstance(node, Extension):
            return node
    raise ValueError("No extension in stmts")

def take_extensions(stmts: list[Statement]) -> list[Extension]:
    res = []
    for node in take_nodes(stmts, ["extension"]):
        if isinstance(node, Extension):
            res.append(node)
    return res

def take_opt_feature(stmts: list[Statement]) -> ?Feature:
    for node in take_nodes(stmts, ["feature"]):
        if isinstance(node, Feature):
            return node

def take_feature(stmts: list[Statement]) -> Feature:
    for node in take_nodes(stmts, ["feature"]):
        if isinstance(node, Feature):
            return node
    raise ValueError("No feature in stmts")

def take_features(stmts: list[Statement]) -> list[Feature]:
    res = []
    for node in take_nodes(stmts, ["feature"]):
        if isinstance(node, Feature):
            res.append(node)
    return res

def take_opt_grouping(stmts: list[Statement]) -> ?Grouping:
    for node in take_nodes(stmts, ["grouping"]):
        if isinstance(node, Grouping):
            return node

def take_grouping(stmts: list[Statement]) -> Grouping:
    for node in take_nodes(stmts, ["grouping"]):
        if isinstance(node, Grouping):
            return node
    raise ValueError("No grouping in stmts")

def take_groupings(stmts: list[Statement]) -> list[Grouping]:
    res = []
    for node in take_nodes(stmts, ["grouping"]):
        if isinstance(node, Grouping):
            res.append(node)
    return res

def take_opt_identity(stmts: list[Statement]) -> ?Identity_:
    for node in take_nodes(stmts, ["identity"]):
        if isinstance(node, Identity_):
            return node

def take_identity(stmts: list[Statement]) -> Identity_:
    for node in take_nodes(stmts, ["identity"]):
        if isinstance(node, Identity_):
            return node
    raise ValueError("No identity in stmts")

def take_identitys(stmts: list[Statement]) -> list[Identity_]:
    res = []
    for node in take_nodes(stmts, ["identity"]):
        if isinstance(node, Identity_):
            res.append(node)
    return res

def take_opt_import(stmts: list[Statement]) -> ?Import:
    for node in take_nodes(stmts, ["import"]):
        if isinstance(node, Import):
            return node

def take_import(stmts: list[Statement]) -> Import:
    for node in take_nodes(stmts, ["import"]):
        if isinstance(node, Import):
            return node
    raise ValueError("No import in stmts")

def take_imports(stmts: list[Statement]) -> list[Import]:
    res = []
    for node in take_nodes(stmts, ["import"]):
        if isinstance(node, Import):
            res.append(node)
    return res

def take_opt_include(stmts: list[Statement]) -> ?Include:
    for node in take_nodes(stmts, ["include"]):
        if isinstance(node, Include):
            return node

def take_include(stmts: list[Statement]) -> Include:
    for node in take_nodes(stmts, ["include"]):
        if isinstance(node, Include):
            return node
    raise ValueError("No include in stmts")

def take_includes(stmts: list[Statement]) -> list[Include]:
    res = []
    for node in take_nodes(stmts, ["include"]):
        if isinstance(node, Include):
            res.append(node)
    return res

def take_opt_input(stmts: list[Statement]) -> ?Input:
    for node in take_nodes(stmts, ["input"]):
        if isinstance(node, Input):
            return node

def take_input(stmts: list[Statement]) -> Input:
    for node in take_nodes(stmts, ["input"]):
        if isinstance(node, Input):
            return node
    raise ValueError("No input in stmts")

def take_inputs(stmts: list[Statement]) -> list[Input]:
    res = []
    for node in take_nodes(stmts, ["input"]):
        if isinstance(node, Input):
            res.append(node)
    return res

def take_opt_leaf(stmts: list[Statement]) -> ?Leaf:
    for node in take_nodes(stmts, ["leaf"]):
        if isinstance(node, Leaf):
            return node

def take_leaf(stmts: list[Statement]) -> Leaf:
    for node in take_nodes(stmts, ["leaf"]):
        if isinstance(node, Leaf):
            return node
    raise ValueError("No leaf in stmts")

def take_leafs(stmts: list[Statement]) -> list[Leaf]:
    res = []
    for node in take_nodes(stmts, ["leaf"]):
        if isinstance(node, Leaf):
            res.append(node)
    return res

def take_opt_leaf_list(stmts: list[Statement]) -> ?LeafList:
    for node in take_nodes(stmts, ["leaf-list"]):
        if isinstance(node, LeafList):
            return node

def take_leaf_list(stmts: list[Statement]) -> LeafList:
    for node in take_nodes(stmts, ["leaf-list"]):
        if isinstance(node, LeafList):
            return node
    raise ValueError("No leaf-list in stmts")

def take_leaf_lists(stmts: list[Statement]) -> list[LeafList]:
    res = []
    for node in take_nodes(stmts, ["leaf-list"]):
        if isinstance(node, LeafList):
            res.append(node)
    return res

def take_opt_length(stmts: list[Statement]) -> ?Length:
    for node in take_nodes(stmts, ["length"]):
        if isinstance(node, Length):
            return node

def take_length(stmts: list[Statement]) -> Length:
    for node in take_nodes(stmts, ["length"]):
        if isinstance(node, Length):
            return node
    raise ValueError("No length in stmts")

def take_lengths(stmts: list[Statement]) -> list[Length]:
    res = []
    for node in take_nodes(stmts, ["length"]):
        if isinstance(node, Length):
            res.append(node)
    return res

def take_opt_list(stmts: list[Statement]) -> ?List:
    for node in take_nodes(stmts, ["list"]):
        if isinstance(node, List):
            return node

def take_list(stmts: list[Statement]) -> List:
    for node in take_nodes(stmts, ["list"]):
        if isinstance(node, List):
            return node
    raise ValueError("No list in stmts")

def take_lists(stmts: list[Statement]) -> list[List]:
    res = []
    for node in take_nodes(stmts, ["list"]):
        if isinstance(node, List):
            res.append(node)
    return res

def take_opt_module(stmts: list[Statement]) -> ?Module:
    for node in take_nodes(stmts, ["module"]):
        if isinstance(node, Module):
            return node

def take_module(stmts: list[Statement]) -> Module:
    for node in take_nodes(stmts, ["module"]):
        if isinstance(node, Module):
            return node
    raise ValueError("No module in stmts")

def take_modules(stmts: list[Statement]) -> list[Module]:
    res = []
    for node in take_nodes(stmts, ["module"]):
        if isinstance(node, Module):
            res.append(node)
    return res

def take_opt_must(stmts: list[Statement]) -> ?Must:
    for node in take_nodes(stmts, ["must"]):
        if isinstance(node, Must):
            return node

def take_must(stmts: list[Statement]) -> Must:
    for node in take_nodes(stmts, ["must"]):
        if isinstance(node, Must):
            return node
    raise ValueError("No must in stmts")

def take_musts(stmts: list[Statement]) -> list[Must]:
    res = []
    for node in take_nodes(stmts, ["must"]):
        if isinstance(node, Must):
            res.append(node)
    return res

def take_opt_notification(stmts: list[Statement]) -> ?Notification:
    for node in take_nodes(stmts, ["notification"]):
        if isinstance(node, Notification):
            return node

def take_notification(stmts: list[Statement]) -> Notification:
    for node in take_nodes(stmts, ["notification"]):
        if isinstance(node, Notification):
            return node
    raise ValueError("No notification in stmts")

def take_notifications(stmts: list[Statement]) -> list[Notification]:
    res = []
    for node in take_nodes(stmts, ["notification"]):
        if isinstance(node, Notification):
            res.append(node)
    return res

def take_opt_output(stmts: list[Statement]) -> ?Output:
    for node in take_nodes(stmts, ["output"]):
        if isinstance(node, Output):
            return node

def take_output(stmts: list[Statement]) -> Output:
    for node in take_nodes(stmts, ["output"]):
        if isinstance(node, Output):
            return node
    raise ValueError("No output in stmts")

def take_outputs(stmts: list[Statement]) -> list[Output]:
    res = []
    for node in take_nodes(stmts, ["output"]):
        if isinstance(node, Output):
            res.append(node)
    return res

def take_opt_pattern(stmts: list[Statement]) -> ?Pattern:
    for node in take_nodes(stmts, ["pattern"]):
        if isinstance(node, Pattern):
            return node

def take_pattern(stmts: list[Statement]) -> Pattern:
    for node in take_nodes(stmts, ["pattern"]):
        if isinstance(node, Pattern):
            return node
    raise ValueError("No pattern in stmts")

def take_patterns(stmts: list[Statement]) -> list[Pattern]:
    res = []
    for node in take_nodes(stmts, ["pattern"]):
        if isinstance(node, Pattern):
            res.append(node)
    return res

def take_opt_range(stmts: list[Statement]) -> ?Range:
    for node in take_nodes(stmts, ["range"]):
        if isinstance(node, Range):
            return node

def take_range(stmts: list[Statement]) -> Range:
    for node in take_nodes(stmts, ["range"]):
        if isinstance(node, Range):
            return node
    raise ValueError("No range in stmts")

def take_ranges(stmts: list[Statement]) -> list[Range]:
    res = []
    for node in take_nodes(stmts, ["range"]):
        if isinstance(node, Range):
            res.append(node)
    return res

def take_opt_refine(stmts: list[Statement]) -> ?Refine:
    for node in take_nodes(stmts, ["refine"]):
        if isinstance(node, Refine):
            return node

def take_refine(stmts: list[Statement]) -> Refine:
    for node in take_nodes(stmts, ["refine"]):
        if isinstance(node, Refine):
            return node
    raise ValueError("No refine in stmts")

def take_refines(stmts: list[Statement]) -> list[Refine]:
    res = []
    for node in take_nodes(stmts, ["refine"]):
        if isinstance(node, Refine):
            res.append(node)
    return res

def take_opt_revision(stmts: list[Statement]) -> ?Revision:
    for node in take_nodes(stmts, ["revision"]):
        if isinstance(node, Revision):
            return node

def take_revision(stmts: list[Statement]) -> Revision:
    for node in take_nodes(stmts, ["revision"]):
        if isinstance(node, Revision):
            return node
    raise ValueError("No revision in stmts")

def take_revisions(stmts: list[Statement]) -> list[Revision]:
    res = []
    for node in take_nodes(stmts, ["revision"]):
        if isinstance(node, Revision):
            res.append(node)
    return res

def take_opt_rpc(stmts: list[Statement]) -> ?Rpc:
    for node in take_nodes(stmts, ["rpc"]):
        if isinstance(node, Rpc):
            return node

def take_rpc(stmts: list[Statement]) -> Rpc:
    for node in take_nodes(stmts, ["rpc"]):
        if isinstance(node, Rpc):
            return node
    raise ValueError("No rpc in stmts")

def take_rpcs(stmts: list[Statement]) -> list[Rpc]:
    res = []
    for node in take_nodes(stmts, ["rpc"]):
        if isinstance(node, Rpc):
            res.append(node)
    return res

def take_opt_submodule(stmts: list[Statement]) -> ?Submodule:
    for node in take_nodes(stmts, ["submodule"]):
        if isinstance(node, Submodule):
            return node

def take_submodule(stmts: list[Statement]) -> Submodule:
    for node in take_nodes(stmts, ["submodule"]):
        if isinstance(node, Submodule):
            return node
    raise ValueError("No submodule in stmts")

def take_submodules(stmts: list[Statement]) -> list[Submodule]:
    res = []
    for node in take_nodes(stmts, ["submodule"]):
        if isinstance(node, Submodule):
            res.append(node)
    return res

def take_opt_type(stmts: list[Statement]) -> ?Type:
    for node in take_nodes(stmts, ["type"]):
        if isinstance(node, Type):
            return node

def take_type(stmts: list[Statement]) -> Type:
    for node in take_nodes(stmts, ["type"]):
        if isinstance(node, Type):
            return node
    raise ValueError("No type in stmts")

def take_types(stmts: list[Statement]) -> list[Type]:
    res = []
    for node in take_nodes(stmts, ["type"]):
        if isinstance(node, Type):
            res.append(node)
    return res

def take_opt_typedef(stmts: list[Statement]) -> ?Typedef:
    for node in take_nodes(stmts, ["typedef"]):
        if isinstance(node, Typedef):
            return node

def take_typedef(stmts: list[Statement]) -> Typedef:
    for node in take_nodes(stmts, ["typedef"]):
        if isinstance(node, Typedef):
            return node
    raise ValueError("No typedef in stmts")

def take_typedefs(stmts: list[Statement]) -> list[Typedef]:
    res = []
    for node in take_nodes(stmts, ["typedef"]):
        if isinstance(node, Typedef):
            res.append(node)
    return res

def take_opt_uses(stmts: list[Statement]) -> ?Uses:
    for node in take_nodes(stmts, ["uses"]):
        if isinstance(node, Uses):
            return node

def take_uses(stmts: list[Statement]) -> Uses:
    for node in take_nodes(stmts, ["uses"]):
        if isinstance(node, Uses):
            return node
    raise ValueError("No uses in stmts")

def take_usess(stmts: list[Statement]) -> list[Uses]:
    res = []
    for node in take_nodes(stmts, ["uses"]):
        if isinstance(node, Uses):
            res.append(node)
    return res

def stmt_to_snode(stmt: Statement) -> SchemaNode:
    arg = stmt.arg
    ss = stmt.substatements.copy()
    if stmt.kw == "action":
        if arg is not None:
            n = Action(arg,
                       description=take_opt_str(ss, "description"),
                       if_feature=take_strlist(ss, "if-feature"),
                       input=take_opt_input(ss),
                       output=take_opt_output(ss),
                       reference=take_opt_str(ss, "reference"),
                       status=take_opt_str(ss, "status"),
                       children=take_nodes(ss, ["grouping", "typedef"]),
                       exts=take_exts(ss)
                       )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under action: %s" % (name))
            return n
    if stmt.kw == "anydata":
        if arg is not None:
            n = Anydata(arg,
                        config=take_opt_bool(ss, "config"),
                        description=take_opt_str(ss, "description"),
                        if_feature=take_strlist(ss, "if-feature"),
                        mandatory=take_opt_bool(ss, "mandatory"),
                        must=take_musts(ss),
                        reference=take_opt_str(ss, "reference"),
                        status=take_opt_str(ss, "status"),
                        when=take_opt_str(ss, "when"),
                        exts=take_exts(ss)
                        )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under anydata: %s" % (name))
            return n
    if stmt.kw == "anyxml":
        if arg is not None:
            n = Anyxml(arg,
                       config=take_opt_bool(ss, "config"),
                       description=take_opt_str(ss, "description"),
                       if_feature=take_strlist(ss, "if-feature"),
                       mandatory=take_opt_bool(ss, "mandatory"),
                       must=take_musts(ss),
                       reference=take_opt_str(ss, "reference"),
                       status=take_opt_str(ss, "status"),
                       when=take_opt_str(ss, "when"),
                       exts=take_exts(ss)
                       )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under anyxml: %s" % (name))
            return n
    if stmt.kw == "augment":
        if arg is not None:
            n = Augment(arg,
                        description=take_opt_str(ss, "description"),
                        if_feature=take_strlist(ss, "if-feature"),
                        reference=take_opt_str(ss, "reference"),
                        status=take_opt_str(ss, "status"),
                        when=take_opt_str(ss, "when"),
                        children=take_nodes(ss, ["action", "anydata", "anyxml", "case", "choice", "container", "leaf", "leaf-list", "list", "notification", "uses"]),
                        exts=take_exts(ss)
                        )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under augment: %s" % (name))
            return n
    if stmt.kw == "belongs-to":
        if arg is not None:
            n = BelongsTo(arg,
                           prefix=take_opt_str(ss, "prefix"),
                           exts=take_exts(ss)
                           )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under belongs-to: %s" % (name))
            return n
    if stmt.kw == "bit":
        if arg is not None:
            n = Bit(arg,
                    description=take_opt_str(ss, "description"),
                    if_feature=take_strlist(ss, "if-feature"),
                    position=take_opt_int(ss, "position"),
                    reference=take_opt_str(ss, "reference"),
                    status=take_opt_str(ss, "status"),
                    exts=take_exts(ss)
                    )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under bit: %s" % (name))
            return n
    if stmt.kw == "case":
        if arg is not None:
            n = Case(arg,
                     description=take_opt_str(ss, "description"),
                     if_feature=take_strlist(ss, "if-feature"),
                     reference=take_opt_str(ss, "reference"),
                     status=take_opt_str(ss, "status"),
                     when=take_opt_str(ss, "when"),
                     children=take_nodes(ss, ["anydata", "anyxml", "choice", "container", "leaf", "leaf-list", "list", "uses"]),
                     exts=take_exts(ss)
                     )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under case: %s" % (name))
            return n
    if stmt.kw == "choice":
        if arg is not None:
            n = Choice(arg,
                       config=take_opt_bool(ss, "config"),
                       default=take_opt_str(ss, "default"),
                       description=take_opt_str(ss, "description"),
                       if_feature=take_strlist(ss, "if-feature"),
                       mandatory=take_opt_bool(ss, "mandatory"),
                       reference=take_opt_str(ss, "reference"),
                       status=take_opt_str(ss, "status"),
                       when=take_opt_str(ss, "when"),
                       children=take_nodes(ss, ["anydata", "anyxml", "case", "choice", "container", "leaf", "leaf-list", "list"]),
                       exts=take_exts(ss)
                       )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under choice: %s" % (name))
            return n
    if stmt.kw == "container":
        if arg is not None:
            n = Container_(arg,
                          config=take_opt_bool(ss, "config"),
                          description=take_opt_str(ss, "description"),
                          if_feature=take_strlist(ss, "if-feature"),
                          must=take_musts(ss),
                          presence=take_opt_str(ss, "presence"),
                          reference=take_opt_str(ss, "reference"),
                          status=take_opt_str(ss, "status"),
                          when=take_opt_str(ss, "when"),
                          children=take_nodes(ss, ["action", "anydata", "anyxml", "choice", "container", "grouping", "leaf", "leaf-list", "list", "notification", "typedef", "uses"]),
                          exts=take_exts(ss)
                          )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under container: %s" % (name))
            return n
    if stmt.kw == "enum":
        if arg is not None:
            n = Enum(arg,
                     description=take_opt_str(ss, "description"),
                     if_feature=take_strlist(ss, "if-feature"),
                     reference=take_opt_str(ss, "reference"),
                     status=take_opt_str(ss, "status"),
                     value=take_opt_str(ss, "value"),
                     exts=take_exts(ss)
                     )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under enum: %s" % (name))
            return n
    if stmt.kw == "extension":
        if arg is not None:
            n = Extension(arg,
                          argument=take_opt_str(ss, "argument"),
                          description=take_opt_str(ss, "description"),
                          reference=take_opt_str(ss, "reference"),
                          status=take_opt_str(ss, "status"),
                          exts=take_exts(ss)
                          )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under extension: %s" % (name))
            return n
    if stmt.kw == "feature":
        if arg is not None:
            n = Feature(arg,
                        description=take_opt_str(ss, "description"),
                        if_feature=take_strlist(ss, "if-feature"),
                        reference=take_opt_str(ss, "reference"),
                        status=take_opt_str(ss, "status"),
                        exts=take_exts(ss)
                        )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under feature: %s" % (name))
            return n
    if stmt.kw == "grouping":
        if arg is not None:
            n = Grouping(arg,
                         description=take_opt_str(ss, "description"),
                         reference=take_opt_str(ss, "reference"),
                         status=take_opt_str(ss, "status"),
                         children=take_nodes(ss, ["action", "anydata", "anyxml", "choice", "container", "grouping", "leaf", "leaf-list", "list", "notification", "typedef", "uses"]),
                         exts=take_exts(ss)
                         )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under grouping: %s" % (name))
            return n
    if stmt.kw == "identity":
        if arg is not None:
            n = Identity_(arg,
                         base=take_strlist(ss, "base"),
                         description=take_opt_str(ss, "description"),
                         if_feature=take_strlist(ss, "if-feature"),
                         reference=take_opt_str(ss, "reference"),
                         status=take_opt_str(ss, "status"),
                         exts=take_exts(ss)
                         )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under identity: %s" % (name))
            return n
    if stmt.kw == "import":
        if arg is not None:
            n = Import(arg,
                       description=take_opt_str(ss, "description"),
                       prefix=take_opt_str(ss, "prefix"),
                       reference=take_opt_str(ss, "reference"),
                       revision_date=take_opt_str(ss, "revision-date"),
                       exts=take_exts(ss)
                       )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under import: %s" % (name))
            return n
    if stmt.kw == "include":
        if arg is not None:
            n = Include(arg,
                        description=take_opt_str(ss, "description"),
                        reference=take_opt_str(ss, "reference"),
                        revision_date=take_opt_str(ss, "revision-date"),
                        exts=take_exts(ss)
                        )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under include: %s" % (name))
            return n
    if stmt.kw == "input":
        if arg is None:
            n = Input(must=take_musts(ss),
                      children=take_nodes(ss, ["anydata", "anyxml", "choice", "container", "grouping", "leaf", "leaf-list", "list", "typedef", "uses"]),
                      exts=take_exts(ss)
                      )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under input: %s" % (name))
            return n
    if stmt.kw == "leaf":
        if arg is not None:
            n = Leaf(arg,
                     config=take_opt_bool(ss, "config"),
                     default=take_opt_str(ss, "default"),
                     description=take_opt_str(ss, "description"),
                     if_feature=take_strlist(ss, "if-feature"),
                     mandatory=take_opt_bool(ss, "mandatory"),
                     must=take_musts(ss),
                     reference=take_opt_str(ss, "reference"),
                     status=take_opt_str(ss, "status"),
                     type_=take_type(ss),
                     units=take_opt_str(ss, "units"),
                     when=take_opt_str(ss, "when"),
                     exts=take_exts(ss)
                     )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under leaf: %s" % (name))
            return n
    if stmt.kw == "leaf-list":
        if arg is not None:
            n = LeafList(arg,
                          config=take_opt_bool(ss, "config"),
                          default=take_strlist(ss, "default"),
                          description=take_opt_str(ss, "description"),
                          if_feature=take_strlist(ss, "if-feature"),
                          max_elements=take_opt_str(ss, "max-elements"),
                          min_elements=take_opt_str(ss, "min-elements"),
                          must=take_musts(ss),
                          ordered_by=take_opt_str(ss, "ordered-by"),
                          reference=take_opt_str(ss, "reference"),
                          status=take_opt_str(ss, "status"),
                          type_=take_type(ss),
                          units=take_opt_str(ss, "units"),
                          when=take_opt_str(ss, "when"),
                          exts=take_exts(ss)
                          )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under leaf-list: %s" % (name))
            return n
    if stmt.kw == "length":
        if arg is not None:
            n = Length(arg,
                       description=take_opt_str(ss, "description"),
                       error_app_tag=take_opt_str(ss, "error-app-tag"),
                       error_message=take_opt_str(ss, "error-message"),
                       reference=take_opt_str(ss, "reference"),
                       exts=take_exts(ss)
                       )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under length: %s" % (name))
            return n
    if stmt.kw == "list":
        if arg is not None:
            n = List(arg,
                     config=take_opt_bool(ss, "config"),
                     description=take_opt_str(ss, "description"),
                     if_feature=take_strlist(ss, "if-feature"),
                     key=take_opt_str(ss, "key"),
                     max_elements=take_opt_str(ss, "max-elements"),
                     min_elements=take_opt_str(ss, "min-elements"),
                     must=take_musts(ss),
                     ordered_by=take_opt_str(ss, "ordered-by"),
                     reference=take_opt_str(ss, "reference"),
                     status=take_opt_str(ss, "status"),
                     unique=take_strlist(ss, "unique"),
                     when=take_opt_str(ss, "when"),
                     children=take_nodes(ss, ["action", "anydata", "anyxml", "choice", "container", "grouping", "leaf", "leaf-list", "list", "notification", "typedef", "uses"]),
                     exts=take_exts(ss)
                     )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under list: %s" % (name))
            return n
    if stmt.kw == "module":
        if arg is not None:
            n = Module(arg,
                       augment=take_augments(ss),
                       contact=take_opt_str(ss, "contact"),
                       description=take_opt_str(ss, "description"),
                       deviation=take_strlist(ss, "deviation"),
                       extension_=take_extensions(ss),
                       feature=take_features(ss),
                       import_=take_imports(ss),
                       include=take_includes(ss),
                       namespace=take_opt_str(ss, "namespace"),
                       organization=take_opt_str(ss, "organization"),
                       prefix=take_opt_str(ss, "prefix"),
                       reference=take_opt_str(ss, "reference"),
                       revision=take_revisions(ss),
                       yang_version=take_yang_version(ss),
                       children=take_nodes(ss, ["anydata", "anyxml", "choice", "container", "grouping", "identity", "leaf", "leaf-list", "list", "notification", "rpc", "typedef", "uses"]),
                       exts=take_exts(ss)
                       )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under module: %s" % (name))
            return n
    if stmt.kw == "must":
        if arg is not None:
            n = Must(arg,
                     description=take_opt_str(ss, "description"),
                     error_app_tag=take_opt_str(ss, "error-app-tag"),
                     error_message=take_opt_str(ss, "error-message"),
                     reference=take_opt_str(ss, "reference"),
                     exts=take_exts(ss)
                     )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under must: %s" % (name))
            return n
    if stmt.kw == "notification":
        if arg is not None:
            n = Notification(arg,
                             description=take_opt_str(ss, "description"),
                             if_feature=take_strlist(ss, "if-feature"),
                             must=take_musts(ss),
                             reference=take_opt_str(ss, "reference"),
                             status=take_opt_str(ss, "status"),
                             children=take_nodes(ss, ["anydata", "anyxml", "choice", "container", "grouping", "leaf", "leaf-list", "list", "typedef", "uses"]),
                             exts=take_exts(ss)
                             )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under notification: %s" % (name))
            return n
    if stmt.kw == "output":
        if arg is None:
            n = Output(must=take_musts(ss),
                       children=take_nodes(ss, ["anydata", "anyxml", "choice", "container", "grouping", "leaf", "leaf-list", "list", "typedef", "uses"]),
                       exts=take_exts(ss)
                       )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under output: %s" % (name))
            return n
    if stmt.kw == "pattern":
        if arg is not None:
            n = Pattern(arg,
                        description=take_opt_str(ss, "description"),
                        error_app_tag=take_opt_str(ss, "error-app-tag"),
                        error_message=take_opt_str(ss, "error-message"),
                        modifier=take_opt_str(ss, "modifier"),
                        reference=take_opt_str(ss, "reference"),
                        exts=take_exts(ss)
                        )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under pattern: %s" % (name))
            return n
    if stmt.kw == "range":
        if arg is not None:
            n = Range(arg,
                      description=take_opt_str(ss, "description"),
                      error_app_tag=take_opt_str(ss, "error-app-tag"),
                      error_message=take_opt_str(ss, "error-message"),
                      reference=take_opt_str(ss, "reference"),
                      exts=take_exts(ss)
                      )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under range: %s" % (name))
            return n
    if stmt.kw == "refine":
        if arg is not None:
            n = Refine(arg,
                       config=take_opt_bool(ss, "config"),
                       default=take_opt_str(ss, "default"),
                       description=take_opt_str(ss, "description"),
                       if_feature=take_strlist(ss, "if-feature"),
                       mandatory=take_opt_bool(ss, "mandatory"),
                       max_elements=take_opt_str(ss, "max-elements"),
                       min_elements=take_opt_str(ss, "min-elements"),
                       must=take_musts(ss),
                       presence=take_opt_str(ss, "presence"),
                       reference=take_opt_str(ss, "reference"),
                       exts=take_exts(ss)
                       )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under refine: %s" % (name))
            return n
    if stmt.kw == "revision":
        if arg is not None:
            n = Revision(arg,
                         description=take_opt_str(ss, "description"),
                         reference=take_opt_str(ss, "reference"),
                         exts=take_exts(ss)
                         )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under revision: %s" % (name))
            return n
    if stmt.kw == "rpc":
        if arg is not None:
            n = Rpc(arg,
                    description=take_opt_str(ss, "description"),
                    if_feature=take_strlist(ss, "if-feature"),
                    input=take_opt_input(ss),
                    output=take_opt_output(ss),
                    reference=take_opt_str(ss, "reference"),
                    status=take_opt_str(ss, "status"),
                    children=take_nodes(ss, ["grouping", "typedef"]),
                    exts=take_exts(ss)
                    )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under rpc: %s" % (name))
            return n
    if stmt.kw == "submodule":
        if arg is not None:
            n = Submodule(arg,
                          augment=take_augments(ss),
                          belongs_to=take_belongs_to(ss),
                          contact=take_opt_str(ss, "contact"),
                          description=take_opt_str(ss, "description"),
                          deviation=take_strlist(ss, "deviation"),
                          extension_=take_extensions(ss),
                          feature=take_features(ss),
                          import_=take_imports(ss),
                          include=take_includes(ss),
                          organization=take_opt_str(ss, "organization"),
                          reference=take_opt_str(ss, "reference"),
                          revision=take_revisions(ss),
                          yang_version=take_yang_version(ss),
                          children=take_nodes(ss, ["anydata", "anyxml", "choice", "container", "grouping", "identity", "leaf", "leaf-list", "list", "notification", "rpc", "typedef", "uses"]),
                          exts=take_exts(ss)
                          )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under submodule: %s" % (name))
            return n
    if stmt.kw == "type":
        if arg is not None:
            n = Type(arg,
                     base=take_strlist(ss, "base"),
                     bit=take_bits(ss),
                     enum=take_enums(ss),
                     fraction_digits=take_opt_int(ss, "fraction-digits"),
                     length=take_opt_length(ss),
                     path=take_opt_str(ss, "path"),
                     pattern=take_patterns(ss),
                     range_=take_opt_range(ss),
                     require_instance=take_opt_bool(ss, "require-instance"),
                     type_=take_types(ss),
                     exts=take_exts(ss)
                     )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under type: %s" % (name))
            return n
    if stmt.kw == "typedef":
        if arg is not None:
            n = Typedef(arg,
                        default=take_opt_str(ss, "default"),
                        description=take_opt_str(ss, "description"),
                        reference=take_opt_str(ss, "reference"),
                        status=take_opt_str(ss, "status"),
                        type_=take_type(ss),
                        units=take_opt_str(ss, "units"),
                        exts=take_exts(ss)
                        )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under typedef: %s" % (name))
            return n
    if stmt.kw == "uses":
        if arg is not None:
            n = Uses(arg,
                     augment=take_augments(ss),
                     description=take_opt_str(ss, "description"),
                     if_feature=take_strlist(ss, "if-feature"),
                     reference=take_opt_str(ss, "reference"),
                     refine=take_refines(ss),
                     status=take_opt_str(ss, "status"),
                     when=take_opt_str(ss, "when"),
                     exts=take_exts(ss)
                     )
            if len(ss) > 0:
                name = ss[0].kw
                prefix = ss[0].prefix
                raise ValueError("Invalid statement under uses: %s" % (name))
            return n
    raise ValueError("Unknown statement:" + stmt.kw)


def stmt_to_smodule(stmt):
    m = stmt_to_snode(stmt)
    if isinstance(m, Module):
        return m
    raise ValueError("Expected a module, got " + type(m))
