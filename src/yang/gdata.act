import base64
import testing
import json
import xml

from yang.identityref import Identityref, PartialIdentityref

"""YANG data

This module defines classes for YANG data nodes. It can represent a YANG data
tree, and can be used to serialize and deserialize YANG data.
"""

# kinds of things?
# - container
# - list
# - list element
# - leaf
# - leaf-list
#
# TODO: for ordered-by user lists, we need to expose a way to influence the order of elements

# Can we simply use the order of elements in the input list to control the order in the output?
#
# ACL1 which allows SSH and rejects everything else
# <acls>
#   <acl>
#     <aces>
#       <ace>
#         <name>SSH</name>
#         <action>permit</action>
#         <matches>
#           <ipv4>
#             <source-ipv4-network>192.0.2.0/24</source-ipv4-network>
#           </ipv4>
#           <protocol>tcp</protocol>
#           <tcp>
#             <destination-port>
#               <operator>eq</operator>
#               <port>22</port>
#             </destionation-port>
#           </tcp>
#         </matches>
#       </ace>
#       <ace>
#         <name>DROP</name>
#         <action>drop</action>
#       </ace>
#     </aces>
#   </acl>
# </acls>
#
# ACL2 which allows BGP and rejects everything else
# <acls>
#   <acl>
#     <aces>
#       <ace>
#         <name>BGP-PASSIVE</name>
#         <action>permit</action>
#         <src-port>179</src-port>
#         <matches>
#           <protocol>tcp</protocol>
#           <tcp>
#             <destination-port>
#               <operator>eq</operator>
#               <port>179</port>
#             </destionation-port>
#           </tcp>
#         </matches>
#       </ace>
#       <ace>
#         <name>DROP</name>
#       </ace>
#     </aces>
#   </acl>
# </acls>
#
# And the merged result should be:
#
# <acls>
#   <acl>
#     <aces>
#       <ace>
#         <name>SSH</name>
#         <action>permit</action>
#         <matches>
#           <ipv4>
#             <source-ipv4-network>192.0.2.0/24</source-ipv4-network>
#           </ipv4>
#           <protocol>tcp</protocol>
#           <tcp>
#             <destination-port>
#               <operator>eq</operator>
#               <port>22</port>
#             </destionation-port>
#           </tcp>
#         </matches>
#       </ace>
#       <ace>
#         <name>BGP-PASSIVE</name>
#         <action>permit</action>
#         <src-port>179</src-port>
#         <matches>
#           <protocol>tcp</protocol>
#           <tcp>
#             <destination-port>
#               <operator>eq</operator>
#               <port>179</port>
#             </destionation-port>
#           </tcp>
#         </matches>
#       </ace>
#       <ace>
#         <name>DROP</name>
#         <action>drop</action>
#       </ace>
#     </aces>
#   </acl>
# </acls>
#

#
#
# ACL1 which allows SSH and rejects everything else
#   <acl>
#       <ace>
#         <name>SSH</name>
#         <action>permit</action>
#         <matches>...</matches>
#       </ace>
#       <ace>
#         <name>DROP</name>
#         <action>drop</action>
#       </ace>
#   </acl>
#
# ACL2 which allows BGP and rejects everything else
#   <acl>
#       <ace>
#         <name>BGP-PASSIVE</name>
#         <action>permit</action>
#         <matches>...</matches>
#       </ace>
#       <ace>
#         <name>DROP</name>
#       </ace>
#   </acl>
#
# And the merged result should be:
#
#   <acl>
#       <ace>
#         <name>SSH</name>
#         <action>permit</action>
#         <matches>...</matches>
#       </ace>
#       <ace>
#         <name>BGP-PASSIVE</name>
#         <action>permit</action>
#         <matches>... </matches>
#       </ace>
#       <ace>
#         <name>DROP</name>
#         <action>drop</action>
#       </ace>
#   </acl>
#
# In the merge, we cannot know if SSH should come before or after BGP-PASSIVE,
# but it dosen't matter. The only important thing is that both are before the
# DROP rule. We make sure of this by stating in both input ACLs that DROP should
# be last. Note how in ACL2 the DROP ace is not complete, it just contains the
# name and nothing else. This is fine because the merge function will take the
# complete ACE from ACL1 and merge it with the incomplete ACE from ACL2 to
# produce a complete output.

def _ind(n):
    return "  " * n

remove_op = (nsdefs=[("xc", "urn:ietf:params:xml:ns:netconf:base:1.0")], attrs=[("xc:operation", "remove")])
create_op = (nsdefs=[("xc", "urn:ietf:params:xml:ns:netconf:base:1.0")], attrs=[("xc:operation", "create")])
delete_op = (nsdefs=[("xc", "urn:ietf:params:xml:ns:netconf:base:1.0")], attrs=[("xc:operation", "delete")])
replace_op = (nsdefs=[("xc", "urn:ietf:params:xml:ns:netconf:base:1.0")], attrs=[("xc:operation", "replace")])


def _nsq(node_ns, v: ?value=None):
    r = []
    if node_ns is not None:
        r.append((None, node_ns))
    if isinstance(v, Identityref):
        r.append((v.mod, v.ns))
    return r


def yang_str(v) -> str:
    if isinstance(v, bytes):
        s = base64.encode(v).decode()
        return s
    if isinstance(v, Identityref):
        s = "{v.mod}:{v.val}"
        return s
    s = str(v)
    if isinstance(v, bool):
        s = s.lower()
    return s


def json_val(yang_type: str, v: value) -> ?value:
    if isinstance(v, bytes):
        return base64.encode(v).decode()
    if yang_type == "int64" or yang_type == "uint64":
        return str(v)
    if isinstance(v, Identityref):
        return "{v.mod}:{v.val}"
    return v


def fmt_json_name(name, module=None):
    name_without_prefix = name.split(":")[-1]
    if module is not None:
        return "{module}:{name_without_prefix}"
    return name_without_prefix


class Node(value):
    ns: ?str
    module: ?str
    children: dict[str, Node]
    txid: ?str

    def __repr__(self) -> str:
        return self.prsrc(deterministic=False)

    def key_str(self, key_names: list[str]) -> str:
        return ",".join([str(self.get_leaf(kn).val).replace(",", "\\,") for kn in key_names])

    def key_values(self, key_names: list[str]) -> dict[str, value]:
        return {kn: self.get_leaf(kn).val for kn in key_names}

    def key_children(self, key_names: list[str]) -> dict[str, Leaf]:
        return {kn: self.get_leaf(kn) for kn in key_names}

    pure def prsrc(self, deterministic=False, indent=0, name="") -> str:
        """Get the Acton source code representation of the node

        Returns a string representation of this node that can be used to recreate
        the same data structure in Acton code. This is useful for debugging and
        testing.

        The deterministic output mode reorders system-ordered leaf-list and list
        elements in order to render deterministic output which is very useful
        for testing. Only user-ordered lists and leaf-lists have semantic
        meaning, for non-user-ordered lists, the order of elements has no
        meaning which is why we can reorder them for deterministic output. The
        default is to produce raw non-deterministic output, which is more true
        to nature and a better representation for debugging.
        """
        ns_args = ["ns='{self.ns}'"] if self.ns is not None else []
        module_args = ["module='{self.module}'"] if self.module is not None else []
        base_args = ns_args + module_args

        if isinstance(self, Leaf):
            args = ["'{str(self.t)}'", repr(self.val)] + base_args
            return "Leaf({", ".join(args)})"
        elif isinstance(self, LeafList):
            # Only sort if deterministic=True and not user_order
            vals_str = repr(self.vals if (self.user_order or not deterministic) else vals_list_sorted(self.vals))
            order_args = ["user_order=True"] if self.user_order else []
            args = ["'{str(self.t)}'", vals_str] + base_args + order_args
            return "LeafList({", ".join(args)})"
        elif isinstance(self, Absent):
            sname = "Absent"
            if len(self.children) == 0:
                return "{sname}({", ".join(base_args)})"
            else:
                child_strs = ["{_ind(indent+1)}'{nm}': {child.prsrc(deterministic, indent+1, nm)}"
                             for nm,child in self.children.items()]
                args_str = ", {", ".join(base_args)}" if len(base_args) > 0 else ""
                return "\n".join([
                    sname + r"({",
                    ",\n".join(child_strs),
                    "{_ind(indent)}}}{args_str})"
                ])
        elif isinstance(self, Delete):
            sname = "Delete"
            if len(self.children) == 0:
                return "{sname}({", ".join(base_args)})"
            else:
                child_strs = ["{_ind(indent+1)}'{nm}': {child.prsrc(deterministic, indent+1, nm)}"
                             for nm,child in self.children.items()]
                args_str = ", {", ".join(base_args)}" if len(base_args) > 0 else ""
                return "\n".join([
                    sname + r"({",
                    ",\n".join(child_strs),
                    "{_ind(indent)}}}{args_str})"
                ])
        elif isinstance(self, List):
            keys_arg = [str(self.keys)]
            order_args = ["user_order=True"] if self.user_order else []
            args = keys_arg + base_args + order_args
            if len(self.elements) == 0:
                return "List({", ".join(args)})"
            else:
                # Only sort if deterministic=True and not user_order
                elems = self.elements if (self.user_order or not deterministic) else sorted_elements(self.elements, self.keys)
                elem_strs = [_ind(indent+1) + elem.prsrc(deterministic, indent+1) for elem in elems]
                args_with_elements = args + ["elements=["]
                return "\n".join([
                    "List({", ".join(args_with_elements)}",
                    ",\n".join(elem_strs),
                    _ind(indent) + "])"
                ])
        elif isinstance(self, Container):
            sname = "Container"
            presence_args = ["presence=True"] if self.presence else []
            args = presence_args + base_args
            if len(self.children) == 0:
                return "{sname}({", ".join(args)})"
            else:
                child_strs = ["{_ind(indent+1)}'{nm}': {child.prsrc(deterministic, indent+1, nm)}"
                             for nm,child in self.children.items()]
                args_str = ", {", ".join(args)}" if len(args) > 0 else ""
                return "\n".join([
                    sname + r"({",
                    ",\n".join(child_strs),
                    "{_ind(indent)}}}{args_str})"
                ])
        elif isinstance(self, Create):
            sname = "Create"
            args = base_args
            if len(self.children) == 0:
                return "{sname}({", ".join(args)})"
            else:
                child_strs = ["{_ind(indent+1)}'{nm}': {child.prsrc(deterministic, indent+1, nm)}"
                             for nm,child in self.children.items()]
                args_str = ", {", ".join(args)}" if len(args) > 0 else ""
                return "\n".join([
                    sname + r"({",
                    ",\n".join(child_strs),
                    "{_ind(indent)}}}{args_str})"
                ])
        elif isinstance(self, Replace):
            sname = "Replace"
            args = base_args
            if len(self.children) == 0:
                return "{sname}({", ".join(args)})"
            else:
                child_strs = ["{_ind(indent+1)}'{nm}': {child.prsrc(deterministic, indent+1, nm)}"
                             for nm,child in self.children.items()]
                args_str = ", {", ".join(args)}" if len(args) > 0 else ""
                return "\n".join([
                    sname + r"({",
                    ",\n".join(child_strs),
                    "{_ind(indent)}}}{args_str})"
                ])
        else:
            raise ValueError("Unsupported node type in prsrc")

    def to_json(self, pretty=True) -> str:
        """Convert gdata to JSON
        """
        return json.encode(self.to_dict(), pretty=pretty)

    def to_dict(self, pretty=True) -> dict[str, ?value]:
        """Convert gdata to a dict, suitable for JSON serialization
        """
        if isinstance(self, Container):
            child_dict = {}
            for nm,child in self.children.items():
                if isinstance(child, Container):
                    child_dict[fmt_json_name(nm, child.module)] = child.to_dict(pretty)
                elif isinstance(child, Leaf):
                    v = child.val
                    # "empty" type is encoded as an array with a null element "[null]"
                    if isinstance(v, Present):
                        if v.present:
                            child_dict[fmt_json_name(nm, child.module)] = [None]
                    elif v is not None:
                        child_dict[fmt_json_name(nm, child.module)] = json_val(child.t, v)
                elif isinstance(child, LeafList):
                    vals = []
                    for v in child.vals if child.user_order else vals_list_sorted(child.vals):
                        vals.append(json_val(child.t, v))
                    child_dict[fmt_json_name(nm, child.module)] = vals
                elif isinstance(child, List):
                    elems = []
                    for elem in child.elements if child.user_order else sorted_elements(child.elements, child.keys):
                        if isinstance(elem, Container):
                            elems.append(elem.to_dict(pretty))
                        else:
                            raise ValueError("Unexpected list ({nm}) element type: {type(elem)}")
                    child_dict[fmt_json_name(nm, child.module)] = elems
                elif isinstance(child, Absent):
                    continue
                else:
                    raise ValueError("Unsupported child ({nm}) node type in to_dict: {type(child)}")
            return child_dict
        raise ValueError("Unsupported node type in to_dict: {type(self)}")

    def _to_xml_rec(self, key_names: ?list[str]=None, skip_nonkeys: bool=False, parent_absent: bool=False) -> list[xml.Node]:
        if isinstance(self, Container) or isinstance(self, Absent) or isinstance(self, Create) or isinstance(self, Delete) or isinstance(self, Replace):
            children = []
            if key_names is not None:
                if skip_nonkeys:
                    iter_children = iter(key_names)
                else:
                    iter_children = iter(key_names + [nm for nm in self.children.keys() if nm not in key_names])
            else:
                iter_children = self.children.keys()
            for name in iter_children:
                child = self.children[name]
                if parent_absent and not isinstance(child, List):
                    continue
                if ":" in name:
                    local_name = name.split(":")[-1]
                else:
                    local_name = name
                if isinstance(child, Container):
                    cchildren = child._to_xml_rec()
                    if len(cchildren) > 0:
                        children.append(xml.Node(local_name, nsdefs=_nsq(child.ns), children=cchildren))
                    elif isinstance(self, Container) and child.presence:
                        children.append(xml.Node(local_name, nsdefs=_nsq(child.ns)))

                elif isinstance(child, List):
                    for elem in child.elements if child.user_order else sorted_elements(child.elements, child.keys):
                        # Determine NETCONF operation for list element based on node type
                        skip_nonkeys = False
                        if isinstance(elem, Absent) or parent_absent:
                            attrs = remove_op
                            skip_nonkeys = True
                        elif isinstance(elem, Delete):
                            attrs = delete_op
                            skip_nonkeys = True
                        elif isinstance(elem, Create):
                            attrs = create_op
                        elif isinstance(elem, Replace):
                            attrs = replace_op
                        else:
                            attrs = (nsdefs=[], attrs=[])
                        children.append(xml.Node(local_name, nsdefs=_nsq(child.ns) + attrs.nsdefs, attributes=attrs.attrs, children=elem._to_xml_rec(child.keys, skip_nonkeys)))
                elif isinstance(child, Leaf):
                    v = child.val
                    if isinstance(v, Present):
                        if v.present:
                            children.append(xml.Node(local_name, nsdefs=_nsq(child.ns)))
                        else:
                            children.append(xml.Node(local_name, nsdefs=_nsq(child.ns) + remove_op.nsdefs, attributes=remove_op.attrs))
                    elif v is not None:
                        children.append(xml.Node(local_name, nsdefs=_nsq(child.ns, child.val), text=yang_str(v)))
                    else:
                        children.append(xml.Node(local_name, nsdefs=_nsq(child.ns) + remove_op.nsdefs, attributes=remove_op.attrs))
                elif isinstance(child, LeafList):
                    vals = []
                    for val in child.vals if child.user_order else vals_list_sorted(child.vals):
                        v = yang_str(val)
                        vals.append(xml.Node(local_name, nsdefs=_nsq(child.ns, val), text=v))
                    children.extend(vals)
                elif isinstance(child, Create):
                    # Render as element with create op, include children
                    children.append(xml.Node(local_name, nsdefs=_nsq(child.ns) + create_op.nsdefs, attributes=create_op.attrs, children=child._to_xml_rec()))
                elif isinstance(child, Replace):
                    # Render as element with replace op, include children
                    children.append(xml.Node(local_name, nsdefs=_nsq(child.ns) + replace_op.nsdefs, attributes=replace_op.attrs, children=child._to_xml_rec()))
                elif isinstance(child, Delete):
                    # Render as element with delete op
                    children.append(xml.Node(local_name, nsdefs=_nsq(child.ns) + delete_op.nsdefs, attributes=delete_op.attrs))
                elif isinstance(child, Absent):
                    # Render as element with remove op, unless the children are rendered explicitly (list)
                    cchildren = child._to_xml_rec(parent_absent=True)
                    if len(cchildren) > 0:
                        children.extend(cchildren)
                    else:
                        children.append(xml.Node(local_name, nsdefs=_nsq(child.ns) + remove_op.nsdefs, attributes=remove_op.attrs))
                else:
                    raise ValueError("Unsupported child ({name}) node type in to_xml: {type(child)}")
            return children
        raise ValueError("Unsupported node type in to_xml: {type(self)}")

    def to_xml(self) -> list[xml.Node]:
        """Convert this gdata node to a list of xml.Node

        The top-level node in a valid gdata structure is an unnamed container
        with named children. But in a valid XML document there must be a single
        top-level element. Thus we return a list of xml.Node fragments, one for
        each of the top-level gdata Container children."""
        return self._to_xml_rec()

    def to_xmlstr(self, pretty=True) -> str:
        """Convert this gdata node to an XML string

        The result is a joined XML string of all the fragments, one for each of
        the top-level gdata Container children."""
        return xml.encode_nodes(self.to_xml(), pretty)

    # --
    def get_leaf(self, name) -> Leaf:
        l = self.get_opt_leaf(name)
        if l is not None:
            return l
        raise ValueError("Cannot find leaf child in {self} with name: {name}")

    def get_opt_leaf(self, name) -> ?Leaf:
        if isinstance(self, Container) or isinstance(self, Absent) or isinstance(self, Create) or isinstance(self, Replace) or isinstance(self, Delete):
            for nm,child in self.children.items():
                if isinstance(child, Leaf) and nm == name:
                    return child

    #--

    def get_cnt(self, name) -> Container:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, Container) and nm == name:
                    return child
        raise ValueError("Cannot find container child with name {name}")

    def get_opt_cnt(self, name) -> ?Container:
        """This is for P-container"""
        try:
            return self.get_cnt(name)
        except ValueError:
            return None

    def get_list(self, name) -> List:
        l = self.get_opt_list(name)
        if l is not None:
            return l
        raise ValueError("Cannot find list child with name " + name)

    def get_opt_list(self, name) -> ?List:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, List) and nm == name:
                    return child

    def get_bool(self, name) -> bool:
        child = self.get_leaf(name)
        childval = child.val
        if isinstance(childval, bool):
            return childval
        raise ValueError("Leaf {name} is not of type bool")

    def get_opt_bool(self, name) -> ?bool:
        child = self.get_opt_leaf(name)
        if child is not None:
            childval = child.val
            if isinstance(childval, bool):
                return childval

    def get_opt_empty(self, name) -> ?Present:
        child = self.get_opt_leaf(name)
        if child is not None:
            childval = child.val
            if isinstance(childval, Present):
                return childval

    def get_float(self, name) -> float:
        child = self.get_leaf(name)
        childval = child.val
        if isinstance(childval, float):
            return childval
        raise ValueError("Leaf {name} is not of type float")

    def get_opt_float(self, name) -> ?float:
        child = self.get_opt_leaf(name)
        if child is not None:
            childval = child.val
            if isinstance(childval, float):
                return childval

    def get_int(self, name) -> int:
        child = self.get_leaf(name)
        childval = child.val
        if isinstance(childval, int):
            return childval
        raise ValueError("Leaf {name} is not of type int")

    def get_ints(self, name) -> list[int]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    cvals = []
                    for v in child.vals:
                        if isinstance(v, int):
                            cvals.append(v)
                    return cvals
        raise ValueError("Cannot find leaf-list child with name {name}")

    def get_opt_int(self, name) -> ?int:
        child = self.get_opt_leaf(name)
        if child is not None:
            childval = child.val
            if isinstance(childval, int):
                return childval

    def get_opt_ints(self, name) -> list[int]:
        try:
            return self.get_ints(name)
        except ValueError:
            return []

    def get_str(self, name) -> str:
        child = self.get_leaf(name)
        childval = child.val
        if isinstance(childval, str):
            return childval
        raise ValueError("Leaf {name} value is not type str")

    def get_opt_str(self, name) -> ?str:
        child = self.get_opt_leaf(name)
        if child is not None:
            childval = child.val
            if isinstance(childval, str):
                return childval

    def get_strs(self, name) -> list[str]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    cvals = []
                    for v in child.vals:
                        if isinstance(v, str):
                            cvals.append(v)
                    return cvals
        raise ValueError("Cannot find leaf-list child with name {name}")

    def get_opt_strs(self, name) -> list[str]:
        try:
            return self.get_strs(name)
        except ValueError:
            return []

    def get_bytes(self, name) -> bytes:
        child = self.get_leaf(name)
        childval = child.val
        if isinstance(childval, bytes):
            return childval
        raise ValueError("Leaf {name} value is not type bytes")

    def get_opt_bytes(self, name) -> ?bytes:
        child = self.get_opt_leaf(name)
        if child is not None:
            childval = child.val
            if isinstance(childval, bytes):
                return childval

    def get_bytess(self, name) -> list[bytes]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    cvals = []
                    for v in child.vals:
                        if isinstance(v, bytes):
                            cvals.append(v)
                    return cvals
        raise ValueError("Cannot find leaf-list child with name {name}")

    def get_opt_bytess(self, name) -> list[bytes]:
        try:
            return self.get_bytess(name)
        except ValueError:
            return []

    def get_floats(self, name) -> list[float]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    cvals = []
                    for v in child.vals:
                        if isinstance(v, float):
                            cvals.append(v)
                    return cvals
        raise ValueError("Cannot find leaf-list child with name {name}")

    def get_opt_floats(self, name) -> list[float]:
        try:
            return self.get_floats(name)
        except ValueError:
            return []

    def get_bools(self, name) -> list[bool]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    cvals = []
                    for v in child.vals:
                        if isinstance(v, bool):
                            cvals.append(v)
                    return cvals
        raise ValueError("Cannot find leaf-list child with name {name}")

    def get_opt_bools(self, name) -> list[bool]:
        try:
            return self.get_bools(name)
        except ValueError:
            return []

    def get_value(self, name) -> value:
        child = self.get_leaf(name)
        return child.val

    def get_opt_value(self, name) -> ?value:
        child = self.get_opt_leaf(name)
        if child is not None:
            return child.val

    def get_values(self, name) -> list[value]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    return child.vals
        raise ValueError("Cannot find leaf-list child with name {name}")

    def get_opt_values(self, name) -> list[value]:
        try:
            return self.get_values(name)
        except ValueError:
            return []

    def get_Identityref(self, name) -> Identityref:
        child = self.get_leaf(name)
        childval = child.val
        if isinstance(childval, Identityref):
            return childval
        raise ValueError("Leaf {name} value is not type Identityref")

    def get_opt_Identityref(self, name) -> ?Identityref:
        child = self.get_opt_leaf(name)
        if child is not None:
            childval = child.val
            if isinstance(childval, Identityref):
                return childval

    def get_Identityrefs(self, name) -> list[Identityref]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    cvals = []
                    for v in child.vals:
                        if isinstance(v, Identityref):
                            cvals.append(v)
                    return cvals
        raise ValueError("Cannot find leaf-list child with name {name}")

    def get_opt_Identityrefs(self, name) -> list[Identityref]:
        try:
            return self.get_Identityrefs(name)
        except ValueError:
            return []

extension Node(Eq):
    def __eq__(self, other: Node) -> bool:
        if self.ns != other.ns:
            return False

        if isinstance(self, Container) and isinstance(other, Container):
            if set(self.children.keys()) != set(other.children.keys()):
                return False
            for key in self.children.keys():
                if self.children[key] != other.children[key]:
                    return False
            return True

        if isinstance(self, Leaf) and isinstance(other, Leaf):
            return vals_equal(self.val, other.val)

        if isinstance(self, LeafList) and isinstance(other, LeafList):
            return vals_list_equal(self.vals, other.vals)

        if isinstance(self, List) and isinstance(other, List):
            if self.keys != other.keys:
                return False
            if len(self.elements) != len(other.elements):
                return False
            for i in range(len(self.elements)):
                e1 = self.elements[i]
                e2 = other.elements[i]
                if not self.user_order and e1.key_str(self.keys) != e2.key_str(other.keys):
                    for e2 in other.elements:
                        if e1.key_str(self.keys) == e2.key_str(other.keys):
                            break
                if e1 != e2:
                    return False
            return True

        if isinstance(self, Absent) and isinstance(other, Absent):
            if set(self.children.keys()) != set(other.children.keys()):
                return False
            for key in self.children.keys():
                if self.children[key] != other.children[key]:
                    return False
            return True

        return False


class List(Node):
    keys: list[str] # name of the key leafs
    elements: list[Node]
    user_order: bool

    def __init__(self, keys: list[str], elements: list[Node]=[], user_order=False, ns: ?str=None, module: ?str=None, txid: ?str=None):
        self.keys = keys
        self.elements = elements
        self.user_order = user_order
        self.ns = ns
        self.module = module
        self.txid = txid
        self.children = {}

    def get_opt_list_entry(self, key: str) -> ?Node:
        """Get a list entry by key value

        Returns None if the entry is not found.
        """
        for elem in self.elements:
            if elem.key_str(self.keys) == key:
                return elem
        return None

    def get_list_entry(self, key: str) -> Node:
        """Get a list entry by key value

        Raises ValueError if the entry is not found.
        """
        elem = self.get_opt_list_entry(key)
        if elem is not None:
            return elem
        raise ValueError("Cannot find list entry with key {key}")

class Container(Node):
    def __init__(self, children: dict[str, Node]={}, presence: bool=False, ns: ?str=None, module: ?str=None, txid: ?str=None):
        self.children = children
        self.presence = presence
        self.ns = ns
        self.module = module
        self.txid = txid

class Leaf(Node):
    t: str
    val: value

    def __init__(self, t: str, val: value, ns: ?str=None, module: ?str=None, txid: ?str=None):
        self.t = t
        self.val = val
        self.ns = ns
        self.module = module
        self.txid = txid
        self.children = {}

class LeafList(Node):
    t: str
    vals: list[value]
    user_order: bool

    def __init__(self, t:str, vals: list[value], user_order=False, ns: ?str=None, module: ?str=None, txid: ?str=None):
        self.t = t
        self.ns = ns
        self.module = module
        self.vals = vals
        self.user_order = user_order
        self.txid = txid
        self.children = {}

class Present:
    """Named type for empty leaf value

    This type is used for the empty leaf value, so that we can do an
    isinstance(v, Present) check to detect whether the leaf is present. When
    Acton supports pattern matching we can switch to the () identity.

    This is the first step towards reducing reliance on the gdata.Node.type
    attribute for comparisons, and instead just comparing the Acton types. In
    the final form, the present boolean argument will also be removed, which
    will make it possible to first make the value optional (?Present) and
    ultimately replace with () identity once Acton supports pattern matching.
    """
    def __init__(self, present: bool=True):
        self.present = present

    def __repr__(self):
        return "yang.gdata.Present({'' if self.present else 'False'})"

class Absent(Node):
    """Declarative definition of the absence of a node

    NETCONF remove operation maps to Absent

    Absent is declarative / idempotent, meaning that if the target to be removed
    / made absent is not present, no error is raised.
    """
    def __init__(self, children: dict[str, Node]={}, ns: ?str=None, module: ?str=None):
        self.ns = ns
        self.module = module
        self.children = children
        self.txid = None

class Delete(Node):
    """Imperative delete of a node
    NETCONF delete operation maps to Delete

    Unlike Absent / remove, Delete of a non-existent node is a failure.
    """
    def __init__(self, children: dict[str, Node]={}, ns: ?str=None, module: ?str=None):
        self.ns = ns
        self.module = module
        self.children = children
        self.txid = None

class Create(Node):
    """Imperative create of a node
    NETCONF create operation maps to Create

    Unlike the default implicit merge, Create of an existing node is a failure.
    """
    def __init__(self, children={}, ns: ?str=None, module: ?str=None):
        self.ns = ns
        self.module = module
        self.children = children
        self.txid = None

class Replace(Node):
    """Imperative replace of a node
    NETCONF replace operation maps to Replace
    """
    def __init__(self, children={}, ns: ?str=None, module: ?str=None):
        self.ns = ns
        self.module = module
        self.children = children
        self.txid = None

def sorted_elements(elements, key_names):
    keys = list(map(lambda elem: elem.key_str(key_names), elements))
    key_map = dict(zip(keys, elements))
    return [key_map[key] for key in sorted(keys)]

def vals_equal(a: value, b: value) -> bool:
    # Compare known leaf value types
    if isinstance(a, int) and isinstance(b, int):
        return a == b
    if isinstance(a, bool) and isinstance(b, bool):
        return a == b
    if isinstance(a, float) and isinstance(b, float):
        return a == b
    if isinstance(a, str) and isinstance(b, str):
        return a == b
    if isinstance(a, bytes) and isinstance(b, bytes):
        return a == b
    # TODO: Add support for u8 and i8
    #if isinstance(a, u8) and isinstance(b, u8):
    #    return a == b
    if isinstance(a, u16) and isinstance(b, u16):
        return a == b
    if isinstance(a, u32) and isinstance(b, u32):
        return a == b
    if isinstance(a, u64) and isinstance(b, u64):
        return a == b
    # TODO: Add support for u8 and i8
    #if isinstance(a, i8) and isinstance(b, i8):
    #    return a == b
    if isinstance(a, i16) and isinstance(b, i16):
        return a == b
    if isinstance(a, i32) and isinstance(b, i32):
        return a == b
    if isinstance(a, i64) and isinstance(b, i64):
        return a == b
    if isinstance(a, Identityref) and isinstance(b, Identityref):
        return a == b
    if isinstance(a, Present) and isinstance(b, Present):
        return a.present == b.present
    if type(a) != type(b):
        # It is valid to compare values of different type, which happens if
        # leaves are of type union and value a and b happen to be of different
        # type.
        return False
    raise ValueError("Unsupported value type in eq comparison")

# For leaf-lists we need to compare a list of values
def vals_list_equal(a: list[value], b: list[value]) -> bool:
    if len(a) != len(b):
        return False
    for i in range(len(a)):
        if not vals_equal(a[i], b[i]):
            return False
    return True

def vals_less_than(a: value, b: value) -> bool:
    # Compare known leaf value types
    if isinstance(a, int) and isinstance(b, int):
        return a < b
    if isinstance(a, bool) and isinstance(b, bool):
        return not a  # False (0) before True (1)
    if isinstance(a, float) and isinstance(b, float):
        return a < b
    if isinstance(a, str) and isinstance(b, str):
        return a < b
    if isinstance(a, bytes) and isinstance(b, bytes):
        return a < b
    # TODO: Add support for u8 and i8
    #if isinstance(a, u8) and isinstance(b, u8):
    #    return a < b
    if isinstance(a, u16) and isinstance(b, u16):
        return a < b
    if isinstance(a, u32) and isinstance(b, u32):
        return a < b
    if isinstance(a, u64) and isinstance(b, u64):
        return a < b
    # TODO: Add support for u8 and i8
    #if isinstance(a, i8) and isinstance(b, i8):
    #    return a < b
    if isinstance(a, i16) and isinstance(b, i16):
        return a < b
    if isinstance(a, i32) and isinstance(b, i32):
        return a < b
    if isinstance(a, i64) and isinstance(b, i64):
        return a < b
    if isinstance(a, Identityref) and isinstance(b, Identityref):
        return a < b
    if isinstance(a, Present) and isinstance(b, Present):
        return not a.present
    raise ValueError("Unsupported value type or mismatch in lt comparison: {type(a)}, {type(b)}")

pure def vals_list_sorted(a: list[value]) -> list[value]:
    """Sort a list of values, comparing only values of the same type

    Uses a functional approach to avoid mutations so that we can be called
    from pure functions. Perhaps this can be made more efficient by mutation -
    look into later once we can contain scope local mutation from leaking
    https://github.com/actonlang/acton/issues/1632
    """
    n = len(a)
    if n <= 1:
        return a

    # Functional bubble sort: recursively sort by finding minimum and building result
    # Find the minimum element
    min_val = a[0]
    min_idx = 0
    for i in range(1, n):
        if vals_less_than(a[i], min_val):
            min_val = a[i]
            min_idx = i

    # Build new list with minimum at front and recursively sort the rest
    remaining = a[:min_idx] + a[min_idx+1:]
    if len(remaining) == 0:
        return [min_val]
    else:
        return [min_val] + vals_list_sorted(remaining)



class _PathElement:
    def __init__(self, name: ?str=None, keys: ?dict[str, Leaf]=None):
        self.name = name
        self.keys = keys


def _format_gdata_path(path: list[_PathElement]) -> str:
    if len(path) == 0:
        return "/"
    path_str = ""
    for elem in path:
        elem_name = elem.name
        if elem_name is not None:
            path_str = path_str + "/" + elem_name
        elem_keys = elem.keys
        if elem_keys is not None and len(elem_keys) > 0:
            predicates = ["{k}={repr(v.val)}" for k, v in elem_keys.items()]
            path_str = path_str + "[" + ",".join(predicates) + "]"
    return path_str


def _merge_rec(a: Node, b: Node, path: list[_PathElement]) -> Node:
    if type(a) != type(b):
        raise ValueError("Cannot merge nodes of different types at {_format_gdata_path(path)}: {type(a)} != {type(b)}")

    # Helper to merge keyed children
    def merge_keyed_children(a_children: dict[str, Node], b_children: dict[str, Node]) -> dict[str, Node]:
        result: dict[str, Node] = {}

        a_keys = list(a_children.keys())
        b_keys = list(b_children.keys())

        i = 0
        j = 0
        while i < len(a_keys) and j < len(b_keys):
            ak = a_keys[i]
            bk = b_keys[j]
            if ak == bk:
                # Overlapping key
                merged_child = _merge_rec(a_children[ak], b_children[bk], path + [_PathElement(ak)])
                result[ak] = merged_child
                i += 1
                j += 1
            else:
                # Keys differ
                ak_in_b = (ak in b_children)
                bk_in_a = (bk in a_children)
                if not ak_in_b:
                    # Child only in a
                    result[ak] = a_children[ak]
                    i += 1
                elif not bk_in_a:
                    # Child only in b
                    # We append it now right after we handle old nodes to keep order of a
                    # In merging, we decided to maintain 'a' order as baseline
                    # So we handle all a_nodes that appear before first
                    # If we want strictly all 'a' first, we can first go through a_keys that are not in b.
                    # But let's insert b node here to keep somewhat stable merging.
                    result[bk] = b_children[bk]
                    j += 1
                else:
                    # Both appear in both sets at different positions, reorder scenario
                    # For simplicity, handle old's node first since we want to keep a's order.
                    merged_child = _merge_rec(a_children[ak], b_children[ak], path + [_PathElement(ak)])
                    result[ak] = merged_child
                    i += 1
                    # We don't advance j here because we haven't handled bk yet.
                    # We'll hit bk again in next iteration and handle it normally.

        # If a still has items
        while i < len(a_keys):
            ak = a_keys[i]
            # If ak also in b but we haven't handled it yet, merge it now.
            # Otherwise just take it from a.
            if ak in b_children:
                merged_child = _merge_rec(a_children[ak], b_children[ak], path + [_PathElement(ak)])
                result[ak] = merged_child
            else:
                result[ak] = a_children[ak]
            i += 1

        # If b still has items
        while j < len(b_keys):
            bk = b_keys[j]
            if bk not in a_children:
                # New child from b
                result[bk] = b_children[bk]
            else:
                # Already handled overlap above, but if we got here, let's be safe:
                merged_child = _merge_rec(a_children[bk], b_children[bk], path + [_PathElement(bk)])
                result[bk] = merged_child
            j += 1

        return result

    if isinstance(a, Container) and isinstance(b, Container):
        # Merge keyed children similarly to Container
        new_children = merge_keyed_children(a.children, b.children)
        return Container(children=new_children, presence=a.presence, ns=a.ns, module=a.module)

    elif isinstance(a, Leaf) and isinstance(b, Leaf):
        if a.t != b.t:
            raise ValueError("Cannot merge leaves with different types at {_format_gdata_path(path)}: {a.t} != {b.t}")
        aval = a.val
        bval = b.val
        if vals_equal(aval, bval):
            return a
        raise ValueError("Cannot merge leaves with different values at {_format_gdata_path(path)}: {str(aval)} != {str(bval)}")

    elif isinstance(a, LeafList) and isinstance(b, LeafList):
        if vals_list_equal(a.vals, b.vals):
            return a
        raise ValueError("Cannot merge leaf-lists with different values at {_format_gdata_path(path)}")

    elif isinstance(a, List) and isinstance(b, List):
        if a.keys != b.keys:
            raise ValueError("Cannot merge lists with different keys at {_format_gdata_path(path)}: {str(a.keys)} != {str(b.keys)}")
        if a.user_order != b.user_order:
            raise ValueError("Cannot merge lists with different user_order at {_format_gdata_path(path)}")

        if a.user_order:
            # user_order = True
            # Two-pointer approach for merging list elements
            # This preserves the order from 'a' as baseline and inserts 'b' elements accordingly.
            new_elements: list[Node] = []

            old_map = {e.key_str(a.keys): e for e in a.elements}

            # Start with elements from a, merge if present in b
            for a_elem in a.elements:
                found = False
                for b_elem in b.elements:
                    if b_elem.key_str(b.keys) == a_elem.key_str(a.keys):
                        key_values = a_elem.key_children(a.keys)
                        merged_elem = _merge_rec(a_elem, b_elem, path + [_PathElement(keys=key_values)])
                        if isinstance(merged_elem, Container):
                            new_elements.append(merged_elem)
                        else:
                            raise ValueError("merge did not return a Container where one was expected at {_format_gdata_path(path)}")
                        found = True
                        break
                if not found:
                    # not in b, just add a_elem
                    new_elements.append(a_elem)

            # Add elements from b that are not in a
            # Insert them in a stable manner at the end to preserve 'a' order
            # If we want a more sophisticated merging of order, we could try to insert them
            # relative to keys present in both.
            # For now, we just append them at the end.
            existing_keys = {}
            for e in new_elements:
                existing_keys[e.key_str(a.keys)] = True
            for b_elem in b.elements:
                bk = b_elem.key_str(b.keys)
                if bk not in existing_keys:
                    new_elements.append(b_elem)
                    existing_keys[bk] = True

            return List(a.keys, new_elements, user_order=a.user_order, ns=a.ns, module=a.module)
        else:
            # user_order = False
            # Keep the original merging logic since it sorts by keys, not order
            all_elements: dict[str, list[Node]] = {}

            for elem in a.elements:
                key_str = elem.key_str(a.keys)
                if key_str not in all_elements:
                    all_elements[key_str] = []
                all_elements[key_str].append(elem)
            for elem in b.elements:
                key_str = elem.key_str(b.keys)
                if key_str not in all_elements:
                    all_elements[key_str] = []
                all_elements[key_str].append(elem)

            new_elements: list[Node] = []
            # sort keys lex order as before
            sorted_keys = sorted(all_elements.keys())

            for key_str in sorted_keys:
                elems = all_elements[key_str]
                new_elem = elems[0]
                if len(elems) > 1:
                    key_values = new_elem.key_children(a.keys)
                    for elem in elems[1:]:
                        new_elem = _merge_rec(new_elem, elem, path + [_PathElement(keys=key_values)])
                if isinstance(new_elem, Container):
                    new_elements.append(new_elem)
                else:
                    raise ValueError("unreachable, new_elem should always be a Container at {_format_gdata_path(path)}")

            return List(a.keys, new_elements, ns=a.ns, module=a.module)

    elif isinstance(a, Absent) and isinstance(b, Absent):
        # Both absent is odd in a merge scenario, but let's just return absent
        return a

    else:
        raise ValueError("Unsupported node type in merge at {_format_gdata_path(path)}: {type(a)}")


def merge(a: Node, b: Node) -> Node:
    return _merge_rec(a, b, [])


def _diff_rec(old: ?Node, new: Node, path: list[_PathElement]) -> ?Node:
    if old is None:
        return new

    if type(old) != type(new):
        raise ValueError("diff called with nodes of different types at {_format_gdata_path(path)}: {type(old)} != {type(new)}")

    # Helper function for diffing Container nodes that have children keyed by strings
    def diff_keyed_children(old_children: dict[str, Node], new_children: dict[str, Node]) -> ?dict[str, Node]:
        # We'll produce a new_children_dict with the diff
        result: dict[str, Node] = {}

        for k,nchild in new_children.items():
            if k in old_children:
                ochild = old_children[k]
                child_diff = _diff_rec(ochild, nchild, path + [_PathElement(k)])
                if child_diff is not None:
                    result[k] = child_diff
            else:
                result[k] = nchild
        for k,ochild in old_children.items():
            if k not in new_children:
                # Preserve full original subtree under Absent for complete context
                # during delete operations (e.g., NETCONF XML, CLI stanza removal)
                result[k] = Absent({k: ochild}, ns=ochild.ns, module=ochild.module)

        if len(result) == 0:
            return None
        return result

    # Helper function for diffing list elements (specialized Container nodes)
    # that *must* always include the key leaf children
    def diff_list_element(old_element: Node, new_element: Node, keys: list[str], elem_path: list[_PathElement]) -> ?Node:
        # Diff of element Container nodes will only contain the actual
        # differences, skipping keys which are equal in both
        entry_diff = _diff_rec(old_element, new_element, elem_path)
        if entry_diff is not None:
            # Update the entry to include key leaf children
            for key in keys:
                entry_diff.children[key] = old_element.get_leaf(key)
            return entry_diff
        return None

    # Helper function for diffing system-ordered lists (order doesn't matter)
    def diff_system_ordered_list_elements(old_list: List, new_list: List) -> ?list[Node]:
        if old_list.keys != new_list.keys:
            raise ValueError("List keys differ at {_format_gdata_path(path)}: {str(old_list.keys)} != {str(new_list.keys)}")

        # Map elements by key for both lists
        old_map = {e.key_str(old_list.keys): e for e in old_list.elements}
        new_map = {e.key_str(new_list.keys): e for e in new_list.elements}

        result: list[Node] = []

        # Check all keys (union of both sets)
        all_keys = set(old_map.keys()) | set(new_map.keys())

        # Sort keys for consistent output
        for key in sorted(all_keys):
            if key in old_map and key in new_map:
                # Element exists in both - check for differences
                key_values = old_map[key].key_children(old_list.keys)
                elem_diff = diff_list_element(old_map[key], new_map[key], old_list.keys, path + [_PathElement(keys=key_values)])
                if elem_diff is not None:
                    result.append(elem_diff)
            elif key in old_map:
                # Element only in old - mark as absent
                oe = old_map[key]
                result.append(Absent(oe.key_children(old_list.keys)))
            else:
                # Element only in new - add it
                ne = new_map[key]
                result.append(ne)

        if len(result) == 0:
            return None
        return result

    # Helper function for diffing user-ordered lists (order matters)
    def diff_user_ordered_list_elements(old_list: List, new_list: List) -> ?list[Node]:

        if old_list.keys != new_list.keys:
            raise ValueError("List keys differ at {_format_gdata_path(path)}: {str(old_list.keys)} != {str(new_list.keys)}")

        # Map old elements by key
        old_map = {e.key_str(old_list.keys): e for e in old_list.elements}
        old_key_order = [e.key_str(old_list.keys) for e in old_list.elements]

        new_map = {e.key_str(new_list.keys): e for e in new_list.elements}
        new_key_order = [e.key_str(new_list.keys) for e in new_list.elements]

        # We'll do the two-pointer approach on these key orders
        i = 0
        j = 0
        result: list[Node] = []

        while i < len(old_key_order) and j < len(new_key_order):
            ok = old_key_order[i]
            nk = new_key_order[j]

            if ok == nk:
                # same element key
                key_values = old_map[ok].key_children(old_list.keys)
                elem_diff = diff_list_element(old_map[ok], new_map[nk], old_list.keys, path + [_PathElement(keys=key_values)])
                if elem_diff is not None:
                    result.append(elem_diff)
                i += 1
                j += 1
            else:
                ok_in_new = (ok in new_map)
                nk_in_old = (nk in old_map)

                if not ok_in_new:
                    # old element not in new => absent
                    oe = old_map[ok]
                    result.append(Absent(oe.key_children(old_list.keys)))
                    i += 1
                elif not nk_in_old:
                    # new element not in old => new element
                    # Insert the new element now
                    ne = new_map[nk]
                    result.append(ne)
                    j += 1
                else:
                    # Complex reordering scenario
                    raise ValueError("Complex reordering scenario encountered in list elements at {_format_gdata_path(path)}")

        # Remaining old elements are absent
        while i < len(old_key_order):
            ok = old_key_order[i]
            if ok not in new_map:
                oe = old_map[ok]
                result.append(Absent(oe.key_children(old_list.keys)))
            i += 1

        # Remaining new elements are new
        while j < len(new_key_order):
            nk = new_key_order[j]
            if nk not in old_map:
                ne = new_map[nk]
                result.append(ne)
            j += 1

        if len(result) == 0:
            return None
        return result

    # Diff logic for each node type

    if isinstance(old, Container) and isinstance(new, Container):
        diff_children = diff_keyed_children(old.children, new.children)
        if diff_children is None:
            return None
        return Container(children=diff_children, presence=new.presence, ns=new.ns, module=new.module)

    elif isinstance(old, List) and isinstance(new, List):
        if old.user_order != new.user_order:
            raise ValueError("Cannot diff lists with different ordering types at {_format_gdata_path(path)}")

        if old.user_order:
            result = diff_user_ordered_list_elements(old, new)
        else:
            result = diff_system_ordered_list_elements(old, new)
        if result is None:
            return None
        return List(new.keys, elements=result, user_order=new.user_order, ns=new.ns, module=new.module)

    elif isinstance(old, Leaf) and isinstance(new, Leaf):
        if old.t != new.t:
            raise ValueError("Leaf types differ at {_format_gdata_path(path)}: {old.t} != {new.t}")
        if vals_equal(old.val, new.val):
            return None
        else:
            return new

    elif isinstance(old, LeafList) and isinstance(new, LeafList):
        if vals_list_equal(old.vals, new.vals):
            return None
        return new

    elif isinstance(old, Absent) and isinstance(new, Absent):
        diff_children = diff_keyed_children(old.children, new.children)
        if diff_children is not None:
            # TODO: can't call key_str(list_keys) without our parent List node!?
            raise ValueError("Absent keys differ at {_format_gdata_path(path)}: {str(old.children)} != {str(new.children)}")
        return None

    else:
        raise ValueError("Unhandled node type in diff at {_format_gdata_path(path)}: {type(old)}")


def diff(old: ?Node, new: Node) -> ?Node:
    return _diff_rec(old, new, [])


# TODO: Can we make patch return a Node instead of ?Node?
def _patch_rec(old: Node, p: ?Node, path: list[_PathElement]) -> ?Node:
    if p is None:
        return old

    if isinstance(p, Absent):
        # Patch says remove this node
        if isinstance(old, Absent):
            # Both absent means node was removed
            if p.children != old.children:
                # TODO: can't call key_str(list_keys) without our parent List node!?
                raise ValueError("Absent keys differ in patch at {_format_gdata_path(path)}: {str(old.children)} != {str(p.children)}")
        return None

    elif isinstance(old, Container) and isinstance(p, Container):
        # Start with old children
        new_children: dict[str, Node] = {}
        for key in old.children:
            new_children[key] = old.children[key]

        # Apply patch changes
        for key in p.children:
            cpatch = p.children[key]
            if key in new_children:
                # Patch existing child
                res = _patch_rec(new_children[key], cpatch, path + [_PathElement(key)])
                if res is not None:
                    new_children[key] = res
                else:
                    del new_children[key]
            else:
                # Key not in old
                if isinstance(cpatch, Absent):
                    # Trying to remove something not in old -> ignore
                    pass
                else:
                    # New child
                    new_children[key] = cpatch

        # No need to remove unchanged nodes; they are already in new_children
        if len(new_children) == 0:
            return None
        return Container(children=new_children, presence=old.presence, ns=old.ns, module=old.module)

    elif isinstance(old, List) and isinstance(p, List):
        if old.keys != p.keys:
            raise ValueError("List keys differ at {_format_gdata_path(path)}: {str(old.keys)} != {str(p.keys)}")

        old_map = {e.key_str(old.keys): e for e in old.elements}

        # Apply patch elements
        patch_elems = p.elements
        for pelem in patch_elems:
            if isinstance(pelem, Absent):
                # Remove this element if it exists
                k = pelem.key_str(p.keys)
                if k in old_map:
                    del old_map[k]
            else:
                # pelem is a ListElement
                k = pelem.key_str(p.keys)
                if k in old_map:
                    # Patch existing element
                    key_values = old_map[k].key_children(old.keys)
                    res = _patch_rec(old_map[k], pelem, path + [_PathElement(keys=key_values)])
                    if res is not None and isinstance(res, Container):
                        old_map[k] = res
                    else:
                        # Remove the element
                        del old_map[k]
                else:
                    # New element
                    old_map[k] = pelem

        # Rebuild elements in final order
        # Start with old's original order for unchanged and patched elements
        final_key_order = []
        chosen = {}
        for e in old.elements:
            k = e.key_str(old.keys)
            if k in old_map:
                final_key_order.append(k)
                chosen[k] = True

        # Now check if patch introduced new elements not in old.
        # Add them in the order they appear in patch.
        for pelem in patch_elems:
            if isinstance(pelem, Absent):
                continue
            k = pelem.key_str(p.keys)
            if k in old_map and k not in chosen:
                final_key_order.append(k)
                chosen[k] = True

        new_elements: list[Node] = []
        for k in final_key_order:
            new_elements.append(old_map[k])

        if len(new_elements) == 0:
            return None
        return List(old.keys, elements=new_elements, user_order=old.user_order, ns=old.ns, module=old.module)

    elif isinstance(old, Leaf) and isinstance(p, Leaf):
        # Patch leaf replaces old leaf value
        if old.t != p.t:
            raise ValueError("Leaf types differ in patch at {_format_gdata_path(path)}: {old.t} != {p.t}")
        return p

    elif isinstance(old, LeafList) and isinstance(p, LeafList):
        # Patch leaf-list replaces old leaf-list values
        return p

    elif isinstance(old, Absent) and isinstance(p, Absent):
        # Both absent means node was removed
        return None

    else:
        if p is not None:
            raise ValueError("Unhandled node type in patch at {_format_gdata_path(path)}: {type(p)}")


def patch(old: Node, p: ?Node) -> ?Node:
    return _patch_rec(old, p, [])


class TreeProvider(object):
    rpc: proc(action(?Node, ?Exception) -> None, Node) -> None
    rpc_xml: proc(action(?xml.Node, ?Exception) -> None, xml.Node) -> None


def _node_match(n: xml.Node, name: str, ns: ?str) -> bool:
    """Check if an XML node matches the given name and namespace

    It will match either on the default (nameless) namespace, or the node prefix
    & a named namespace. For example:
    <foo xmlns="urn:foo"> and <ns:foo xmlns:ns="urn:foo"> both match with name="foo", ns="urn:foo"
    """
    if n.tag == name:
        if ns is not None:
            for nsdef in n.nsdefs:
                n0 = nsdef.0
                n1 = nsdef.1
                if n0 is not None and n0 == n.prefix and n1 == ns:
                    return True
                elif n0 is None and n1 == ns:
                    return True
        else:
            return True
    return False

def get_xml_child(n: xml.Node, name: str, ns: ?str) -> xml.Node:
    r = get_xml_opt_child(n, name, ns)
    if r is not None:
        return r
    raise ValueError("Cannot find xml child with name {name}")

def get_xml_opt_child(n: xml.Node, name: str, ns: ?str) -> ?xml.Node:
    for child in n.children:
        if _node_match(child, name, ns):
            return child
    return None

def get_xml_child_text(n: xml.Node, name: str) -> str:
    for child in n.children:
        if child.tag == name:
            childtext = child.text
            if childtext is not None:
                return childtext
            raise ValueError("Child text is None")
    raise ValueError("Cannot find xml child with name {name}")

def get_xml_children(n: xml.Node, name: str, ns: ?str) -> list[xml.Node]:
    res = []
    for child in n.children:
        if _node_match(child, name, ns):
            res.append(child)
    return res

def from_xml_opt_list(n: xml.Node, name: str, ns: ?str) -> ?list[xml.Node]:
    r = get_xml_children(n, name, ns)
    if len(r) == 0:
        return None
    return r

def from_xml_list(n: xml.Node, name: str, ns: ?str) -> list[xml.Node]:
    r = from_xml_opt_list(n, name, ns)
    if r is not None:
        return r
    raise ValueError("Cannot find xml child with name {name}")

def from_xml_opt_cnt(n: xml.Node, name: str, ns: ?str) -> ?xml.Node:
    return get_xml_opt_child(n, name, ns)

def from_xml_cnt(n: xml.Node, name: str, ns: ?str) -> xml.Node:
    return get_xml_child(n, name, ns)

def from_xml_opt_bool(n: xml.Node, name: str, ns: ?str) -> ?bool:
    try:
        text = get_xml_child(n, name, ns).text
        if text == "true":
            return True
        elif text == "false":
            return False
        elif text is not None:
            raise ValueError("Expected 'true' or 'false' for boolean type leaf, got '{text}'")
    except ValueError:
        return None

def from_xml_bool(n: xml.Node, name: str, ns: ?str) -> bool:
    r = from_xml_opt_bool(n, name, ns)
    if r is not None:
        return r
    raise ValueError("Cannot find xml child with name {name}")

def from_xml_opt_empty(n: xml.Node, name: str, ns: ?str) -> ?Present:
    try:
        text = get_xml_child(n, name, ns).text
    except ValueError:
        return None
    else:
        if text is None:
            return Present()
        raise ValueError("Expected no text for empty leaf {name}, got {str(text)}")

def from_xml_float(n: xml.Node, name: str, ns: ?str) -> float:
    text = get_xml_child(n, name, ns).text
    if text is not None:
        res = float(text)
        return res
    raise ValueError("Cannot find xml child with name {name}")
    return 13.37 # bah, get C error otherwise

def from_xml_opt_float(n: xml.Node, name: str, ns: ?str) -> ?float:
    try:
        text = get_xml_child(n, name, ns).text
        if text is not None:
            res = float(text)
            return res
    except ValueError:
        return None

def from_xml_opt_int(n: xml.Node, name: str, ns: ?str) -> ?int:
    try:
        text = get_xml_child(n, name, ns).text
        if text is not None:
            return int(text)
    except ValueError:
        return None

def from_xml_int(n: xml.Node, name: str, ns: ?str) -> int:
    r = from_xml_opt_int(n, name, ns)
    if r is not None:
        return r
    raise ValueError("Cannot find xml child with name {name}")

def from_xml_opt_str(n: xml.Node, name: str, ns: ?str) -> ?str:
    try:
        return get_xml_child(n, name, ns).text
    except ValueError:
        return None

def from_xml_str(n: xml.Node, name: str, ns: ?str) -> str:
    r = from_xml_opt_str(n, name, ns)
    if r is not None:
        return r
    raise ValueError("Cannot find xml child with name {name}")

def from_xml_opt_bytes(n: xml.Node, name: str, ns: ?str) -> ?bytes:
    try:
        text = get_xml_child(n, name, ns).text
        if text is not None:
            return base64.decode(text.encode())
    except ValueError:
        return None

def from_xml_bytes(n: xml.Node, name: str, ns: ?str) -> bytes:
    r = from_xml_opt_bytes(n, name, ns)
    if r is not None:
        return r
    raise ValueError("Cannot find xml child with name {name}")

def from_xml_opt_value(n: xml.Node, name: str, ns: ?str) -> ?value:
    try:
        t = get_xml_child(n, name, ns).text
        if isinstance(t, value):
            return t
    except ValueError:
        return None

def from_xml_value(n: xml.Node, name: str, ns: ?str) -> value:
    r = from_xml_opt_value(n, name, ns)
    if r is not None:
        return r
    raise ValueError("Cannot find xml child with name {name}")

def from_xml_opt_Identityref(n: xml.Node, name: str, ns: ?str) -> ?PartialIdentityref:
    try:
        c = get_xml_child(n, name, ns)
        t = c.text
        if t is not None:
            return Identityref.from_xml(t, c.nsdefs)
    except ValueError:
        return None

def from_xml_Identityref(n: xml.Node, name: str, ns: ?str) -> PartialIdentityref:
    r = from_xml_opt_Identityref(n, name, ns)
    if r is not None:
        return r
    raise ValueError("Cannot find xml child with name {name}")

# plural
def from_xml_opt_Identityrefs(n: xml.Node, name: str, ns: ?str) -> ?list[PartialIdentityref]:
    res = []
    for child in get_xml_children(n, name, ns):
        t = child.text
        if t is not None:
            res.append(Identityref.from_xml(t, child.nsdefs))
    if len(res) == 0:
        return None
    return res

def from_xml_Identityrefs(n: xml.Node, name: str, ns: ?str) -> list[PartialIdentityref]:
    r = from_xml_opt_Identityrefs(n, name, ns)
    if r is not None:
        return r
    raise ValueError("Cannot find xml child with name {name}")

# plural
def from_xml_strs(n: xml.Node, name: str, ns: ?str) -> list[str]:
    r = from_xml_opt_strs(n, name, ns)
    if r is not None:
        return r
    raise ValueError("Cannot find xml child with name {name}")

def from_xml_opt_strs(n: xml.Node, name: str, ns: ?str) -> ?list[str]:
    res = []
    for child in get_xml_children(n, name, ns):
        ctext = child.text
        if ctext is not None:
            res.append(ctext)
    if len(res) == 0:
        return None
    return res

def from_xml_bytess(n: xml.Node, name: str, ns: ?str) -> list[bytes]:
    r = from_xml_opt_bytess(n, name, ns)
    if r is not None:
        return r
    raise ValueError("Cannot find xml child with name {name}")

def from_xml_opt_bytess(n: xml.Node, name: str, ns: ?str) -> ?list[bytes]:
    res = []
    for child in get_xml_children(n, name, ns):
        ctext = child.text
        if ctext is not None:
            res.append(base64.decode(ctext.encode()))
    if len(res) == 0:
        return None
    return res

def from_xml_values(n: xml.Node, name: str, ns: ?str) -> list[value]:
    r = from_xml_opt_values(n, name, ns)
    if r is not None:
        return r
    raise ValueError("Cannot find xml child with name {name}")

def from_xml_opt_values(n: xml.Node, name: str, ns: ?str) -> ?list[value]:
    res = []
    for child in get_xml_children(n, name, ns):
        ctext = child.text
        if isinstance(ctext, value):
            res.append(ctext)
    if len(res) == 0:
        return None
    return res

def from_xml_ints(n: xml.Node, name: str, ns: ?str) -> list[int]:
    r = from_xml_opt_ints(n, name, ns)
    if r is not None:
        return r
    raise ValueError("Cannot find xml child with name {name}")

def from_xml_opt_ints(n: xml.Node, name: str, ns: ?str) -> ?list[int]:
    res = []
    for child in get_xml_children(n, name, ns):
        ctext = child.text
        if ctext is not None:
            res.append(int(ctext))
    if len(res) == 0:
        return None
    return res

def from_xml_floats(n: xml.Node, name: str, ns: ?str) -> list[float]:
    r = from_xml_opt_floats(n, name, ns)
    if r is not None:
        return r
    raise ValueError("Cannot find xml child with name {name}")

def from_xml_opt_floats(n: xml.Node, name: str, ns: ?str) -> ?list[float]:
    res = []
    for child in get_xml_children(n, name, ns):
        ctext = child.text
        if ctext is not None:
            res.append(float(ctext))
    if len(res) == 0:
        return None
    return res

def from_xml_bools(n: xml.Node, name: str, ns: ?str) -> list[bool]:
    r = from_xml_opt_bools(n, name, ns)
    if r is not None:
        return r
    raise ValueError("Cannot find xml child with name {name}")

def from_xml_opt_bools(n: xml.Node, name: str, ns: ?str) -> ?list[bool]:
    res = []
    for child in get_xml_children(n, name, ns):
        ctext = child.text
        if ctext == "true":
            res.append(True)
        elif ctext == "false":
            res.append(False)
        elif ctext is not None:
            raise ValueError("Expected 'true' or 'false' for boolean type leaf-list, got '{ctext}'")
    if len(res) == 0:
        return None
    return res

#def from_xml_opt_u16(n: xml.Node, name: str) -> ?u16:
#    try:
#        return u16(get_xml_child_text(n, name))
#    except ValueError:
#        return None
#
#def from_xml_u16(n: xml.Node, name: str) -> u16:
#    return u16(get_xml_child_text(n, name))

mut def maybe_add[T](target: dict[str, Node], key: str, taker: mut(T) -> Node, val: ?T) -> None:
    if val is not None:
        target[key] = taker(val)

def take_json_opt_value(jd: dict[str, ?value], name: str, module: ?str=None) -> ?value:
    full_name = "{module}:{name}" if module is not None else name
    return jd.get(full_name)

def take_json_value(jd: dict[str, ?value], name: str, module: ?str=None) -> value:
    val = take_json_opt_value(jd, name, module)
    if val is not None:
        return val
    raise ValueError("Cannot find json child with name {name}")

def take_json_opt_cnt(jd: dict[str, ?value], name: str, module: ?str=None) -> ?dict[str, ?value]:
    child = take_json_opt_value(jd, name, module)
    if child is not None:
        try:
            return unwrap_dict(child)
        except:
            raise ValueError("Expected a dictionary for {name}")
    return None

def take_json_cnt(jd: dict[str, ?value], name: str, module: ?str=None) -> dict[str, ?value]:
    val = take_json_opt_cnt(jd, name, module)
    if val is not None:
        return val
    raise ValueError("Cannot find json child with name {name}")

def take_json_opt_list(jd: dict[str, ?value], name: str, module: ?str=None) -> ?list[dict[str, ?value]]:
    child = take_json_opt_value(jd, name, module)
    if child is not None:
        try:
            return unwrap_list(child)
        except:
            raise ValueError("Expected a list for {name}")
    return None

def take_json_list(jd: dict[str, ?value], name: str, module: ?str=None) -> list[dict[str, ?value]]:
    val = take_json_opt_list(jd, name, module)
    if val is not None:
        return val
    raise ValueError("Cannot find json list with name {name}")

def take_json_opt_str(jd: dict[str, ?value], name: str, module: ?str=None) -> ?str:
    child = take_json_opt_value(jd, name, module)
    if child is not None:
        if isinstance(child, str):
            return child
        raise ValueError("Expected a string for {name}")
    return None

def take_json_str(jd: dict[str, ?value], name: str, module: ?str=None) -> str:
    val = take_json_opt_str(jd, name, module)
    if val is not None:
        return val
    raise ValueError("Cannot find json str child with name: {name}")

def take_json_opt_strs(jd: dict[str, ?value], name: str, module: ?str=None) -> ?list[str]:
    child = take_json_opt_value(jd, name, module)
    if child is not None:
        if isinstance(child, list):
            if len(child) == 0:
                return []
            elem = child[0]
            if isinstance(elem, str):
                return child
            raise ValueError("{name}is a list of wrong type, should be str, not {type(elem)}")
        raise ValueError(name + "is not a list of strings")
    return None

def take_json_strs(jd: dict[str, ?value], name: str, module: ?str=None) -> list[str]:
    val = take_json_opt_strs(jd, name, module)
    if val is not None:
        return val
    raise ValueError("Cannot find json str child with name {name}")

def take_json_opt_int(jd: dict[str, ?value], name: str, module: ?str=None) -> ?int:
    child = take_json_opt_value(jd, name, module)
    if child is not None:
        if isinstance(child, int):
            return child
        # TODO: strings are only allowed / mandated for 64-bit numbers!
        elif isinstance(child, str):
            return int(child)
        raise ValueError("Expected an int for {name}")
    return None

def take_json_int(jd: dict[str, ?value], name: str, module: ?str=None) -> int:
    val = take_json_opt_int(jd, name, module)
    if val is not None:
        return val
    raise ValueError("Cannot find json int child with name {name}")

def take_json_opt_ints(jd: dict[str, ?value], name: str, module: ?str=None) -> ?list[int]:
    child = take_json_opt_value(jd, name, module)
    if child is not None:
        if isinstance(child, list):
            if len(child) == 0:
                return []
            elem = child[0]
            int_vals = []
            for c in child:
                if isinstance(c, int):
                    int_vals.append(c)
                else:
                    raise ValueError("{name}is a list of wrong type, should be int, not {type(elem)}")
            return int_vals
        raise ValueError(name + "is not a list of ints")
    return None

def take_json_ints(jd: dict[str, ?value], name: str, module: ?str=None) -> list[int]:
    val = take_json_opt_ints(jd, name, module)
    if val is not None:
        return val
    raise ValueError("Cannot find json int child with name {name}")

def take_json_opt_int64(jd: dict[str, ?value], name: str, module: ?str=None) -> ?int:
    child = take_json_opt_value(jd, name, module)
    if child is not None:
        if isinstance(child, str):
            return int(child)
        raise ValueError("Expected a string for 64-bit number {name}")
    return None

def take_json_int64(jd: dict[str, ?value], name: str, module: ?str=None) -> int:
    val = take_json_opt_int64(jd, name, module)
    if val is not None:
        return val
    raise ValueError("Cannot find json int64 child with name {name}")

def take_json_opt_int64s(jd: dict[str, ?value], name: str, module: ?str=None) -> ?list[int]:
    child = take_json_opt_value(jd, name, module)
    if child is not None:
        if isinstance(child, list):
            if len(child) == 0:
                return []
            elem = child[0]
            int_vals = []
            for c in child:
                if isinstance(c, str):
                    int_vals.append(int(c))
                else:
                    raise ValueError("{name}is a list of wrong type, should be str, not {type(elem)}")
            return int_vals
        raise ValueError(name + "is not a list of 64-bit numbers")
    return None

def take_json_int64s(jd: dict[str, ?value], name: str, module: ?str=None) -> list[int]:
    val = take_json_opt_int64s(jd, name, module)
    if val is not None:
        return val
    raise ValueError("Cannot find json int64 child with name {name}")

def take_json_opt_float(jd: dict[str, ?value], name: str, module: ?str=None) -> ?float:
    child = take_json_opt_value(jd, name, module)
    if child is not None:
        if isinstance(child, float):
            return child

def take_json_float(jd: dict[str, ?value], name: str, module: ?str=None) -> float:
    val = take_json_opt_float(jd, name, module)
    if val is not None:
        return val
    raise ValueError("Cannot find json float child with name {name}")
    return 13.37 # bah, get C error otherwise

def take_json_opt_bool(jd: dict[str, ?value], name: str, module: ?str=None) -> ?bool:
    child = take_json_opt_value(jd, name, module)
    if child is not None:
        if isinstance(child, bool):
            return child
        raise ValueError("Expected a bool for {name}")
    return None

def take_json_bool(jd: dict[str, ?value], name: str, module: ?str=None) -> bool:
    val = take_json_opt_bool(jd, name, module)
    if val is not None:
        return val
    raise ValueError("Cannot find json child with name {name}")

def take_json_opt_empty(jd: dict[str, ?value], name: str, module: ?str=None) -> ?Present:
    child = take_json_opt_value(jd, name, module)
    if child is not None:
        if isinstance(child, list) and len(child) == 1:
            v = child[0]
            if v is None:
                return Present()
        raise ValueError("Expected a [null] for empty leaf {name}")
    return None

def take_json_opt_bytes(jd: dict[str, ?value], name: str, module: ?str=None) -> ?bytes:
    child = take_json_opt_value(jd, name, module)
    if child is not None:
        if isinstance(child, str):
            return base64.decode(child.encode())
        raise ValueError("Expected a base64 encoded str for {name}")
    return None

def take_json_bytes(jd: dict[str, ?value], name: str, module: ?str=None) -> bytes:
    val = take_json_opt_bytes(jd, name, module)
    if val is not None:
        return val
    raise ValueError("Cannot find json child with name {name}")

def take_json_opt_bytess(jd: dict[str, ?value], name: str, module: ?str=None) -> ?list[bytes]:
    child = take_json_opt_value(jd, name, module)
    if child is not None:
        if isinstance(child, list):
            if len(child) == 0:
                return []
            decoded = []
            for c in child:
                if isinstance(c, str):
                    decoded.append(base64.decode(c.encode()))
                else:
                    raise ValueError("{name}is a list of wrong type, should be base64 encoded strings, not {type(c)}")
            return decoded
        raise ValueError(name + "is not a list of bytes")
    return None

def take_json_bytess(jd: dict[str, ?value], name: str, module: ?str=None) -> list[bytes]:
    val = take_json_opt_bytess(jd, name, module)
    if val is not None:
        return val
    raise ValueError("Cannot find json child with name {name}")

def take_json_opt_floats(jd: dict[str, ?value], name: str, module: ?str=None) -> ?list[float]:
    child = take_json_opt_value(jd, name, module)
    if child is not None:
        if isinstance(child, list):
            if len(child) == 0:
                return []
            float_vals = []
            for c in child:
                if isinstance(c, float):
                    float_vals.append(c)
                else:
                    raise ValueError("{name}is a list of wrong type, should be float, not {type(c)}")
            return float_vals
        raise ValueError(name + "is not a list of floats")
    return None

def take_json_floats(jd: dict[str, ?value], name: str, module: ?str=None) -> list[float]:
    val = take_json_opt_floats(jd, name, module)
    if val is not None:
        return val
    raise ValueError("Cannot find json float child with name {name}")

def take_json_opt_bools(jd: dict[str, ?value], name: str, module: ?str=None) -> ?list[bool]:
    child = take_json_opt_value(jd, name, module)
    if child is not None:
        if isinstance(child, list):
            if len(child) == 0:
                return []
            bool_vals = []
            for c in child:
                if isinstance(c, bool):
                    bool_vals.append(c)
                else:
                    raise ValueError("{name}is a list of wrong type, should be bool, not {type(c)}")
            return bool_vals
        raise ValueError(name + "is not a list of bools")
    return None

def take_json_bools(jd: dict[str, ?value], name: str, module: ?str=None) -> list[bool]:
    val = take_json_opt_bools(jd, name, module)
    if val is not None:
        return val
    raise ValueError("Cannot find json bool child with name {name}")

def take_json_opt_values(jd: dict[str, ?value], name: str, module: ?str=None) -> ?list[value]:
    child = take_json_opt_value(jd, name, module)
    if child is not None:
        if isinstance(child, list):
            if len(child) == 0:
                return []
            values = []
            for c in child:
                if isinstance(c, value):
                    values.append(c)
            return values
        raise ValueError(name + "is not a list of values")
    return None

def take_json_values(jd: dict[str, ?value], name: str, module: ?str=None) -> list[value]:
    val = take_json_opt_values(jd, name, module)
    if val is not None:
        return val
    raise ValueError("Cannot find json value child with name {name}")

def take_json_opt_Identityref(jd: dict[str, ?value], name: str, module: ?str=None) -> ?PartialIdentityref:
    child = take_json_opt_value(jd, name, module)
    if child is not None:
        if isinstance(child, str):
            return Identityref.from_json(child)
        raise ValueError("Expected a string for identityref {name}")
    return None

def take_json_Identityref(jd: dict[str, ?value], name: str, module: ?str=None) -> PartialIdentityref:
    val = take_json_opt_Identityref(jd, name, module)
    if val is not None:
        return val
    raise ValueError("Cannot find json identityref child with name {name}")

def take_json_opt_Identityrefs(jd: dict[str, ?value], name: str, module: ?str=None) -> ?list[PartialIdentityref]:
    child = take_json_opt_value(jd, name, module)
    if child is not None:
        if isinstance(child, list):
            if len(child) == 0:
                return []
            result = []
            for c in child:
                if isinstance(c, str):
                    result.append(Identityref.from_json(c))
                else:
                    raise ValueError("{name} is a list of wrong type, should be str for identityref, not {type(c)}")
            return result
        raise ValueError(name + " is not a list of identityrefs")
    return None

def take_json_Identityrefs(jd: dict[str, ?value], name: str, module: ?str=None) -> list[PartialIdentityref]:
    val = take_json_opt_Identityrefs(jd, name, module)
    if val is not None:
        return val
    raise ValueError("Cannot find json identityrefs child with name {name}")

# --
def unwrap_dict(jd: value) -> dict[str, value]:
    """Unwrap an unknown JSON data structure to a dict or throw an error
    """
    if isinstance(jd, dict):
        if len(jd) == 0:
            res: dict[str, value] = {}
            return res
        key = next(jd.keys())
        if isinstance(key, str):
            return jd
    raise ValueError("Expected a dictionary with str keys")

def unwrap_list(jd: value) -> list[dict[str, value]]:
    """Unwrap an unknown JSON data structure to a list of dicts or throw an error
    """
    if isinstance(jd, list):
        if len(jd) == 0:
            res: list[dict[str, value]] = []
            return res
        elem = jd[0]
        if isinstance(elem, dict):
            key = next(elem.keys())
            if isinstance(key, str):
                return jd
    raise ValueError("Expected a list of dicts, got something else")


def _test_format_gdata_path():
    path = [
        _PathElement("config"),
        _PathElement("interfaces"),
        _PathElement(keys={"name": Leaf("str", "eth0"), "vlan": Leaf("int", 100)}),
        _PathElement("ipv4"),
        _PathElement(keys={"ip": Leaf("str", "10.0.0.1"), "prefix": Leaf("int", 24)})
    ]
    testing.assertEqual("/config/interfaces[name='eth0',vlan=100]/ipv4[ip='10.0.0.1',prefix=24]", _format_gdata_path(path))


def _test_merge1():
    y1 = Container({
        "a": Leaf("int", 1),
        "l1": List(["name"], [
            Container({
                "name": Leaf("str", "k1"),
                "n1": Leaf("int", 1),
                "n2": Leaf("int", 2)
            }),
            Container({
                "name": Leaf("str", "k4"),
                "n4": Leaf("int", 4),
            }),
        ])
    }, ns="http://example.com/acme", module="acme")

    y2 = Container({
        "b": Leaf("int", 2),
        "c": Leaf("int", 3),
        "l1": List(["name"], [
            Container({
                "name": Leaf("str", "k2"),
                "n1": Leaf("int", 1),
                "n3": Leaf("int", 3)
            }),
        ]),
        "d": LeafList("str", ["a", "b", "c"])
    }, ns="http://example.com/acme", module="acme")

    res = merge(y1, y2)

    exp = Container({
        "a": Leaf("int", 1),
        "b": Leaf("int", 2),
        "c": Leaf("int", 3),
        "l1": List(["name"], [
            Container({
                "name": Leaf("str", "k1"),
                "n1": Leaf("int", 1),
                "n2": Leaf("int", 2)
            }),
            Container({
                "name": Leaf("str", "k2"),
                "n1": Leaf("int", 1),
                "n3": Leaf("int", 3)
            }),
            Container({
                "name": Leaf("str", "k4"),
                "n4": Leaf("int", 4),
            }),
        ]),
        "d": LeafList("str", ["a", "b", "c"])
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(res.prsrc(deterministic=True), exp.prsrc(deterministic=True))

def _test_merge_list1():
    y1 = List(["name"], [
        Container({
            "name": Leaf("str", "first"),
            "n1": Leaf("int", 1)
        }),
        Container({
            "name": Leaf("str", "breaker"),
            "n1": Leaf("int", 1)
        }),
        Container({
            "name": Leaf("str", "fourth"),
            "n1": Leaf("int", 1)
        }),
        Container({
            "name": Leaf("str", "common"),
            "n2": Leaf("int", 2)
        }),
        Container({
            "name": Leaf("str", "last"),
            "n1": Leaf("int", 1)
        }),
    ], user_order=True, ns="http://example.com/acme", module="acme")

    y2 = List(["name"], [
        Container({
            "name": Leaf("str", "breaker")
        }),
        Container({
            "name": Leaf("str", "second"),
            "n1": Leaf("int", 1)
        }),
        Container({
            "name": Leaf("str", "third"),
            "n1": Leaf("int", 1)
        }),
        Container({
            "name": Leaf("str", "common"),
            "n1": Leaf("int", 1)
        }),
        Container({
            "name": Leaf("str", "last")
        })
    ], user_order=True, ns="http://example.com/acme", module="acme")

    exp = List(["name"], [
        Container({
            "name": Leaf("str", "first"),
            "n1": Leaf("int", 1)
        }),
        Container({
            "name": Leaf("str", "breaker"),
            "n1": Leaf("int", 1)
        }),
        Container({
            "name": Leaf("str", "fourth"),
            "n1": Leaf("int", 1)
        }),
        Container({
            "name": Leaf("str", "common"),
            "n2": Leaf("int", 2),
            "n1": Leaf("int", 1)
        }),
        Container({
            "name": Leaf("str", "last"),
            "n1": Leaf("int", 1)
        }),
        Container({
            "name": Leaf("str", "second"),
            "n1": Leaf("int", 1)
        }),
        Container({
            "name": Leaf("str", "third"),
            "n1": Leaf("int", 1)
        }),
    ], user_order=True, ns="http://example.com/acme", module="acme")

    testing.assertEqual(exp, merge(y1, y2))

def _test_merge_leaf_conflict():
    y1 = Container({
        "a": Leaf("int", 1)
    })
    y2 = Container({
        "a": Leaf("int", 2)
    })

    try:
        merge(y1, y2)
        testing.assertFalse(True, "Expected ValueError but merge succeeded")
    except ValueError as e:
        testing.assertEqual("Cannot merge leaves with different values at /a: 1 != 2", e.error_message)

def _test_eq_list():
    l1 = List(["name"], [
        Container({
            "name": Leaf("str", "a"),
            "x": Leaf("int", 1)
        }),
        Container({
            "name": Leaf("str", "b"),
            "x": Leaf("int", 2)
        })
    ])
    l2 = List(["name"], [
        Container({
            "name": Leaf("str", "b"),
            "x": Leaf("int", 2)
        }),
        Container({
            "name": Leaf("str", "a"),
            "x": Leaf("int", 1)
        })
    ])
    testing.assertEqual(l1, l1)
    testing.assertEqual(l1, l2)

def _test_eq_list_user_order():
    l1 = List(["name"], user_order=True, elements=[
        Container({
            "x": Leaf("int", 1)
        }),
        Container({
            "x": Leaf("int", 2)
        })
    ])
    l2 = List(["name"], user_order=True, elements=[
        Container({
            "x": Leaf("int", 2)
        }),
        Container({
            "x": Leaf("int", 1)
        })
    ])
    testing.assertEqual(l1, l1)
    testing.assertNotEqual(l1, l2)

def _test_vals_list_sorted():
    l1 = LeafList("str", ["a", "b", "c"])
    l2 = LeafList("str", ["c", "b", "a"])
    testing.assertEqual(l1.prsrc(deterministic=True), l1.prsrc(deterministic=True))
    testing.assertEqual(l1.prsrc(deterministic=True), l2.prsrc(deterministic=True))

def _test_eq_leaf_list_user_order():
    l1 = LeafList("str", ["a", "b", "c"], user_order=True)
    l2 = LeafList("str", ["c", "b", "a"], user_order=True)
    testing.assertEqual(l1, l1)
    testing.assertNotEqual(l1, l2)

def _test_diff_no_change():
    """In this test, old and new are identical. We expect diff to return None
    since there are no differences.
    """
    old = Container({
        "a": Leaf("int", 1),
        "b": Leaf("int", 2)
    }, ns="http://example.com/acme", module="acme")

    new = Container({
        "a": Leaf("int", 1),
        "b": Leaf("int", 2)
    }, ns="http://example.com/acme", module="acme")

    d = diff(old, new)
    testing.assertEqual(d, None)

def _test_diff_leaf_change():
    """Only one leaf changes its value. We expect diff to return a container
    with just that leaf changed.
    """
    old = Container({
        "a": Leaf("int", 1),
        "b": Leaf("int", 2)
    }, ns="http://example.com/acme", module="acme")

    new = Container({
        "a": Leaf("int", 42), # Changed from 1 to 42
        "b": Leaf("int", 2)
    }, ns="http://example.com/acme", module="acme")

    d = diff(old, new)

    exp = Container({
        "a": Leaf("int", 42)
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(d, exp)

def _test_diff_node_removal():
    """A node c is removed from old to new. We expect an Absent() node in the
    diff at the place where c was.
    """
    old = Container({
        "a": Leaf("int", 1),
        "c": Leaf("int", 3),
        "d": Leaf("int", 4)
    }, ns="http://example.com/acme", module="acme")

    new = Container({
        "a": Leaf("int", 1),
        "d": Leaf("int", 4)
    }, ns="http://example.com/acme", module="acme")

    d = diff(old, new)

    # c is removed
    exp = Container({
        "c": Absent({
            "c": Leaf("int", 3)
        })
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(d, exp)

def _test_diff_list_removal():
    """The entire list (all entries) is removed."""
    old = Container({
        "l": List(["name"], [
        Container({
            "name": Leaf("str", "k1"),
            "n1": Leaf("int", 1),
            "n2": Leaf("int", 2),
        }),
        Container({
            "name": Leaf("str", "k4"),
            "n4": Leaf("int", 4),
        }),
    ], ns="http://example.com/acme", module="acme")
    })

    new = Container()

    d = diff(old, new)

    # Entire list is removed
    exp = Container({
        "l": Absent({
            "l": List(["name"], [
                Container({
                    "name": Leaf("str", "k1"),
                    "n1": Leaf("int", 1),
                    "n2": Leaf("int", 2),
                }),
                Container({
                    "name": Leaf("str", "k4"),
                    "n4": Leaf("int", 4),
                }),
            ], ns="http://example.com/acme", module="acme")
        }, ns="http://example.com/acme", module="acme")
    })

    if d is not None:
        testing.assertEqual(d.prsrc(), exp.prsrc())
    testing.assertEqual(d, exp)

def _test_diff_elem_removal():
    """A list element k1 is removed from old to new. We expect an Absent("k1")
    node in the diff at the place where k1 was.
    """
    old = List(["name"], [
        Container({
            "name": Leaf("str", "k1"),
            "n1": Leaf("int", 1),
            "n2": Leaf("int", 2),
        }),
        Container({
            "name": Leaf("str", "k4"),
            "n4": Leaf("int", 4),
        }),
    ], ns="http://example.com/acme", module="acme")

    new = List(["name"], [
        Container({
            "name": Leaf("str", "k4"),
            "n4": Leaf("int", 4),
        }),
    ], ns="http://example.com/acme", module="acme")

    d = diff(old, new)

    # k1 is removed
    exp = List(["name"], [
        Absent({
            "name": Leaf("str", "k1")
        })
    ], ns="http://example.com/acme", module="acme")

    testing.assertEqual(d, exp)

def _test_diff_node_addition():
    """A new node e is added in new. We expect the diff to have that new node.
    """
    old = Container({
        "a": Leaf("int", 1)
    }, ns="http://example.com/acme", module="acme")

    new = Container({
        "a": Leaf("int", 1),
        "e": Leaf("int", 5)
    }, ns="http://example.com/acme", module="acme")

    d = diff(old, new)

    # e is new
    exp = Container({
        "e": Leaf("int", 5)
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(d, exp)

def _test_diff_leaflist():
    """Testing differences in a leaf-list. One value changes and one is
    added.
    """
    old = Container({
        "l": LeafList("str", ["a", "b", "c"])
    }, ns="http://example.com/acme", module="acme")

    new = Container({
        "l": LeafList("str", ["a", "x", "c", "d"]) # "b" changed to "x" and "d" added
    }, ns="http://example.com/acme", module="acme")

    d = diff(old, new)

    exp = Container({
        "l": LeafList("str", ["a", "x", "c", "d"])
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(d, exp)

def _test_diff_complex_ordering():
    """A more complex scenario where the old container has nodes [a, b, c] and
    the new container has [a, c, d]. We expect the absent node b to appear
    before the new node d in the diff.
    """
    old = Container({
        "a": Leaf("int", 1),
        "b": Leaf("int", 2),
        "c": Leaf("int", 3)
    }, ns="http://example.com/acme", module="acme")

    new = Container({
        "a": Leaf("int", 1),
        "c": Leaf("int", 3),
        "d": Leaf("int", 4)
    }, ns="http://example.com/acme", module="acme")

    d = diff(old, new)

    # "b" is absent before "d" is introduced
    exp = Container({
        "b": Absent({
            "b": Leaf("int", 2)
        }),
        "d": Leaf("int", 4)
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(d, exp)

def _test_patch_no_change():
    old = Container({
        "a": Leaf("int", 1),
        "b": Leaf("int", 2),
    }, ns="http://example.com/acme", module="acme")

    # diff is None means no changes
    p = None

    res = patch(old, p)
    testing.assertEqual(res, old)

def _test_patch_leaf_change():
    old = Container({
        "a": Leaf("int", 1),
        "b": Leaf("int", 2),
    }, ns="http://example.com/acme", module="acme")

    # Suppose we want to change leaf 'a' from 1 to 42
    # diff would look like this:
    p = Container({
        "a": Leaf("int", 42),
    }, ns="http://example.com/acme", module="acme")

    res = patch(old, p)
    exp = Container({
        "a": Leaf("int", 42),
        "b": Leaf("int", 2),
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(res, exp)

def _test_patch_node_removal():
    old = Container({
        "a": Leaf("int", 1),
        "c": Leaf("int", 3),
    }, ns="http://example.com/acme", module="acme")

    # Suppose we remove 'c'
    # patch would be:
    p = Container({
        "c": Absent()
    }, ns="http://example.com/acme", module="acme")

    res = patch(old, p)
    exp = Container({
        "a": Leaf("int", 1),
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(res, exp)

def _test_patch_elem_removal():
    old = List(["name"], [
        Container({
            "name": Leaf("str", "k1"),
            "n1": Leaf("int", 1),
            "n2": Leaf("int", 2)
        }),
        Container({
            "name": Leaf("str", "k4"),
            "n4": Leaf("int", 4),
        }),
    ], ns="http://example.com/acme", module="acme")

    # Suppose we remove 'k1'
    # patch would be:
    p = List(["name"], [
        Absent({
            "name": Leaf("str", "k1")
        })
    ], ns="http://example.com/acme", module="acme")

    res = patch(old, p)
    exp = List(["name"], [
        Container({
            "name": Leaf("str", "k4"),
            "n4": Leaf("int", 4),
        }),
    ], ns="http://example.com/acme", module="acme")

    testing.assertEqual(res, exp)

def _test_patch_elem_removal2():
    old = Container({
        "n1": Leaf("int", 1),
        "n2": Leaf("int", 2)
    })

    p = Absent({
        "name": Leaf("str", "k1")
    })

    res = patch(old, p)

    testing.assertEqual(res, None)

def _test_patch_node_addition():
    old = Container({
        "a": Leaf("int", 1),
    }, ns="http://example.com/acme", module="acme")

    # Add a new leaf 'e':
    p = Container({
        "e": Leaf("int", 5)
    }, ns="http://example.com/acme", module="acme")

    res = patch(old, p)
    exp = Container({
        "a": Leaf("int", 1),
        "e": Leaf("int", 5),
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(res, exp)

def _test_patch_complex_ordering():
    # old: a, b, c
    old = Container({
        "a": Leaf("int", 1),
        "b": Leaf("int", 2),
        "c": Leaf("int", 3),
    }, ns="http://example.com/acme", module="acme")

    # new: a, c, d
    # diff: remove b, add d
    p = Container({
        "b": Absent(),
        "d": Leaf("int", 4)
    }, ns="http://example.com/acme", module="acme")

    res = patch(old, p)
    exp = Container({
        "a": Leaf("int", 1),
        "c": Leaf("int", 3),
        "d": Leaf("int", 4),
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(res, exp)

def _test_patch_leaflist():
    old = Container({
        "l": LeafList("str", ["a", "b", "c"])
    }, ns="http://example.com/acme", module="acme")

    # new: l = [a, x, c, d]
    # diff would be a leaflist replace:
    p = Container({
        "l": LeafList("str", ["a", "x", "c", "d"])
    }, ns="http://example.com/acme", module="acme")

    res = patch(old, p)
    exp = Container({
        "l": LeafList("str", ["a", "x", "c", "d"])
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(res, exp)

def _test_diff_system_ordered_list_no_diff():
    """Test that diff returns None for reordered elements in system-ordered lists.

    System-ordered lists (user_order=False, which is the default) should not care about
    element ordering. The system is free to reorder elements, so reordering should not
    generate any diff. The diff should be None when comparing two system-ordered lists
    with the same elements in different order.
    """
    elem1 = Container({
        "id": Leaf("string", "1"),
        "name": Leaf("string", "first")
    })
    elem2 = Container({
        "id": Leaf("string", "2"),
        "name": Leaf("string", "second")
    })
    elem3 = Container({
        "id": Leaf("string", "3"),
        "name": Leaf("string", "third")
    })

    old_list = List(
        keys=["id"],
        elements=[elem1, elem2, elem3],
        user_order=False
    )

    new_list = List(
        keys=["id"],
        elements=[elem2, elem1, elem3],
        user_order=False
    )

    result = diff(old_list, new_list)
    testing.assertNone(result, "System-ordered list reordering should not generate a diff")

def _test_diff_and_patch_large_tree():
    # Construct a large 'old' data tree under a Container node
    old = Container({
        "mod1": Container(children={
            "conf": Container(children={
                "settings": Container({
                    "hostname": Leaf("str", "old-router"),
                    "motd": Leaf("str", "Welcome!")
                }),
                "interfaces": List(["name"], elements=[
                    Container({
                        "name": Leaf("str", "eth0"),
                        "desc": Leaf("str", "Uplink interface"),
                        "enabled": Leaf("bool", True)
                    }),
                    Container({
                        "name": Leaf("str", "eth1"),
                        "desc": Leaf("str", "Internal interface"),
                        "enabled": Leaf("bool", True)
                    }),
                ])
            }, ns="http://example.com/yang/mod1", module="mod1")
        }),
        "mod2": Container(children={
            "acl": Container(children={
                "rules": List(["id"], elements=[
                    Container({
                        "id": Leaf("int", 10),
                        "action": Leaf("str", "permit"),
                        "src": Leaf("str", "10.0.0.0/24"),
                        "dst": Leaf("str", "10.0.1.0/24"),
                    }),
                    Container({
                        "id": Leaf("int", 20),
                        "action": Leaf("str", "deny"),
                        "src": Leaf("str", "any"),
                        "dst": Leaf("str", "any"),
                    }),
                ])
            }, ns="http://example.com/yang/mod2", module="mod2")
        }),
    })

    # Construct a large 'new' data tree under a Container node
    # Changes from old:
    # - hostname changed from "old-router" to "new-router"
    # - motd removed
    # - eth1 is removed
    # - a new interface eth2 is added
    # - mod2 acl rule 20 changes action from deny to drop
    # - a new acl rule 30 is added
    # - add a LeafList in settings "ntp-servers"
    new = Container(children={
        "mod1": Container(children={
            "conf": Container(children={
                "settings": Container(children={
                    "hostname": Leaf("str", "new-router"),
                    # motd removed
                    "ntp-servers": LeafList("str", ["192.168.100.1", "192.168.100.2"])
                }),
                "interfaces": List(["name"], elements=[
                    Container({
                        "name": Leaf("str", "eth0"),
                        "desc": Leaf("str", "Uplink interface"),
                        "enabled": Leaf("bool", True)
                    }),
                    # eth1 removed
                    Container({
                        "name": Leaf("str", "eth2"),
                        "desc": Leaf("str", "DMZ interface"),
                        "enabled": Leaf("bool", False)
                    }),
                ])
            }, ns="http://example.com/yang/mod1", module="mod1")
        }),
        "mod2": Container(children={
            "acl": Container(children={
                "rules": List(["id"], elements=[
                    Container({
                        "id": Leaf("int", 10),
                        "action": Leaf("str", "permit"),
                        "src": Leaf("str", "10.0.0.0/24"),
                        "dst": Leaf("str", "10.0.1.0/24"),
                    }),
                    Container({
                        "id": Leaf("int", 20),
                        "action": Leaf("str", "drop"),  # changed from deny
                        "src": Leaf("str", "any"),
                        "dst": Leaf("str", "any"),
                    }),
                    Container({
                        "id": Leaf("int", 30),
                        "action": Leaf("str", "permit"),
                        "src": Leaf("str", "192.0.2.0/24"),
                        "dst": Leaf("str", "198.51.100.0/24"),
                    }),
                ])
            }, ns="http://example.com/yang/mod2", module="mod2")
        })
    })

    # Compute diff
    print("Old: ", old.prsrc())
    d = diff(old, new)
    if d is not None:
        print("Diff result: ", d.prsrc())
    else:
        print("Diff result: None")

    # Check that patching old with d results in new
    res = patch(old, d)
    if res is not None:
        testing.assertEqual(res.prsrc(deterministic=True), new.prsrc(deterministic=True))

    # Also check that if we apply diff(new, old), and patch(new, diff(new, old)) we get old back.
    # This ensures round-trip behavior.
    #d2 = diff(new, old)
    #res2 = patch(new, d2)
    #testing.assertEqual(res2, old)

def _test_prsrc():
    y1 = Container({
        "foo": Container({
            "a": Leaf("int", 1),
            "l1": List(["name"], [
                Container({
                    "name": Leaf("str", "k1"),
                    "n1": Leaf("int", 1),
                    "n2": Leaf("int", 2)
                }),
                Container({
                    "name": Leaf("str", "k4"),
                    "n4": Leaf("int", 4),
                }),
            ])
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.prsrc()

def _test_prsrc_absent():
    y1 = Container({
        "foo": Container({
            "a": Absent(),
            "l1": List(["name"], [
                Absent({
                    "name": Leaf("str", "k1")
                }),
                Container({
                    "name": Leaf("str", "k4"),
                    "n4": Leaf("int", 4),
                }),
            ])
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.prsrc()

def _test_prsrc_root():
    y1 = Container({
        "foo": Container({
            "a": Leaf("int", 1),
            "b": LeafList("str", ["a", "b", "c"]),
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.prsrc()

def _test_prsrc_leaf_ns():
    y1 = Container({
        "foo": Container({
            "a": Leaf("int", 1, ns="http://example.com/foo", module="foo"),
            "b": Leaf("int", 2)
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.prsrc()

def _test_prsrc_identityref():
    y1 = Container({
        "identity-local": Leaf("identityref", Identityref("foo", "http://example.com/acme", "acme", "acme")),
        "identity-other": Leaf("identityref", Identityref("bar", "http://example.com/bar", "bar", "bar")),
        "augmented-identity-other": Leaf("identityref", Identityref("bar", "http://example.com/bar", "bar", "bar"), "http://example.com/augmentor", "augmentor"),
    }, ns="http://example.com/acme", module="acme")

    return y1.prsrc()

def _test_to_json():
    y1 = Container({
        "acme:foo": Container({
            "a": Leaf("int", 1),
            "l1": List(["name", "name_two"], [
                Container({
                    "name": Leaf("str", "k1"),
                    "name_two": Leaf("str", "k1a"),
                    "n1": Leaf("int", 1),
                    "n2": Leaf("int", 2)
                }),
                Container({
                    "name": Leaf("str", "k4"),
                    "name_two": Leaf("str", "k4a"),
                    "n4": Leaf("int", 4),
                }),
            ]),
            "b": Leaf("bool", False),
            "lb": Leaf("binary", b"Hello Acton \xf0\x9f\xab\xa1"),
            "llb": LeafList("binary", [b"Hello Acton \xf0\x9f\xab\xa1"]),
            "c": Leaf("uint64", 18446744073709551615),
        }, ns="http://example.com/acme", module="acme"),
        "beep:foo": Container({
            "a": Leaf("int", 1)
        }, ns="http://example.com/beep", module="beep")
    })

    return y1.to_json(pretty=True)

def _test_to_json_empty_leaf():
    y1 = Container({
        "e1": Leaf("empty", Present()),
        "e2": Leaf("empty", Present(False))
    })

    return y1.to_json(pretty=True)

def _test_to_json_identityref():
    y1 = Container({
        "identity-local": Leaf("identityref", Identityref("foo", "http://example.com/acme", "acme", "acme")),
        "identity-other": Leaf("identityref", Identityref("bar", "http://example.com/bar", "bar", "bar")),
        "augmented-identity-other": Leaf("identityref", Identityref("bar", "http://example.com/bar", "bar", "bar"), "http://example.com/augmentor", "augmentor"),
    }, ns="http://example.com/acme", module="acme")

    return y1.to_json(pretty=True)

def _test_to_xmlstr():
    y1 = Container({
        "acme:foo": Container({
            "a": Leaf("int", 1),
            "l1": List(["name", "name_two"], [
                Container({
                    "name": Leaf("str", "k1"),
                    "name_two": Leaf("str", "k1a"),
                    "n1": Leaf("int", 1),
                    "n2": Leaf("int", 2)
                }),
                Container({
                    "name": Leaf("str", "k4"),
                    "name_two": Leaf("str", "k4a"),
                    "n4": Leaf("int", 4),
                }),
            ]),
            "b": Leaf("bool", False),
            "lb": Leaf("binary", b"Hello Acton \xf0\x9f\xab\xa1"),
            "llb": LeafList("binary", [b"Hello Acton \xf0\x9f\xab\xa1"]),
            "c": Leaf("uint64", 18446744073709551615),
        }, ns="http://example.com/acme", module="acme"),
        "beep:foo": Container({
            "a": Leaf("int", 1)
        }, ns="http://example.com/beep", module="beep")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_root():
    y1 = Container({
        "foo": Container({
            "a": Leaf("int", 1),
            "b": LeafList("binary", ["a", "b", "c"]),
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_module():
    y1 = Container({
        "foo": Container({
            "a": Leaf("int", 1),
            "b": LeafList("str", ["a", "b", "c"]),
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_leaf_ns():
    y1 = Container({
        "foo": Container({
            "a": Leaf("int", 1, ns="http://example.com/foo", module="foo"),
            "b": Leaf("int", 2)
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_mixed():
    y1 = Container({
        "device": List(["name"], [
            Container({
                "name": Leaf("str", "dev1"),
                "config": Container({
                    "hostname": Container({
                        "system-network-name": Leaf("str", "dev1")
                    }, ns="http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg")
                }),
            }),
            Container({
                "name": Leaf("str", "dev2"),
                "config": Container({
                    "hostname": Container({
                        "system-network-name": Leaf("str", "dev2")
                    }, ns="http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg")
                }),
            }),
        ], ns="http://orchestron.org/yang/orchestron-device.yang")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_root_merge():
    y1 = Container({
        "foo": Container({
            "a": Leaf("int", 1),
            "b": LeafList("str", ["a", "b", "c"]),
        }, ns="http://example.com/acme", module="acme")
    })
    y2 = Container({
        "bar": Container({
            "b": Leaf("int", 42),
        }, ns="http://example.com/bar", module="bar")
    })
    ym = merge(y1, y2)

    return ym.to_xmlstr()

def _test_to_xmlstr_presence():
    y1 = Container({
        "foo": Container({
            "a": Leaf("int", 1)
        }, presence=True, ns="http://example.com/acme", module="acme")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_presence_childless():
    y1 = Container({
        "foo": Container(presence=True, ns="http://example.com/acme", module="acme")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_empty_leaf():
    y1 = Container({
        "e1": Leaf("empty", Present()),
        "e2": Leaf("empty", Present(False))
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_identityref():
    y1 = Container({
        "identity-local": Leaf("identityref", Identityref("foo", "http://example.com/acme", "acme", "acme")),
        "identity-other": Leaf("identityref", Identityref("bar", "http://example.com/bar", "bar", "bar")),
        "augmented-identity-other": Leaf("identityref", Identityref("bar", "http://example.com/bar", "bar", "bar"), "http://example.com/augmentor", "augmentor"),
    }, ns="http://example.com/acme", module="acme")

    return y1.to_xmlstr()

def _test_to_xmlstr_list_removal():
    y1 = Container({
        "l": Absent({
            "l": List(["name"], [
                Container({
                    "name": Leaf("str", "k1"),
                    "n1": Leaf("int", 1),
                    "n2": Leaf("int", 2),
                }),
                Container({
                    "name": Leaf("str", "k4"),
                    "n4": Leaf("int", 4),
                }),
            ], ns="http://example.com/acme", module="acme")
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.to_xmlstr()
