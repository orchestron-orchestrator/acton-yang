import base64
import testing
import json
import xml

"""YANG data

This module defines classes for YANG data nodes. It can represent a YANG data
tree, and can be used to serialize and deserialize YANG data.
"""

# kinds of things?
# - container
# - list
# - list element
# - leaf
# - leaf-list
#
# TODO: for ordered-by user lists, we need to expose a way to influence the order of elements

# Can we simply use the order of elements in the input list to control the order in the output?
#
# ACL1 which allows SSH and rejects everything else
# <acls>
#   <acl>
#     <aces>
#       <ace>
#         <name>SSH</name>
#         <action>permit</action>
#         <matches>
#           <ipv4>
#             <source-ipv4-network>192.0.2.0/24</source-ipv4-network>
#           </ipv4>
#           <protocol>tcp</protocol>
#           <tcp>
#             <destination-port>
#               <operator>eq</operator>
#               <port>22</port>
#             </destionation-port>
#           </tcp>
#         </matches>
#       </ace>
#       <ace>
#         <name>DROP</name>
#         <action>drop</action>
#       </ace>
#     </aces>
#   </acl>
# </acls>
#
# ACL2 which allows BGP and rejects everything else
# <acls>
#   <acl>
#     <aces>
#       <ace>
#         <name>BGP-PASSIVE</name>
#         <action>permit</action>
#         <src-port>179</src-port>
#         <matches>
#           <protocol>tcp</protocol>
#           <tcp>
#             <destination-port>
#               <operator>eq</operator>
#               <port>179</port>
#             </destionation-port>
#           </tcp>
#         </matches>
#       </ace>
#       <ace>
#         <name>DROP</name>
#       </ace>
#     </aces>
#   </acl>
# </acls>
#
# And the merged result should be:
#
# <acls>
#   <acl>
#     <aces>
#       <ace>
#         <name>SSH</name>
#         <action>permit</action>
#         <matches>
#           <ipv4>
#             <source-ipv4-network>192.0.2.0/24</source-ipv4-network>
#           </ipv4>
#           <protocol>tcp</protocol>
#           <tcp>
#             <destination-port>
#               <operator>eq</operator>
#               <port>22</port>
#             </destionation-port>
#           </tcp>
#         </matches>
#       </ace>
#       <ace>
#         <name>BGP-PASSIVE</name>
#         <action>permit</action>
#         <src-port>179</src-port>
#         <matches>
#           <protocol>tcp</protocol>
#           <tcp>
#             <destination-port>
#               <operator>eq</operator>
#               <port>179</port>
#             </destionation-port>
#           </tcp>
#         </matches>
#       </ace>
#       <ace>
#         <name>DROP</name>
#         <action>drop</action>
#       </ace>
#     </aces>
#   </acl>
# </acls>
#

#
#
# ACL1 which allows SSH and rejects everything else
#   <acl>
#       <ace>
#         <name>SSH</name>
#         <action>permit</action>
#         <matches>...</matches>
#       </ace>
#       <ace>
#         <name>DROP</name>
#         <action>drop</action>
#       </ace>
#   </acl>
#
# ACL2 which allows BGP and rejects everything else
#   <acl>
#       <ace>
#         <name>BGP-PASSIVE</name>
#         <action>permit</action>
#         <matches>...</matches>
#       </ace>
#       <ace>
#         <name>DROP</name>
#       </ace>
#   </acl>
#
# And the merged result should be:
#
#   <acl>
#       <ace>
#         <name>SSH</name>
#         <action>permit</action>
#         <matches>...</matches>
#       </ace>
#       <ace>
#         <name>BGP-PASSIVE</name>
#         <action>permit</action>
#         <matches>... </matches>
#       </ace>
#       <ace>
#         <name>DROP</name>
#         <action>drop</action>
#       </ace>
#   </acl>
#
# In the merge, we cannot know if SSH should come before or after BGP-PASSIVE,
# but it dosen't matter. The only important thing is that both are before the
# DROP rule. We make sure of this by stating in both input ACLs that DROP should
# be last. Note how in ACL2 the DROP ace is not complete, it just contains the
# name and nothing else. This is fine because the merge function will take the
# complete ACE from ACL1 and merge it with the incomplete ACE from ACL2 to
# produce a complete output.

def _ind(n):
    return "  " * n

remove_op = [("xmlns:xc", '"urn:ietf:params:xml:ns:netconf:base:1.0"'), ("xc:operation", '"remove"')]

def either(a: ?str, b: ?str):
    if a is not None:
        return a
    else:
        return b

def yang_str(v) -> str:
    if isinstance(v, bytes):
        s = base64.encode(v).decode()
        return s
    s = str(v)
    if isinstance(v, bool):
        s = s.lower()
    return s

def json_val(yang_type: str, v: ?value) -> ?value:
    if isinstance(v, bytes):
        return base64.encode(v).decode()
    if yang_type == "int64" or yang_type == "uint64":
        return str(v)
    return v


def fmt_json_name(name, module=None):
    name_without_prefix = name.split(":")[-1]
    if module is not None:
        return f"{module}:{name_without_prefix}"
    return name_without_prefix


def fmt_tag(name, ns=None, attrs: list[(str, str)]=[], close=False, end=False):
    ns_attr = [("xmlns", '"'+ns+'"')] if ns is not None and not close else []
    attr_strs = list(map(lambda x: x.0 + "=" + x.1, ns_attr + attrs))
    left = "</" if close else "<"
    right = "/>" if end else ">"
    name_without_prefix = name.split(":")[-1]
    return left + " ".join([name_without_prefix] + attr_strs) + right


# Static value for empty key, used by Node that do not have a key (it must still
# be set for all concrete classes since it's an attribute of the Node parent)
empty_key = []

class Node(value):
    ns: ?str
    module: ?str
    key: list[str] # values of the key leafs
    children: dict[str, Node]

    def key_str(self) -> str:
        def escape_keys(key_val):
            return key_val.replace(",", "\\,")
        return ",".join(map(escape_keys, self.key))

    def prsrc(self, indent=0, name="") -> str:
        args = []
        sns = self.ns
        if sns is not None:
            args += [f"ns='{sns}'"]
        smodule = self.module
        if smodule is not None:
            args += [f"module='{smodule}'"]
        res = []
        if isinstance(self, Leaf):
            args.insert(0, f"'{str(self.t)}'")
            if isinstance(self.val, str):
                val = f"'{self.val}'"
            else:
                val = str(self.val)
            args.insert(1, val)
            return "Leaf(" + ", ".join(args) + ")"
        elif isinstance(self, LeafList):
            args.insert(0, f"'{str(self.t)}'")
            args.insert(1, str(self.vals if self.user_order else vals_list_sorted(self.vals)))
            if self.user_order:
                args.append("user_order=True")
            return "LeafList(" + ", ".join(args) + ")"
        elif isinstance(self, Absent):
            if self.key != []:
                args.insert(0, str(self.key))
            return "Absent(" + ", ".join(args) + ")"
        elif isinstance(self, List):
            args.insert(0, str(self.keys))
            if self.user_order:
                args.append("user_order=True")
            if len(self.elements) == 0:
                res.append("List(" + ", ".join(args) + ')')
            else:
                args.append("elements=[")
                res.append("List(" + ", ".join(args))
                child_res = []
                for elem in self.elements if self.user_order else sorted(self.elements):
                    child_res.append(_ind(indent+1) + elem.prsrc(indent+1))
                res.append(",\n".join(child_res))
                res.append(_ind(indent) + "])")
            return "\n".join(res)
        elif isinstance(self, Container):
            sname = "Container"
            if self.presence:
                args.insert(0, "presence=True")
            if self.key != []:
                args.insert(0, str(self.key))

            if len(self.children) == 0:
                res.append(sname + "(" + ", ".join(args) + ")")
            else:
                child_res = []
                for nm,child in self.children.items():
                    child_res.append(_ind(indent+1) + "'" + nm + "': " + child.prsrc(indent+1, nm))
                res.append(sname + "({")
                res.append(",\n".join(child_res))

                args_str = ""
                if len(args) > 0:
                    args_str = ", " + ", ".join(args)
                res.append(_ind(indent) + "}" + args_str + ")")
            return "\n".join(res)
        else:
            raise ValueError("Unsupported node type in prsrc")

    def to_json(self, pretty=True) -> str:
        """Convert gdata to JSON
        """
        return json.encode(self.to_dict(), pretty=pretty)

    def to_dict(self, pretty=True) -> dict[str, ?value]:
        """Convert gdata to a dict, suitable for JSON serialization
        """
        if isinstance(self, Container):
            child_dict = {}
            for nm,child in self.children.items():
                if isinstance(child, Container):
                    child_dict[fmt_json_name(nm, child.module)] = child.to_dict(pretty)
                elif isinstance(child, Leaf):
                    child_dict[fmt_json_name(nm, child.module)] = json_val(child.t, child.val)
                elif isinstance(child, LeafList):
                    vals = []
                    for v in child.vals if child.user_order else vals_list_sorted(child.vals):
                        vals.append(json_val(child.t, v))
                    child_dict[fmt_json_name(nm, child.module)] = vals
                elif isinstance(child, List):
                    elems = []
                    for elem in child.elements if child.user_order else sorted(child.elements):
                        if isinstance(elem, Container):
                            elem_dict = {}
                            for k, v in dict(zip(child.keys, elem.key)).items():
                                elem_dict[k] = v
                            elem_dict.update(elem.to_dict(pretty).items())
                            elems.append(elem_dict)
                        else:
                            raise ValueError("Unexpected list (" + nm + ") element type: " + type(elem))
                    child_dict[fmt_json_name(nm, child.module)] = elems
                else:
                    raise ValueError("Unsupported child (" + nm + ") node type in to_dict: " + type(child))
            return child_dict
        raise ValueError("Unsupported node type in to_dict: " + type(self))

    def to_xmlstr(self, name="top", pretty=True, indent=0, cns: ?str=None) -> str:
        # TODO: get rid of cns, I don't think it is necessary anymore, right?
        # TODO: uh, do not use the name "top" for the root node, since it can
        # conflict with the name of a child node actually named "top"
        def _indent(extra=0):
            if pretty:
                return "  " * (indent+extra)
            return ""

        def _nl():
            if pretty:
                return "\n"
            return ""

        if isinstance(self, Container):
            child_indent = indent if name == "top" else indent + 1
            child_cns = None if name == "top" else either(self.ns, cns)
            child_xml = ""
            for nm, child in self.children.items():
                child_xml += child.to_xmlstr(nm, pretty, child_indent)
            if name == "top":
                return child_xml

            if child_xml == "":
                if self.presence:
                    return _indent() + fmt_tag(name, either(self.ns, cns), end=True) + _nl()
                else:
                    return ""

            xml = _indent() + fmt_tag(name, either(self.ns, cns)) + _nl()
            xml += child_xml
            xml += _indent() + fmt_tag(name, close=True) + _nl()
            return xml

        elif isinstance(self, List):
            xml = ""
            for elem in self.elements if self.user_order else sorted(self.elements):
                remove = isinstance(elem, Absent)
                xml += _indent() + fmt_tag(name, either(self.ns, cns), attrs=remove_op if remove else []) + _nl()
                # Print key leafs first
                for key_idx, key_name in enumerate(self.keys):
                    xml += _indent(1) + "<" + key_name + ">" + str(elem.key[key_idx]) + "</" + key_name + ">" + _nl()
                for nm,child in elem.children.items():
                    if nm in self.keys or remove:
                        continue
                    xml += child.to_xmlstr(nm, pretty, indent+1)
                xml += _indent() + fmt_tag(name, close=True) + _nl()
            return xml
        elif isinstance(self, Leaf):
            xml = _indent()
            if self.t == "empty":
                v = self.val
                if v == None:
                    return ""
                if isinstance(v, bool):
                    if v == True:
                        xml += fmt_tag(name, either(self.ns, cns), end=True)
                    else:
                        xml += fmt_tag(name, either(self.ns, cns), attrs=remove_op, end=True)
            else:
                v = yang_str(self.val)
                xml += fmt_tag(name, either(self.ns, cns)) + v + fmt_tag(name, close=True)
            xml += _nl()
            return xml
        elif isinstance(self, LeafList):
            xml = ""
            for val in self.vals if self.user_order else vals_list_sorted(self.vals):
                v = yang_str(val)
                xml += _indent() + fmt_tag(name, either(self.ns, cns)) + v + fmt_tag(name, close=True) + _nl()
            return xml
        elif isinstance(self, Absent):
            return _indent() + fmt_tag(name, either(self.ns, cns), attrs=remove_op, end=True) + _nl()
        raise ValueError("Unsupported node type in to_xml: " + type(self))

    # --
    def get_leaf(self, name) -> Leaf:
        l = self.get_opt_leaf(name)
        if l != None:
            return l
        raise ValueError("Cannot find leaf child with name: " + name)

    def get_opt_leaf(self, name) -> ?Leaf:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, Leaf) and nm == name:
                    return child

    #--

    def get_container(self, name) -> Container:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, Container) and nm == name:
                    return child
        raise ValueError("Cannot find container child with name " + name)

    def get_opt_container(self, name) -> ?Container:
        """This is for P-container"""
        try:
            return self.get_container(name)
        except ValueError:
            return None

    def get_opt_list(self, name) -> ?List:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, List) and nm == name:
                    return child

    def get_bool(self, name) -> bool:
        child = self.get_leaf(name)
        childval = child.val
        if isinstance(childval, bool):
            return childval
        raise ValueError("Leaf %s is not of type bool" % name)

    def get_opt_bool(self, name) -> ?bool:
        child = self.get_opt_leaf(name)
        if child != None:
            childval = child.val
            if isinstance(childval, bool):
                return childval

    def get_float(self, name) -> float:
        child = self.get_leaf(name)
        childval = child.val
        if isinstance(childval, float):
            return childval
        raise ValueError("Leaf %s is not of type float" % name)

    def get_opt_float(self, name) -> ?float:
        child = self.get_opt_leaf(name)
        if child != None:
            childval = child.val
            if isinstance(childval, float):
                return childval

    def get_int(self, name) -> int:
        child = self.get_leaf(name)
        childval = child.val
        if isinstance(childval, int):
            return childval
        raise ValueError("Leaf %s is not of type int" % name)

    def get_ints(self, name) -> list[int]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    cvals = []
                    for v in child.vals:
                        if isinstance(v, int):
                            cvals.append(v)
                    return cvals
        raise ValueError("Cannot find leaf-list child with name " + name)

    def get_opt_int(self, name) -> ?int:
        child = self.get_opt_leaf(name)
        if child != None:
            childval = child.val
            if isinstance(childval, int):
                return childval

    def get_opt_ints(self, name) -> list[int]:
        try:
            return self.get_ints(name)
        except ValueError:
            return []

    def get_str(self, name) -> str:
        child = self.get_leaf(name)
        childval = child.val
        if isinstance(childval, str):
            return childval
        raise ValueError("Leaf %s value is not type str" % name)

    def get_opt_str(self, name) -> ?str:
        child = self.get_opt_leaf(name)
        if child != None:
            childval = child.val
            if isinstance(childval, str):
                return childval

    def get_strs(self, name) -> list[str]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    cvals = []
                    for v in child.vals:
                        if isinstance(v, str):
                            cvals.append(v)
                    return cvals
        raise ValueError("Cannot find leaf-list child with name " + name)

    def get_opt_strs(self, name) -> list[str]:
        try:
            return self.get_strs(name)
        except ValueError:
            return []

    def get_bytes(self, name) -> bytes:
        child = self.get_leaf(name)
        childval = child.val
        if isinstance(childval, bytes):
            return childval
        raise ValueError("Leaf %s value is not type bytes" % name)

    def get_opt_bytes(self, name) -> ?bytes:
        child = self.get_opt_leaf(name)
        if child != None:
            childval = child.val
            if isinstance(childval, bytes):
                return childval

    def get_bytess(self, name) -> list[bytes]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    cvals = []
                    for v in child.vals:
                        if isinstance(v, bytes):
                            cvals.append(v)
                    return cvals
        raise ValueError("Cannot find leaf-list child with name " + name)

    def get_opt_bytess(self, name) -> list[bytes]:
        try:
            return self.get_bytess(name)
        except ValueError:
            return []

    def get_value(self, name) -> value:
        child = self.get_leaf(name)
        return child.val

    def get_opt_value(self, name) -> ?value:
        child = self.get_opt_leaf(name)
        if child != None:
            return child.val

    def get_values(self, name) -> list[value]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    return child.vals
        raise ValueError("Cannot find leaf-list child with name " + name)

    def get_opt_values(self, name) -> list[value]:
        try:
            return self.get_values(name)
        except ValueError:
            return []

extension Node(Ord):
    def __eq__(self, other: Node) -> bool:
        if self.ns != other.ns:
            return False

        if isinstance(self, Container) and isinstance(other, Container):
            if self.key != other.key:
                return False
            if set(self.children.keys()) != set(other.children.keys()):
                return False
            for key in self.children.keys():
                if self.children[key] != other.children[key]:
                    return False
            return True

        if isinstance(self, Leaf) and isinstance(other, Leaf):
            return vals_equal(self.val, other.val)

        if isinstance(self, LeafList) and isinstance(other, LeafList):
            return vals_list_equal(self.vals, other.vals)

        if isinstance(self, List) and isinstance(other, List):
            if self.keys != other.keys:
                return False
            if len(self.elements) != len(other.elements):
                return False
            for i in range(len(self.elements)):
                e1 = self.elements[i]
                e2 = other.elements[i]
                if not self.user_order and e1.key != e2.key:
                    for e2 in other.elements:
                        if e1.key == e2.key:
                            break
                if e1 != e2:
                    return False
            return True

        if isinstance(self, Absent) and isinstance(other, Absent):
            return self.key == other.key

        return False

    def __lt__(a, b):
        return a.key_str() <= b.key_str()


class List(Node):
    keys: list[str] # name of the key leafs
    elements: list[Node]
    user_order: bool

    def __init__(self, keys: list[str], elements: list[Node]=[], user_order=False, ns: ?str=None, module: ?str=None):
        self.key = empty_key
        self.keys = keys
        self.elements = elements
        self.user_order = user_order
        self.ns = ns
        self.module = module

class Container(Node):
    def __init__(self, children: dict[str, Node]={}, key: list[str]=[], presence: bool=False, ns: ?str=None, module: ?str=None):
        self.children = children
        self.key = key
        self.presence = presence
        self.ns = ns
        self.module = module

class Leaf(Node):
    t: str
    val: value

    def __init__(self, t: str, val: value, ns: ?str=None, module: ?str=None):
        self.key = empty_key
        self.t = t
        self.val = val
        self.ns = ns
        self.module = module

class LeafList(Node):
    t: str
    vals: list[value]
    user_order: bool

    def __init__(self, t:str, vals: list[value], user_order=False, ns: ?str=None, module: ?str=None):
        self.key = empty_key
        self.t = t
        self.ns = ns
        self.module = module
        self.vals = vals
        self.user_order = user_order

class Absent(Node):
    """Declarative definition of the absence of a node

    NETCONF remove operation maps to Absent

    Absent is declarative / idempotent, meaning that if the target to be removed
    / made absent is not present, no error is raised.
    """
    def __init__(self, key: list[str]=[], ns: ?str=None, module: ?str=None):
        self.key = key
        self.ns = ns
        self.module = module
        self.children = {}

class Delete(Node):
    """Imperative delete of a node
    NETCONF delete operation maps to Delete

    Unlike Absent / remove, Delete of a non-existent node is a failure.
    """
    def __init__(self, key: list[str]=[], ns: ?str=None, module: ?str=None):
        self.key = key
        self.ns = ns
        self.module = module
        self.children = {}

class Create(Node):
    """Imperative create of a node
    NETCONF create operation maps to Create

    Unlike the default implicit merge, Create of an existing node is a failure.
    """
    def __init__(self, children={}, key: list[str]=[], ns: ?str=None, module: ?str=None):
        self.key = key
        self.ns = ns
        self.module = module
        self.children = children

class Replace(Node):
    """Imperative replace of a node
    NETCONF replace operation maps to Replace
    """
    def __init__(self, children={}, key: list[str]=[], ns: ?str=None, module: ?str=None):
        self.key = key
        self.ns = ns
        self.module = module
        self.children = children


def vals_equal(a: value, b: value) -> bool:
    # Compare known leaf value types
    if isinstance(a, int) and isinstance(b, int):
        return a == b
    if isinstance(a, bool) and isinstance(b, bool):
        return a == b
    if isinstance(a, float) and isinstance(b, float):
        return a == b
    if isinstance(a, str) and isinstance(b, str):
        return a == b
    # TODO: Add support for u8 and i8
    #if isinstance(a, u8) and isinstance(b, u8):
    #    return a == b
    if isinstance(a, u16) and isinstance(b, u16):
        return a == b
    if isinstance(a, u32) and isinstance(b, u32):
        return a == b
    if isinstance(a, u64) and isinstance(b, u64):
        return a == b
    # TODO: Add support for u8 and i8
    #if isinstance(a, i8) and isinstance(b, i8):
    #    return a == b
    if isinstance(a, i16) and isinstance(b, i16):
        return a == b
    if isinstance(a, i32) and isinstance(b, i32):
        return a == b
    if isinstance(a, i64) and isinstance(b, i64):
        return a == b
    raise ValueError(f"Unsupported value type or mismatch in comparison: {type(a)}, {type(b)}")

# For leaf-lists we need to compare a list of values
def vals_list_equal(a: list[value], b: list[value]) -> bool:
    if len(a) != len(b):
        return False
    for i in range(len(a)):
        if not vals_equal(a[i], b[i]):
            return False
    return True

def vals_less_than(a: value, b: value) -> bool:
    # Compare known leaf value types
    if isinstance(a, int) and isinstance(b, int):
        return a < b
    if isinstance(a, bool) and isinstance(b, bool):
        return not a  # False (0) before True (1)
    if isinstance(a, float) and isinstance(b, float):
        return a < b
    if isinstance(a, str) and isinstance(b, str):
        return a < b
    # TODO: Add support for u8 and i8
    #if isinstance(a, u8) and isinstance(b, u8):
    #    return a < b
    if isinstance(a, u16) and isinstance(b, u16):
        return a < b
    if isinstance(a, u32) and isinstance(b, u32):
        return a < b
    if isinstance(a, u64) and isinstance(b, u64):
        return a < b
    # TODO: Add support for u8 and i8
    #if isinstance(a, i8) and isinstance(b, i8):
    #    return a < b
    if isinstance(a, i16) and isinstance(b, i16):
        return a < b
    if isinstance(a, i32) and isinstance(b, i32):
        return a < b
    if isinstance(a, i64) and isinstance(b, i64):
        return a < b
    raise ValueError(f"Unsupported value type or mismatch in comparison: {type(a)}, {type(b)}")

def vals_list_sorted(a: list[value]) -> list[value]:
    """Sort a list of values, comparing only values of the same type

    Uses an insertion sort implementation that respects type safety
    by only comparing values of the same type.
    """
    n = len(a)
    if n <= 1:
        return a

    result = a.copy()  # Create a copy to avoid modifying the input list

    # Insertion sort implementation
    for i in range(1, n):
        key = result[i]
        j = i - 1
        # Move elements that are greater than key to one position ahead
        while j >= 0 and not vals_less_than(result[j], key):
            result[j + 1] = result[j]
            j -= 1
        result[j + 1] = key

    return result

def merge(a: Node, b: Node) -> Node:
    if type(a) != type(b):
        raise ValueError("Cannot merge nodes of different types, type(a) = %s, type(b) = %s" % (str(type(a)), str(type(b))))

    # Helper to merge keyed children
    def merge_keyed_children(a_children: dict[str, Node], b_children: dict[str, Node]) -> dict[str, Node]:
        result: dict[str, Node] = {}

        a_keys = []
        for k in a_children:
            a_keys.append(k)
        b_keys = []
        for k in b_children:
            b_keys.append(k)

        i = 0
        j = 0
        while i < len(a_keys) and j < len(b_keys):
            ak = a_keys[i]
            bk = b_keys[j]
            if ak == bk:
                # Overlapping key
                merged_child = merge(a_children[ak], b_children[bk])
                result[ak] = merged_child
                i += 1
                j += 1
            else:
                # Keys differ
                ak_in_b = (ak in b_children)
                bk_in_a = (bk in a_children)
                if not ak_in_b:
                    # Child only in a
                    result[ak] = a_children[ak]
                    i += 1
                elif not bk_in_a:
                    # Child only in b
                    # We append it now right after we handle old nodes to keep order of a
                    # In merging, we decided to maintain 'a' order as baseline
                    # So we handle all a_nodes that appear before first
                    # If we want strictly all 'a' first, we can first go through a_keys that are not in b.
                    # But let's insert b node here to keep somewhat stable merging.
                    result[bk] = b_children[bk]
                    j += 1
                else:
                    # Both appear in both sets at different positions, reorder scenario
                    # For simplicity, handle old's node first since we want to keep a's order.
                    merged_child = merge(a_children[ak], b_children[ak])
                    result[ak] = merged_child
                    i += 1
                    # We don't advance j here because we haven't handled bk yet.
                    # We'll hit bk again in next iteration and handle it normally.

        # If a still has items
        while i < len(a_keys):
            ak = a_keys[i]
            # If ak also in b but we haven't handled it yet, merge it now.
            # Otherwise just take it from a.
            if ak in b_children:
                merged_child = merge(a_children[ak], b_children[ak])
                result[ak] = merged_child
            else:
                result[ak] = a_children[ak]
            i += 1

        # If b still has items
        while j < len(b_keys):
            bk = b_keys[j]
            if bk not in a_children:
                # New child from b
                result[bk] = b_children[bk]
            else:
                # Already handled overlap above, but if we got here, let's be safe:
                merged_child = merge(a_children[bk], b_children[bk])
                result[bk] = merged_child
            j += 1

        return result

    if isinstance(a, Container) and isinstance(b, Container):
        if a.key != b.key:
            raise ValueError("Cannot merge containers with different keys: %s vs %s" % (str(a.key), str(b.key)))
        # Merge keyed children similarly to Container
        new_children = merge_keyed_children(a.children, b.children)
        return Container(children=new_children, key=a.key, presence=a.presence, ns=a.ns, module=a.module)

    elif isinstance(a, Leaf) and isinstance(b, Leaf):
        if a.t != b.t:
            raise ValueError("Cannot merge leaves with different types")
        aval = a.val
        bval = b.val
        if vals_equal(aval, bval):
            return a
        raise ValueError("Cannot merge leaves with different values: %s != %s" % (str(aval), str(bval)))

    elif isinstance(a, LeafList) and isinstance(b, LeafList):
        if vals_list_equal(a.vals, b.vals):
            return a
        raise ValueError("Cannot merge leaf-lists with different values")

    elif isinstance(a, List) and isinstance(b, List):
        if a.keys != b.keys:
            raise ValueError("Cannot merge lists with different keys: %s vs %s" % (str(a.keys), str(b.keys)))
        if a.user_order != b.user_order:
            raise ValueError("Cannot merge lists with different user_order")

        if a.user_order:
            # user_order = True
            # Two-pointer approach for merging list elements
            # This preserves the order from 'a' as baseline and inserts 'b' elements accordingly.
            new_elements: list[Node] = []

            old_map = {}
            for e in a.elements:
                old_map[e.key_str()] = e

            # Start with elements from a, merge if present in b
            for a_elem in a.elements:
                k = a_elem.key_str()
                found = False
                for b_elem in b.elements:
                    if b_elem.key == a_elem.key:
                        merged_elem = merge(a_elem, b_elem)
                        if isinstance(merged_elem, Container):
                            new_elements.append(merged_elem)
                        else:
                            raise ValueError("merge did not return a Container where one was expected")
                        found = True
                        break
                if not found:
                    # not in b, just add a_elem
                    new_elements.append(a_elem)

            # Add elements from b that are not in a
            # Insert them in a stable manner at the end to preserve 'a' order
            # If we want a more sophisticated merging of order, we could try to insert them
            # relative to keys present in both.
            # For now, we just append them at the end.
            existing_keys = {}
            for e in new_elements:
                existing_keys[e.key_str()] = True
            for b_elem in b.elements:
                bk = b_elem.key_str()
                if bk not in existing_keys:
                    new_elements.append(b_elem)
                    existing_keys[bk] = True

            return List(a.keys, new_elements, user_order=a.user_order, ns=a.ns, module=a.module)
        else:
            # user_order = False
            # Keep the original merging logic since it sorts by keys, not order
            all_elements: dict[str, list[Node]] = {}

            def escape_keys(key_val):
                return key_val.replace(",", "\\,")
            for elem in a.elements:
                key_str = ",".join(elem.key)
                if key_str not in all_elements:
                    all_elements[key_str] = []
                all_elements[key_str].append(elem)
            for elem in b.elements:
                key_str = ",".join(elem.key)
                if key_str not in all_elements:
                    all_elements[key_str] = []
                all_elements[key_str].append(elem)

            new_elements: list[Node] = []
            # sort keys lex order as before
            unsorted_keys = []
            for k in all_elements:
                unsorted_keys.append(k)
            sorted_keys = sorted(unsorted_keys)

            for key_str in sorted_keys:
                elems = all_elements[key_str]
                new_elem = elems[0]
                if len(elems) > 1:
                    for elem in elems[1:]:
                        new_elem = merge(new_elem, elem)
                if isinstance(new_elem, Container):
                    new_elements.append(new_elem)
                else:
                    raise ValueError("unreachable, new_elem should always be a Container")

            return List(a.keys, new_elements, ns=a.ns, module=a.module)

    elif isinstance(a, Absent) and isinstance(b, Absent):
        # Both absent is odd in a merge scenario, but let's just return absent
        return a

    else:
        raise ValueError("Unsupported node type in merge: %s" % str(type(a)))


def diff(old: Node, new: Node) -> ?Node:
    if type(old) != type(new):
        raise ValueError("diff called with nodes of different types: %s vs %s" % (str(type(old)), str(type(new))))

    # Helper function for diffing Container nodes that have children keyed by strings
    def diff_keyed_children(old_children: dict[str, Node], new_children: dict[str, Node]) -> ?dict[str, Node]:
        # We'll produce a new_children_dict with the diff
        result: dict[str, Node] = {}

        for k,nchild in new_children.items():
            if k in old_children:
                ochild = old_children[k]
                child_diff = diff(ochild, nchild)
                if child_diff is not None:
                    result[k] = child_diff
            else:
                result[k] = nchild
        for k,ochild in old_children.items():
            if k not in new_children:
                result[k] = Absent(ns=ochild.ns, module=ochild.module)

        if len(result) == 0:
            return None
        return result

    # Helper function for diffing Lists which have ordered elements
    def diff_list_elements(old_list: List, new_list: List) -> ?list[Node]:

        if old_list.keys != new_list.keys:
            raise ValueError("List keys differ: %s vs %s" % (str(old_list.keys), str(new_list.keys)))

        # Map old elements by key
        old_map = {}
        old_key_order = []
        for e in old_list.elements:
            k = e.key_str()
            old_map[k] = e
            old_key_order.append(k)

        new_map = {}
        new_key_order = []
        for e in new_list.elements:
            nk = e.key_str()
            new_map[nk] = e
            new_key_order.append(nk)

        # We'll do the two-pointer approach on these key orders
        i = 0
        j = 0
        result: list[Node] = []

        while i < len(old_key_order) and j < len(new_key_order):
            ok = old_key_order[i]
            nk = new_key_order[j]

            if ok == nk:
                # same element key
                elem_diff = diff(old_map[ok], new_map[nk])
                if elem_diff != None:
                    if isinstance(elem_diff, Absent):
                        raise ValueError("Absent returned from diff in list elements")
                    elif isinstance(elem_diff, Container):
                        result.append(elem_diff)
                i += 1
                j += 1
            else:
                ok_in_new = (ok in new_map)
                nk_in_old = (nk in old_map)

                if not ok_in_new:
                    # old element not in new => absent
                    oe = old_map[ok]
                    result.append(Absent(oe.key, ns=oe.ns, module=oe.module))
                    i += 1
                elif not nk_in_old:
                    # new element not in old => new element
                    # Insert the new element now
                    ne = new_map[nk]
                    result.append(ne)
                    j += 1
                else:
                    # Complex reordering scenario
                    raise ValueError("Complex reordering scenario encountered in list elements")

        # Remaining old elements are absent
        while i < len(old_key_order):
            ok = old_key_order[i]
            if ok not in new_map:
                oe = old_map[ok]
                result.append(Absent(oe.key, ns=old_list.ns, module=old_list.module))
            i += 1

        # Remaining new elements are new
        while j < len(new_key_order):
            nk = new_key_order[j]
            if nk not in old_map:
                ne = new_map[nk]
                result.append(ne)
            j += 1

        if len(result) == 0:
            return None
        return result

    # Diff logic for each node type

    if isinstance(old, Container) and isinstance(new, Container):
        if old.key != new.key:
            raise ValueError("Container keys differ: %s vs %s" % (str(old.key), str(new.key)))
        diff_children = diff_keyed_children(old.children, new.children)
        if diff_children is None:
            return None
        return Container(children=diff_children, key=new.key, presence=new.presence, ns=new.ns, module=new.module)

    elif isinstance(old, List) and isinstance(new, List):
        # For lists, we have elements instead of children
        result = diff_list_elements(old, new)
        if result is None:
            return None
        return List(new.keys, elements=result, user_order=new.user_order, ns=new.ns, module=new.module)

    elif isinstance(old, Leaf) and isinstance(new, Leaf):
        if old.t != new.t:
            raise ValueError("Leaf types differ: %s vs %s" % (old.t, new.t))
        if vals_equal(old.val, new.val):
            return None
        else:
            return new

    elif isinstance(old, LeafList) and isinstance(new, LeafList):
        if vals_list_equal(old.vals, new.vals):
            return None
        return new

    elif isinstance(old, Absent) and isinstance(new, Absent):
        if old.key != new.key:
            raise ValueError("Absent keys differ: %s vs %s" % (str(old.key), str(new.key)))
        return None

    else:
        raise ValueError("Unhandled node type in diff: %s" % str(type(old)))


# TODO: Can we make patch return a Node instead of ?Node?
def patch(old: Node, p: ?Node) -> ?Node:
    if p is None:
        return old

    if isinstance(p, Absent):
        # Patch says remove this node
        return None

    elif isinstance(old, Container) and isinstance(p, Container):
        if old.key != p.key:
            raise ValueError("Container keys differ in patch: %s vs %s" % (str(old.key), str(p.key)))

        # Start with old children
        new_children: dict[str, Node] = {}
        for key in old.children:
            new_children[key] = old.children[key]

        # Apply patch changes
        for key in p.children:
            cpatch = p.children[key]
            if key in new_children:
                # Patch existing child
                res = patch(new_children[key], cpatch)
                if res is not None:
                    new_children[key] = res
                else:
                    del new_children[key]
            else:
                # Key not in old
                if isinstance(cpatch, Absent):
                    # Trying to remove something not in old -> ignore
                    pass
                else:
                    # New child
                    new_children[key] = cpatch

        # No need to remove unchanged nodes; they are already in new_children
        if len(new_children) == 0:
            return None
        return Container(children=new_children, key=old.key, presence=old.presence, ns=old.ns, module=old.module)

    elif isinstance(old, List) and isinstance(p, List):
        if old.keys != p.keys:
            raise ValueError("List keys differ: %s vs %s" % (str(old.keys), str(p.keys)))

        old_map = {}
        for e in old.elements:
            k = e.key_str()
            old_map[k] = e

        # Apply patch elements
        patch_elems = p.elements
        for pelem in patch_elems:
            if isinstance(pelem, Absent):
                # Remove this element if it exists
                k = pelem.key_str()
                if k in old_map:
                    del old_map[k]
            else:
                # pelem is a ListElement
                k = pelem.key_str()
                if k in old_map:
                    # Patch existing element
                    res = patch(old_map[k], pelem)
                    if res is not None and isinstance(res, Container):
                        old_map[k] = res
                    else:
                        # Remove the element
                        del old_map[k]
                else:
                    # New element
                    old_map[k] = pelem

        # Rebuild elements in final order
        # Start with old's original order for unchanged and patched elements
        final_key_order = []
        chosen = {}
        for e in old.elements:
            k = e.key_str()
            if k in old_map:
                final_key_order.append(k)
                chosen[k] = True

        # Now check if patch introduced new elements not in old.
        # Add them in the order they appear in patch.
        for pelem in patch_elems:
            if isinstance(pelem, Absent):
                continue
            k = pelem.key_str()
            if k in old_map and k not in chosen:
                final_key_order.append(k)
                chosen[k] = True

        new_elements: list[Node] = []
        for k in final_key_order:
            new_elements.append(old_map[k])

        if len(new_elements) == 0:
            return None
        return List(old.keys, elements=new_elements, user_order=old.user_order, ns=old.ns, module=old.module)

    elif isinstance(old, Leaf) and isinstance(p, Leaf):
        # Patch leaf replaces old leaf value
        if old.t != p.t:
            raise ValueError("Leaf types differ in patch: %s vs %s" % (old.t, p.t))
        return p

    elif isinstance(old, LeafList) and isinstance(p, LeafList):
        # Patch leaf-list replaces old leaf-list values
        return p

    elif isinstance(old, Absent) and isinstance(p, Absent):
        # Both absent means node was removed
        if old.key != p.key:
            raise ValueError("Absent keys differ in patch: %s vs %s" % (str(old.key), str(p.key)))
        return None

    else:
        if p != None:
            raise ValueError("Unhandled node type in patch: %s" % str(type(p)))

def _node_match(n: xml.Node, name: str, ns: ?str) -> bool:
    """Check if an XML node matches the given name and namespace

    It will match either on the default (nameless) namespace, or the node prefix
    & a named namespace. For example:
    <foo xmlns="urn:foo"> and <ns:foo xmlns:ns="urn:foo"> both match with name="foo", ns="urn:foo"
    """
    if n.tag == name:
        if ns is not None:
            for nsdef in n.nsdefs:
                n0 = nsdef.0
                n1 = nsdef.1
                if n0 is not None and n0 == n.prefix and n1 == ns:
                    return True
                elif n0 is None and n1 == ns:
                    return True
        else:
            return True
    return False

def get_xml_child(n: xml.Node, name: str, ns: ?str) -> xml.Node:
    r = get_xml_opt_child(n, name, ns)
    if r is not None:
        return r
    raise ValueError("Cannot find xml child with name " + name)

def get_xml_opt_child(n: xml.Node, name: str, ns: ?str) -> ?xml.Node:
    for child in n.children:
        if _node_match(child, name, ns):
            return child
    return None

def get_xml_child_text(n: xml.Node, name: str) -> str:
    for child in n.children:
        if child.tag == name:
            childtext = child.text
            if childtext is not None:
                return childtext
            raise ValueError("Child text is None")
    raise ValueError("Cannot find xml child with name " + name)

def get_xml_children(n: xml.Node, name: str, ns: ?str) -> list[xml.Node]:
    res = []
    for child in n.children:
        if _node_match(child, name, ns):
            res.append(child)
    return res

def from_xml_opt_bool(n: xml.Node, name: str, ns: ?str) -> ?bool:
    try:
        text = get_xml_child(n, name, ns).text
        if text is not None:
            return bool(text)
    except ValueError:
        return None

def from_xml_bool(n: xml.Node, name: str, ns: ?str) -> bool:
    r = from_xml_opt_bool(n, name, ns)
    if r is not None:
        return r
    raise ValueError("Cannot find xml child with name " + name)

def from_xml_float(n: xml.Node, name: str, ns: ?str) -> float:
    text = get_xml_child(n, name, ns).text
    if text is not None:
        res = float(text)
        return res
    raise ValueError("Cannot find xml child with name " + name)
    return 13.37 # bah, get C error otherwise

def from_xml_opt_float(n: xml.Node, name: str, ns: ?str) -> ?float:
    try:
        text = get_xml_child(n, name, ns).text
        if text is not None:
            res = float(text)
            return res
    except ValueError:
        return None

def from_xml_opt_int(n: xml.Node, name: str, ns: ?str) -> ?int:
    try:
        text = get_xml_child(n, name, ns).text
        if text is not None:
            return int(text)
    except ValueError:
        return None

def from_xml_int(n: xml.Node, name: str, ns: ?str) -> int:
    r = from_xml_opt_int(n, name, ns)
    if r is not None:
        return r
    raise ValueError("Cannot find xml child with name " + name)

def from_xml_opt_str(n: xml.Node, name: str, ns: ?str) -> ?str:
    try:
        return get_xml_child(n, name, ns).text
    except ValueError:
        return None

def from_xml_str(n: xml.Node, name: str, ns: ?str) -> str:
    r = from_xml_opt_str(n, name, ns)
    if r is not None:
        return r
    raise ValueError("Cannot find xml child with name " + name)

def from_xml_opt_bytes(n: xml.Node, name: str, ns: ?str) -> ?bytes:
    try:
        text = get_xml_child(n, name, ns).text
        if text is not None:
            return base64.decode(text.encode())
    except ValueError:
        return None

def from_xml_bytes(n: xml.Node, name: str, ns: ?str) -> bytes:
    r = from_xml_opt_bytes(n, name, ns)
    if r is not None:
        return r
    raise ValueError("Cannot find xml child with name " + name)

def from_xml_opt_value(n: xml.Node, name: str, ns: ?str) -> ?value:
    try:
        t = get_xml_child(n, name, ns).text
        if isinstance(t, value):
            return t
    except ValueError:
        return None

def from_xml_value(n: xml.Node, name: str, ns: ?str) -> value:
    r = from_xml_opt_value(n, name, ns)
    if r is not None:
        return r
    raise ValueError("Cannot find xml child with name " + name)

# plural
def from_xml_opt_strs(n: xml.Node, name: str, ns: ?str) -> list[str]:
    res = []
    for child in get_xml_children(n, name, ns):
        ctext = child.text
        if ctext is not None:
            res.append(ctext)
    return res

def from_xml_opt_bytess(n: xml.Node, name: str, ns: ?str) -> list[bytes]:
    res = []
    for child in get_xml_children(n, name, ns):
        ctext = child.text
        if ctext is not None:
            res.append(base64.decode(ctext.encode()))
    return res

def from_xml_opt_values(n: xml.Node, name: str, ns: ?str) -> list[value]:
    res = []
    for child in get_xml_children(n, name, ns):
        ctext = child.text
        if isinstance(ctext, value):
            res.append(ctext)
    return res

def from_xml_opt_ints(n: xml.Node, name: str, ns: ?str) -> list[int]:
    res = []
    for child in get_xml_children(n, name, ns):
        ctext = child.text
        if ctext is not None:
            res.append(int(ctext))
    return res

#def from_xml_opt_u16(n: xml.Node, name: str) -> ?u16:
#    try:
#        return u16(get_xml_child_text(n, name))
#    except ValueError:
#        return None
#
#def from_xml_u16(n: xml.Node, name: str) -> u16:
#    return u16(get_xml_child_text(n, name))

def maybe_add(target: dict[str, value], key: str, val: ?value) -> None:
    if val is not None:
        target[key] = val

def take_json_opt_value(jd: dict[str, value], name: str, prefix: ?str=None) -> ?value:
    print("jd: ", jd)
    full_name = (prefix + ":" + name) if prefix is not None else name
    fname = jd.get(full_name)
    if fname is not None:
        print("fname: ", fname)
        return fname
    sname = jd.get(name)
    print("sname: ", sname)
    return sname

def take_json_value(jd: dict[str, value], name: str, prefix: ?str=None) -> value:
    full_name = (prefix + ":" + name) if prefix is not None else name
    val = take_json_opt_value(jd, name, prefix)
    if val is not None:
        return val
    raise ValueError("Cannot find json child with name " + full_name)

def take_json_opt_cnt(jd: dict[str, value], name: str, prefix: ?str=None) -> ?dict[str, value]:
    child = take_json_opt_value(jd, name, prefix)
    print("child: ", child)
    if child is not None:
        try:
            return unwrap_dict(child)
        except:
            raise ValueError("Expected a dictionary for " + name)
    return None

def take_json_cnt(jd: dict[str, value], name: str, prefix: ?str=None) -> dict[str, value]:
    val = take_json_opt_cnt(jd, name, prefix)
    if val is not None:
        return val
    raise ValueError("Cannot find json child with name " + name)

def take_json_opt_list(jd: dict[str, value], name: str, prefix: ?str=None) -> ?list[dict[str, value]]:
    child = take_json_opt_value(jd, name, prefix)
    if child is not None:
        try:
            return unwrap_list(child)
        except:
            raise ValueError("Expected a list for " + name)
    return None

def take_json_list(jd: dict[str, value], name: str, prefix: ?str=None) -> list[dict[str, value]]:
    val = take_json_opt_list(jd, name, prefix)
    if val is not None:
        return val
    raise ValueError("Cannot find json list with name " + name)

def take_json_opt_str(jd: dict[str, value], name: str, prefix: ?str=None) -> ?str:
    child = take_json_opt_value(jd, name, prefix)
    if child is not None:
        if isinstance(child, str):
            return child
        raise ValueError("Expected a string for " + name)
    return None

def take_json_str(jd: dict[str, value], name: str, prefix: ?str=None) -> str:
    val = take_json_opt_str(jd, name, prefix)
    if val is not None:
        return val
    raise ValueError("Cannot find json str child with name: " + name)

def take_json_strs(jd: dict[str, value], name: str, prefix: ?str=None) -> list[str]:
    child = take_json_opt_value(jd, name, prefix)
    if child is not None:
        if isinstance(child, list):
            if len(child) == 0:
                return []
            elem = child[0]
            if isinstance(elem, str):
                return child
            raise ValueError(name + "is a list of wrong type, should be str, not " + str(type(elem)))
        raise ValueError(name + "is not a list of strings")
    return []

def take_json_opt_int(jd: dict[str, value], name: str, prefix: ?str=None) -> ?int:
    child = take_json_opt_value(jd, name, prefix)
    if child is not None:
        if isinstance(child, int):
            return child
        raise ValueError("Expected an int for " + name)
    return None

def take_json_int(jd: dict[str, value], name: str, prefix: ?str=None) -> int:
    val = take_json_opt_int(jd, name, prefix)
    if val is not None:
        return val
    raise ValueError("Cannot find json int child with name " + name)

def take_json_ints(jd: dict[str, value], name: str, prefix: ?str=None) -> list[int]:
    child = take_json_opt_value(jd, name, prefix)
    if child is not None:
        if isinstance(child, list):
            if len(child) == 0:
                return []
            elem = child[0]
            if isinstance(elem, int):
                return child
            raise ValueError(name + "is a list of wrong type, should be int, not " + str(type(elem)))
        raise ValueError(name + "is not a list of ints")
    return []


def take_json_opt_bool(jd: dict[str, value], name: str, prefix: ?str=None) -> ?bool:
    child = take_json_opt_value(jd, name, prefix)
    if child is not None:
        if isinstance(child, bool):
            return child
        raise ValueError("Expected a bool for " + name)
    return None

def take_json_bool(jd: dict[str, value], name: str, prefix: ?str=None) -> bool:
    val = take_json_opt_bool(jd, name, prefix)
    if val is not None:
        return val
    raise ValueError("Cannot find json child with name " + name)

# --
def unwrap_dict(jd: value) -> dict[str, value]:
    """Unwrap an unknown JSON data structure to a dict or throw an error
    """
    if isinstance(jd, dict):
        if len(jd) == 0:
            res: dict[str, value] = {}
            return res
        key = next(jd.keys())
        if isinstance(key, str):
            return jd
    raise ValueError("Expected a dictionary with str keys")

def unwrap_list(jd: value) -> list[dict[str, value]]:
    """Unwrap an unknown JSON data structure to a list of dicts or throw an error
    """
    if isinstance(jd, list):
        if len(jd) == 0:
            res: list[dict[str, value]] = []
            return res
        elem = jd[0]
        if isinstance(elem, dict):
            key = next(elem.keys())
            if isinstance(key, str):
                return jd
    raise ValueError("Expected a list of dicts, got something else")


def _test_merge1():
    y1 = Container({
        "a": Leaf("int", 1),
        "l1": List(["name"], [
            Container({
                "n1": Leaf("int", 1),
                "n2": Leaf("int", 2)
            }, ["k1"]),
            Container({
                "n4": Leaf("int", 4),
            }, ["k4"]),
        ])
    }, ns="http://example.com/acme", module="acme")

    y2 = Container({
        "b": Leaf("int", 2),
        "c": Leaf("int", 3),
        "l1": List(["name"], [
            Container({
                "n1": Leaf("int", 1),
                "n3": Leaf("int", 3)
            }, ["k2"]),
        ]),
        "d": LeafList("str", ["a", "b", "c"])
    }, ns="http://example.com/acme", module="acme")

    res = merge(y1, y2)

    exp = Container({
        "a": Leaf("int", 1),
        "b": Leaf("int", 2),
        "c": Leaf("int", 3),
        "l1": List(["name"], [
            Container({
                "n1": Leaf("int", 1),
                "n2": Leaf("int", 2)
            }, ["k1"]),
            Container({
                "n1": Leaf("int", 1),
                "n3": Leaf("int", 3)
            }, ["k2"]),
            Container({
                "n4": Leaf("int", 4),
            }, ["k4"]),
        ]),
        "d": LeafList("str", ["a", "b", "c"])
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(res.prsrc(), exp.prsrc())

def _test_merge_list1():
    y1 = List(["name"], [
        Container({
            "n1": Leaf("int", 1)
        }, ["first"]),
        Container({
            "n1": Leaf("int", 1)
        }, ["breaker"]),
        Container({
            "n1": Leaf("int", 1)
        }, ["fourth"]),
        Container({
            "n2": Leaf("int", 2)
        }, ["common"]),
        Container({
            "n1": Leaf("int", 1)
        }, ["last"]),
    ], user_order=True, ns="http://example.com/acme", module="acme")

    y2 = List(["name"], [
        Container({}, ["breaker"]),
        Container({
            "n1": Leaf("int", 1)
        }, ["second"]),
        Container({
            "n1": Leaf("int", 1)
        }, ["third"]),
        Container({
            "n1": Leaf("int", 1)
        }, ["common"]),
        Container({}, ["last"])
    ], user_order=True, ns="http://example.com/acme", module="acme")

    exp = List(["name"], [
        Container({
            "n1": Leaf("int", 1)
        }, ["first"]),
        Container({
            "n1": Leaf("int", 1)
        }, ["breaker"]),
        Container({
            "n1": Leaf("int", 1)
        }, ["fourth"]),
        Container({
            "n2": Leaf("int", 2),
            "n1": Leaf("int", 1)
        }, ["common"]),
        Container({
            "n1": Leaf("int", 1)
        }, ["last"]),
        Container({
            "n1": Leaf("int", 1)
        }, ["second"]),
        Container({
            "n1": Leaf("int", 1)
        }, ["third"]),
    ], user_order=True, ns="http://example.com/acme", module="acme")

    testing.assertEqual(exp, merge(y1, y2))

def _test_eq_list():
    l1 = List(["name"], [
        Container({
            "x": Leaf("int", 1)
        }, ["a"]),
        Container({
            "x": Leaf("int", 2)
        }, ["b"])
    ])
    l2 = List(["name"], [
        Container({
            "x": Leaf("int", 2)
        }, ["b"]),
        Container({
            "x": Leaf("int", 1)
        }, ["a"])
    ])
    testing.assertEqual(l1, l1)
    testing.assertEqual(l1, l2)

def _test_eq_list_user_order():
    l1 = List(["name"], user_order=True, elements=[
        Container({
            "x": Leaf("int", 1)
        }, ["a"]),
        Container({
            "x": Leaf("int", 2)
        }, ["b"])
    ])
    l2 = List(["name"], user_order=True, elements=[
        Container({
            "x": Leaf("int", 2)
        }, ["b"]),
        Container({
            "x": Leaf("int", 1)
        }, ["a"])
    ])
    testing.assertEqual(l1, l1)
    testing.assertNotEqual(l1, l2)

def _test_vals_list_sorted():
    l1 = LeafList("str", ["a", "b", "c"])
    l2 = LeafList("str", ["c", "b", "a"])
    testing.assertEqual(l1.prsrc(), l1.prsrc())
    testing.assertEqual(l1.prsrc(), l2.prsrc())

def _test_eq_leaf_list_user_order():
    l1 = LeafList("str", ["a", "b", "c"], user_order=True)
    l2 = LeafList("str", ["c", "b", "a"], user_order=True)
    testing.assertEqual(l1, l1)
    testing.assertNotEqual(l1, l2)

def _test_diff_no_change():
    """In this test, old and new are identical. We expect diff to return None
    since there are no differences.
    """
    old = Container({
        "a": Leaf("int", 1),
        "b": Leaf("int", 2)
    }, ns="http://example.com/acme", module="acme")

    new = Container({
        "a": Leaf("int", 1),
        "b": Leaf("int", 2)
    }, ns="http://example.com/acme", module="acme")

    d = diff(old, new)
    testing.assertEqual(d, None)

def _test_diff_leaf_change():
    """Only one leaf changes its value. We expect diff to return a container
    with just that leaf changed.
    """
    old = Container({
        "a": Leaf("int", 1),
        "b": Leaf("int", 2)
    }, ns="http://example.com/acme", module="acme")

    new = Container({
        "a": Leaf("int", 42), # Changed from 1 to 42
        "b": Leaf("int", 2)
    }, ns="http://example.com/acme", module="acme")

    d = diff(old, new)

    exp = Container({
        "a": Leaf("int", 42)
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(d, exp)

def _test_diff_node_removal():
    """A node c is removed from old to new. We expect an Absent() node in the
    diff at the place where c was.
    """
    old = Container({
        "a": Leaf("int", 1),
        "c": Leaf("int", 3),
        "d": Leaf("int", 4)
    }, ns="http://example.com/acme", module="acme")

    new = Container({
        "a": Leaf("int", 1),
        "d": Leaf("int", 4)
    }, ns="http://example.com/acme", module="acme")

    d = diff(old, new)

    # c is removed
    exp = Container({
        "c": Absent()
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(d, exp)

def _test_diff_elem_removal():
    """A list element k1 is removed from old to new. We expect an Absent(["k1"])
    node in the diff at the place where k1 was.
    """
    old = List(["name"], [
        Container({
            "n1": Leaf("int", 1),
            "n2": Leaf("int", 2)
        }, ["k1"]),
        Container({
            "n4": Leaf("int", 4),
        }, ["k4"]),
    ], ns="http://example.com/acme", module="acme")

    new = List(["name"], [
        Container({
            "n4": Leaf("int", 4),
        }, ["k4"]),
    ], ns="http://example.com/acme", module="acme")

    d = diff(old, new)

    # k1 is removed
    exp = List(["name"], [
        Absent(["k1"]),
    ], ns="http://example.com/acme", module="acme")

    testing.assertEqual(d, exp)

def _test_diff_node_addition():
    """A new node e is added in new. We expect the diff to have that new node.
    """
    old = Container({
        "a": Leaf("int", 1)
    }, ns="http://example.com/acme", module="acme")

    new = Container({
        "a": Leaf("int", 1),
        "e": Leaf("int", 5)
    }, ns="http://example.com/acme", module="acme")

    d = diff(old, new)

    # e is new
    exp = Container({
        "e": Leaf("int", 5)
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(d, exp)

def _test_diff_leaflist():
    """Testing differences in a leaf-list. One value changes and one is
    added.
    """
    old = Container({
        "l": LeafList("str", ["a", "b", "c"])
    }, ns="http://example.com/acme", module="acme")

    new = Container({
        "l": LeafList("str", ["a", "x", "c", "d"]) # "b" changed to "x" and "d" added
    }, ns="http://example.com/acme", module="acme")

    d = diff(old, new)

    exp = Container({
        "l": LeafList("str", ["a", "x", "c", "d"])
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(d, exp)

def _test_diff_complex_ordering():
    """A more complex scenario where the old container has nodes [a, b, c] and
    the new container has [a, c, d]. We expect the absent node b to appear
    before the new node d in the diff.
    """
    old = Container({
        "a": Leaf("int", 1),
        "b": Leaf("int", 2),
        "c": Leaf("int", 3)
    }, ns="http://example.com/acme", module="acme")

    new = Container({
        "a": Leaf("int", 1),
        "c": Leaf("int", 3),
        "d": Leaf("int", 4)
    }, ns="http://example.com/acme", module="acme")

    d = diff(old, new)

    # "b" is absent before "d" is introduced
    exp = Container({
        "b": Absent(),
        "d": Leaf("int", 4)
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(d, exp)

def _test_patch_no_change():
    old = Container({
        "a": Leaf("int", 1),
        "b": Leaf("int", 2),
    }, ns="http://example.com/acme", module="acme")

    # diff is None means no changes
    p = None

    res = patch(old, p)
    testing.assertEqual(res, old)

def _test_patch_leaf_change():
    old = Container({
        "a": Leaf("int", 1),
        "b": Leaf("int", 2),
    }, ns="http://example.com/acme", module="acme")

    # Suppose we want to change leaf 'a' from 1 to 42
    # diff would look like this:
    p = Container({
        "a": Leaf("int", 42),
    }, ns="http://example.com/acme", module="acme")

    res = patch(old, p)
    exp = Container({
        "a": Leaf("int", 42),
        "b": Leaf("int", 2),
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(res, exp)

def _test_patch_node_removal():
    old = Container({
        "a": Leaf("int", 1),
        "c": Leaf("int", 3),
    }, ns="http://example.com/acme", module="acme")

    # Suppose we remove 'c'
    # patch would be:
    p = Container({
        "c": Absent()
    }, ns="http://example.com/acme", module="acme")

    res = patch(old, p)
    exp = Container({
        "a": Leaf("int", 1),
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(res, exp)

def _test_patch_elem_removal():
    old = List(["name"], [
        Container({
            "n1": Leaf("int", 1),
            "n2": Leaf("int", 2)
        }, ["k1"]),
        Container({
            "n4": Leaf("int", 4),
        }, ["k4"]),
    ], ns="http://example.com/acme", module="acme")

    # Suppose we remove 'k1'
    # patch would be:
    p = List(["name"], [
        Absent(["k1"]),
    ], ns="http://example.com/acme", module="acme")

    res = patch(old, p)
    exp = List(["name"], [
        Container({
            "n4": Leaf("int", 4),
        }, ["k4"]),
    ], ns="http://example.com/acme", module="acme")

    testing.assertEqual(res, exp)

def _test_patch_elem_removal2():
    old = Container({
        "n1": Leaf("int", 1),
        "n2": Leaf("int", 2)
    }, ["k1"])

    p = Absent(["k1"])

    res = patch(old, p)

    testing.assertEqual(res, None)

def _test_patch_node_addition():
    old = Container({
        "a": Leaf("int", 1),
    }, ns="http://example.com/acme", module="acme")

    # Add a new leaf 'e':
    p = Container({
        "e": Leaf("int", 5)
    }, ns="http://example.com/acme", module="acme")

    res = patch(old, p)
    exp = Container({
        "a": Leaf("int", 1),
        "e": Leaf("int", 5),
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(res, exp)

def _test_patch_complex_ordering():
    # old: a, b, c
    old = Container({
        "a": Leaf("int", 1),
        "b": Leaf("int", 2),
        "c": Leaf("int", 3),
    }, ns="http://example.com/acme", module="acme")

    # new: a, c, d
    # diff: remove b, add d
    p = Container({
        "b": Absent(),
        "d": Leaf("int", 4)
    }, ns="http://example.com/acme", module="acme")

    res = patch(old, p)
    exp = Container({
        "a": Leaf("int", 1),
        "c": Leaf("int", 3),
        "d": Leaf("int", 4),
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(res, exp)

def _test_patch_leaflist():
    old = Container({
        "l": LeafList("str", ["a", "b", "c"])
    }, ns="http://example.com/acme", module="acme")

    # new: l = [a, x, c, d]
    # diff would be a leaflist replace:
    p = Container({
        "l": LeafList("str", ["a", "x", "c", "d"])
    }, ns="http://example.com/acme", module="acme")

    res = patch(old, p)
    exp = Container({
        "l": LeafList("str", ["a", "x", "c", "d"])
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(res, exp)

def _test_diff_and_patch_large_tree():
    # Construct a large 'old' data tree under a Container node
    old = Container({
        "mod1": Container(children={
            "conf": Container(children={
                "settings": Container({
                    "hostname": Leaf("str", "old-router"),
                    "motd": Leaf("str", "Welcome!")
                }),
                "interfaces": List(["name"], elements=[
                    Container({
                        "desc": Leaf("str", "Uplink interface"),
                        "enabled": Leaf("bool", True)
                    }, ["eth0"]),
                    Container({
                        "desc": Leaf("str", "Internal interface"),
                        "enabled": Leaf("bool", True)
                    }, ["eth1"]),
                ])
            }, ns="http://example.com/yang/mod1", module="mod1")
        }),
        "mod2": Container(children={
            "acl": Container(children={
                "rules": List(["id"], elements=[
                    Container({
                        "action": Leaf("str", "permit"),
                        "src": Leaf("str", "10.0.0.0/24"),
                        "dst": Leaf("str", "10.0.1.0/24"),
                    }, ["10"]),
                    Container({
                        "action": Leaf("str", "deny"),
                        "src": Leaf("str", "any"),
                        "dst": Leaf("str", "any"),
                    }, ["20"]),
                ])
            }, ns="http://example.com/yang/mod2", module="mod2")
        }),
    })

    # Construct a large 'new' data tree under a Container node
    # Changes from old:
    # - hostname changed from "old-router" to "new-router"
    # - motd removed
    # - eth1 is removed
    # - a new interface eth2 is added
    # - mod2 acl rule 20 changes action from deny to drop
    # - a new acl rule 30 is added
    # - add a LeafList in settings "ntp-servers"
    new = Container(children={
        "mod1": Container(children={
            "conf": Container(children={
                "settings": Container(children={
                    "hostname": Leaf("str", "new-router"),
                    # motd removed
                    "ntp-servers": LeafList("str", ["192.168.100.1", "192.168.100.2"])
                }),
                "interfaces": List(["name"], elements=[
                    Container({
                        "desc": Leaf("str", "Uplink interface"),
                        "enabled": Leaf("bool", True)
                    }, ["eth0"]),
                    # eth1 removed
                    Container({
                        "desc": Leaf("str", "DMZ interface"),
                        "enabled": Leaf("bool", False)
                    }, ["eth2"]),
                ])
            }, ns="http://example.com/yang/mod1", module="mod1")
        }),
        "mod2": Container(children={
            "acl": Container(children={
                "rules": List(["id"], elements=[
                    Container({
                        "action": Leaf("str", "permit"),
                        "src": Leaf("str", "10.0.0.0/24"),
                        "dst": Leaf("str", "10.0.1.0/24"),
                    }, ["10"]),
                    Container({
                        "action": Leaf("str", "drop"),  # changed from deny
                        "src": Leaf("str", "any"),
                        "dst": Leaf("str", "any"),
                    }, ["20"]),
                    Container({
                        "action": Leaf("str", "permit"),
                        "src": Leaf("str", "192.0.2.0/24"),
                        "dst": Leaf("str", "198.51.100.0/24"),
                    }, ["30"]),
                ])
            }, ns="http://example.com/yang/mod2", module="mod2")
        })
    })

    # Compute diff
    d = diff(old, new)

    # Check that patching old with d results in new
    res = patch(old, d)
    if res != None:
        testing.assertEqual(res.prsrc(), new.prsrc())

    # Also check that if we apply diff(new, old), and patch(new, diff(new, old)) we get old back.
    # This ensures round-trip behavior.
    #d2 = diff(new, old)
    #res2 = patch(new, d2)
    #testing.assertEqual(res2, old)

def _test_prsrc():
    y1 = Container({
        "foo": Container({
            "a": Leaf("int", 1),
            "l1": List(["name"], [
                Container({
                    "n1": Leaf("int", 1),
                    "n2": Leaf("int", 2)
                }, ["k1"]),
                Container({
                    "n4": Leaf("int", 4),
                }, ["k4"]),
            ])
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.prsrc()

def _test_prsrc_absent():
    y1 = Container({
        "foo": Container({
            "a": Absent(),
            "l1": List(["name"], [
                Absent(["k1"]),
                Container({
                    "n4": Leaf("int", 4),
                }, ["k4"]),
            ])
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.prsrc()

def _test_prsrc_root():
    y1 = Container({
        "foo": Container({
            "a": Leaf("int", 1),
            "b": LeafList("str", ["a", "b", "c"]),
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.prsrc()

def _test_prsrc_leaf_ns():
    y1 = Container({
        "foo": Container({
            "a": Leaf("int", 1, ns="http://example.com/foo", module="foo"),
            "b": Leaf("int", 2)
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.prsrc()

def _test_to_json():
    y1 = Container({
        "acme:foo": Container({
            "a": Leaf("int", 1),
            "l1": List(["name", "name_two"], [
                Container({
                    "n1": Leaf("int", 1),
                    "n2": Leaf("int", 2)
                }, ["k1", "k1a"]),
                Container({
                    "n4": Leaf("int", 4),
                }, ["k4", "k4a"]),
            ]),
            "b": Leaf("bool", False),
            "lb": Leaf("binary", b"Hello Acton \xf0\x9f\xab\xa1"),
            "llb": LeafList("binary", [b"Hello Acton \xf0\x9f\xab\xa1"]),
            "c": Leaf("uint64", 18446744073709551615),
        }, ns="http://example.com/acme", module="acme"),
        "beep:foo": Container({
            "a": Leaf("int", 1)
        }, ns="http://example.com/beep", module="beep")
    })

    return y1.to_json(pretty=True)

def _test_to_xmlstr():
    y1 = Container({
        "acme:foo": Container({
            "a": Leaf("int", 1),
            "l1": List(["name", "name_two"], [
                Container({
                    "n1": Leaf("int", 1),
                    "n2": Leaf("int", 2)
                }, ["k1", "k1a"]),
                Container({
                    "n4": Leaf("int", 4),
                }, ["k4", "k4a"]),
            ]),
            "b": Leaf("bool", False),
            "lb": Leaf("binary", b"Hello Acton \xf0\x9f\xab\xa1"),
            "llb": LeafList("binary", [b"Hello Acton \xf0\x9f\xab\xa1"]),
            "c": Leaf("uint64", 18446744073709551615),
        }, ns="http://example.com/acme", module="acme"),
        "beep:foo": Container({
            "a": Leaf("int", 1)
        }, ns="http://example.com/beep", module="beep")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_root():
    y1 = Container({
        "foo": Container({
            "a": Leaf("int", 1),
            "b": LeafList("binary", ["a", "b", "c"]),
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_module():
    y1 = Container({
        "foo": Container({
            "a": Leaf("int", 1),
            "b": LeafList("str", ["a", "b", "c"]),
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_leaf_ns():
    y1 = Container({
        "foo": Container({
            "a": Leaf("int", 1, ns="http://example.com/foo", module="foo"),
            "b": Leaf("int", 2)
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_mixed():
    y1 = Container({
        "device": List(["name"], [
            Container({
                "config": Container({
                    "hostname": Container({
                        "system-network-name": Leaf("str", "dev1")
                    }, ns="http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg")
                }),
            }, ["dev1"]),
            Container({
                "config": Container({
                    "hostname": Container({
                        "system-network-name": Leaf("str", "dev2")
                    }, ns="http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg")
                }),
            }, ["dev2"]),
        ], ns="http://orchestron.org/yang/orchestron-device.yang")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_root_merge():
    y1 = Container({
        "foo": Container({
            "a": Leaf("int", 1),
            "b": LeafList("str", ["a", "b", "c"]),
        }, ns="http://example.com/acme", module="acme")
    })
    y2 = Container({
        "bar": Container({
            "b": Leaf("int", 42),
        }, ns="http://example.com/bar", module="bar")
    })
    ym = merge(y1, y2)

    return ym.to_xmlstr()

def _test_to_xmlstr_presence():
    y1 = Container({
        "foo": Container({
            "a": Leaf("int", 1)
        }, presence=True, ns="http://example.com/acme", module="acme")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_presence_childless():
    y1 = Container({
        "foo": Container(presence=True, ns="http://example.com/acme", module="acme")
    })

    return y1.to_xmlstr()
