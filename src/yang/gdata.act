import base64
import testing
import json
import xml

from yang.identityref import Identityref, PartialIdentityref
from yang.type import Decimal

"""YANG data

This module defines classes for YANG data nodes. It can represent a YANG data
tree, and can be used to serialize and deserialize YANG data.
"""

# kinds of things?
# - container
# - list
# - list element
# - leaf
# - leaf-list
#
# TODO: for ordered-by user lists, we need to expose a way to influence the order of elements

# Can we simply use the order of elements in the input list to control the order in the output?
#
# ACL1 which allows SSH and rejects everything else
# <acls>
#   <acl>
#     <aces>
#       <ace>
#         <name>SSH</name>
#         <action>permit</action>
#         <matches>
#           <ipv4>
#             <source-ipv4-network>192.0.2.0/24</source-ipv4-network>
#           </ipv4>
#           <protocol>tcp</protocol>
#           <tcp>
#             <destination-port>
#               <operator>eq</operator>
#               <port>22</port>
#             </destionation-port>
#           </tcp>
#         </matches>
#       </ace>
#       <ace>
#         <name>DROP</name>
#         <action>drop</action>
#       </ace>
#     </aces>
#   </acl>
# </acls>
#
# ACL2 which allows BGP and rejects everything else
# <acls>
#   <acl>
#     <aces>
#       <ace>
#         <name>BGP-PASSIVE</name>
#         <action>permit</action>
#         <src-port>179</src-port>
#         <matches>
#           <protocol>tcp</protocol>
#           <tcp>
#             <destination-port>
#               <operator>eq</operator>
#               <port>179</port>
#             </destionation-port>
#           </tcp>
#         </matches>
#       </ace>
#       <ace>
#         <name>DROP</name>
#       </ace>
#     </aces>
#   </acl>
# </acls>
#
# And the merged result should be:
#
# <acls>
#   <acl>
#     <aces>
#       <ace>
#         <name>SSH</name>
#         <action>permit</action>
#         <matches>
#           <ipv4>
#             <source-ipv4-network>192.0.2.0/24</source-ipv4-network>
#           </ipv4>
#           <protocol>tcp</protocol>
#           <tcp>
#             <destination-port>
#               <operator>eq</operator>
#               <port>22</port>
#             </destionation-port>
#           </tcp>
#         </matches>
#       </ace>
#       <ace>
#         <name>BGP-PASSIVE</name>
#         <action>permit</action>
#         <src-port>179</src-port>
#         <matches>
#           <protocol>tcp</protocol>
#           <tcp>
#             <destination-port>
#               <operator>eq</operator>
#               <port>179</port>
#             </destionation-port>
#           </tcp>
#         </matches>
#       </ace>
#       <ace>
#         <name>DROP</name>
#         <action>drop</action>
#       </ace>
#     </aces>
#   </acl>
# </acls>
#

#
#
# ACL1 which allows SSH and rejects everything else
#   <acl>
#       <ace>
#         <name>SSH</name>
#         <action>permit</action>
#         <matches>...</matches>
#       </ace>
#       <ace>
#         <name>DROP</name>
#         <action>drop</action>
#       </ace>
#   </acl>
#
# ACL2 which allows BGP and rejects everything else
#   <acl>
#       <ace>
#         <name>BGP-PASSIVE</name>
#         <action>permit</action>
#         <matches>...</matches>
#       </ace>
#       <ace>
#         <name>DROP</name>
#       </ace>
#   </acl>
#
# And the merged result should be:
#
#   <acl>
#       <ace>
#         <name>SSH</name>
#         <action>permit</action>
#         <matches>...</matches>
#       </ace>
#       <ace>
#         <name>BGP-PASSIVE</name>
#         <action>permit</action>
#         <matches>... </matches>
#       </ace>
#       <ace>
#         <name>DROP</name>
#         <action>drop</action>
#       </ace>
#   </acl>
#
# In the merge, we cannot know if SSH should come before or after BGP-PASSIVE,
# but it dosen't matter. The only important thing is that both are before the
# DROP rule. We make sure of this by stating in both input ACLs that DROP should
# be last. Note how in ACL2 the DROP ace is not complete, it just contains the
# name and nothing else. This is fine because the merge function will take the
# complete ACE from ACL1 and merge it with the incomplete ACE from ACL2 to
# produce a complete output.

def _ind(n):
    return "  " * n

remove_op = (nsdefs=[("xc", "urn:ietf:params:xml:ns:netconf:base:1.0")], attrs=[("xc:operation", "remove")])
create_op = (nsdefs=[("xc", "urn:ietf:params:xml:ns:netconf:base:1.0")], attrs=[("xc:operation", "create")])
delete_op = (nsdefs=[("xc", "urn:ietf:params:xml:ns:netconf:base:1.0")], attrs=[("xc:operation", "delete")])
replace_op = (nsdefs=[("xc", "urn:ietf:params:xml:ns:netconf:base:1.0")], attrs=[("xc:operation", "replace")])


def _nsq(node_ns, v: ?value=None):
    r = []
    if node_ns is not None:
        r.append((None, node_ns))
    if isinstance(v, Identityref):
        r.append((v.mod, v.ns))
    return r


def yang_str(v) -> str:
    if isinstance(v, bytes):
        s = base64.encode(v).decode()
        return s
    if isinstance(v, Identityref):
        s = "{v.mod}:{v.val}"
        return s
    s = str(v)
    if isinstance(v, bool):
        s = s.lower()
    return s


def json_val(v: value) -> ?value:
    if isinstance(v, bytes):
        return base64.encode(v).decode()
    if isinstance(v, Identityref):
        return "{v.mod}:{v.val}"
    if isinstance(v, Decimal):
        return str(v)
    return v


def fmt_json_name(name: Id, module=None):
    if module is not None:
        return "{module}:{name.name}"
    return name.name


def repr_gdata(v) -> str:
    # Include explicit casts for integer values to preserve types in "value"
    if isinstance(v, u64):
        return "u64({v})"
    elif isinstance(v, list):
        return "[" + ", ".join([repr_gdata(e) for e in v]) + "]"
    return repr(v)


def repr_adata(v) -> str:
    if isinstance(v, Present):
        return "True"
    return repr_gdata(v)


class Id:
    def __init__(self, q: str, name: str):
        self.q = q
        self.name = name

    def __str__(self):
        return "{self.name}#{self.q}"

    def __repr__(self):
        return "Id({repr(self.q)}, {repr(self.name)})"


# We can't implement both Ord and Hashable protocol?!
# https://github.com/actonlang/acton/pull/2380#issuecomment-3092550729
# Until that is adressed, we have hack_sorted function so sort a list of Id objects
#extension Id (Ord):
#    def __lt__(self, other: Id):
#        return self.q < other.q or (self.q == other.q and self.name < other.name)

def hack_sorted[T](li: Iterator[T]) -> list[T]:
    l = list(li)
    ls = list(map(str, l))
    key_map = dict(zip(ls, l))
    return [key_map[key] for key in sorted(ls)]


# This is a shim to do equality comparison on lists with elements where we can't implement Ord
def hack_eq[T(Eq)](l1: list[T], l2: list[T]) -> bool:
    if len(l1) != len(l2):
        return False
    for i in range(len(l1)):
        if l1[i] != l2[i]:
            return False
    return True


extension Id (Hashable):
    def __eq__(self, other: Id):
        return self.q == other.q and self.name == other.name

    def hash(self, hasher):
        self.q.hash(hasher)
        self.name.hash(hasher)


class Node(value):
    ns: ?str
    module: ?str
    children: dict[Id, Node]
    txid: ?str

    def __repr__(self) -> str:
        return self.prsrc(deterministic=False)

    def key_str(self, key_names: list[Id]) -> str:
        return ",".join([str(self.get_leaf(kn).val).replace(",", "\\,") for kn in key_names])

    def key_values(self, key_names: list[Id]) -> dict[str, value]:
        return {kn.name: self.get_leaf(kn).val for kn in key_names}

    def key_children(self, key_names: list[Id]) -> dict[Id, Leaf]:
        return {kn: self.get_leaf(kn) for kn in key_names}

    pure def prsrc(self, deterministic=False, indent=0) -> str:
        """Get the Acton source code representation of the node

        Returns a string representation of this node that can be used to recreate
        the same data structure in Acton code. This is useful for debugging and
        testing.

        The deterministic output mode reorders children along with
        system-ordered leaf-list and list elements in order to render
        deterministic output which is very useful for testing. Only user-ordered
        lists and leaf-lists have semantic meaning, for non-user-ordered lists,
        the order of elements has no meaning which is why we can reorder them
        for deterministic output. The default is to produce raw
        non-deterministic output, which is more true to nature and a better
        representation for debugging.
        """
        ns_args = ["ns='{self.ns}'"] if self.ns is not None else []
        module_args = ["module='{self.module}'"] if self.module is not None else []
        base_args = ns_args + module_args

        if deterministic:
            self_children = {k: self.children[k] for k in hack_sorted(self.children.keys())}
        else:
            self_children = self.children

        if isinstance(self, Leaf):
            args = [repr_gdata(self.val)] + base_args
            return "Leaf({", ".join(args)})"
        elif isinstance(self, LeafList):
            # Only sort if deterministic=True and not user_order
            vals_str = repr_gdata(self.vals if (self.user_order or not deterministic) else vals_list_sorted(self.vals))
            order_args = ["user_order=True"] if self.user_order else []
            args = [vals_str] + base_args + order_args
            return "LeafList({", ".join(args)})"
        elif isinstance(self, Absent):
            sname = "Absent"
            if len(self_children) == 0:
                return "{sname}({", ".join(base_args)})"
            else:
                child_strs = ["{_ind(indent+1)}{repr(nm)}: {child.prsrc(deterministic, indent+1)}"
                             for nm,child in self_children.items()]
                args_str = ", {", ".join(base_args)}" if len(base_args) > 0 else ""
                return "\n".join([
                    sname + r"({",
                    ",\n".join(child_strs),
                    "{_ind(indent)}}}{args_str})"
                ])
        elif isinstance(self, Delete):
            sname = "Delete"
            if len(self_children) == 0:
                return "{sname}({", ".join(base_args)})"
            else:
                child_strs = ["{_ind(indent+1)}{repr(nm)}: {child.prsrc(deterministic, indent+1)}"
                             for nm,child in self_children.items()]
                args_str = ", {", ".join(base_args)}" if len(base_args) > 0 else ""
                return "\n".join([
                    sname + r"({",
                    ",\n".join(child_strs),
                    "{_ind(indent)}}}{args_str})"
                ])
        elif isinstance(self, List):
            keys_arg = [repr(self.keys)]
            order_args = ["user_order=True"] if self.user_order else []
            args = keys_arg + base_args + order_args
            if len(self.elements) == 0:
                return "List({", ".join(args)})"
            else:
                # Only sort if deterministic=True and not user_order
                elems = self.elements if (self.user_order or not deterministic) else sorted_elements(self.elements, self.keys)
                elem_strs = [_ind(indent+1) + elem.prsrc(deterministic, indent+1) for elem in elems]
                args_with_elements = args + ["elements=["]
                return "\n".join([
                    "List({", ".join(args_with_elements)}",
                    ",\n".join(elem_strs),
                    _ind(indent) + "])"
                ])
        elif isinstance(self, Container):
            sname = "Container"
            presence_args = ["presence=True"] if self.presence else []
            args = presence_args + base_args
            if len(self_children) == 0:
                return "{sname}({", ".join(args)})"
            else:
                child_strs = ["{_ind(indent+1)}{repr(nm)}: {child.prsrc(deterministic, indent+1)}"
                             for nm,child in self_children.items()]
                args_str = ", {", ".join(args)}" if len(args) > 0 else ""
                return "\n".join([
                    sname + r"({",
                    ",\n".join(child_strs),
                    "{_ind(indent)}}}{args_str})"
                ])
        elif isinstance(self, CreateLeaf):
            sname = "CreateLeaf"
            args = [repr_gdata(self.val)] + base_args
            return "{sname}({", ".join(args)})"
        elif isinstance(self, Create):
            sname = "Create"
            args = base_args
            if len(self_children) == 0:
                return "{sname}({", ".join(args)})"
            else:
                child_strs = ["{_ind(indent+1)}{repr(nm)}: {child.prsrc(deterministic, indent+1)}"
                             for nm,child in self_children.items()]
                args_str = ", {", ".join(args)}" if len(args) > 0 else ""
                return "\n".join([
                    sname + r"({",
                    ",\n".join(child_strs),
                    "{_ind(indent)}}}{args_str})"
                ])
        elif isinstance(self, ReplaceLeaf):
            sname = "ReplaceLeaf"
            args = [repr_gdata(self.val)] + base_args
            return "{sname}({", ".join(args)})"
        elif isinstance(self, Replace):
            sname = "Replace"
            args = base_args
            if len(self_children) == 0:
                return "{sname}({", ".join(args)})"
            else:
                child_strs = ["{_ind(indent+1)}{repr(nm)}: {child.prsrc(deterministic, indent+1)}"
                             for nm,child in self_children.items()]
                args_str = ", {", ".join(args)}" if len(args) > 0 else ""
                return "\n".join([
                    sname + r"({",
                    ",\n".join(child_strs),
                    "{_ind(indent)}}}{args_str})"
                ])
        else:
            raise ValueError("Unsupported node type in prsrc")

    def to_jsonstr(self, pretty=True, deterministic=False) -> str:
        """Convert gdata to JSON.

        When deterministic=True, node children are emitted in sorted order
        and system-ordered lists and leaf-lists elements are sorted. This makes
        the output stable for comparisons/tests.
        """
        return json.encode(self.to_dict(pretty, deterministic), pretty=pretty)

    def to_dict(self, pretty=True, deterministic=False) -> dict[str, ?value]:
        """Convert gdata to a dict, suitable for JSON serialization.

        When deterministic=True, node children are emitted in sorted order
        and system-ordered lists and leaf-lists elements are sorted. This makes
        the output stable for comparisons/tests.
        """
        if deterministic:
            self_children = {k: self.children[k] for k in hack_sorted(self.children.keys())}
        else:
            self_children = self.children

        if isinstance(self, Container):
            child_dict = {}
            for nm,child in self_children.items():
                if isinstance(child, Container):
                    child_dict[fmt_json_name(nm, child.module)] = child.to_dict(pretty, deterministic)
                elif isinstance(child, Leaf):
                    v = child.val
                    # "empty" type is encoded as an array with a null element "[null]"
                    if isinstance(v, Present):
                        child_dict[fmt_json_name(nm, child.module)] = [None]
                    elif v is not None and not isinstance(v, Absent):
                        # Absent - value for unset empty leaf
                        child_dict[fmt_json_name(nm, child.module)] = json_val(v)
                elif isinstance(child, LeafList):
                    vals = []
                    for v in child.vals if child.user_order or not deterministic else vals_list_sorted(child.vals):
                        vals.append(json_val(v))
                    child_dict[fmt_json_name(nm, child.module)] = vals
                elif isinstance(child, List):
                    elems = []
                    if child.user_order or not deterministic:
                        iter_elems = child.elements
                    else:
                        iter_elems = sorted_elements(child.elements, child.keys)
                    for elem in iter_elems:
                        if isinstance(elem, Container):
                            elems.append(elem.to_dict(pretty, deterministic))
                        elif isinstance(elem, Absent):
                            continue
                        else:
                            raise ValueError("Unexpected list ({nm}) element type: {type(elem)}")
                    child_dict[fmt_json_name(nm, child.module)] = elems
                elif isinstance(child, Absent):
                    continue
                else:
                    raise ValueError("Unsupported child ({nm}) node type in to_dict: {type(child)}")
            return child_dict
        raise ValueError("Unsupported node type in to_dict: {type(self)}")

    def _to_xml_rec(self, key_names: ?list[Id]=None, skip_nonkeys: bool=False, parent_absent: bool=False, deterministic=False) -> list[xml.Node]:
        if isinstance(self, Container) or isinstance(self, Absent) or isinstance(self, Create) or isinstance(self, Delete) or isinstance(self, Replace):
            if deterministic:
                self_children = {k: self.children[k] for k in hack_sorted(self.children.keys())}
            else:
                self_children = self.children
            children = []
            if key_names is not None:
                if skip_nonkeys:
                    iter_children = iter(key_names)
                else:
                    iter_children = iter(key_names + [nm for nm in self_children.keys() if nm not in key_names])
            else:
                iter_children = self_children.keys()
            for name in iter_children:
                child = self_children[name]
                if parent_absent and not isinstance(child, List):
                    continue
                local_name = name.name
                if isinstance(child, Container):
                    cchildren = child._to_xml_rec(deterministic=deterministic)
                    if len(cchildren) > 0:
                        children.append(xml.Node(local_name, nsdefs=_nsq(child.ns), children=cchildren))
                    elif isinstance(self, Container) and child.presence:
                        children.append(xml.Node(local_name, nsdefs=_nsq(child.ns)))

                elif isinstance(child, List):
                    for elem in child.elements if child.user_order or not deterministic else sorted_elements(child.elements, child.keys):
                        # Determine NETCONF operation for list element based on node type
                        skip_nonkeys = False
                        if isinstance(elem, Absent) or parent_absent:
                            attrs = remove_op
                            skip_nonkeys = True
                        elif isinstance(elem, Delete):
                            attrs = delete_op
                            skip_nonkeys = True
                        elif isinstance(elem, Create):
                            attrs = create_op
                        elif isinstance(elem, Replace):
                            attrs = replace_op
                        else:
                            attrs = (nsdefs=[], attrs=[])
                        children.append(xml.Node(local_name, nsdefs=_nsq(child.ns) + attrs.nsdefs, attributes=attrs.attrs, children=elem._to_xml_rec(child.keys, skip_nonkeys, deterministic=deterministic)))
                elif isinstance(child, Leaf):
                    v = child.val
                    if isinstance(v, Present):
                        children.append(xml.Node(local_name, nsdefs=_nsq(child.ns)))
                    elif v is not None and not isinstance(v, Absent):
                        # Absent - value for unset empty leaf
                        children.append(xml.Node(local_name, nsdefs=_nsq(child.ns, child.val), text=yang_str(v)))
                    else:
                        children.append(xml.Node(local_name, nsdefs=_nsq(child.ns) + remove_op.nsdefs, attributes=remove_op.attrs))
                elif isinstance(child, CreateLeaf):
                    v = child.val
                    if isinstance(v, Present):
                        children.append(xml.Node(local_name, nsdefs=_nsq(child.ns) + create_op.nsdefs, attributes=create_op.attrs))
                    else:
                        children.append(xml.Node(local_name, nsdefs=_nsq(child.ns, v) + create_op.nsdefs, attributes=create_op.attrs, text=yang_str(v)))
                elif isinstance(child, ReplaceLeaf):
                    v = child.val
                    if isinstance(v, Present):
                        children.append(xml.Node(local_name, nsdefs=_nsq(child.ns) + replace_op.nsdefs, attributes=replace_op.attrs))
                    else:
                        children.append(xml.Node(local_name, nsdefs=_nsq(child.ns, v) + replace_op.nsdefs, attributes=replace_op.attrs, text=yang_str(v)))
                elif isinstance(child, LeafList):
                    vals = []
                    for val in child.vals if child.user_order or not deterministic else vals_list_sorted(child.vals):
                        v = yang_str(val)
                        vals.append(xml.Node(local_name, nsdefs=_nsq(child.ns, val), text=v))
                    children.extend(vals)
                elif isinstance(child, Create):
                    # Render as element with create op, include children
                    children.append(xml.Node(local_name, nsdefs=_nsq(child.ns) + create_op.nsdefs, attributes=create_op.attrs, children=child._to_xml_rec(deterministic=deterministic)))
                elif isinstance(child, Replace):
                    # Render as element with replace op, include children
                    children.append(xml.Node(local_name, nsdefs=_nsq(child.ns) + replace_op.nsdefs, attributes=replace_op.attrs, children=child._to_xml_rec(deterministic=deterministic)))
                elif isinstance(child, Delete):
                    # Render as element with delete op
                    children.append(xml.Node(local_name, nsdefs=_nsq(child.ns) + delete_op.nsdefs, attributes=delete_op.attrs))
                elif isinstance(child, Absent):
                    # Render as element with remove op, unless the children are rendered explicitly (list)
                    cchildren = child._to_xml_rec(parent_absent=True, deterministic=deterministic)
                    if len(cchildren) > 0:
                        children.extend(cchildren)
                    else:
                        children.append(xml.Node(local_name, nsdefs=_nsq(child.ns) + remove_op.nsdefs, attributes=remove_op.attrs))
                else:
                    raise ValueError("Unsupported child ({name}) node type in to_xml: {type(child)}")
            return children
        raise ValueError("Unsupported node type in to_xml: {type(self)}")

    def to_xml(self, deterministic=False) -> list[xml.Node]:
        """Convert this gdata node to a list of xml.Node.

        The top-level node in a valid gdata structure is an unnamed container
        with named children. But in a valid XML document there must be a single
        top-level element. Thus we return a list of xml.Node fragments, one for
        each of the top-level gdata Container children.

        When deterministic=True, node children are emitted in sorted order
        and system-ordered lists and leaf-lists elements are sorted. This makes
        the output stable for comparisons/tests."""
        return self._to_xml_rec(deterministic=deterministic)

    def to_xmlstr(self, pretty=True, deterministic=False) -> str:
        """Convert this gdata node to an XML string.

        The result is a joined XML string of all the fragments, one for each of
        the top-level gdata Container children.

        When deterministic=True, node children are emitted in sorted order
        and system-ordered lists and leaf-lists elements are sorted. This makes
        the output stable for comparisons/tests."""
        return xml.encode_nodes(self.to_xml(deterministic), pretty)

    # --
    def get_leaf(self, name) -> Leaf:
        l = self.get_opt_leaf(name)
        if l is not None:
            return l
        raise ValueError("Cannot find leaf child in {self} with name: {name}")

    def get_opt_leaf(self, name) -> ?Leaf:
        if isinstance(self, Container) or isinstance(self, Absent) or isinstance(self, Create) or isinstance(self, Replace) or isinstance(self, Delete):
            for nm,child in self.children.items():
                if isinstance(child, Leaf) and nm == name:
                    return child

    def get_opt_leaf_or_absent(self, name) -> ?Node:
        if isinstance(self, Container) or isinstance(self, Absent) or isinstance(self, Create) or isinstance(self, Replace) or isinstance(self, Delete):
            for nm,child in self.children.items():
                if nm == name and (isinstance(child, Leaf) or isinstance(child, Absent)):
                    return child

    def get_leaflist(self, name) -> LeafList:
        l = self.get_opt_leaflist(name)
        if l is not None:
            return l
        raise ValueError("Cannot find leaf-list child in {self} with name: {name}")

    def get_opt_leaflist(self, name) -> ?LeafList:
        child = self.children.get(name)
        if isinstance(child, LeafList):
            return child
    #--

    def get_cnt(self, name) -> Container:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, Container) and nm == name:
                    return child
        raise ValueError("Cannot find container child with name {name}")

    def get_opt_cnt(self, name) -> ?Container:
        """This is for P-container"""
        try:
            return self.get_cnt(name)
        except ValueError:
            return None

    def get_list(self, name) -> List:
        l = self.get_opt_list(name)
        if l is not None:
            return l
        raise ValueError("Cannot find list child with name {name}")

    def get_opt_list(self, name) -> ?List:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, List) and nm == name:
                    return child

    def get_bool(self, name) -> bool:
        child = self.get_leaf(name)
        childval = child.val
        if isinstance(childval, bool):
            return childval
        raise ValueError("Leaf {name} is not of type bool")

    def get_opt_bool(self, name) -> ?bool:
        child = self.get_opt_leaf(name)
        if child is not None:
            childval = child.val
            if isinstance(childval, bool):
                return childval

    def get_opt_empty(self, name) -> ?bool:
        child = self.get_opt_leaf_or_absent(name)
        if isinstance(child, Leaf):
            childval = child.val
            if isinstance(childval, Present):
                return True
        if isinstance(child, Absent):
            return False

    def get_Decimal(self, name) -> Decimal:
        child = self.get_leaf(name)
        childval = child.val
        if isinstance(childval, Decimal):
            return childval
        raise ValueError("Leaf {name} is not of type Decimal")

    def get_opt_Decimal(self, name) -> ?Decimal:
        child = self.get_opt_leaf(name)
        if child is not None:
            childval = child.val
            if isinstance(childval, Decimal):
                return childval

    def get_int(self, name) -> int:
        child = self.get_leaf(name)
        childval = child.val
        if isinstance(childval, int):
            return childval
        raise ValueError("Leaf {name} is not of type int")

    def get_ints(self, name) -> list[int]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    cvals = []
                    for v in child.vals:
                        if isinstance(v, int):
                            cvals.append(v)
                    return cvals
        raise ValueError("Cannot find leaf-list child with name {name}")

    def get_opt_int(self, name) -> ?int:
        child = self.get_opt_leaf(name)
        if child is not None:
            childval = child.val
            if isinstance(childval, int):
                return childval

    def get_opt_ints(self, name) -> list[int]:
        try:
            return self.get_ints(name)
        except ValueError:
            return []

    def get_u64(self, name) -> u64:
        child = self.get_leaf(name)
        childval = child.val
        if isinstance(childval, u64):
            return childval
        raise ValueError("Leaf {name} is not of type u64")

    def get_u64s(self, name) -> list[u64]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    cvals = []
                    for v in child.vals:
                        if isinstance(v, u64):
                            cvals.append(v)
                    return cvals
        raise ValueError("Cannot find leaf-list child with name {name}")

    def get_opt_u64(self, name) -> ?u64:
        child = self.get_opt_leaf(name)
        if child is not None:
            childval = child.val
            if isinstance(childval, u64):
                return childval

    def get_opt_u64s(self, name) -> list[u64]:
        try:
            return self.get_u64s(name)
        except ValueError:
            return []

    def get_str(self, name) -> str:
        child = self.get_leaf(name)
        childval = child.val
        if isinstance(childval, str):
            return childval
        raise ValueError("Leaf {name} value is not type str")

    def get_opt_str(self, name) -> ?str:
        child = self.get_opt_leaf(name)
        if child is not None:
            childval = child.val
            if isinstance(childval, str):
                return childval

    def get_strs(self, name) -> list[str]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    cvals = []
                    for v in child.vals:
                        if isinstance(v, str):
                            cvals.append(v)
                    return cvals
        raise ValueError("Cannot find leaf-list child with name {name}")

    def get_opt_strs(self, name) -> list[str]:
        try:
            return self.get_strs(name)
        except ValueError:
            return []

    def get_bytes(self, name) -> bytes:
        child = self.get_leaf(name)
        childval = child.val
        if isinstance(childval, bytes):
            return childval
        raise ValueError("Leaf {name} value is not type bytes")

    def get_opt_bytes(self, name) -> ?bytes:
        child = self.get_opt_leaf(name)
        if child is not None:
            childval = child.val
            if isinstance(childval, bytes):
                return childval

    def get_bytess(self, name) -> list[bytes]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    cvals = []
                    for v in child.vals:
                        if isinstance(v, bytes):
                            cvals.append(v)
                    return cvals
        raise ValueError("Cannot find leaf-list child with name {name}")

    def get_opt_bytess(self, name) -> list[bytes]:
        try:
            return self.get_bytess(name)
        except ValueError:
            return []

    def get_Decimals(self, name) -> list[Decimal]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    cvals = []
                    for v in child.vals:
                        if isinstance(v, Decimal):
                            cvals.append(v)
                    return cvals
        raise ValueError("Cannot find leaf-list child with name {name}")

    def get_opt_Decimals(self, name) -> list[Decimal]:
        try:
            return self.get_Decimals(name)
        except ValueError:
            return []

    def get_bools(self, name) -> list[bool]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    cvals = []
                    for v in child.vals:
                        if isinstance(v, bool):
                            cvals.append(v)
                    return cvals
        raise ValueError("Cannot find leaf-list child with name {name}")

    def get_opt_bools(self, name) -> list[bool]:
        try:
            return self.get_bools(name)
        except ValueError:
            return []

    def get_value(self, name) -> value:
        child = self.get_leaf(name)
        return child.val

    def get_opt_value(self, name) -> ?value:
        child = self.get_opt_leaf(name)
        if child is not None:
            return child.val

    def get_values(self, name) -> list[value]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    return child.vals
        raise ValueError("Cannot find leaf-list child with name {name}")

    def get_opt_values(self, name) -> list[value]:
        try:
            return self.get_values(name)
        except ValueError:
            return []

    def get_Identityref(self, name) -> Identityref:
        child = self.get_leaf(name)
        childval = child.val
        if isinstance(childval, Identityref):
            return childval
        raise ValueError("Leaf {name} value is not type Identityref")

    def get_opt_Identityref(self, name) -> ?Identityref:
        child = self.get_opt_leaf(name)
        if child is not None:
            childval = child.val
            if isinstance(childval, Identityref):
                return childval

    def get_Identityrefs(self, name) -> list[Identityref]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    cvals = []
                    for v in child.vals:
                        if isinstance(v, Identityref):
                            cvals.append(v)
                    return cvals
        raise ValueError("Cannot find leaf-list child with name {name}")

    def get_opt_Identityrefs(self, name) -> list[Identityref]:
        try:
            return self.get_Identityrefs(name)
        except ValueError:
            return []

extension Node(Eq):
    def __eq__(self, other: Node) -> bool:
        if self.ns != other.ns:
            return False

        if isinstance(self, Container) and isinstance(other, Container):
            if set(self.children.keys()) != set(other.children.keys()):
                return False
            for key in self.children.keys():
                if self.children[key] != other.children[key]:
                    return False
            return True

        if isinstance(self, Leaf) and isinstance(other, Leaf):
            return vals_equal(self.val, other.val)

        if isinstance(self, CreateLeaf) and isinstance(other, CreateLeaf):
            return True

        if isinstance(self, ReplaceLeaf) and isinstance(other, ReplaceLeaf):
            return True

        if isinstance(self, LeafList) and isinstance(other, LeafList):
            return vals_list_equal(self.vals, other.vals)

        if isinstance(self, List) and isinstance(other, List):
            if not hack_eq(self.keys, other.keys):
                return False
            if len(self.elements) != len(other.elements):
                return False
            for i in range(len(self.elements)):
                e1 = self.elements[i]
                e2 = other.elements[i]
                if not self.user_order and e1.key_str(self.keys) != e2.key_str(other.keys):
                    for e2 in other.elements:
                        if e1.key_str(self.keys) == e2.key_str(other.keys):
                            break
                if e1 != e2:
                    return False
            return True

        if isinstance(self, Create) and isinstance(other, Create):
            if set(self.children.keys()) != set(other.children.keys()):
                return False
            for key in self.children.keys():
                if self.children[key] != other.children[key]:
                    return False
            return True

        if isinstance(self, Replace) and isinstance(other, Replace):
            if set(self.children.keys()) != set(other.children.keys()):
                return False
            for key in self.children.keys():
                if self.children[key] != other.children[key]:
                    return False
            return True

        if isinstance(self, Delete) and isinstance(other, Delete):
            if set(self.children.keys()) != set(other.children.keys()):
                return False
            for key in self.children.keys():
                if self.children[key] != other.children[key]:
                    return False
            return True

        if isinstance(self, Absent) and isinstance(other, Absent):
            if set(self.children.keys()) != set(other.children.keys()):
                return False
            for key in self.children.keys():
                if self.children[key] != other.children[key]:
                    return False
            return True

        return False


class List(Node):
    keys: list[Id] # name of the key leafs
    elements: list[Node]
    user_order: bool

    def __init__(self, keys: list[Id], elements: list[Node]=[], user_order=False, ns: ?str=None, module: ?str=None, txid: ?str=None):
        self.keys = keys
        self.elements = elements
        self.user_order = user_order
        self.ns = ns
        self.module = module
        self.txid = txid
        self.children = {}

    def get_opt_list_entry(self, key: str) -> ?Node:
        """Get a list entry by key value

        Returns None if the entry is not found.
        """
        for elem in self.elements:
            if elem.key_str(self.keys) == key:
                return elem
        return None

    def get_list_entry(self, key: str) -> Node:
        """Get a list entry by key value

        Raises ValueError if the entry is not found.
        """
        elem = self.get_opt_list_entry(key)
        if elem is not None:
            return elem
        raise ValueError("Cannot find list entry with key {key}")

class Container(Node):
    def __init__(self, children: dict[Id, Node]={}, presence: bool=False, ns: ?str=None, module: ?str=None, txid: ?str=None):
        self.children = children
        self.presence = presence
        self.ns = ns
        self.module = module
        self.txid = txid

class Leaf(Node):
    val: value

    def __init__(self, val: value, ns: ?str=None, module: ?str=None, txid: ?str=None):
        self.val = val
        self.ns = ns
        self.module = module
        self.txid = txid
        self.children = {}

class LeafList(Node):
    vals: list[value]
    user_order: bool

    def __init__(self, vals: list[value], user_order=False, ns: ?str=None, module: ?str=None, txid: ?str=None):
        self.ns = ns
        self.module = module
        self.vals = vals
        self.user_order = user_order
        self.txid = txid
        self.children = {}

class Present:
    """Named type for empty leaf value

    This type is used for the empty leaf value, so that we can do an
    isinstance(v, Present) check to detect when an empty leaf is set. An unset
    empty leaf has the value Absent(). When Acton supports pattern matching we
    can switch to the () identity.
    """
    def __init__(self):
        pass

    def __repr__(self):
        return "Present()"

class Absent(Node):
    """Declarative definition of the absence of a node

    NETCONF remove operation maps to Absent

    Absent is declarative / idempotent, meaning that if the target to be removed
    / made absent is not present, no error is raised.
    """
    def __init__(self, children: dict[Id, Node]={}, ns: ?str=None, module: ?str=None):
        self.ns = ns
        self.module = module
        self.children = children
        self.txid = None

class Delete(Node):
    """Imperative delete of a node
    NETCONF delete operation maps to Delete

    Unlike Absent / remove, Delete of a non-existent node is a failure.
    """
    def __init__(self, children: dict[Id, Node]={}, ns: ?str=None, module: ?str=None):
        self.ns = ns
        self.module = module
        self.children = children
        self.txid = None

class Create(Node):
    """Imperative create of a node
    NETCONF create operation maps to Create

    Unlike the default implicit merge, Create of an existing node is a failure.
    """
    def __init__(self, children={}, ns: ?str=None, module: ?str=None):
        self.ns = ns
        self.module = module
        self.children = children
        self.txid = None

class CreateLeaf(Create):
    """Imperative create of a leaf (has val)
    NETCONF create operation maps to Create
    """
    val: value
    def __init__(self, val: value, ns: ?str=None, module: ?str=None):
        Create.__init__(self, {}, ns, module)
        self.val = val

class Replace(Node):
    """Imperative replace of a node
    NETCONF replace operation maps to Replace
    """
    def __init__(self, children={}, ns: ?str=None, module: ?str=None):
        self.ns = ns
        self.module = module
        self.children = children
        self.txid = None

class ReplaceLeaf(Replace):
    """Imperative replace of a leaf (has val)
    NETCONF replace operation maps to Replace
    """
    val: value
    def __init__(self, val: value, ns: ?str=None, module: ?str=None):
        Replace.__init__(self, {}, ns, module)
        self.val = val


class ValueMatch(value):
    pass


class VWildcard(ValueMatch):
    pattern: str

    def __init__(self, pattern: str):
        self.pattern = pattern

    def __repr__(self):
        return "VWildcard({repr(self.pattern)})"


class FNode(value):
    name: ?Id
    value_match: ?value
    children: list[FNode]

    def __init__(self, name: ?Id=None, value_match: ?value=None, children: list[FNode]=[]):
        self.name = name
        self.value_match = value_match
        self.children = children

    def __repr__(self):
        return self.prsrc(deterministic=False)

    pure def prsrc(self, deterministic=False, indent=0) -> str:
        child_list = self.children
        parts: list[str] = []
        if self.name is not None:
            parts = parts + [repr(self.name)]
        if self.value_match is not None:
            if isinstance(self.value_match, ValueMatch):
                parts = parts + [repr(self.value_match)]
            else:
                parts = parts + [repr_gdata(self.value_match)]
        if len(child_list) > 0:
            child_strs = [c.prsrc(deterministic, indent+1) for c in child_list]
            parts = parts + ["[" + ", ".join(child_strs) + "]"]
        return "FNode({", ".join(parts)})"

    def _to_filter_xml_rec(self, parent_ns: ?str=None, deterministic=False) -> xml.Node:
        name = expect(self.name, "filter node")
        node_ns = name.q if name.q != "" and name.q != parent_ns else None
        xml_children = [c._to_filter_xml_rec(name.q, deterministic) for c in self.children]
        text_value: ?str = None
        v = None
        vm = self.value_match
        if vm is not None:
            if isinstance(vm, ValueMatch):
                if isinstance(vm, VWildcard):
                    text_value = vm.pattern
                else:
                    raise ValueError("Unknown value match type: {type(vm)}")
            else:
                v = vm
                text_value = yang_str(vm)
        return xml.Node(name.name, nsdefs=_nsq(node_ns, v), children=xml_children, text=text_value)

    def to_filter_xml(self, deterministic=False) -> list[xml.Node]:
        if self.name is None:
            return [c._to_filter_xml_rec(None, deterministic) for c in self.children]
        return [self._to_filter_xml_rec(None, deterministic)]

    def to_filter_xmlstr(self, pretty=True, deterministic=False) -> str:
        return xml.encode_nodes(self.to_filter_xml(deterministic), pretty)


def expect[T](a: ?T, ctx: str) -> T:
    if a is not None:
        return a
    raise ValueError("expected value (not None) for: {ctx}")

def _value_match_equal(a: value, b: value) -> bool:
    """Compare filter value matches (plain values vs match operators)."""
    if isinstance(a, ValueMatch):
        if isinstance(a, VWildcard):
            if isinstance(b, VWildcard):
                return a.pattern == b.pattern
            return False
        raise ValueError("Unknown value match type: {type(a)}")
    if isinstance(b, ValueMatch):
        return False
    return vals_equal(a, b)

extension ValueMatch(Eq):
    def __eq__(self, other: ValueMatch) -> bool:
        if isinstance(self, VWildcard) and isinstance(other, VWildcard):
            return self.pattern == other.pattern
        return False


extension FNode(Eq):
    def __eq__(self, other: FNode) -> bool:
        if self.name != other.name:
            return False
        if self.value_match is None and other.value_match is not None:
            return False
        if self.value_match is not None and other.value_match is None:
            return False
        if self.value_match is not None and other.value_match is not None:
            a = expect(self.value_match, "filter value")
            b = expect(other.value_match, "filter value")
            if not _value_match_equal(a, b):
                return False
        if len(self.children) != len(other.children):
            return False
        for i in range(len(self.children)):
            if self.children[i] != other.children[i]:
                return False
        return True

def sorted_elements(elements, key_names: list[Id]):
    keys = list(map(lambda elem: elem.key_str(key_names), elements))
    key_map = dict(zip(keys, elements))
    return [key_map[key] for key in sorted(keys)]

def vals_equal(a: value, b: value) -> bool:
    # Compare known leaf value types
    if isinstance(a, bool) and isinstance(b, bool):
        return a == b
    if isinstance(a, float) and isinstance(b, float):
        return a == b
    if isinstance(a, Decimal) and isinstance(b, Decimal):
        return a == b
    if isinstance(a, str) and isinstance(b, str):
        return a == b
    if isinstance(a, bytes) and isinstance(b, bytes):
        return a == b
    if isinstance(a, u64) and isinstance(b, u64):
        return a == b
    if isinstance(a, int) and isinstance(b, int):
        return a == b
    if isinstance(a, Identityref) and isinstance(b, Identityref):
        return a == b
    if isinstance(a, Present) and isinstance(b, Present):
        return True
    if type(a) != type(b):
        # It is valid to compare values of different type, which happens if
        # leaves are of type union and value a and b happen to be of different
        # type.
        return False
    raise ValueError("Unsupported value type in eq comparison")

# For leaf-lists we need to compare a list of values
def vals_list_equal(a: list[value], b: list[value]) -> bool:
    if len(a) != len(b):
        return False
    for i in range(len(a)):
        if not vals_equal(a[i], b[i]):
            return False
    return True

def vals_less_than(a: value, b: value) -> bool:
    # Compare known leaf value types
    if isinstance(a, bool) and isinstance(b, bool):
        return not a  # False (0) before True (1)
    if isinstance(a, float) and isinstance(b, float):
        return a < b
    if isinstance(a, Decimal) and isinstance(b, Decimal):
        return a < b
    if isinstance(a, str) and isinstance(b, str):
        return a < b
    if isinstance(a, bytes) and isinstance(b, bytes):
        return a < b
    if isinstance(a, u64) and isinstance(b, u64):
        return a < b
    if isinstance(a, int) and isinstance(b, int):
        return a < b
    if isinstance(a, Identityref) and isinstance(b, Identityref):
        return a < b
    if isinstance(a, Present) and isinstance(b, Present):
        return False
    raise ValueError("Unsupported value type or mismatch in lt comparison: {type(a)}, {type(b)}")

pure def vals_list_sorted(a: list[value]) -> list[value]:
    """Sort a list of values, comparing only values of the same type

    Uses a functional approach to avoid mutations so that we can be called
    from pure functions. Perhaps this can be made more efficient by mutation -
    look into later once we can contain scope local mutation from leaking
    https://github.com/actonlang/acton/issues/1632
    """
    n = len(a)
    if n <= 1:
        return a

    # Functional bubble sort: recursively sort by finding minimum and building result
    # Find the minimum element
    min_val = a[0]
    min_idx = 0
    for i in range(1, n):
        if vals_less_than(a[i], min_val):
            min_val = a[i]
            min_idx = i

    # Build new list with minimum at front and recursively sort the rest
    remaining = a[:min_idx] + a[min_idx+1:]
    if len(remaining) == 0:
        return [min_val]
    else:
        return [min_val] + vals_list_sorted(remaining)



class _PathElement:
    def __init__(self, name: ?Id=None, keys: ?dict[str, value]=None):
        self.name = name
        self.keys = keys


def _format_gdata_path(path: list[_PathElement]) -> str:
    if len(path) == 0:
        return "/"
    path_str = ""
    for elem in path:
        elem_name = elem.name
        if elem_name is not None:
            path_str = path_str + "/" + elem_name.name
        elem_keys = elem.keys
        if elem_keys is not None and len(elem_keys) > 0:
            predicates = ["{k}={repr(v)}" for k, v in elem_keys.items()]
            path_str = path_str + "[" + ",".join(predicates) + "]"
    return path_str


def _merge_rec(a: Node, b: Node, path: list[_PathElement]) -> Node:
    if type(a) != type(b):
        raise ValueError("Cannot merge nodes of different types at {_format_gdata_path(path)}: {type(a)} != {type(b)}")

    # Helper to merge keyed children
    def merge_keyed_children(a_children: dict[Id, Node], b_children: dict[Id, Node]) -> dict[Id, Node]:
        result: dict[Id, Node] = {}

        a_keys = list(a_children.keys())
        b_keys = list(b_children.keys())

        i = 0
        j = 0
        while i < len(a_keys) and j < len(b_keys):
            ak = a_keys[i]
            bk = b_keys[j]
            if ak == bk:
                # Overlapping key
                merged_child = _merge_rec(a_children[ak], b_children[bk], path + [_PathElement(ak)])
                result[ak] = merged_child
                i += 1
                j += 1
            else:
                # Keys differ
                ak_in_b = (ak in b_children)
                bk_in_a = (bk in a_children)
                if not ak_in_b:
                    # Child only in a
                    result[ak] = a_children[ak]
                    i += 1
                elif not bk_in_a:
                    # Child only in b
                    # We append it now right after we handle old nodes to keep order of a
                    # In merging, we decided to maintain 'a' order as baseline
                    # So we handle all a_nodes that appear before first
                    # If we want strictly all 'a' first, we can first go through a_keys that are not in b.
                    # But let's insert b node here to keep somewhat stable merging.
                    result[bk] = b_children[bk]
                    j += 1
                else:
                    # Both appear in both sets at different positions, reorder scenario
                    # For simplicity, handle old's node first since we want to keep a's order.
                    merged_child = _merge_rec(a_children[ak], b_children[ak], path + [_PathElement(ak)])
                    result[ak] = merged_child
                    i += 1
                    # We don't advance j here because we haven't handled bk yet.
                    # We'll hit bk again in next iteration and handle it normally.

        # If a still has items
        while i < len(a_keys):
            ak = a_keys[i]
            # If ak also in b but we haven't handled it yet, merge it now.
            # Otherwise just take it from a.
            if ak in b_children:
                merged_child = _merge_rec(a_children[ak], b_children[ak], path + [_PathElement(ak)])
                result[ak] = merged_child
            else:
                result[ak] = a_children[ak]
            i += 1

        # If b still has items
        while j < len(b_keys):
            bk = b_keys[j]
            if bk not in a_children:
                # New child from b
                result[bk] = b_children[bk]
            else:
                # Already handled overlap above, but if we got here, let's be safe:
                merged_child = _merge_rec(a_children[bk], b_children[bk], path + [_PathElement(bk)])
                result[bk] = merged_child
            j += 1

        return result

    if isinstance(a, Container) and isinstance(b, Container):
        # Merge keyed children similarly to Container
        new_children = merge_keyed_children(a.children, b.children)
        return Container(children=new_children, presence=a.presence, ns=a.ns, module=a.module)

    elif isinstance(a, Leaf) and isinstance(b, Leaf):
        if type(a.val) != type(b.val):
            raise ValueError("Cannot merge leaves with different types at {_format_gdata_path(path)}: {type(a.val)} != {type(b.val)}")
        aval = a.val
        bval = b.val
        if vals_equal(aval, bval):
            return a
        raise ValueError("Cannot merge leaves with different values at {_format_gdata_path(path)}: {str(aval)} != {str(bval)}")

    elif isinstance(a, LeafList) and isinstance(b, LeafList):
        if vals_list_equal(a.vals, b.vals):
            return a
        raise ValueError("Cannot merge leaf-lists with different values at {_format_gdata_path(path)}")

    elif isinstance(a, List) and isinstance(b, List):
        if not hack_eq(a.keys, b.keys):
            raise ValueError("Cannot merge lists with different keys at {_format_gdata_path(path)}: {str(a.keys)} != {str(b.keys)}")
        if a.user_order != b.user_order:
            raise ValueError("Cannot merge lists with different user_order at {_format_gdata_path(path)}")

        if a.user_order:
            # user_order = True
            # Two-pointer approach for merging list elements
            # This preserves the order from 'a' as baseline and inserts 'b' elements accordingly.
            new_elements: list[Node] = []

            old_map = {e.key_str(a.keys): e for e in a.elements}

            # Start with elements from a, merge if present in b
            for a_elem in a.elements:
                found = False
                for b_elem in b.elements:
                    if b_elem.key_str(b.keys) == a_elem.key_str(a.keys):
                        key_values = a_elem.key_values(a.keys)
                        merged_elem = _merge_rec(a_elem, b_elem, path + [_PathElement(keys=key_values)])
                        if isinstance(merged_elem, Container):
                            new_elements.append(merged_elem)
                        else:
                            raise ValueError("merge did not return a Container where one was expected at {_format_gdata_path(path)}")
                        found = True
                        break
                if not found:
                    # not in b, just add a_elem
                    new_elements.append(a_elem)

            # Add elements from b that are not in a
            # Insert them in a stable manner at the end to preserve 'a' order
            # If we want a more sophisticated merging of order, we could try to insert them
            # relative to keys present in both.
            # For now, we just append them at the end.
            existing_keys = {}
            for e in new_elements:
                existing_keys[e.key_str(a.keys)] = True
            for b_elem in b.elements:
                bk = b_elem.key_str(b.keys)
                if bk not in existing_keys:
                    new_elements.append(b_elem)
                    existing_keys[bk] = True

            return List(a.keys, new_elements, user_order=a.user_order, ns=a.ns, module=a.module)
        else:
            # user_order = False
            # Keep the original merging logic since it sorts by keys, not order
            all_elements: dict[str, list[Node]] = {}

            for elem in a.elements:
                key_str = elem.key_str(a.keys)
                if key_str not in all_elements:
                    all_elements[key_str] = []
                all_elements[key_str].append(elem)
            for elem in b.elements:
                key_str = elem.key_str(b.keys)
                if key_str not in all_elements:
                    all_elements[key_str] = []
                all_elements[key_str].append(elem)

            new_elements: list[Node] = []
            # sort keys lex order as before
            sorted_keys = sorted(all_elements.keys())

            for key_str in sorted_keys:
                elems = all_elements[key_str]
                new_elem = elems[0]
                if len(elems) > 1:
                    key_values = new_elem.key_values(a.keys)
                    for elem in elems[1:]:
                        new_elem = _merge_rec(new_elem, elem, path + [_PathElement(keys=key_values)])
                if isinstance(new_elem, Container):
                    new_elements.append(new_elem)
                else:
                    raise ValueError("unreachable, new_elem should always be a Container at {_format_gdata_path(path)}")

            return List(a.keys, new_elements, ns=a.ns, module=a.module)

    elif isinstance(a, Absent) and isinstance(b, Absent):
        # Both absent is odd in a merge scenario, but let's just return absent
        return a

    else:
        raise ValueError("Unsupported node type in merge at {_format_gdata_path(path)}: {type(a)}")


def merge(a: Node, b: Node) -> Node:
    return _merge_rec(a, b, [])


def _diff_rec(old: ?Node, new: Node, path: list[_PathElement]) -> ?Node:
    if old is None:
        return new

    # old is empty leaf, new is an explicit remove: Leaf -> Absent: Absent
    if isinstance(old, Leaf) and isinstance(new, Absent):
        return new

    if type(old) != type(new):
        raise ValueError("diff called with nodes of different types at {_format_gdata_path(path)}: {type(old)} != {type(new)}")

    # Helper function for diffing Container nodes that have children keyed by strings
    def diff_keyed_children(old_children: dict[Id, Node], new_children: dict[Id, Node]) -> ?dict[Id, Node]:
        # We'll produce a new_children_dict with the diff
        result: dict[Id, Node] = {}

        for k,nchild in new_children.items():
            if k in old_children:
                ochild = old_children[k]
                child_diff = _diff_rec(ochild, nchild, path + [_PathElement(k)])
                if child_diff is not None:
                    result[k] = child_diff
            else:
                result[k] = nchild
        for k,ochild in old_children.items():
            if k not in new_children:
                # Preserve full original subtree under Absent for complete context
                # during delete operations (e.g., NETCONF XML, CLI stanza removal)
                result[k] = Absent({k: ochild}, ns=ochild.ns, module=ochild.module)

        if len(result) == 0:
            return None
        return result

    # Helper function for diffing list elements (specialized Container nodes)
    # that *must* always include the key leaf children
    def diff_list_element(old_element: Node, new_element: Node, keys: list[Id], elem_path: list[_PathElement]) -> ?Node:
        # Diff of element Container nodes will only contain the actual
        # differences, skipping keys which are equal in both
        entry_diff = _diff_rec(old_element, new_element, elem_path)
        if entry_diff is not None:
            # Update the entry to include key leaf children
            for key in keys:
                entry_diff.children[key] = old_element.get_leaf(key)
            return entry_diff
        return None

    # Helper function for diffing system-ordered lists (order doesn't matter)
    def diff_system_ordered_list_elements(old_list: List, new_list: List) -> ?list[Node]:
        if not hack_eq(old_list.keys, new_list.keys):
            raise ValueError("List keys differ at {_format_gdata_path(path)}: {str(old_list.keys)} != {str(new_list.keys)}")

        # Map elements by key for both lists
        old_map = {e.key_str(old_list.keys): e for e in old_list.elements}
        new_map = {e.key_str(new_list.keys): e for e in new_list.elements}

        result: list[Node] = []

        # Check all keys (union of both sets)
        all_keys = set(old_map.keys()) | set(new_map.keys())

        # Sort keys for consistent output
        for key in sorted(all_keys):
            if key in old_map and key in new_map:
                # Element exists in both - check for differences
                key_values = old_map[key].key_values(old_list.keys)
                elem_diff = diff_list_element(old_map[key], new_map[key], old_list.keys, path + [_PathElement(keys=key_values)])
                if elem_diff is not None:
                    result.append(elem_diff)
            elif key in old_map:
                # Element only in old - mark as absent
                oe = old_map[key]
                result.append(Absent(oe.key_children(old_list.keys)))
            else:
                # Element only in new - add it
                ne = new_map[key]
                result.append(ne)

        if len(result) == 0:
            return None
        return result

    # Helper function for diffing user-ordered lists (order matters)
    def diff_user_ordered_list_elements(old_list: List, new_list: List) -> ?list[Node]:

        if not hack_eq(old_list.keys, new_list.keys):
            raise ValueError("List keys differ at {_format_gdata_path(path)}: {str(old_list.keys)} != {str(new_list.keys)}")

        # Map old elements by key
        old_map = {e.key_str(old_list.keys): e for e in old_list.elements}
        old_key_order = [e.key_str(old_list.keys) for e in old_list.elements]

        new_map = {e.key_str(new_list.keys): e for e in new_list.elements}
        new_key_order = [e.key_str(new_list.keys) for e in new_list.elements]

        # We'll do the two-pointer approach on these key orders
        i = 0
        j = 0
        result: list[Node] = []

        while i < len(old_key_order) and j < len(new_key_order):
            ok = old_key_order[i]
            nk = new_key_order[j]

            if ok == nk:
                # same element key
                key_values = old_map[ok].key_values(old_list.keys)
                elem_diff = diff_list_element(old_map[ok], new_map[nk], old_list.keys, path + [_PathElement(keys=key_values)])
                if elem_diff is not None:
                    result.append(elem_diff)
                i += 1
                j += 1
            else:
                ok_in_new = (ok in new_map)
                nk_in_old = (nk in old_map)

                if not ok_in_new:
                    # old element not in new => absent
                    oe = old_map[ok]
                    result.append(Absent(oe.key_children(old_list.keys)))
                    i += 1
                elif not nk_in_old:
                    # new element not in old => new element
                    # Insert the new element now
                    ne = new_map[nk]
                    result.append(ne)
                    j += 1
                else:
                    # Complex reordering scenario
                    raise ValueError("Complex reordering scenario encountered in list elements at {_format_gdata_path(path)}")

        # Remaining old elements are absent
        while i < len(old_key_order):
            ok = old_key_order[i]
            if ok not in new_map:
                oe = old_map[ok]
                result.append(Absent(oe.key_children(old_list.keys)))
            i += 1

        # Remaining new elements are new
        while j < len(new_key_order):
            nk = new_key_order[j]
            if nk not in old_map:
                ne = new_map[nk]
                result.append(ne)
            j += 1

        if len(result) == 0:
            return None
        return result

    # Diff logic for each node type

    if isinstance(old, Container) and isinstance(new, Container):
        diff_children = diff_keyed_children(old.children, new.children)
        if diff_children is None:
            return None
        return Container(children=diff_children, presence=new.presence, ns=new.ns, module=new.module)

    elif isinstance(old, List) and isinstance(new, List):
        if old.user_order != new.user_order:
            raise ValueError("Cannot diff lists with different ordering types at {_format_gdata_path(path)}")

        if old.user_order:
            result = diff_user_ordered_list_elements(old, new)
        else:
            result = diff_system_ordered_list_elements(old, new)
        if result is None:
            return None
        return List(new.keys, elements=result, user_order=new.user_order, ns=new.ns, module=new.module)

    elif isinstance(old, Leaf) and isinstance(new, Leaf):
        if vals_equal(old.val, new.val):
            return None
        return new

    elif isinstance(old, LeafList) and isinstance(new, LeafList):
        if vals_list_equal(old.vals, new.vals):
            return None
        return new

    elif isinstance(old, Absent) and isinstance(new, Absent):
        diff_children = diff_keyed_children(old.children, new.children)
        if diff_children is not None:
            # TODO: can't call key_str(list_keys) without our parent List node!?
            raise ValueError("Absent keys differ at {_format_gdata_path(path)}: {str(old.children)} != {str(new.children)}")
        return None

    else:
        raise ValueError("Unhandled node type in diff at {_format_gdata_path(path)}: {type(old)}")


def diff(old: ?Node, new: Node) -> ?Node:
    return _diff_rec(old, new, [])


def _wildcard_match(pattern: str, s: str) -> bool:
    pi = 0
    si = 0
    star = -1
    match = 0
    while si < len(s):
        if pi < len(pattern) and pattern[pi] == "*":
            star = pi
            match = si
            pi += 1
        elif pi < len(pattern) and pattern[pi] == s[si]:
            pi += 1
            si += 1
        elif star != -1:
            pi = star + 1
            match += 1
            si = match
        else:
            return False
    while pi < len(pattern) and pattern[pi] == "*":
        pi += 1
    return pi == len(pattern)


def _match_value(vm: value, v: value) -> bool:
    """Return True when value v matches filter value vm."""
    if isinstance(vm, ValueMatch):
        if isinstance(vm, VWildcard):
            return _wildcard_match(vm.pattern, yang_str(v))
        raise ValueError("Unknown value match type: {type(vm)}")
    return vals_equal(v, vm)


def _group_filter_children(children: list[FNode]) -> dict[Id, list[FNode]]:
    """Group filter children by name for per-child evaluation."""
    groups: dict[Id, list[FNode]] = {}
    for child in children:
        name = expect(child.name, "filter child")
        if name in groups:
            groups[name].append(child)
        else:
            groups[name] = [child]
    return groups


def _filter_container_result(data: Node, children: dict[Id, Node]) -> Node:
    """Rebuild a container-like node with filtered children."""
    if isinstance(data, Absent):
        return Absent(children, ns=data.ns, module=data.module)
    if isinstance(data, Delete):
        return Delete(children, ns=data.ns, module=data.module)
    if isinstance(data, Create):
        return Create(children, ns=data.ns, module=data.module)
    if isinstance(data, Replace):
        return Replace(children, ns=data.ns, module=data.module)
    if isinstance(data, Container):
        return Container(children, presence=data.presence, ns=data.ns, module=data.module)
    return Container(children)


def _filter_leaf(data: Leaf, flist: list[FNode]) -> (node: ?Node, select: bool):
    """Apply leaf filters and determine selection status."""
    matched = False
    select = False
    for f in flist:
        if len(f.children) > 0:
            raise ValueError("Leaf filter cannot have children")
        if f.value_match is None:
            matched = True
            select = True
        else:
            vm = expect(f.value_match, "leaf")
            if _match_value(vm, data.val):
                matched = True
    if not matched:
        return (node=None, select=False)
    return (node=data, select=select)


def _filter_leaflist(data: LeafList, flist: list[FNode]) -> (node: ?Node, select: bool):
    """Apply leaf-list filters and determine selection status."""
    if len(flist) == 0:
        return (node=data, select=True)
    select_all = False
    matches: list[value] = []
    for f in flist:
        if len(f.children) > 0:
            raise ValueError("Leaf-list filter cannot have children")
        if f.value_match is None:
            select_all = True
        else:
            vm = expect(f.value_match, "leaf-list")
            matches.append(vm)
    if select_all:
        return (node=data, select=True)
    new_vals: list[value] = []
    for v in data.vals:
        for m in matches:
            if _match_value(m, v):
                new_vals.append(v)
                break
    if len(new_vals) == 0:
        return (node=None, select=False)
    return (node=LeafList(new_vals, user_order=data.user_order, ns=data.ns, module=data.module), select=True)


def _filter_list_element(elem: Node, fnode: FNode, keys: list[Id]) -> ?Node:
    """Filter a single list element against a list element predicate."""
    if not (isinstance(elem, Container) or isinstance(elem, Absent)):
        return None
    if fnode.value_match is not None:
        raise ValueError("List element filter cannot have value match")
    if len(fnode.children) == 0:
        return elem

    groups = _group_filter_children(fnode.children)
    selected_children: dict[Id, Node] = {}
    has_selection = False
    for name, flist in groups.items():
        if name not in elem.children:
            return None
        res = _filter_child(elem.children[name], flist)
        if res.node is None:
            return None
        if res.select:
            selected_children[name] = expect(res.node, "list element selection")
            has_selection = True

    if not has_selection:
        return elem

    for key in keys:
        if key in elem.children and key not in selected_children:
            selected_children[key] = elem.children[key]

    return _filter_container_result(elem, selected_children)


def _filter_list(data: List, flist: list[FNode]) -> (node: ?Node, select: bool):
    """Apply list predicates to produce a filtered list result."""
    if len(flist) == 0:
        return (node=data, select=True)
    for f in flist:
        if f.value_match is not None:
            raise ValueError("List filter cannot have value match")
    for f in flist:
        if len(f.children) == 0:
            return (node=data, select=True)
    new_elements: list[Node] = []
    seen = {}
    for elem in data.elements:
        for f in flist:
            res = _filter_list_element(elem, f, data.keys)
            if res is not None:
                k = elem.key_str(data.keys)
                if k not in seen:
                    new_elements.append(res)
                    seen[k] = True
                break
    if len(new_elements) == 0:
        return (node=None, select=False)
    return (node=List(data.keys, elements=new_elements, user_order=data.user_order, ns=data.ns, module=data.module), select=True)


def _filter_container_children(data: Node, fchildren: list[FNode]) -> ?Node:
    """Filter container children and select requested subtrees."""
    if len(fchildren) == 0:
        return data
    if not (isinstance(data, Container) or isinstance(data, Absent) or isinstance(data, Create) or isinstance(data, Delete) or isinstance(data, Replace)):
        raise ValueError("Filter root expects a container-like node")

    groups = _group_filter_children(fchildren)
    selected_children: dict[Id, Node] = {}
    has_selection = False
    for name, flist in groups.items():
        if name not in data.children:
            return None
        res = _filter_child(data.children[name], flist)
        if res.node is None:
            return None
        if res.select:
            selected_children[name] = expect(res.node, "container selection")
            has_selection = True

    if not has_selection:
        return data
    return _filter_container_result(data, selected_children)


def _filter_child(data: Node, flist: list[FNode]) -> (node: ?Node, select: bool):
    """Dispatch filter evaluation based on child node type."""
    if isinstance(data, Container) or isinstance(data, Absent) or isinstance(data, Create) or isinstance(data, Delete) or isinstance(data, Replace):
        if len(flist) != 1:
            raise ValueError("Multiple filter nodes for container child")
        fnode = flist[0]
        if fnode.value_match is not None:
            raise ValueError("Container filter cannot have value match")
        res = _filter_container_children(data, fnode.children)
        if res is None:
            return (node=None, select=False)
        return (node=res, select=True)
    if isinstance(data, List):
        return _filter_list(data, flist)
    if isinstance(data, LeafList):
        return _filter_leaflist(data, flist)
    if isinstance(data, Leaf):
        return _filter_leaf(data, flist)
    return (node=None, select=False)


def filter(data: ?Node, filt: FNode) -> ?Node:
    if data is None:
        return None
    d = expect(data, "filter root")
    if filt.name is None:
        return _filter_container_children(d, filt.children)
    res = _filter_child(d, [filt])
    return res.node


# TODO: Can we make patch return a Node instead of ?Node?
def _patch_rec(old: Node, p: ?Node, path: list[_PathElement]) -> ?Node:
    if p is None:
        return old

    if isinstance(p, Absent):
        # Patch says remove this node
        if isinstance(old, Absent):
            # Both absent means node was removed
            if p.children != old.children:
                # TODO: can't call key_str(list_keys) without our parent List node!?
                raise ValueError("Absent keys differ in patch at {_format_gdata_path(path)}: {str(old.children)} != {str(p.children)}")
        return None

    if isinstance(p, Delete):
        # Delete requires the node to exist
        if isinstance(old, Absent):
            # TODO: structured error (error-tag, ...)
            raise ValueError("data-missing: node does not exist at {_format_gdata_path(path)}")
        return None

    if isinstance(p, Create):
        # Create requires the node to NOT exist
        # TODO: structured error (error-tag, ...)
        raise ValueError("data-exists: node already exists at {_format_gdata_path(path)}")

    if isinstance(p, ReplaceLeaf):
        return Leaf(p.val, ns=p.ns, module=p.module)

    if isinstance(p, Replace):
        # Replace ignores old contents and applies patch to an empty base
        if isinstance(old, Container):
            empty_cnt = Container({}, presence=old.presence, ns=old.ns, module=old.module)
            patch_cnt = Container(p.children, ns=p.ns, module=p.module)
            res = _patch_rec(empty_cnt, patch_cnt, path)
            if res is None and old.presence:
                return Container({}, presence=old.presence, ns=old.ns, module=old.module)
            return res
        # Replace on other node types is not expected at this point
        raise ValueError("Unhandled node type in patch at {_format_gdata_path(path)}: {type(p)}")

    elif isinstance(old, Container) and isinstance(p, Container):
        # Start with old children
        new_children: dict[Id, Node] = {}
        for key in old.children:
            new_children[key] = old.children[key]

        # Apply patch changes
        for key in p.children:
            cpatch = p.children[key]
            if key in new_children:
                # Patch existing child
                res = _patch_rec(new_children[key], cpatch, path + [_PathElement(key)])
                if res is not None:
                    new_children[key] = res
                else:
                    del new_children[key]
            else:
                # Key not in old
                if isinstance(cpatch, Absent):
                    # Trying to remove something not in old -> ignore
                    if len(cpatch.children) == 0:
                        # TODO: reconsider modeling empty leaf removal with something other than Absent?!
                        # Preserve explicit remove of empty leaf / leaf-list (childless)
                        new_children[key] = cpatch
                elif isinstance(cpatch, Delete):
                    # TODO: structured error (error-tag, ...)
                    raise ValueError("data-missing: node does not exist at {_format_gdata_path(path + [_PathElement(key)])}")
                elif isinstance(cpatch, CreateLeaf):
                    new_children[key] = Leaf(cpatch.val, ns=cpatch.ns, module=cpatch.module)
                elif isinstance(cpatch, ReplaceLeaf):
                    new_children[key] = Leaf(cpatch.val, ns=cpatch.ns, module=cpatch.module)
                # Apply patch against an empty node so nested ops are sanitized
                # (remove->noop, create->merge, delete->data-missing). We end up
                # with a "declarative" gdata tree without imperative operations.
                elif isinstance(cpatch, List):
                    empty_list = List(cpatch.keys, elements=[], user_order=cpatch.user_order, ns=cpatch.ns, module=cpatch.module)
                    res = _patch_rec(empty_list, cpatch, path + [_PathElement(key)])
                    if res is not None:
                        new_children[key] = res
                elif isinstance(cpatch, Container):
                    empty_cnt = Container({}, presence=cpatch.presence, ns=cpatch.ns, module=cpatch.module)
                    res = _patch_rec(empty_cnt, cpatch, path + [_PathElement(key)])
                    if res is not None:
                        new_children[key] = res
                    elif cpatch.presence:
                        # Preserve presence containers even when empty
                        new_children[key] = Container({}, presence=True, ns=cpatch.ns, module=cpatch.module)
                elif isinstance(cpatch, Create) or isinstance(cpatch, Replace):
                    empty_cnt = Container({}, ns=cpatch.ns, module=cpatch.module)
                    patch_cnt = Container(cpatch.children, ns=cpatch.ns, module=cpatch.module)
                    res = _patch_rec(empty_cnt, patch_cnt, path + [_PathElement(key)])
                    if res is not None:
                        new_children[key] = res
                else:
                    # New leaf / leaf-list child
                    new_children[key] = cpatch

        # No need to remove unchanged nodes; they are already in new_children
        if len(new_children) == 0:
            return None
        return Container(children=new_children, presence=old.presence, ns=old.ns, module=old.module)

    elif isinstance(old, List) and isinstance(p, List):
        if not hack_eq(old.keys, p.keys):
            raise ValueError("List keys differ at {_format_gdata_path(path)}: {str(old.keys)} != {str(p.keys)}")

        old_map = {e.key_str(old.keys): e for e in old.elements}

        # Apply patch elements
        patch_elems = p.elements
        for pelem in patch_elems:
            if isinstance(pelem, Absent):
                # Remove this element if it exists
                k = pelem.key_str(p.keys)
                if k in old_map:
                    del old_map[k]
            elif isinstance(pelem, Delete):
                # Delete this element if it exists, otherwise error
                k = pelem.key_str(p.keys)
                if k in old_map:
                    del old_map[k]
                else:
                    # TODO: structured error (error-tag, ...)
                    pelem_path = path + [_PathElement(keys=pelem.key_values(p.keys))]
                    raise ValueError("data-missing: list element does not exist at {_format_gdata_path(pelem_path)}")
            else:
                # pelem is a ListElement
                k = pelem.key_str(p.keys)
                if k in old_map:
                    # Patch existing element
                    key_values = old_map[k].key_values(old.keys)
                    res = _patch_rec(old_map[k], pelem, path + [_PathElement(keys=key_values)])
                    if res is not None and isinstance(res, Container):
                        old_map[k] = res
                    else:
                        # Remove the element
                        del old_map[k]
                else:
                    # New element: Apply patch against an empty node so nested ops are sanitized
                    # (remove->noop, create->merge, delete->data-missing). We end up
                    # with a "declarative" gdata tree without imperative operations.
                    if isinstance(pelem, Create):
                        # Bypass data-exists error check for create op
                        patch_elem = Container(pelem.children)
                    else:
                        patch_elem = pelem
                    elem_path = path + [_PathElement(keys=pelem.key_values(p.keys))]
                    res = _patch_rec(Container(), patch_elem, elem_path)
                    if res is not None and isinstance(res, Container):
                        old_map[k] = res

        # Rebuild elements in final order
        # Start with old's original order for unchanged and patched elements
        final_key_order = []
        chosen = {}
        for e in old.elements:
            k = e.key_str(old.keys)
            if k in old_map:
                final_key_order.append(k)
                chosen[k] = True

        # Now check if patch introduced new elements not in old.
        # Add them in the order they appear in patch.
        for pelem in patch_elems:
            if isinstance(pelem, Absent):
                continue
            k = pelem.key_str(p.keys)
            if k in old_map and k not in chosen:
                final_key_order.append(k)
                chosen[k] = True

        new_elements: list[Node] = []
        for k in final_key_order:
            new_elements.append(old_map[k])

        if len(new_elements) == 0:
            return None
        return List(old.keys, elements=new_elements, user_order=old.user_order, ns=old.ns, module=old.module)

    elif isinstance(old, Leaf) and isinstance(p, Leaf):
        # Patch leaf replaces old leaf value
        return p

    elif isinstance(old, LeafList) and isinstance(p, LeafList):
        # Patch leaf-list replaces old leaf-list values
        return p

    elif isinstance(old, Absent) and isinstance(p, Absent):
        # Both absent means node was removed
        return None

    else:
        if p is not None:
            raise ValueError("Unhandled node type in patch at {_format_gdata_path(path)}: {type(p)}")


def patch(old: Node, p: ?Node) -> ?Node:
    return _patch_rec(old, p, [])


class TreeProvider(object):
    rpc: proc(action(?Node, ?Exception) -> None, Node) -> None
    rpc_xml: proc(action(?xml.Node, ?Exception) -> None, xml.Node) -> None


def _node_match(n: xml.Node, name: str, ns: ?str) -> bool:
    """Check if an XML node matches the given name and namespace

    It will match either on the default (nameless) namespace, or the node prefix
    & a named namespace. For example:
    <foo xmlns="urn:foo"> and <ns:foo xmlns:ns="urn:foo"> both match with name="foo", ns="urn:foo"
    """
    if n.tag == name:
        if ns is not None:
            for nsdef in n.nsdefs:
                n0 = nsdef.0
                n1 = nsdef.1
                if n0 is not None and n0 == n.prefix and n1 == ns:
                    return True
                elif n0 is None and n1 == ns:
                    return True
        else:
            return True
    return False


def get_xml_opt_child(n: xml.Node, name: str, ns: ?str) -> ?xml.Node:
    for child in n.children:
        if _node_match(child, name, ns):
            return child
    return None


def get_xml_children(n: xml.Node, name: str, ns: ?str) -> list[xml.Node]:
    res = []
    for child in n.children:
        if _node_match(child, name, ns):
            res.append(child)
    return res


NS_acme = "http://example.com/acme"


def _test_format_gdata_path():
    path = [
        _PathElement(Id("", "config")),
        _PathElement(Id("", "interfaces")),
        _PathElement(keys={"name": "eth0", "vlan": u64(100)}),
        _PathElement(Id("", "ipv4")),
        _PathElement(keys={"ip": "10.0.0.1", "prefix": u64(24)})
    ]
    testing.assertEqual("/config/interfaces[name='eth0',vlan=100]/ipv4[ip='10.0.0.1',prefix=24]", _format_gdata_path(path))


def _test_merge1():
    y1 = Container({
        Id(NS_acme, "a"): Leaf(u64(1)),
        Id(NS_acme, "l1"): List([Id(NS_acme, "name")], [
            Container({
                Id(NS_acme, "name"): Leaf("k1"),
                Id(NS_acme, "n1"): Leaf(u64(1)),
                Id(NS_acme, "n2"): Leaf(u64(2))
            }),
            Container({
                Id(NS_acme, "name"): Leaf("k4"),
                Id(NS_acme, "n4"): Leaf(u64(4)),
            }),
        ])
    }, ns="http://example.com/acme", module="acme")

    y2 = Container({
        Id(NS_acme, "b"): Leaf(u64(2)),
        Id(NS_acme, "c"): Leaf(u64(3)),
        Id(NS_acme, "l1"): List([Id(NS_acme, "name")], [
            Container({
                Id(NS_acme, "name"): Leaf("k2"),
                Id(NS_acme, "n1"): Leaf(u64(1)),
                Id(NS_acme, "n3"): Leaf(u64(3))
            }),
        ]),
        Id(NS_acme, "d"): LeafList(["a", "b", "c"])
    }, ns="http://example.com/acme", module="acme")

    res = merge(y1, y2)

    exp = Container({
        Id(NS_acme, "a"): Leaf(u64(1)),
        Id(NS_acme, "b"): Leaf(u64(2)),
        Id(NS_acme, "c"): Leaf(u64(3)),
        Id(NS_acme, "l1"): List([Id(NS_acme, "name")], [
            Container({
                Id(NS_acme, "name"): Leaf("k1"),
                Id(NS_acme, "n1"): Leaf(u64(1)),
                Id(NS_acme, "n2"): Leaf(u64(2))
            }),
            Container({
                Id(NS_acme, "name"): Leaf("k2"),
                Id(NS_acme, "n1"): Leaf(u64(1)),
                Id(NS_acme, "n3"): Leaf(u64(3))
            }),
            Container({
                Id(NS_acme, "name"): Leaf("k4"),
                Id(NS_acme, "n4"): Leaf(u64(4)),
            }),
        ]),
        Id(NS_acme, "d"): LeafList(["a", "b", "c"])
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(res.prsrc(deterministic=True), exp.prsrc(deterministic=True))

def _test_merge_list1():
    y1 = List([Id(NS_acme, "name")], [
        Container({
            Id(NS_acme, "name"): Leaf("first"),
            Id(NS_acme, "n1"): Leaf(u64(1))
        }),
        Container({
            Id(NS_acme, "name"): Leaf("breaker"),
            Id(NS_acme, "n1"): Leaf(u64(1))
        }),
        Container({
            Id(NS_acme, "name"): Leaf("fourth"),
            Id(NS_acme, "n1"): Leaf(u64(1))
        }),
        Container({
            Id(NS_acme, "name"): Leaf("common"),
            Id(NS_acme, "n2"): Leaf(u64(2))
        }),
        Container({
            Id(NS_acme, "name"): Leaf("last"),
            Id(NS_acme, "n1"): Leaf(u64(1))
        }),
    ], user_order=True, ns="http://example.com/acme", module="acme")

    y2 = List([Id(NS_acme, "name")], [
        Container({
            Id(NS_acme, "name"): Leaf("breaker")
        }),
        Container({
            Id(NS_acme, "name"): Leaf("second"),
            Id(NS_acme, "n1"): Leaf(u64(1))
        }),
        Container({
            Id(NS_acme, "name"): Leaf("third"),
            Id(NS_acme, "n1"): Leaf(u64(1))
        }),
        Container({
            Id(NS_acme, "name"): Leaf("common"),
            Id(NS_acme, "n1"): Leaf(u64(1))
        }),
        Container({
            Id(NS_acme, "name"): Leaf("last")
        })
    ], user_order=True, ns="http://example.com/acme", module="acme")

    exp = List([Id(NS_acme, "name")], [
        Container({
            Id(NS_acme, "name"): Leaf("first"),
            Id(NS_acme, "n1"): Leaf(u64(1))
        }),
        Container({
            Id(NS_acme, "name"): Leaf("breaker"),
            Id(NS_acme, "n1"): Leaf(u64(1))
        }),
        Container({
            Id(NS_acme, "name"): Leaf("fourth"),
            Id(NS_acme, "n1"): Leaf(u64(1))
        }),
        Container({
            Id(NS_acme, "name"): Leaf("common"),
            Id(NS_acme, "n2"): Leaf(u64(2)),
            Id(NS_acme, "n1"): Leaf(u64(1))
        }),
        Container({
            Id(NS_acme, "name"): Leaf("last"),
            Id(NS_acme, "n1"): Leaf(u64(1))
        }),
        Container({
            Id(NS_acme, "name"): Leaf("second"),
            Id(NS_acme, "n1"): Leaf(u64(1))
        }),
        Container({
            Id(NS_acme, "name"): Leaf("third"),
            Id(NS_acme, "n1"): Leaf(u64(1))
        }),
    ], user_order=True, ns="http://example.com/acme", module="acme")

    testing.assertEqual(exp, merge(y1, y2))

def _test_merge_leaf_conflict():
    y1 = Container({
        Id("", "a"): Leaf(u64(1))
    })
    y2 = Container({
        Id("", "a"): Leaf(u64(2))
    })

    try:
        merge(y1, y2)
        testing.assertFalse(True, "Expected ValueError but merge succeeded")
    except ValueError as e:
        testing.assertEqual("Cannot merge leaves with different values at /a: 1 != 2", e.error_message)

def _test_eq_list():
    l1 = List([Id("", "name")], [
        Container({
            Id("", "name"): Leaf("a"),
            Id("", "x"): Leaf(u64(1))
        }),
        Container({
            Id("", "name"): Leaf("b"),
            Id("", "x"): Leaf(u64(2))
        })
    ])
    l2 = List([Id("", "name")], [
        Container({
            Id("", "name"): Leaf("b"),
            Id("", "x"): Leaf(u64(2))
        }),
        Container({
            Id("", "name"): Leaf("a"),
            Id("", "x"): Leaf(u64(1))
        })
    ])
    testing.assertEqual(l1, l1)
    testing.assertEqual(l1, l2)

def _test_eq_list_user_order():
    l1 = List([Id("", "name")], user_order=True, elements=[
        Container({
            Id("", "x"): Leaf(u64(1))
        }),
        Container({
            Id("", "x"): Leaf(u64(2))
        })
    ])
    l2 = List([Id("", "name")], user_order=True, elements=[
        Container({
            Id("", "x"): Leaf(u64(2))
        }),
        Container({
            Id("", "x"): Leaf(u64(1))
        })
    ])
    testing.assertEqual(l1, l1)
    testing.assertNotEqual(l1, l2)

def _test_vals_list_sorted():
    l1 = LeafList(["a", "b", "c"])
    l2 = LeafList(["c", "b", "a"])
    testing.assertEqual(l1.prsrc(deterministic=True), l1.prsrc(deterministic=True))
    testing.assertEqual(l1.prsrc(deterministic=True), l2.prsrc(deterministic=True))

def _test_eq_leaf_list_user_order():
    l1 = LeafList(["a", "b", "c"], user_order=True)
    l2 = LeafList(["c", "b", "a"], user_order=True)
    testing.assertEqual(l1, l1)
    testing.assertNotEqual(l1, l2)

def _test_diff_no_change():
    """In this test, old and new are identical. We expect diff to return None
    since there are no differences.
    """
    old = Container({
        Id(NS_acme, "a"): Leaf(u64(1)),
        Id(NS_acme, "b"): Leaf(u64(2))
    }, ns="http://example.com/acme", module="acme")

    new = Container({
        Id(NS_acme, "a"): Leaf(u64(1)),
        Id(NS_acme, "b"): Leaf(u64(2))
    }, ns="http://example.com/acme", module="acme")

    d = diff(old, new)
    testing.assertEqual(d, None)

def _test_diff_leaf_change():
    """Only one leaf changes its value. We expect diff to return a container
    with just that leaf changed.
    """
    old = Container({
        Id(NS_acme, "a"): Leaf(u64(1)),
        Id(NS_acme, "b"): Leaf(u64(2))
    }, ns="http://example.com/acme", module="acme")

    new = Container({
        Id(NS_acme, "a"): Leaf(u64(42)), # Changed from 1 to 42
        Id(NS_acme, "b"): Leaf(u64(2))
    }, ns="http://example.com/acme", module="acme")

    d = diff(old, new)

    exp = Container({
        Id(NS_acme, "a"): Leaf(u64(42))
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(d, exp)

def _test_diff_node_removal():
    """A node c is removed from old to new. We expect an Absent() node in the
    diff at the place where c was.
    """
    old = Container({
        Id(NS_acme, "a"): Leaf(u64(1)),
        Id(NS_acme, "c"): Leaf(u64(3)),
        Id(NS_acme, "d"): Leaf(u64(4))
    }, ns="http://example.com/acme", module="acme")

    new = Container({
        Id(NS_acme, "a"): Leaf(u64(1)),
        Id(NS_acme, "d"): Leaf(u64(4))
    }, ns="http://example.com/acme", module="acme")

    d = diff(old, new)

    # c is removed
    exp = Container({
        Id(NS_acme, "c"): Absent({
            Id(NS_acme, "c"): Leaf(u64(3))
        })
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(d, exp)

def _test_diff_list_removal():
    """The entire list (all entries) is removed."""
    old = Container({
        Id(NS_acme, "l"): List([Id(NS_acme, "name")], [
        Container({
            Id(NS_acme, "name"): Leaf("k1"),
            Id(NS_acme, "n1"): Leaf(u64(1)),
            Id(NS_acme, "n2"): Leaf(u64(2)),
        }),
        Container({
            Id(NS_acme, "name"): Leaf("k4"),
            Id(NS_acme, "n4"): Leaf(u64(4)),
        }),
    ], ns="http://example.com/acme", module="acme")
    })

    new = Container()

    d = diff(old, new)

    # Entire list is removed
    exp = Container({
        Id(NS_acme, "l"): Absent({
            Id(NS_acme, "l"): List([Id(NS_acme, "name")], [
                Container({
                    Id(NS_acme, "name"): Leaf("k1"),
                    Id(NS_acme, "n1"): Leaf(u64(1)),
                    Id(NS_acme, "n2"): Leaf(u64(2)),
                }),
                Container({
                    Id(NS_acme, "name"): Leaf("k4"),
                    Id(NS_acme, "n4"): Leaf(u64(4)),
                }),
            ], ns="http://example.com/acme", module="acme")
        }, ns="http://example.com/acme", module="acme")
    })

    if d is not None:
        testing.assertEqual(d.prsrc(), exp.prsrc())
    testing.assertEqual(d, exp)

def _test_diff_elem_removal():
    """A list element k1 is removed from old to new. We expect an Absent("k1")
    node in the diff at the place where k1 was.
    """
    old = List([Id(NS_acme, "name")], [
        Container({
            Id(NS_acme, "name"): Leaf("k1"),
            Id(NS_acme, "n1"): Leaf(u64(1)),
            Id(NS_acme, "n2"): Leaf(u64(2)),
        }),
        Container({
            Id(NS_acme, "name"): Leaf("k4"),
            Id(NS_acme, "n4"): Leaf(u64(4)),
        }),
    ], ns="http://example.com/acme", module="acme")

    new = List([Id(NS_acme, "name")], [
        Container({
            Id(NS_acme, "name"): Leaf("k4"),
            Id(NS_acme, "n4"): Leaf(u64(4)),
        }),
    ], ns="http://example.com/acme", module="acme")

    d = diff(old, new)

    # k1 is removed
    exp = List([Id(NS_acme, "name")], [
        Absent({
            Id(NS_acme, "name"): Leaf("k1")
        })
    ], ns="http://example.com/acme", module="acme")

    testing.assertEqual(d, exp)

def _test_diff_node_addition():
    """A new node e is added in new. We expect the diff to have that new node.
    """
    old = Container({
        Id(NS_acme, "a"): Leaf(u64(1))
    }, ns="http://example.com/acme", module="acme")

    new = Container({
        Id(NS_acme, "a"): Leaf(u64(1)),
        Id(NS_acme, "e"): Leaf(u64(5))
    }, ns="http://example.com/acme", module="acme")

    d = diff(old, new)

    # e is new
    exp = Container({
        Id(NS_acme, "e"): Leaf(u64(5))
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(d, exp)

def _test_diff_leaflist():
    """Testing differences in a leaf-list. One value changes and one is
    added.
    """
    old = Container({
        Id(NS_acme, "l"): LeafList(["a", "b", "c"])
    }, ns="http://example.com/acme", module="acme")

    new = Container({
        Id(NS_acme, "l"): LeafList(["a", "x", "c", "d"]) # "b" changed to "x" and "d" added
    }, ns="http://example.com/acme", module="acme")

    d = diff(old, new)

    exp = Container({
        Id(NS_acme, "l"): LeafList(["a", "x", "c", "d"])
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(d, exp)

def _test_diff_complex_ordering():
    """A more complex scenario where the old container has nodes [a, b, c] and
    the new container has [a, c, d]. We expect the absent node b to appear
    before the new node d in the diff.
    """
    old = Container({
        Id(NS_acme, "a"): Leaf(u64(1)),
        Id(NS_acme, "b"): Leaf(u64(2)),
        Id(NS_acme, "c"): Leaf(u64(3))
    }, ns="http://example.com/acme", module="acme")

    new = Container({
        Id(NS_acme, "a"): Leaf(u64(1)),
        Id(NS_acme, "c"): Leaf(u64(3)),
        Id(NS_acme, "d"): Leaf(u64(4))
    }, ns="http://example.com/acme", module="acme")

    d = diff(old, new)

    # "b" is absent before "d" is introduced
    exp = Container({
        Id(NS_acme, "b"): Absent({
            Id(NS_acme, "b"): Leaf(u64(2))
        }),
        Id(NS_acme, "d"): Leaf(u64(4))
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(d, exp)

def _test_diff_union_type():
    old = Container({
        Id("", "l"): Leaf(u64(42)),
        Id("", "ll"): LeafList([u64(42)])
    })

    new = Container({
        Id("", "l"): Leaf("forty-two"),
        Id("", "ll"): LeafList(["forty-two"])
    })

    d = diff(old, new)
    testing.assertEqual(d, new)

def _test_diff_empty_leaf_delete():
    old = Container({
        Id("", "a"): Leaf(Present()),
    })

    new = Container({
        Id("", "a"): Absent()
    })

    d = diff(old, new)
    testing.assertEqual(d, new)

def _test_patch_no_change():
    old = Container({
        Id(NS_acme, "a"): Leaf(u64(1)),
        Id(NS_acme, "b"): Leaf(u64(2)),
    }, ns="http://example.com/acme", module="acme")

    # diff is None means no changes
    p = None

    res = patch(old, p)
    testing.assertEqual(res, old)

def _test_patch_leaf_change():
    old = Container({
        Id(NS_acme, "a"): Leaf(u64(1)),
        Id(NS_acme, "b"): Leaf(u64(2)),
    }, ns="http://example.com/acme", module="acme")

    # Suppose we want to change leaf 'a' from 1 to 42
    # diff would look like this:
    p = Container({
        Id(NS_acme, "a"): Leaf(u64(42)),
    }, ns="http://example.com/acme", module="acme")

    res = patch(old, p)
    exp = Container({
        Id(NS_acme, "a"): Leaf(u64(42)),
        Id(NS_acme, "b"): Leaf(u64(2)),
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(res, exp)

def _test_patch_node_removal():
    old = Container({
        Id(NS_acme, "a"): Leaf(u64(1)),
        Id(NS_acme, "c"): Leaf(u64(3)),
    }, ns="http://example.com/acme", module="acme")

    # Suppose we remove 'c'
    # patch would be:
    p = Container({
        Id(NS_acme, "c"): Absent()
    }, ns="http://example.com/acme", module="acme")

    res = patch(old, p)
    exp = Container({
        Id(NS_acme, "a"): Leaf(u64(1)),
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(res, exp)

def _test_patch_elem_removal():
    old = List([Id(NS_acme, "name")], [
        Container({
            Id(NS_acme, "name"): Leaf("k1"),
            Id(NS_acme, "n1"): Leaf(u64(1)),
            Id(NS_acme, "n2"): Leaf(u64(2))
        }),
        Container({
            Id(NS_acme, "name"): Leaf("k4"),
            Id(NS_acme, "n4"): Leaf(u64(4)),
        }),
    ], ns="http://example.com/acme", module="acme")

    # Suppose we remove 'k1'
    # patch would be:
    p = List([Id(NS_acme, "name")], [
        Absent({
            Id(NS_acme, "name"): Leaf("k1")
        })
    ], ns="http://example.com/acme", module="acme")

    res = patch(old, p)
    exp = List([Id(NS_acme, "name")], [
        Container({
            Id(NS_acme, "name"): Leaf("k4"),
            Id(NS_acme, "n4"): Leaf(u64(4)),
        }),
    ], ns="http://example.com/acme", module="acme")

    testing.assertEqual(res, exp)

def _test_patch_elem_removal2():
    old = Container({
        Id("", "n1"): Leaf(u64(1)),
        Id("", "n2"): Leaf(u64(2))
    })

    p = Absent({
        Id("", "name"): Leaf("k1")
    })

    res = patch(old, p)

    testing.assertEqual(res, None)

def _test_patch_node_addition():
    old = Container({
        Id(NS_acme, "a"): Leaf(u64(1)),
    }, ns="http://example.com/acme", module="acme")

    # Add a new leaf 'e':
    p = Container({
        Id(NS_acme, "e"): Leaf(u64(5))
    }, ns="http://example.com/acme", module="acme")

    res = patch(old, p)
    exp = Container({
        Id(NS_acme, "a"): Leaf(u64(1)),
        Id(NS_acme, "e"): Leaf(u64(5)),
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(res, exp)

def _test_patch_create_leaf_wrapper_to_leaf():
    old = Container({})

    p = Container({
        Id("", "a"): CreateLeaf(u64(9))
    })

    res = patch(old, p)
    exp = Container({
        Id("", "a"): Leaf(u64(9))
    })

    testing.assertEqual(res, exp)

def _test_patch_replace_leaf_wrapper_to_leaf():
    old = Container({
        Id("", "a"): Leaf(u64(1))
    })

    p = Container({
        Id("", "a"): ReplaceLeaf(u64(2))
    })

    res = patch(old, p)
    exp = Container({
        Id("", "a"): Leaf(u64(2))
    })

    testing.assertEqual(res, exp)

def _test_patch_create_leaf_existing_error():
    old = Container({
        Id("", "a"): Leaf(u64(1))
    })

    p = Container({
        Id("", "a"): CreateLeaf(u64(2))
    })

    try:
        patch(old, p)
        testing.assertFalse(True, "Expected ValueError for data-exists but patch succeeded")
    except ValueError as e:
        testing.assertIn("data-exists", e.error_message)


def _test_patch_complex_ordering():
    # old: a, b, c
    old = Container({
        Id(NS_acme, "a"): Leaf(u64(1)),
        Id(NS_acme, "b"): Leaf(u64(2)),
        Id(NS_acme, "c"): Leaf(u64(3)),
    }, ns="http://example.com/acme", module="acme")

    # new: a, c, d
    # diff: remove b, add d
    p = Container({
        Id(NS_acme, "b"): Absent(),
        Id(NS_acme, "d"): Leaf(u64(4))
    }, ns="http://example.com/acme", module="acme")

    res = patch(old, p)
    exp = Container({
        Id(NS_acme, "a"): Leaf(u64(1)),
        Id(NS_acme, "c"): Leaf(u64(3)),
        Id(NS_acme, "d"): Leaf(u64(4)),
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(res, exp)

def _test_patch_leaflist():
    old = Container({
        Id(NS_acme, "l"): LeafList(["a", "b", "c"])
    }, ns="http://example.com/acme", module="acme")

    # new: l = [a, x, c, d]
    # diff would be a leaflist replace:
    p = Container({
        Id(NS_acme, "l"): LeafList(["a", "x", "c", "d"])
    }, ns="http://example.com/acme", module="acme")

    res = patch(old, p)
    exp = Container({
        Id(NS_acme, "l"): LeafList(["a", "x", "c", "d"])
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(res, exp)

def _test_patch_union_type():
    old = Container({
        Id("", "l"): Leaf(u64(42)),
        Id("", "ll"): LeafList([u64(42)])
    })

    p = Container({
        Id("", "l"): Leaf("forty-two"),
        Id("", "ll"): LeafList(["forty-two"])
    })

    res = patch(old, p)
    testing.assertEqual(res, p)

def _test_patch_create_container_missing():
    old = Container({
        Id("", "a"): Leaf(u64(1))
    })

    p = Container({
        Id("", "c"): Create({
            Id("", "x"): Leaf(u64(9))
        })
    })

    res = patch(old, p)
    exp = Container({
        Id("", "a"): Leaf(u64(1)),
        Id("", "c"): Container({
            Id("", "x"): Leaf(u64(9))
        })
    })

    testing.assertEqual(res, exp)

def _test_patch_create_container_existing_error():
    old = Container({
        Id("", "c"): Container({
            Id("", "x"): Leaf(u64(1))
        })
    })

    p = Container({
        Id("", "c"): Create({
            Id("", "x"): Leaf(u64(2))
        })
    })

    try:
        patch(old, p)
        testing.assertFalse(True, "Expected ValueError for data-exists but patch succeeded")
    except ValueError as e:
        testing.assertIn("data-exists", e.error_message)

def _test_patch_replace_container_existing():
    old = Container({
        Id("", "c"): Container({
            Id("", "x"): Leaf(u64(1)),
            Id("", "y"): Leaf(u64(2))
        })
    })

    p = Container({
        Id("", "c"): Replace({
            Id("", "x"): Leaf(u64(9))
        })
    })

    res = patch(old, p)
    exp = Container({
        Id("", "c"): Container({
            Id("", "x"): Leaf(u64(9))
        })
    })

    testing.assertEqual(res, exp)

def _test_patch_delete_container_missing_error():
    old = Container({
        Id("", "a"): Leaf(u64(1))
    })

    p = Container({
        Id("", "c"): Delete()
    })

    try:
        patch(old, p)
        testing.assertFalse(True, "Expected ValueError for data-missing but patch succeeded")
    except ValueError as e:
        testing.assertIn("data-missing", e.error_message)

def _test_patch_list_elem_create_replace():
    old = List([Id("", "k")], [
        Container({
            Id("", "k"): Leaf("a"),
            Id("", "v"): Leaf("old"),
            Id("", "x"): Leaf("keep")
        })
    ])

    p = List([Id("", "k")], [
        Replace({
            Id("", "k"): Leaf("a"),
            Id("", "v"): Leaf("rep")
        }),
        Create({
            Id("", "k"): Leaf("b"),
            Id("", "v"): Leaf("new")
        })
    ])

    res = patch(old, p)
    exp = List([Id("", "k")], [
        Container({
            Id("", "k"): Leaf("a"),
            Id("", "v"): Leaf("rep")
        }),
        Container({
            Id("", "k"): Leaf("b"),
            Id("", "v"): Leaf("new")
        })
    ])

    testing.assertEqual(res, exp)

def _test_patch_preserve_empty_leaf():
    """Remove (Absent) on empty leaf inside list element/container should be preserved."""
    old = Container({})

    p = Container({
        Id("", "c"): Container({
            Id("", "shutdown"): Absent()
        }),
        Id("", "l"): List([Id("", "name")], [
            Container({
                Id("", "name"): Leaf("a"),
                Id("", "shutdown"): Absent()
            })
        ])
    })

    res = patch(old, p)
    exp = Container({
        Id("", "c"): Container({
            Id("", "shutdown"): Absent()
        }),
        Id("", "l"): List([Id("", "name")], [
            Container({
                Id("", "name"): Leaf("a"),
                Id("", "shutdown"): Absent()
            })
        ])
    })

    testing.assertEqual(res, exp)

def _test_patch_list_elem_create_existing_error():
    old = List([Id("", "k")], [
        Container({
            Id("", "k"): Leaf("a"),
            Id("", "v"): Leaf("old")
        })
    ])

    p = List([Id("", "k")], [
        Create({
            Id("", "k"): Leaf("a"),
            Id("", "v"): Leaf("new")
        })
    ])

    try:
        patch(old, p)
        testing.assertFalse(True, "Expected ValueError for data-exists but patch succeeded")
    except ValueError as e:
        testing.assertIn("data-exists", e.error_message)

def _test_patch_list_elem_delete_missing_error():
    old = List([Id("", "k")], [
        Container({
            Id("", "k"): Leaf("a"),
            Id("", "v"): Leaf("old")
        })
    ])

    p = List([Id("", "k")], [
        Delete({
            Id("", "k"): Leaf("b")
        })
    ])

    try:
        patch(old, p)
        testing.assertFalse(True, "Expected ValueError for data-missing but patch succeeded")
    except ValueError as e:
        testing.assertIn("data-missing", e.error_message)

def _test_diff_system_ordered_list_no_diff():
    """Test that diff returns None for reordered elements in system-ordered lists.

    System-ordered lists (user_order=False, which is the default) should not care about
    element ordering. The system is free to reorder elements, so reordering should not
    generate any diff. The diff should be None when comparing two system-ordered lists
    with the same elements in different order.
    """
    elem1 = Container({
        Id("", "id"): Leaf("1"),
        Id("", "name"): Leaf("first")
    })
    elem2 = Container({
        Id("", "id"): Leaf("2"),
        Id("", "name"): Leaf("second")
    })
    elem3 = Container({
        Id("", "id"): Leaf("3"),
        Id("", "name"): Leaf("third")
    })

    old_list = List(
        keys=[Id("", "id")],
        elements=[elem1, elem2, elem3],
        user_order=False
    )

    new_list = List(
        keys=[Id("", "id")],
        elements=[elem2, elem1, elem3],
        user_order=False
    )

    result = diff(old_list, new_list)
    testing.assertNone(result, "System-ordered list reordering should not generate a diff")

def _test_diff_and_patch_large_tree():
    # Construct a large 'old' data tree under a Container node
    old = Container({
        Id("http://example.com/yang/mod1", "mod1"): Container(children={
            Id("http://example.com/yang/mod1", "conf"): Container(children={
                Id("http://example.com/yang/mod1", "settings"): Container({
                    Id("http://example.com/yang/mod1", "hostname"): Leaf("old-router"),
                    Id("http://example.com/yang/mod1", "motd"): Leaf("Welcome!")
                }),
                Id("http://example.com/yang/mod1", "interfaces"): List([Id("http://example.com/yang/mod1", "name")], elements=[
                    Container({
                        Id("http://example.com/yang/mod1", "name"): Leaf("eth0"),
                        Id("http://example.com/yang/mod1", "desc"): Leaf("Uplink interface"),
                        Id("http://example.com/yang/mod1", "enabled"): Leaf(True)
                    }),
                    Container({
                        Id("http://example.com/yang/mod1", "name"): Leaf("eth1"),
                        Id("http://example.com/yang/mod1", "desc"): Leaf("Internal interface"),
                        Id("http://example.com/yang/mod1", "enabled"): Leaf(True)
                    }),
                ])
            }, ns="http://example.com/yang/mod1", module="mod1")
        }),
        Id("http://example.com/yang/mod2", "mod2"): Container(children={
            Id("http://example.com/yang/mod2", "acl"): Container(children={
                Id("http://example.com/yang/mod2", "rules"): List([Id("http://example.com/yang/mod2", "id")], elements=[
                    Container({
                        Id("http://example.com/yang/mod2", "id"): Leaf(u64(10)),
                        Id("http://example.com/yang/mod2", "action"): Leaf("permit"),
                        Id("http://example.com/yang/mod2", "src"): Leaf("10.0.0.0/24"),
                        Id("http://example.com/yang/mod2", "dst"): Leaf("10.0.1.0/24"),
                    }),
                    Container({
                        Id("http://example.com/yang/mod2", "id"): Leaf(u64(20)),
                        Id("http://example.com/yang/mod2", "action"): Leaf("deny"),
                        Id("http://example.com/yang/mod2", "src"): Leaf("any"),
                        Id("http://example.com/yang/mod2", "dst"): Leaf("any"),
                    }),
                ])
            }, ns="http://example.com/yang/mod2", module="mod2")
        }),
    })

    # Construct a large 'new' data tree under a Container node
    # Changes from old:
    # - hostname changed from "old-router" to "new-router"
    # - motd removed
    # - eth1 is removed
    # - a new interface eth2 is added
    # - mod2 acl rule 20 changes action from deny to drop
    # - a new acl rule 30 is added
    # - add a LeafList in settings "ntp-servers"
    new = Container(children={
        Id("http://example.com/yang/mod1", "mod1"): Container(children={
            Id("http://example.com/yang/mod1", "conf"): Container(children={
                Id("http://example.com/yang/mod1", "settings"): Container(children={
                    Id("http://example.com/yang/mod1", "hostname"): Leaf("new-router"),
                    # motd removed
                    Id("http://example.com/yang/mod1", "ntp-servers"): LeafList(["192.168.100.1", "192.168.100.2"])
                }),
                Id("http://example.com/yang/mod1", "interfaces"): List([Id("http://example.com/yang/mod1", "name")], elements=[
                    Container({
                        Id("http://example.com/yang/mod1", "name"): Leaf("eth0"),
                        Id("http://example.com/yang/mod1", "desc"): Leaf("Uplink interface"),
                        Id("http://example.com/yang/mod1", "enabled"): Leaf(True)
                    }),
                    # eth1 removed
                    Container({
                        Id("http://example.com/yang/mod1", "name"): Leaf("eth2"),
                        Id("http://example.com/yang/mod1", "desc"): Leaf("DMZ interface"),
                        Id("http://example.com/yang/mod1", "enabled"): Leaf(False)
                    }),
                ])
            }, ns="http://example.com/yang/mod1", module="mod1")
        }),
        Id("http://example.com/yang/mod2", "mod2"): Container(children={
            Id("http://example.com/yang/mod2", "acl"): Container(children={
                Id("http://example.com/yang/mod2", "rules"): List([Id("http://example.com/yang/mod2", "id")], elements=[
                    Container({
                        Id("http://example.com/yang/mod2", "id"): Leaf(u64(10)),
                        Id("http://example.com/yang/mod2", "action"): Leaf("permit"),
                        Id("http://example.com/yang/mod2", "src"): Leaf("10.0.0.0/24"),
                        Id("http://example.com/yang/mod2", "dst"): Leaf("10.0.1.0/24"),
                    }),
                    Container({
                        Id("http://example.com/yang/mod2", "id"): Leaf(u64(20)),
                        Id("http://example.com/yang/mod2", "action"): Leaf("drop"),  # changed from deny
                        Id("http://example.com/yang/mod2", "src"): Leaf("any"),
                        Id("http://example.com/yang/mod2", "dst"): Leaf("any"),
                    }),
                    Container({
                        Id("http://example.com/yang/mod2", "id"): Leaf(u64(30)),
                        Id("http://example.com/yang/mod2", "action"): Leaf("permit"),
                        Id("http://example.com/yang/mod2", "src"): Leaf("192.0.2.0/24"),
                        Id("http://example.com/yang/mod2", "dst"): Leaf("198.51.100.0/24"),
                    }),
                ])
            }, ns="http://example.com/yang/mod2", module="mod2")
        })
    })

    # Compute diff
    print("Old: ", old.prsrc())
    d = diff(old, new)
    if d is not None:
        print("Diff result: ", d.prsrc())
    else:
        print("Diff result: None")

    # Check that patching old with d results in new
    res = patch(old, d)
    if res is not None:
        testing.assertEqual(res.prsrc(deterministic=True), new.prsrc(deterministic=True))

    # Also check that if we apply diff(new, old), and patch(new, diff(new, old)) we get old back.
    # This ensures round-trip behavior.
    #d2 = diff(new, old)
    #res2 = patch(new, d2)
    #testing.assertEqual(res2, old)

def _test_prsrc():
    y1 = Container({
        Id(NS_acme, "foo"): Container({
            Id(NS_acme, "a"): Leaf(u64(1)),
            Id(NS_acme, "l1"): List([Id(NS_acme, "name")], [
                Container({
                    Id(NS_acme, "name"): Leaf("k1"),
                    Id(NS_acme, "n1"): Leaf(u64(1)),
                    Id(NS_acme, "n2"): Leaf(u64(2))
                }),
                Container({
                    Id(NS_acme, "name"): Leaf("k4"),
                    Id(NS_acme, "n4"): Leaf(u64(4)),
                }),
            ])
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.prsrc()

def _test_prsrc_absent():
    y1 = Container({
        Id(NS_acme, "foo"): Container({
            Id(NS_acme, "a"): Absent(),
            Id(NS_acme, "l1"): List([Id(NS_acme, "name")], [
                Absent({
                    Id(NS_acme, "name"): Leaf("k1")
                }),
                Container({
                    Id(NS_acme, "name"): Leaf("k4"),
                    Id(NS_acme, "n4"): Leaf(u64(4)),
                }),
            ])
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.prsrc()

def _test_prsrc_root():
    y1 = Container({
        Id(NS_acme, "foo"): Container({
            Id(NS_acme, "a"): Leaf(u64(1)),
            Id(NS_acme, "b"): LeafList(["a", "b", "c"]),
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.prsrc()

def _test_prsrc_leaf_ns():
    y1 = Container({
        Id(NS_acme, "foo"): Container({
            Id(NS_acme, "a"): Leaf(u64(1), ns="http://example.com/foo", module="foo"),
            Id(NS_acme, "b"): Leaf(u64(2))
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.prsrc()

def _test_prsrc_identityref():
    y1 = Container({
        Id(NS_acme, "identity-local"): Leaf(Identityref("foo", "http://example.com/acme", "acme", "acme")),
        Id(NS_acme, "identity-other"): Leaf(Identityref("bar", "http://example.com/bar", "bar", "bar")),
        Id(NS_acme, "augmented-identity-other"): Leaf(Identityref("bar", "http://example.com/bar", "bar", "bar"), "http://example.com/augmentor", "augmentor"),
    }, ns="http://example.com/acme", module="acme")

    return y1.prsrc()

def _test_to_jsonstr():
    y1 = Container({
        Id(NS_acme, "foo"): Container({
            Id(NS_acme, "a"): Leaf(u64(1)),
            Id(NS_acme, "l1"): List([Id(NS_acme, "name"), Id(NS_acme, "name_two")], [
                Container({
                    Id(NS_acme, "name"): Leaf("k1"),
                    Id(NS_acme, "name_two"): Leaf("k1a"),
                    Id(NS_acme, "n1"): Leaf(u64(1)),
                    Id(NS_acme, "n2"): Leaf(u64(2))
                }),
                Container({
                    Id(NS_acme, "name"): Leaf("k4"),
                    Id(NS_acme, "name_two"): Leaf("k4a"),
                    Id(NS_acme, "n4"): Leaf(u64(4)),
                }),
            ]),
            Id(NS_acme, "b"): Leaf(False),
            Id(NS_acme, "lb"): Leaf(b"Hello Acton \xf0\x9f\xab\xa1"),
            Id(NS_acme, "llb"): LeafList([b"Hello Acton \xf0\x9f\xab\xa1"]),
            Id(NS_acme, "c"): Leaf(u64(18446744073709551615)),
            Id(NS_acme, "d"): Leaf(Decimal(314, -2))
        }, ns="http://example.com/acme", module="acme"),
        Id("http://example.com/beep", "foo"): Container({
            Id("http://example.com/beep", "a"): Leaf(u64(1))
        }, ns="http://example.com/beep", module="beep")
    })

    return y1.to_jsonstr(pretty=True)

def _test_to_jsonstr_empty_leaf():
    y1 = Container({
        Id("", "e1"): Leaf(Present()),
        Id("", "e2"): Absent()
    })

    return y1.to_jsonstr(pretty=True)

def _test_to_jsonstr_identityref():
    y1 = Container({
        Id(NS_acme, "identity-local"): Leaf(Identityref("foo", "http://example.com/acme", "acme", "acme")),
        Id(NS_acme, "identity-other"): Leaf(Identityref("bar", "http://example.com/bar", "bar", "bar")),
        Id(NS_acme, "augmented-identity-other"): Leaf(Identityref("bar", "http://example.com/bar", "bar", "bar"), "http://example.com/augmentor", "augmentor"),
    }, ns="http://example.com/acme", module="acme")

    return y1.to_jsonstr(pretty=True)

def _test_to_xmlstr():
    y1 = Container({
        Id(NS_acme, "foo"): Container({
            Id(NS_acme, "a"): Leaf(u64(1)),
            Id(NS_acme, "l1"): List([Id(NS_acme, "name"), Id(NS_acme, "name_two")], [
                Container({
                    Id(NS_acme, "name"): Leaf("k1"),
                    Id(NS_acme, "name_two"): Leaf("k1a"),
                    Id(NS_acme, "n1"): Leaf(u64(1)),
                    Id(NS_acme, "n2"): Leaf(u64(2))
                }),
                Container({
                    Id(NS_acme, "name"): Leaf("k4"),
                    Id(NS_acme, "name_two"): Leaf("k4a"),
                    Id(NS_acme, "n4"): Leaf(u64(4)),
                }),
            ]),
            Id(NS_acme, "b"): Leaf(False),
            Id(NS_acme, "lb"): Leaf(b"Hello Acton \xf0\x9f\xab\xa1"),
            Id(NS_acme, "llb"): LeafList([b"Hello Acton \xf0\x9f\xab\xa1"]),
            Id(NS_acme, "c"): Leaf(u64(18446744073709551615)),
            Id(NS_acme, "d"): Leaf(Decimal(314, -2))
        }, ns="http://example.com/acme", module="acme"),
        Id("http://example.com/beep", "foo"): Container({
            Id("http://example.com/beep", "a"): Leaf(u64(1))
        }, ns="http://example.com/beep", module="beep")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_root():
    y1 = Container({
        Id(NS_acme, "foo"): Container({
            Id(NS_acme, "a"): Leaf(u64(1)),
            Id(NS_acme, "b"): LeafList(["a", "b", "c"]),
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_module():
    y1 = Container({
        Id(NS_acme, "foo"): Container({
            Id(NS_acme, "a"): Leaf(u64(1)),
            Id(NS_acme, "b"): LeafList(["a", "b", "c"]),
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_leaf_ns():
    y1 = Container({
        Id(NS_acme, "foo"): Container({
            Id(NS_acme, "a"): Leaf(u64(1), ns="http://example.com/foo", module="foo"),
            Id(NS_acme, "b"): Leaf(u64(2))
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_mixed():
    y1 = Container({
        Id("http://orchestron.org/yang/orchestron-device.yang", "device"): List([Id("http://orchestron.org/yang/orchestron-device.yang", "name")], [
            Container({
                Id("http://orchestron.org/yang/orchestron-device.yang", "name"): Leaf("dev1"),
                Id("http://orchestron.org/yang/orchestron-device.yang", "config"): Container({
                    Id("http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg", "hostname"): Container({
                        Id("http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg", "system-network-name"): Leaf("dev1")
                    }, ns="http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg")
                }),
            }),
            Container({
                Id("http://orchestron.org/yang/orchestron-device.yang", "name"): Leaf("dev2"),
                Id("http://orchestron.org/yang/orchestron-device.yang", "config"): Container({
                    Id("http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg", "hostname"): Container({
                        Id("http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg", "system-network-name"): Leaf("dev2")
                    }, ns="http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg")
                }),
            }),
        ], ns="http://orchestron.org/yang/orchestron-device.yang")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_root_merge():
    y1 = Container({
        Id(NS_acme, "foo"): Container({
            Id(NS_acme, "a"): Leaf(u64(1)),
            Id(NS_acme, "b"): LeafList(["a", "b", "c"]),
        }, ns="http://example.com/acme", module="acme")
    })
    y2 = Container({
        Id("http://example.com/bar", "bar"): Container({
            Id("http://example.com/bar", "b"): Leaf(u64(42)),
        }, ns="http://example.com/bar", module="bar")
    })
    ym = merge(y1, y2)

    return ym.to_xmlstr()

def _test_to_xmlstr_presence():
    y1 = Container({
        Id(NS_acme, "foo"): Container({
            Id(NS_acme, "a"): Leaf(u64(1))
        }, presence=True, ns="http://example.com/acme", module="acme")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_presence_childless():
    y1 = Container({
        Id(NS_acme, "foo"): Container(presence=True, ns="http://example.com/acme", module="acme")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_empty_leaf():
    y1 = Container({
        Id("", "e1"): Leaf(Present()),
        Id("", "e2"): Absent()
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_identityref():
    y1 = Container({
        Id(NS_acme, "identity-local"): Leaf(Identityref("foo", "http://example.com/acme", "acme", "acme")),
        Id(NS_acme, "identity-other"): Leaf(Identityref("bar", "http://example.com/bar", "bar", "bar")),
        Id(NS_acme, "augmented-identity-other"): Leaf(Identityref("bar", "http://example.com/bar", "bar", "bar"), "http://example.com/augmentor", "augmentor"),
    }, ns="http://example.com/acme", module="acme")

    return y1.to_xmlstr()

def _test_to_xmlstr_list_removal():
    y1 = Container({
        Id(NS_acme, "l"): Absent({
            Id(NS_acme, "l"): List([Id(NS_acme, "name")], [
                Container({
                    Id(NS_acme, "name"): Leaf("k1"),
                    Id(NS_acme, "n1"): Leaf(u64(1)),
                    Id(NS_acme, "n2"): Leaf(u64(2)),
                }),
                Container({
                    Id(NS_acme, "name"): Leaf("k4"),
                    Id(NS_acme, "n4"): Leaf(u64(4)),
                }),
            ], ns="http://example.com/acme", module="acme")
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.to_xmlstr()

################################################################################
# Filter tests
def _test_filter_container_wildcard():
    """Select a container without child predicates returns the full subtree."""
    data = Container({
        Id(NS_acme, "foo"): Container({
            Id(NS_acme, "l1"): Leaf(u64(1)),
            Id(NS_acme, "l2"): Leaf(u64(2)),
        }, ns=NS_acme, module="acme"),
        Id(NS_acme, "bar"): Container({
            Id(NS_acme, "b1"): Leaf(u64(7)),
        }, ns=NS_acme, module="acme"),
    })
    filt = FNode(None, None, [
        FNode(Id(NS_acme, "foo")),
    ])
    res = expect(filter(data, filt), "filter result")
    testing.assertEqual(
        res.prsrc(deterministic=True),
        Container({
            Id(NS_acme, "foo"): Container({
                Id(NS_acme, "l1"): Leaf(u64(1)),
                Id(NS_acme, "l2"): Leaf(u64(2)),
            }, ns=NS_acme, module="acme"),
        }).prsrc(deterministic=True)
    )


def _test_filter_container_leaf_content_match():
    """Content-match leaf predicates filter by value but do not restrict selected leaves."""
    data = Container({
        Id(NS_acme, "foo"): Container({
            Id(NS_acme, "l1"): Leaf(u64(1)),
            Id(NS_acme, "l2"): Leaf(u64(2)),
        }, ns=NS_acme, module="acme"),
        Id(NS_acme, "bar"): Container({
            Id(NS_acme, "b1"): Leaf(u64(7)),
        }, ns=NS_acme, module="acme"),
    })
    filt = FNode(None, None, [
        FNode(Id(NS_acme, "foo"), children=[
            FNode(Id(NS_acme, "l1"), value_match=u64(1)),
        ]),
    ])
    res = expect(filter(data, filt), "filter result")
    testing.assertEqual(
        res.prsrc(deterministic=True),
        Container({
            Id(NS_acme, "foo"): Container({
                Id(NS_acme, "l1"): Leaf(u64(1)),
                Id(NS_acme, "l2"): Leaf(u64(2)),
            }, ns=NS_acme, module="acme"),
        }).prsrc(deterministic=True)
    )


def _test_filter_container_leaf_select():
    """Leaf selection predicate limits output to requested leaves."""
    data = Container({
        Id(NS_acme, "foo"): Container({
            Id(NS_acme, "l1"): Leaf(u64(1)),
            Id(NS_acme, "l2"): Leaf(u64(2)),
        }, ns=NS_acme, module="acme"),
        Id(NS_acme, "bar"): Container({
            Id(NS_acme, "b1"): Leaf(u64(7)),
        }, ns=NS_acme, module="acme"),
    })
    filt = FNode(None, None, [
        FNode(Id(NS_acme, "foo"), children=[
            FNode(Id(NS_acme, "l1")),
        ]),
    ])
    res = expect(filter(data, filt), "filter result")
    testing.assertEqual(
        res.prsrc(deterministic=True),
        Container({
            Id(NS_acme, "foo"): Container({
                Id(NS_acme, "l1"): Leaf(u64(1)),
            }, ns=NS_acme, module="acme"),
        }).prsrc(deterministic=True)
    )


def _test_filter_container_leaf_no_match():
    """Non-matching content predicate yields no result."""
    data = Container({
        Id(NS_acme, "foo"): Container({
            Id(NS_acme, "l1"): Leaf(u64(1)),
            Id(NS_acme, "l2"): Leaf(u64(2)),
        }, ns=NS_acme, module="acme")
    })
    filt = FNode(None, None, [
        FNode(Id(NS_acme, "foo"), children=[
            FNode(Id(NS_acme, "l1"), value_match=u64(3)),
        ]),
    ])
    res = filter(data, filt)
    testing.assertEqual(res, None)


def _test_filter_list_wildcard():
    """List selection without element predicates returns all list elements."""
    k = Id(NS_acme, "name")
    data = Container({
        Id(NS_acme, "foo"): Container({
            Id(NS_acme, "l"): List([k], [
                Container({
                    Id(NS_acme, "name"): Leaf("a"),
                    Id(NS_acme, "v"): Leaf(u64(1)),
                }),
                Container({
                    Id(NS_acme, "name"): Leaf("b"),
                    Id(NS_acme, "v"): Leaf(u64(2)),
                }),
            ], ns=NS_acme, module="acme"),
            Id(NS_acme, "extra"): Leaf(u64(9)),
        }, ns=NS_acme, module="acme"),
        Id(NS_acme, "bar"): Container({
            Id(NS_acme, "b1"): Leaf(u64(7)),
        }, ns=NS_acme, module="acme"),
    })
    filt = FNode(None, None, [
        FNode(Id(NS_acme, "foo"), children=[
            FNode(Id(NS_acme, "l")),
        ]),
    ])
    res = expect(filter(data, filt), "filter result")
    testing.assertEqual(
        res.prsrc(deterministic=True),
        Container({
            Id(NS_acme, "foo"): Container({
                Id(NS_acme, "l"): List([k], [
                    Container({
                        Id(NS_acme, "name"): Leaf("a"),
                        Id(NS_acme, "v"): Leaf(u64(1)),
                    }),
                    Container({
                        Id(NS_acme, "name"): Leaf("b"),
                        Id(NS_acme, "v"): Leaf(u64(2)),
                    }),
                ], ns=NS_acme, module="acme")
            }, ns=NS_acme, module="acme")
        }).prsrc(deterministic=True)
    )


def _test_filter_list_keyed_child():
    """List element predicate on key selects matching element, returns full element subtree."""
    k = Id(NS_acme, "name")
    data = Container({
        Id(NS_acme, "foo"): Container({
            Id(NS_acme, "l"): List([k], [
                Container({
                    Id(NS_acme, "name"): Leaf("a"),
                    Id(NS_acme, "v"): Leaf(u64(1)),
                    Id(NS_acme, "x"): Leaf(u64(9)),
                }),
                Container({
                    Id(NS_acme, "name"): Leaf("b"),
                    Id(NS_acme, "v"): Leaf(u64(2)),
                }),
            ], ns=NS_acme, module="acme")
        }, ns=NS_acme, module="acme"),
        Id(NS_acme, "bar"): Container({
            Id(NS_acme, "b1"): Leaf(u64(7)),
        }, ns=NS_acme, module="acme"),
    })
    filt = FNode(None, None, [
        FNode(Id(NS_acme, "foo"), children=[
            FNode(Id(NS_acme, "l"), children=[
                FNode(Id(NS_acme, "name"), value_match="a"),
            ]),
        ]),
    ])
    res = expect(filter(data, filt), "filter result")
    testing.assertEqual(
        res.prsrc(deterministic=True),
        Container({
            Id(NS_acme, "foo"): Container({
                Id(NS_acme, "l"): List([k], [
                    Container({
                        Id(NS_acme, "name"): Leaf("a"),
                        Id(NS_acme, "v"): Leaf(u64(1)),
                        Id(NS_acme, "x"): Leaf(u64(9)),
                    }),
                ], ns=NS_acme, module="acme")
            }, ns=NS_acme, module="acme")
        }).prsrc(deterministic=True)
    )


def _test_filter_list_select_leaf():
    """List element predicate plus leaf selection limits fields in matched element."""
    k = Id(NS_acme, "name")
    data = Container({
        Id(NS_acme, "foo"): Container({
            Id(NS_acme, "l"): List([k], [
                Container({
                    Id(NS_acme, "name"): Leaf("a"),
                    Id(NS_acme, "v"): Leaf(u64(1)),
                    Id(NS_acme, "x"): Leaf(u64(9)),
                }),
                Container({
                    Id(NS_acme, "name"): Leaf("b"),
                    Id(NS_acme, "v"): Leaf(u64(2)),
                    Id(NS_acme, "x"): Leaf(u64(8)),
                }),
            ], ns=NS_acme, module="acme")
        }, ns=NS_acme, module="acme"),
    })
    filt = FNode(None, None, [
        FNode(Id(NS_acme, "foo"), children=[
            FNode(Id(NS_acme, "l"), children=[
                FNode(Id(NS_acme, "name"), value_match="a"),
                FNode(Id(NS_acme, "v")),
            ]),
        ]),
    ])
    res = expect(filter(data, filt), "filter result")
    testing.assertEqual(
        res.prsrc(deterministic=True),
        Container({
            Id(NS_acme, "foo"): Container({
                Id(NS_acme, "l"): List([k], [
                    Container({
                        Id(NS_acme, "name"): Leaf("a"),
                        Id(NS_acme, "v"): Leaf(u64(1)),
                    }),
                ], ns=NS_acme, module="acme")
            }, ns=NS_acme, module="acme")
        }).prsrc(deterministic=True)
    )


def _test_filter_leaflist_values():
    """Leaf-list content predicates return only matching values."""
    data = Container({
        Id(NS_acme, "foo"): Container({
            Id(NS_acme, "ll"): LeafList([u64(1), u64(2), u64(3)]),
            Id(NS_acme, "x"): Leaf(u64(9)),
        }, ns=NS_acme, module="acme"),
        Id(NS_acme, "bar"): Container({
            Id(NS_acme, "b1"): Leaf(u64(7)),
        }, ns=NS_acme, module="acme"),
    })
    filt = FNode(None, None, [
        FNode(Id(NS_acme, "foo"), children=[
            FNode(Id(NS_acme, "ll"), value_match=u64(2)),
            FNode(Id(NS_acme, "ll"), value_match=u64(3)),
        ]),
    ])
    res = expect(filter(data, filt), "filter result")
    # NOTE: Hmm, not entirely sure whether the expected LeafList should contain
    # all elements or just the content-matched ones!? RFC is not super clear...
    testing.assertEqual(
        res.prsrc(deterministic=True),
        Container({
            Id(NS_acme, "foo"): Container({
                Id(NS_acme, "ll"): LeafList([u64(2), u64(3)]),
            }, ns=NS_acme, module="acme")
        }).prsrc(deterministic=True)
    )


def _test_filter_wildcard_value_match():
    """Wildcard value match selects list elements by key pattern."""
    k = Id(NS_acme, "name")
    data = Container({
        Id(NS_acme, "foo"): Container({
            Id(NS_acme, "l"): List([k], [
                Container({
                    Id(NS_acme, "name"): Leaf("alpha"),
                    Id(NS_acme, "v"): Leaf(u64(1)),
                }),
                Container({
                    Id(NS_acme, "name"): Leaf("beta"),
                    Id(NS_acme, "v"): Leaf(u64(2)),
                }),
            ], ns=NS_acme, module="acme")
        }, ns=NS_acme, module="acme"),
    })
    filt = FNode(None, None, [
        FNode(Id(NS_acme, "foo"), children=[
            FNode(Id(NS_acme, "l"), children=[
                FNode(Id(NS_acme, "name"), value_match=VWildcard("a*")),
            ]),
        ]),
    ])
    res = expect(filter(data, filt), "filter result")
    testing.assertEqual(
        res.prsrc(deterministic=True),
        Container({
            Id(NS_acme, "foo"): Container({
                Id(NS_acme, "l"): List([k], [
                    Container({
                        Id(NS_acme, "name"): Leaf("alpha"),
                        Id(NS_acme, "v"): Leaf(u64(1)),
                    }),
                ], ns=NS_acme, module="acme")
            }, ns=NS_acme, module="acme")
        }).prsrc(deterministic=True)
    )
