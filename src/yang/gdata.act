import base64
import testing
import json
import xml

from yang.identityref import Identityref, PartialIdentityref
from yang.type import Decimal

"""YANG data

This module defines classes for YANG data nodes. It can represent a YANG data
tree, and can be used to serialize and deserialize YANG data.
"""

# kinds of things?
# - container
# - list
# - list element
# - leaf
# - leaf-list
#
# TODO: for ordered-by user lists, we need to expose a way to influence the order of elements

# Can we simply use the order of elements in the input list to control the order in the output?
#
# ACL1 which allows SSH and rejects everything else
# <acls>
#   <acl>
#     <aces>
#       <ace>
#         <name>SSH</name>
#         <action>permit</action>
#         <matches>
#           <ipv4>
#             <source-ipv4-network>192.0.2.0/24</source-ipv4-network>
#           </ipv4>
#           <protocol>tcp</protocol>
#           <tcp>
#             <destination-port>
#               <operator>eq</operator>
#               <port>22</port>
#             </destionation-port>
#           </tcp>
#         </matches>
#       </ace>
#       <ace>
#         <name>DROP</name>
#         <action>drop</action>
#       </ace>
#     </aces>
#   </acl>
# </acls>
#
# ACL2 which allows BGP and rejects everything else
# <acls>
#   <acl>
#     <aces>
#       <ace>
#         <name>BGP-PASSIVE</name>
#         <action>permit</action>
#         <src-port>179</src-port>
#         <matches>
#           <protocol>tcp</protocol>
#           <tcp>
#             <destination-port>
#               <operator>eq</operator>
#               <port>179</port>
#             </destionation-port>
#           </tcp>
#         </matches>
#       </ace>
#       <ace>
#         <name>DROP</name>
#       </ace>
#     </aces>
#   </acl>
# </acls>
#
# And the merged result should be:
#
# <acls>
#   <acl>
#     <aces>
#       <ace>
#         <name>SSH</name>
#         <action>permit</action>
#         <matches>
#           <ipv4>
#             <source-ipv4-network>192.0.2.0/24</source-ipv4-network>
#           </ipv4>
#           <protocol>tcp</protocol>
#           <tcp>
#             <destination-port>
#               <operator>eq</operator>
#               <port>22</port>
#             </destionation-port>
#           </tcp>
#         </matches>
#       </ace>
#       <ace>
#         <name>BGP-PASSIVE</name>
#         <action>permit</action>
#         <src-port>179</src-port>
#         <matches>
#           <protocol>tcp</protocol>
#           <tcp>
#             <destination-port>
#               <operator>eq</operator>
#               <port>179</port>
#             </destionation-port>
#           </tcp>
#         </matches>
#       </ace>
#       <ace>
#         <name>DROP</name>
#         <action>drop</action>
#       </ace>
#     </aces>
#   </acl>
# </acls>
#

#
#
# ACL1 which allows SSH and rejects everything else
#   <acl>
#       <ace>
#         <name>SSH</name>
#         <action>permit</action>
#         <matches>...</matches>
#       </ace>
#       <ace>
#         <name>DROP</name>
#         <action>drop</action>
#       </ace>
#   </acl>
#
# ACL2 which allows BGP and rejects everything else
#   <acl>
#       <ace>
#         <name>BGP-PASSIVE</name>
#         <action>permit</action>
#         <matches>...</matches>
#       </ace>
#       <ace>
#         <name>DROP</name>
#       </ace>
#   </acl>
#
# And the merged result should be:
#
#   <acl>
#       <ace>
#         <name>SSH</name>
#         <action>permit</action>
#         <matches>...</matches>
#       </ace>
#       <ace>
#         <name>BGP-PASSIVE</name>
#         <action>permit</action>
#         <matches>... </matches>
#       </ace>
#       <ace>
#         <name>DROP</name>
#         <action>drop</action>
#       </ace>
#   </acl>
#
# In the merge, we cannot know if SSH should come before or after BGP-PASSIVE,
# but it dosen't matter. The only important thing is that both are before the
# DROP rule. We make sure of this by stating in both input ACLs that DROP should
# be last. Note how in ACL2 the DROP ace is not complete, it just contains the
# name and nothing else. This is fine because the merge function will take the
# complete ACE from ACL1 and merge it with the incomplete ACE from ACL2 to
# produce a complete output.

def _ind(n):
    return "  " * n

remove_op = (nsdefs=[("xc", "urn:ietf:params:xml:ns:netconf:base:1.0")], attrs=[("xc:operation", "remove")])
create_op = (nsdefs=[("xc", "urn:ietf:params:xml:ns:netconf:base:1.0")], attrs=[("xc:operation", "create")])
delete_op = (nsdefs=[("xc", "urn:ietf:params:xml:ns:netconf:base:1.0")], attrs=[("xc:operation", "delete")])
replace_op = (nsdefs=[("xc", "urn:ietf:params:xml:ns:netconf:base:1.0")], attrs=[("xc:operation", "replace")])


def _nsq(node_ns, v: ?value=None):
    r = []
    if node_ns is not None:
        r.append((None, node_ns))
    if isinstance(v, Identityref):
        r.append((v.mod, v.ns))
    return r


def yang_str(v) -> str:
    if isinstance(v, bytes):
        s = base64.encode(v).decode()
        return s
    if isinstance(v, Identityref):
        s = "{v.mod}:{v.val}"
        return s
    s = str(v)
    if isinstance(v, bool):
        s = s.lower()
    return s


_min_i64 = bigint(-9223372036854775807-1)
_max_i64 = bigint(9223372036854775807)
_max_u64 = bigint(18446744073709551615)
def json_val(yang_type: str, v: value) -> ?value:
    if isinstance(v, bytes):
        return base64.encode(v).decode()
    if yang_type == "int64" or yang_type == "uint64" or yang_type == "decimal64":
        return str(v)
    if isinstance(v, Identityref):
        return "{v.mod}:{v.val}"
    # JSON encoder doesn't handle bigint, so we convert to a fixed size int, else a string
    if isinstance(v, bigint):
        if v >= _min_i64 and v <= _max_i64:
            return int(v)
        elif v >= 0 and v <= _max_u64:
            return u64(v)
        else:
            return str(v)
    return v


def fmt_json_name(name, module=None):
    name_without_prefix = name.split(":")[-1]
    if module is not None:
        return "{module}:{name_without_prefix}"
    return name_without_prefix


def repr_yang(v) -> str:
    # All numeric gdata values are bigint, so include an explicit cast because
    # these printed values are assigned to the "value" type when compiled
    if isinstance(v, bigint):
        return "bigint({v})"
    elif isinstance(v, list):
        return "[" + ", ".join([repr_yang(e) for e in v]) + "]"
    return repr(v)


class Node(value):
    ns: ?str
    module: ?str
    children: dict[str, Node]
    txid: ?str

    def __repr__(self) -> str:
        return self.prsrc(deterministic=False)

    def key_str(self, key_names: list[str]) -> str:
        return ",".join([str(self.get_leaf(kn).val).replace(",", "\\,") for kn in key_names])

    def key_values(self, key_names: list[str]) -> dict[str, value]:
        return {kn: self.get_leaf(kn).val for kn in key_names}

    def key_children(self, key_names: list[str]) -> dict[str, Leaf]:
        return {kn: self.get_leaf(kn) for kn in key_names}

    pure def prsrc(self, deterministic=False, indent=0, name="") -> str:
        """Get the Acton source code representation of the node

        Returns a string representation of this node that can be used to recreate
        the same data structure in Acton code. This is useful for debugging and
        testing.

        The deterministic output mode reorders children along with
        system-ordered leaf-list and list elements in order to render
        deterministic output which is very useful for testing. Only user-ordered
        lists and leaf-lists have semantic meaning, for non-user-ordered lists,
        the order of elements has no meaning which is why we can reorder them
        for deterministic output. The default is to produce raw
        non-deterministic output, which is more true to nature and a better
        representation for debugging.
        """
        ns_args = ["ns='{self.ns}'"] if self.ns is not None else []
        module_args = ["module='{self.module}'"] if self.module is not None else []
        base_args = ns_args + module_args

        if deterministic:
            self_children = {k: self.children[k] for k in sorted(self.children.keys())}
        else:
            self_children = self.children

        if isinstance(self, Leaf):
            args = ["'{str(self.t)}'", repr_yang(self.val)] + base_args
            return "Leaf({", ".join(args)})"
        elif isinstance(self, LeafList):
            # Only sort if deterministic=True and not user_order
            vals_str = repr_yang(self.vals if (self.user_order or not deterministic) else vals_list_sorted(self.vals))
            order_args = ["user_order=True"] if self.user_order else []
            args = ["'{str(self.t)}'", vals_str] + base_args + order_args
            return "LeafList({", ".join(args)})"
        elif isinstance(self, Absent):
            sname = "Absent"
            if len(self_children) == 0:
                return "{sname}({", ".join(base_args)})"
            else:
                child_strs = ["{_ind(indent+1)}'{nm}': {child.prsrc(deterministic, indent+1, nm)}"
                             for nm,child in self_children.items()]
                args_str = ", {", ".join(base_args)}" if len(base_args) > 0 else ""
                return "\n".join([
                    sname + r"({",
                    ",\n".join(child_strs),
                    "{_ind(indent)}}}{args_str})"
                ])
        elif isinstance(self, Delete):
            sname = "Delete"
            if len(self_children) == 0:
                return "{sname}({", ".join(base_args)})"
            else:
                child_strs = ["{_ind(indent+1)}'{nm}': {child.prsrc(deterministic, indent+1, nm)}"
                             for nm,child in self_children.items()]
                args_str = ", {", ".join(base_args)}" if len(base_args) > 0 else ""
                return "\n".join([
                    sname + r"({",
                    ",\n".join(child_strs),
                    "{_ind(indent)}}}{args_str})"
                ])
        elif isinstance(self, List):
            keys_arg = [str(self.keys)]
            order_args = ["user_order=True"] if self.user_order else []
            args = keys_arg + base_args + order_args
            if len(self.elements) == 0:
                return "List({", ".join(args)})"
            else:
                # Only sort if deterministic=True and not user_order
                elems = self.elements if (self.user_order or not deterministic) else sorted_elements(self.elements, self.keys)
                elem_strs = [_ind(indent+1) + elem.prsrc(deterministic, indent+1) for elem in elems]
                args_with_elements = args + ["elements=["]
                return "\n".join([
                    "List({", ".join(args_with_elements)}",
                    ",\n".join(elem_strs),
                    _ind(indent) + "])"
                ])
        elif isinstance(self, Container):
            sname = "Container"
            presence_args = ["presence=True"] if self.presence else []
            args = presence_args + base_args
            if len(self_children) == 0:
                return "{sname}({", ".join(args)})"
            else:
                child_strs = ["{_ind(indent+1)}'{nm}': {child.prsrc(deterministic, indent+1, nm)}"
                             for nm,child in self_children.items()]
                args_str = ", {", ".join(args)}" if len(args) > 0 else ""
                return "\n".join([
                    sname + r"({",
                    ",\n".join(child_strs),
                    "{_ind(indent)}}}{args_str})"
                ])
        elif isinstance(self, Create):
            sname = "Create"
            args = base_args
            if len(self_children) == 0:
                return "{sname}({", ".join(args)})"
            else:
                child_strs = ["{_ind(indent+1)}'{nm}': {child.prsrc(deterministic, indent+1, nm)}"
                             for nm,child in self_children.items()]
                args_str = ", {", ".join(args)}" if len(args) > 0 else ""
                return "\n".join([
                    sname + r"({",
                    ",\n".join(child_strs),
                    "{_ind(indent)}}}{args_str})"
                ])
        elif isinstance(self, Replace):
            sname = "Replace"
            args = base_args
            if len(self_children) == 0:
                return "{sname}({", ".join(args)})"
            else:
                child_strs = ["{_ind(indent+1)}'{nm}': {child.prsrc(deterministic, indent+1, nm)}"
                             for nm,child in self_children.items()]
                args_str = ", {", ".join(args)}" if len(args) > 0 else ""
                return "\n".join([
                    sname + r"({",
                    ",\n".join(child_strs),
                    "{_ind(indent)}}}{args_str})"
                ])
        else:
            raise ValueError("Unsupported node type in prsrc")

    def to_json(self, pretty=True, deterministic=False) -> str:
        """Convert gdata to JSON.

        When deterministic=True, node children are emitted in sorted order
        and system-ordered lists and leaf-lists elements are sorted. This makes
        the output stable for comparisons/tests.
        """
        return json.encode(self.to_dict(pretty, deterministic), pretty=pretty)

    def to_dict(self, pretty=True, deterministic=False) -> dict[str, ?value]:
        """Convert gdata to a dict, suitable for JSON serialization.

        When deterministic=True, node children are emitted in sorted order
        and system-ordered lists and leaf-lists elements are sorted. This makes
        the output stable for comparisons/tests.
        """
        if deterministic:
            self_children = {k: self.children[k] for k in sorted(self.children.keys())}
        else:
            self_children = self.children

        if isinstance(self, Container):
            child_dict = {}
            for nm,child in self_children.items():
                if isinstance(child, Container):
                    child_dict[fmt_json_name(nm, child.module)] = child.to_dict(pretty, deterministic)
                elif isinstance(child, Leaf):
                    # "empty" type is encoded as an array with a null element "[null]"
                    if child.t == "empty":
                        v = child.val
                        if isinstance(v, bool):
                            if v == True:
                                child_dict[fmt_json_name(nm, child.module)] = [None]
                    else:
                        child_dict[fmt_json_name(nm, child.module)] = json_val(child.t, child.val)
                elif isinstance(child, LeafList):
                    vals = []
                    if child.user_order or not deterministic:
                        iter_vals = child.vals
                    else:
                        iter_vals = vals_list_sorted(child.vals)
                    for v in iter_vals:
                        vals.append(json_val(child.t, v))
                    child_dict[fmt_json_name(nm, child.module)] = vals
                elif isinstance(child, List):
                    elems = []
                    if child.user_order or not deterministic:
                        iter_elems = child.elements
                    else:
                        iter_elems = sorted_elements(child.elements, child.keys)
                    for elem in iter_elems:
                        if isinstance(elem, Container):
                            elems.append(elem.to_dict(pretty, deterministic))
                        else:
                            raise ValueError("Unexpected list ({nm}) element type: {type(elem)}")
                    child_dict[fmt_json_name(nm, child.module)] = elems
                elif isinstance(child, Absent):
                    continue
                else:
                    raise ValueError("Unsupported child ({nm}) node type in to_dict: {type(child)}")
            return child_dict
        raise ValueError("Unsupported node type in to_dict: {type(self)}")

    def _to_xml_rec(self, key_names: ?list[str]=None, skip_nonkeys: bool=False, parent_absent: bool=False, deterministic=False) -> list[xml.Node]:
        if isinstance(self, Container) or isinstance(self, Absent) or isinstance(self, Create) or isinstance(self, Delete) or isinstance(self, Replace):
            if deterministic:
                self_children = {k: self.children[k] for k in sorted(self.children.keys())}
            else:
                self_children = self.children
            children = []
            if key_names is not None:
                if skip_nonkeys:
                    iter_children = iter(key_names)
                else:
                    iter_children = iter(key_names + [nm for nm in self_children.keys() if nm not in key_names])
            else:
                iter_children = self_children.keys()
            for name in iter_children:
                child = self_children[name]
                if parent_absent and not isinstance(child, List):
                    continue
                if ":" in name:
                    local_name = name.split(":")[-1]
                else:
                    local_name = name
                if isinstance(child, Container):
                    cchildren = child._to_xml_rec(deterministic=deterministic)
                    if len(cchildren) > 0:
                        children.append(xml.Node(local_name, nsdefs=_nsq(child.ns), children=cchildren))
                    elif isinstance(self, Container) and child.presence:
                        children.append(xml.Node(local_name, nsdefs=_nsq(child.ns)))

                elif isinstance(child, List):
                    for elem in child.elements if child.user_order or not deterministic else sorted_elements(child.elements, child.keys):
                        # Determine NETCONF operation for list element based on node type
                        skip_nonkeys = False
                        if isinstance(elem, Absent) or parent_absent:
                            attrs = remove_op
                            skip_nonkeys = True
                        elif isinstance(elem, Delete):
                            attrs = delete_op
                            skip_nonkeys = True
                        elif isinstance(elem, Create):
                            attrs = create_op
                        elif isinstance(elem, Replace):
                            attrs = replace_op
                        else:
                            attrs = (nsdefs=[], attrs=[])
                        children.append(xml.Node(local_name, nsdefs=_nsq(child.ns) + attrs.nsdefs, attributes=attrs.attrs, children=elem._to_xml_rec(child.keys, skip_nonkeys, deterministic=deterministic)))
                elif isinstance(child, Leaf):
                    if child.t == "empty":
                        v = child.val
                        if isinstance(v, bool):
                            if v == True:
                                children.append(xml.Node(local_name, nsdefs=_nsq(child.ns)))
                            else:
                                children.append(xml.Node(local_name, nsdefs=_nsq(child.ns) + remove_op.nsdefs, attributes=remove_op.attrs))
                    else:
                        v = yang_str(child.val)
                        children.append(xml.Node(local_name, nsdefs=_nsq(child.ns, child.val), text=v))
                elif isinstance(child, LeafList):
                    vals = []
                    for val in child.vals if child.user_order or not deterministic else vals_list_sorted(child.vals):
                        v = yang_str(val)
                        vals.append(xml.Node(local_name, nsdefs=_nsq(child.ns, val), text=v))
                    children.extend(vals)
                elif isinstance(child, Create):
                    # Render as element with create op, include children
                    children.append(xml.Node(local_name, nsdefs=_nsq(child.ns) + create_op.nsdefs, attributes=create_op.attrs, children=child._to_xml_rec(deterministic=deterministic)))
                elif isinstance(child, Replace):
                    # Render as element with replace op, include children
                    children.append(xml.Node(local_name, nsdefs=_nsq(child.ns) + replace_op.nsdefs, attributes=replace_op.attrs, children=child._to_xml_rec(deterministic=deterministic)))
                elif isinstance(child, Delete):
                    # Render as element with delete op
                    children.append(xml.Node(local_name, nsdefs=_nsq(child.ns) + delete_op.nsdefs, attributes=delete_op.attrs))
                elif isinstance(child, Absent):
                    # Render as element with remove op, unless the children are rendered explicitly (list)
                    cchildren = child._to_xml_rec(parent_absent=True, deterministic=deterministic)
                    if len(cchildren) > 0:
                        children.extend(cchildren)
                    else:
                        children.append(xml.Node(local_name, nsdefs=_nsq(child.ns) + remove_op.nsdefs, attributes=remove_op.attrs))
                else:
                    raise ValueError("Unsupported child ({name}) node type in to_xml: {type(child)}")
            return children
        raise ValueError("Unsupported node type in to_xml: {type(self)}")

    def to_xml(self, deterministic=False) -> list[xml.Node]:
        """Convert this gdata node to a list of xml.Node.

        The top-level node in a valid gdata structure is an unnamed container
        with named children. But in a valid XML document there must be a single
        top-level element. Thus we return a list of xml.Node fragments, one for
        each of the top-level gdata Container children.

        When deterministic=True, node children are emitted in sorted order
        and system-ordered lists and leaf-lists elements are sorted. This makes
        the output stable for comparisons/tests."""
        return self._to_xml_rec(deterministic=deterministic)

    def to_xmlstr(self, pretty=True, deterministic=False) -> str:
        """Convert this gdata node to an XML string.

        The result is a joined XML string of all the fragments, one for each of
        the top-level gdata Container children.

        When deterministic=True, node children are emitted in sorted order
        and system-ordered lists and leaf-lists elements are sorted. This makes
        the output stable for comparisons/tests."""
        return xml.encode_nodes(self.to_xml(deterministic), pretty)

    # --
    def get_leaf(self, name) -> Leaf:
        l = self.get_opt_leaf(name)
        if l is not None:
            return l
        raise ValueError("Cannot find leaf child in {self} with name: {name}")

    def get_opt_leaf(self, name) -> ?Leaf:
        if isinstance(self, Container) or isinstance(self, Absent) or isinstance(self, Create) or isinstance(self, Replace) or isinstance(self, Delete):
            for nm,child in self.children.items():
                if isinstance(child, Leaf) and nm == name:
                    return child

    def get_leaflist(self, name) -> LeafList:
        l = self.get_opt_leaflist(name)
        if l is not None:
            return l
        raise ValueError("Cannot find leaf-list child in {self} with name: {name}")

    def get_opt_leaflist(self, name) -> ?LeafList:
        child = self.children.get(name)
        if isinstance(child, LeafList):
            return child
    #--

    def get_cnt(self, name) -> Container:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, Container) and nm == name:
                    return child
        raise ValueError("Cannot find container child with name {name}")

    def get_opt_cnt(self, name) -> ?Container:
        """This is for P-container"""
        try:
            return self.get_cnt(name)
        except ValueError:
            return None

    def get_list(self, name) -> List:
        l = self.get_opt_list(name)
        if l is not None:
            return l
        raise ValueError("Cannot find list child with name " + name)

    def get_opt_list(self, name) -> ?List:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, List) and nm == name:
                    return child

    def get_bool(self, name) -> bool:
        child = self.get_leaf(name)
        childval = child.val
        if isinstance(childval, bool):
            return childval
        raise ValueError("Leaf {name} is not of type bool")

    def get_opt_bool(self, name) -> ?bool:
        child = self.get_opt_leaf(name)
        if child is not None:
            childval = child.val
            if isinstance(childval, bool):
                return childval

    def get_opt_empty(self, name) -> ?bool:
        return self.get_opt_bool(name)

    def get_Decimal(self, name) -> Decimal:
        child = self.get_leaf(name)
        childval = child.val
        if isinstance(childval, Decimal):
            return childval
        raise ValueError("Leaf {name} is not of type Decimal")

    def get_opt_Decimal(self, name) -> ?Decimal:
        child = self.get_opt_leaf(name)
        if child is not None:
            childval = child.val
            if isinstance(childval, Decimal):
                return childval

    def get_bigint(self, name) -> bigint:
        child = self.get_leaf(name)
        childval = child.val
        if isinstance(childval, bigint):
            return childval
        raise ValueError("Leaf {name} is not of type bigint")

    def get_bigints(self, name) -> list[bigint]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    cvals = []
                    for v in child.vals:
                        if isinstance(v, bigint):
                            cvals.append(v)
                    return cvals
        raise ValueError("Cannot find leaf-list child with name {name}")

    def get_opt_bigint(self, name) -> ?bigint:
        child = self.get_opt_leaf(name)
        if child is not None:
            childval = child.val
            if isinstance(childval, bigint):
                return childval

    def get_opt_bigints(self, name) -> list[bigint]:
        try:
            return self.get_bigints(name)
        except ValueError:
            return []

    def get_str(self, name) -> str:
        child = self.get_leaf(name)
        childval = child.val
        if isinstance(childval, str):
            return childval
        raise ValueError("Leaf {name} value is not type str")

    def get_opt_str(self, name) -> ?str:
        child = self.get_opt_leaf(name)
        if child is not None:
            childval = child.val
            if isinstance(childval, str):
                return childval

    def get_strs(self, name) -> list[str]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    cvals = []
                    for v in child.vals:
                        if isinstance(v, str):
                            cvals.append(v)
                    return cvals
        raise ValueError("Cannot find leaf-list child with name {name}")

    def get_opt_strs(self, name) -> list[str]:
        try:
            return self.get_strs(name)
        except ValueError:
            return []

    def get_bytes(self, name) -> bytes:
        child = self.get_leaf(name)
        childval = child.val
        if isinstance(childval, bytes):
            return childval
        raise ValueError("Leaf {name} value is not type bytes")

    def get_opt_bytes(self, name) -> ?bytes:
        child = self.get_opt_leaf(name)
        if child is not None:
            childval = child.val
            if isinstance(childval, bytes):
                return childval

    def get_bytess(self, name) -> list[bytes]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    cvals = []
                    for v in child.vals:
                        if isinstance(v, bytes):
                            cvals.append(v)
                    return cvals
        raise ValueError("Cannot find leaf-list child with name {name}")

    def get_opt_bytess(self, name) -> list[bytes]:
        try:
            return self.get_bytess(name)
        except ValueError:
            return []

    def get_Decimals(self, name) -> list[Decimal]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    cvals = []
                    for v in child.vals:
                        if isinstance(v, Decimal):
                            cvals.append(v)
                    return cvals
        raise ValueError("Cannot find leaf-list child with name {name}")

    def get_opt_Decimals(self, name) -> list[Decimal]:
        try:
            return self.get_Decimals(name)
        except ValueError:
            return []

    def get_bools(self, name) -> list[bool]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    cvals = []
                    for v in child.vals:
                        if isinstance(v, bool):
                            cvals.append(v)
                    return cvals
        raise ValueError("Cannot find leaf-list child with name {name}")

    def get_opt_bools(self, name) -> list[bool]:
        try:
            return self.get_bools(name)
        except ValueError:
            return []

    def get_value(self, name) -> value:
        child = self.get_leaf(name)
        return child.val

    def get_opt_value(self, name) -> ?value:
        child = self.get_opt_leaf(name)
        if child is not None:
            return child.val

    def get_values(self, name) -> list[value]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    return child.vals
        raise ValueError("Cannot find leaf-list child with name {name}")

    def get_opt_values(self, name) -> list[value]:
        try:
            return self.get_values(name)
        except ValueError:
            return []

    def get_Identityref(self, name) -> Identityref:
        child = self.get_leaf(name)
        childval = child.val
        if isinstance(childval, Identityref):
            return childval
        raise ValueError("Leaf {name} value is not type Identityref")

    def get_opt_Identityref(self, name) -> ?Identityref:
        child = self.get_opt_leaf(name)
        if child is not None:
            childval = child.val
            if isinstance(childval, Identityref):
                return childval

    def get_Identityrefs(self, name) -> list[Identityref]:
        if isinstance(self, Container):
            for nm,child in self.children.items():
                if isinstance(child, LeafList) and nm == name:
                    cvals = []
                    for v in child.vals:
                        if isinstance(v, Identityref):
                            cvals.append(v)
                    return cvals
        raise ValueError("Cannot find leaf-list child with name {name}")

    def get_opt_Identityrefs(self, name) -> list[Identityref]:
        try:
            return self.get_Identityrefs(name)
        except ValueError:
            return []

extension Node(Eq):
    def __eq__(self, other: Node) -> bool:
        if self.ns != other.ns:
            return False

        if isinstance(self, Container) and isinstance(other, Container):
            if set(self.children.keys()) != set(other.children.keys()):
                return False
            for key in self.children.keys():
                if self.children[key] != other.children[key]:
                    return False
            return True

        if isinstance(self, Leaf) and isinstance(other, Leaf):
            return vals_equal(self.val, other.val)

        if isinstance(self, LeafList) and isinstance(other, LeafList):
            return vals_list_equal(self.vals, other.vals)

        if isinstance(self, List) and isinstance(other, List):
            if self.keys != other.keys:
                return False
            if len(self.elements) != len(other.elements):
                return False
            for i in range(len(self.elements)):
                e1 = self.elements[i]
                e2 = other.elements[i]
                if not self.user_order and e1.key_str(self.keys) != e2.key_str(other.keys):
                    for e2 in other.elements:
                        if e1.key_str(self.keys) == e2.key_str(other.keys):
                            break
                if e1 != e2:
                    return False
            return True

        if isinstance(self, Absent) and isinstance(other, Absent):
            if set(self.children.keys()) != set(other.children.keys()):
                return False
            for key in self.children.keys():
                if self.children[key] != other.children[key]:
                    return False
            return True

        return False


class List(Node):
    keys: list[str] # name of the key leafs
    elements: list[Node]
    user_order: bool

    def __init__(self, keys: list[str], elements: list[Node]=[], user_order=False, ns: ?str=None, module: ?str=None, txid: ?str=None):
        self.keys = keys
        self.elements = elements
        self.user_order = user_order
        self.ns = ns
        self.module = module
        self.txid = txid
        self.children = {}

    def get_opt_list_entry(self, key: str) -> ?Node:
        """Get a list entry by key value

        Returns None if the entry is not found.
        """
        for elem in self.elements:
            if elem.key_str(self.keys) == key:
                return elem
        return None

    def get_list_entry(self, key: str) -> Node:
        """Get a list entry by key value

        Raises ValueError if the entry is not found.
        """
        elem = self.get_opt_list_entry(key)
        if elem is not None:
            return elem
        raise ValueError("Cannot find list entry with key {key}")

class Container(Node):
    def __init__(self, children: dict[str, Node]={}, presence: bool=False, ns: ?str=None, module: ?str=None, txid: ?str=None):
        self.children = children
        self.presence = presence
        self.ns = ns
        self.module = module
        self.txid = txid

class Leaf(Node):
    t: str
    val: value

    def __init__(self, t: str, val: value, ns: ?str=None, module: ?str=None, txid: ?str=None):
        self.t = t
        self.val = val
        self.ns = ns
        self.module = module
        self.txid = txid
        self.children = {}

class LeafList(Node):
    t: str
    vals: list[value]
    user_order: bool

    def __init__(self, t:str, vals: list[value], user_order=False, ns: ?str=None, module: ?str=None, txid: ?str=None):
        self.t = t
        self.ns = ns
        self.module = module
        self.vals = vals
        self.user_order = user_order
        self.txid = txid
        self.children = {}

class Absent(Node):
    """Declarative definition of the absence of a node

    NETCONF remove operation maps to Absent

    Absent is declarative / idempotent, meaning that if the target to be removed
    / made absent is not present, no error is raised.
    """
    def __init__(self, children: dict[str, Node]={}, ns: ?str=None, module: ?str=None):
        self.ns = ns
        self.module = module
        self.children = children
        self.txid = None

class Delete(Node):
    """Imperative delete of a node
    NETCONF delete operation maps to Delete

    Unlike Absent / remove, Delete of a non-existent node is a failure.
    """
    def __init__(self, children: dict[str, Node]={}, ns: ?str=None, module: ?str=None):
        self.ns = ns
        self.module = module
        self.children = children
        self.txid = None

class Create(Node):
    """Imperative create of a node
    NETCONF create operation maps to Create

    Unlike the default implicit merge, Create of an existing node is a failure.
    """
    def __init__(self, children={}, ns: ?str=None, module: ?str=None):
        self.ns = ns
        self.module = module
        self.children = children
        self.txid = None

class Replace(Node):
    """Imperative replace of a node
    NETCONF replace operation maps to Replace
    """
    def __init__(self, children={}, ns: ?str=None, module: ?str=None):
        self.ns = ns
        self.module = module
        self.children = children
        self.txid = None

def sorted_elements(elements, key_names):
    keys = list(map(lambda elem: elem.key_str(key_names), elements))
    key_map = dict(zip(keys, elements))
    return [key_map[key] for key in sorted(keys)]

def vals_equal(a: value, b: value) -> bool:
    # Compare known leaf value types
    if isinstance(a, bigint) and isinstance(b, bigint):
        return a == b
    if isinstance(a, bool) and isinstance(b, bool):
        return a == b
    if isinstance(a, float) and isinstance(b, float):
        return a == b
    if isinstance(a, Decimal) and isinstance(b, Decimal):
        return a == b
    if isinstance(a, str) and isinstance(b, str):
        return a == b
    if isinstance(a, bytes) and isinstance(b, bytes):
        return a == b
    # TODO: Add support for u8 and i8
    #if isinstance(a, u8) and isinstance(b, u8):
    #    return a == b
    if isinstance(a, u16) and isinstance(b, u16):
        return a == b
    if isinstance(a, u32) and isinstance(b, u32):
        return a == b
    if isinstance(a, u64) and isinstance(b, u64):
        return a == b
    # TODO: Add support for u8 and i8
    #if isinstance(a, i8) and isinstance(b, i8):
    #    return a == b
    if isinstance(a, i16) and isinstance(b, i16):
        return a == b
    if isinstance(a, i32) and isinstance(b, i32):
        return a == b
    if isinstance(a, int) and isinstance(b, int):
        return a == b
    if isinstance(a, Identityref) and isinstance(b, Identityref):
        return a == b
    if type(a) != type(b):
        # It is valid to compare values of different type, which happens if
        # leaves are of type union and value a and b happen to be of different
        # type.
        return False
    raise ValueError("Unsupported value type in eq comparison")

# For leaf-lists we need to compare a list of values
def vals_list_equal(a: list[value], b: list[value]) -> bool:
    if len(a) != len(b):
        return False
    for i in range(len(a)):
        if not vals_equal(a[i], b[i]):
            return False
    return True

def vals_less_than(a: value, b: value) -> bool:
    # Compare known leaf value types
    if isinstance(a, bigint) and isinstance(b, bigint):
        return a < b
    if isinstance(a, bool) and isinstance(b, bool):
        return not a  # False (0) before True (1)
    if isinstance(a, float) and isinstance(b, float):
        return a < b
    if isinstance(a, Decimal) and isinstance(b, Decimal):
        return a < b
    if isinstance(a, str) and isinstance(b, str):
        return a < b
    if isinstance(a, bytes) and isinstance(b, bytes):
        return a < b
    # TODO: Add support for u8 and i8
    #if isinstance(a, u8) and isinstance(b, u8):
    #    return a < b
    if isinstance(a, u16) and isinstance(b, u16):
        return a < b
    if isinstance(a, u32) and isinstance(b, u32):
        return a < b
    if isinstance(a, u64) and isinstance(b, u64):
        return a < b
    # TODO: Add support for u8 and i8
    #if isinstance(a, i8) and isinstance(b, i8):
    #    return a < b
    if isinstance(a, i16) and isinstance(b, i16):
        return a < b
    if isinstance(a, i32) and isinstance(b, i32):
        return a < b
    if isinstance(a, int) and isinstance(b, int):
        return a < b
    if isinstance(a, Identityref) and isinstance(b, Identityref):
        return a < b
    raise ValueError("Unsupported value type or mismatch in lt comparison: {type(a)}, {type(b)}")

pure def vals_list_sorted(a: list[value]) -> list[value]:
    """Sort a list of values, comparing only values of the same type

    Uses a functional approach to avoid mutations so that we can be called
    from pure functions. Perhaps this can be made more efficient by mutation -
    look into later once we can contain scope local mutation from leaking
    https://github.com/actonlang/acton/issues/1632
    """
    n = len(a)
    if n <= 1:
        return a

    # Functional bubble sort: recursively sort by finding minimum and building result
    # Find the minimum element
    min_val = a[0]
    min_idx = 0
    for i in range(1, n):
        if vals_less_than(a[i], min_val):
            min_val = a[i]
            min_idx = i

    # Build new list with minimum at front and recursively sort the rest
    remaining = a[:min_idx] + a[min_idx+1:]
    if len(remaining) == 0:
        return [min_val]
    else:
        return [min_val] + vals_list_sorted(remaining)



class _PathElement:
    def __init__(self, name: ?str=None, keys: ?dict[str, Leaf]=None):
        self.name = name
        self.keys = keys


def _format_gdata_path(path: list[_PathElement]) -> str:
    if len(path) == 0:
        return "/"
    path_str = ""
    for elem in path:
        elem_name = elem.name
        if elem_name is not None:
            path_str = path_str + "/" + elem_name
        elem_keys = elem.keys
        if elem_keys is not None and len(elem_keys) > 0:
            predicates = ["{k}={repr(v.val)}" for k, v in elem_keys.items()]
            path_str = path_str + "[" + ",".join(predicates) + "]"
    return path_str


def _merge_rec(a: Node, b: Node, path: list[_PathElement]) -> Node:
    if type(a) != type(b):
        raise ValueError("Cannot merge nodes of different types at {_format_gdata_path(path)}: {type(a)} != {type(b)}")

    # Helper to merge keyed children
    def merge_keyed_children(a_children: dict[str, Node], b_children: dict[str, Node]) -> dict[str, Node]:
        result: dict[str, Node] = {}

        a_keys = list(a_children.keys())
        b_keys = list(b_children.keys())

        i = 0
        j = 0
        while i < len(a_keys) and j < len(b_keys):
            ak = a_keys[i]
            bk = b_keys[j]
            if ak == bk:
                # Overlapping key
                merged_child = _merge_rec(a_children[ak], b_children[bk], path + [_PathElement(ak)])
                result[ak] = merged_child
                i += 1
                j += 1
            else:
                # Keys differ
                ak_in_b = (ak in b_children)
                bk_in_a = (bk in a_children)
                if not ak_in_b:
                    # Child only in a
                    result[ak] = a_children[ak]
                    i += 1
                elif not bk_in_a:
                    # Child only in b
                    # We append it now right after we handle old nodes to keep order of a
                    # In merging, we decided to maintain 'a' order as baseline
                    # So we handle all a_nodes that appear before first
                    # If we want strictly all 'a' first, we can first go through a_keys that are not in b.
                    # But let's insert b node here to keep somewhat stable merging.
                    result[bk] = b_children[bk]
                    j += 1
                else:
                    # Both appear in both sets at different positions, reorder scenario
                    # For simplicity, handle old's node first since we want to keep a's order.
                    merged_child = _merge_rec(a_children[ak], b_children[ak], path + [_PathElement(ak)])
                    result[ak] = merged_child
                    i += 1
                    # We don't advance j here because we haven't handled bk yet.
                    # We'll hit bk again in next iteration and handle it normally.

        # If a still has items
        while i < len(a_keys):
            ak = a_keys[i]
            # If ak also in b but we haven't handled it yet, merge it now.
            # Otherwise just take it from a.
            if ak in b_children:
                merged_child = _merge_rec(a_children[ak], b_children[ak], path + [_PathElement(ak)])
                result[ak] = merged_child
            else:
                result[ak] = a_children[ak]
            i += 1

        # If b still has items
        while j < len(b_keys):
            bk = b_keys[j]
            if bk not in a_children:
                # New child from b
                result[bk] = b_children[bk]
            else:
                # Already handled overlap above, but if we got here, let's be safe:
                merged_child = _merge_rec(a_children[bk], b_children[bk], path + [_PathElement(bk)])
                result[bk] = merged_child
            j += 1

        return result

    if isinstance(a, Container) and isinstance(b, Container):
        # Merge keyed children similarly to Container
        new_children = merge_keyed_children(a.children, b.children)
        return Container(children=new_children, presence=a.presence, ns=a.ns, module=a.module)

    elif isinstance(a, Leaf) and isinstance(b, Leaf):
        if a.t != b.t:
            raise ValueError("Cannot merge leaves with different types at {_format_gdata_path(path)}: {a.t} != {b.t}")
        aval = a.val
        bval = b.val
        if vals_equal(aval, bval):
            return a
        raise ValueError("Cannot merge leaves with different values at {_format_gdata_path(path)}: {str(aval)} != {str(bval)}")

    elif isinstance(a, LeafList) and isinstance(b, LeafList):
        if vals_list_equal(a.vals, b.vals):
            return a
        raise ValueError("Cannot merge leaf-lists with different values at {_format_gdata_path(path)}")

    elif isinstance(a, List) and isinstance(b, List):
        if a.keys != b.keys:
            raise ValueError("Cannot merge lists with different keys at {_format_gdata_path(path)}: {str(a.keys)} != {str(b.keys)}")
        if a.user_order != b.user_order:
            raise ValueError("Cannot merge lists with different user_order at {_format_gdata_path(path)}")

        if a.user_order:
            # user_order = True
            # Two-pointer approach for merging list elements
            # This preserves the order from 'a' as baseline and inserts 'b' elements accordingly.
            new_elements: list[Node] = []

            old_map = {e.key_str(a.keys): e for e in a.elements}

            # Start with elements from a, merge if present in b
            for a_elem in a.elements:
                found = False
                for b_elem in b.elements:
                    if b_elem.key_str(b.keys) == a_elem.key_str(a.keys):
                        key_values = a_elem.key_children(a.keys)
                        merged_elem = _merge_rec(a_elem, b_elem, path + [_PathElement(keys=key_values)])
                        if isinstance(merged_elem, Container):
                            new_elements.append(merged_elem)
                        else:
                            raise ValueError("merge did not return a Container where one was expected at {_format_gdata_path(path)}")
                        found = True
                        break
                if not found:
                    # not in b, just add a_elem
                    new_elements.append(a_elem)

            # Add elements from b that are not in a
            # Insert them in a stable manner at the end to preserve 'a' order
            # If we want a more sophisticated merging of order, we could try to insert them
            # relative to keys present in both.
            # For now, we just append them at the end.
            existing_keys = {}
            for e in new_elements:
                existing_keys[e.key_str(a.keys)] = True
            for b_elem in b.elements:
                bk = b_elem.key_str(b.keys)
                if bk not in existing_keys:
                    new_elements.append(b_elem)
                    existing_keys[bk] = True

            return List(a.keys, new_elements, user_order=a.user_order, ns=a.ns, module=a.module)
        else:
            # user_order = False
            # Keep the original merging logic since it sorts by keys, not order
            all_elements: dict[str, list[Node]] = {}

            for elem in a.elements:
                key_str = elem.key_str(a.keys)
                if key_str not in all_elements:
                    all_elements[key_str] = []
                all_elements[key_str].append(elem)
            for elem in b.elements:
                key_str = elem.key_str(b.keys)
                if key_str not in all_elements:
                    all_elements[key_str] = []
                all_elements[key_str].append(elem)

            new_elements: list[Node] = []
            # sort keys lex order as before
            sorted_keys = sorted(all_elements.keys())

            for key_str in sorted_keys:
                elems = all_elements[key_str]
                new_elem = elems[0]
                if len(elems) > 1:
                    key_values = new_elem.key_children(a.keys)
                    for elem in elems[1:]:
                        new_elem = _merge_rec(new_elem, elem, path + [_PathElement(keys=key_values)])
                if isinstance(new_elem, Container):
                    new_elements.append(new_elem)
                else:
                    raise ValueError("unreachable, new_elem should always be a Container at {_format_gdata_path(path)}")

            return List(a.keys, new_elements, ns=a.ns, module=a.module)

    elif isinstance(a, Absent) and isinstance(b, Absent):
        # Both absent is odd in a merge scenario, but let's just return absent
        return a

    else:
        raise ValueError("Unsupported node type in merge at {_format_gdata_path(path)}: {type(a)}")


def merge(a: Node, b: Node) -> Node:
    return _merge_rec(a, b, [])


def _diff_rec(old: ?Node, new: Node, path: list[_PathElement]) -> ?Node:
    if old is None:
        return new

    if type(old) != type(new):
        raise ValueError("diff called with nodes of different types at {_format_gdata_path(path)}: {type(old)} != {type(new)}")

    # Helper function for diffing Container nodes that have children keyed by strings
    def diff_keyed_children(old_children: dict[str, Node], new_children: dict[str, Node]) -> ?dict[str, Node]:
        # We'll produce a new_children_dict with the diff
        result: dict[str, Node] = {}

        for k,nchild in new_children.items():
            if k in old_children:
                ochild = old_children[k]
                child_diff = _diff_rec(ochild, nchild, path + [_PathElement(k)])
                if child_diff is not None:
                    result[k] = child_diff
            else:
                result[k] = nchild
        for k,ochild in old_children.items():
            if k not in new_children:
                # Preserve full original subtree under Absent for complete context
                # during delete operations (e.g., NETCONF XML, CLI stanza removal)
                result[k] = Absent({k: ochild}, ns=ochild.ns, module=ochild.module)

        if len(result) == 0:
            return None
        return result

    # Helper function for diffing list elements (specialized Container nodes)
    # that *must* always include the key leaf children
    def diff_list_element(old_element: Node, new_element: Node, keys: list[str], elem_path: list[_PathElement]) -> ?Node:
        # Diff of element Container nodes will only contain the actual
        # differences, skipping keys which are equal in both
        entry_diff = _diff_rec(old_element, new_element, elem_path)
        if entry_diff is not None:
            # Update the entry to include key leaf children
            for key in keys:
                entry_diff.children[key] = old_element.get_leaf(key)
            return entry_diff
        return None

    # Helper function for diffing system-ordered lists (order doesn't matter)
    def diff_system_ordered_list_elements(old_list: List, new_list: List) -> ?list[Node]:
        if old_list.keys != new_list.keys:
            raise ValueError("List keys differ at {_format_gdata_path(path)}: {str(old_list.keys)} != {str(new_list.keys)}")

        # Map elements by key for both lists
        old_map = {e.key_str(old_list.keys): e for e in old_list.elements}
        new_map = {e.key_str(new_list.keys): e for e in new_list.elements}

        result: list[Node] = []

        # Check all keys (union of both sets)
        all_keys = set(old_map.keys()) | set(new_map.keys())

        # Sort keys for consistent output
        for key in sorted(all_keys):
            if key in old_map and key in new_map:
                # Element exists in both - check for differences
                key_values = old_map[key].key_children(old_list.keys)
                elem_diff = diff_list_element(old_map[key], new_map[key], old_list.keys, path + [_PathElement(keys=key_values)])
                if elem_diff is not None:
                    result.append(elem_diff)
            elif key in old_map:
                # Element only in old - mark as absent
                oe = old_map[key]
                result.append(Absent(oe.key_children(old_list.keys)))
            else:
                # Element only in new - add it
                ne = new_map[key]
                result.append(ne)

        if len(result) == 0:
            return None
        return result

    # Helper function for diffing user-ordered lists (order matters)
    def diff_user_ordered_list_elements(old_list: List, new_list: List) -> ?list[Node]:

        if old_list.keys != new_list.keys:
            raise ValueError("List keys differ at {_format_gdata_path(path)}: {str(old_list.keys)} != {str(new_list.keys)}")

        # Map old elements by key
        old_map = {e.key_str(old_list.keys): e for e in old_list.elements}
        old_key_order = [e.key_str(old_list.keys) for e in old_list.elements]

        new_map = {e.key_str(new_list.keys): e for e in new_list.elements}
        new_key_order = [e.key_str(new_list.keys) for e in new_list.elements]

        # We'll do the two-pointer approach on these key orders
        i = 0
        j = 0
        result: list[Node] = []

        while i < len(old_key_order) and j < len(new_key_order):
            ok = old_key_order[i]
            nk = new_key_order[j]

            if ok == nk:
                # same element key
                key_values = old_map[ok].key_children(old_list.keys)
                elem_diff = diff_list_element(old_map[ok], new_map[nk], old_list.keys, path + [_PathElement(keys=key_values)])
                if elem_diff is not None:
                    result.append(elem_diff)
                i += 1
                j += 1
            else:
                ok_in_new = (ok in new_map)
                nk_in_old = (nk in old_map)

                if not ok_in_new:
                    # old element not in new => absent
                    oe = old_map[ok]
                    result.append(Absent(oe.key_children(old_list.keys)))
                    i += 1
                elif not nk_in_old:
                    # new element not in old => new element
                    # Insert the new element now
                    ne = new_map[nk]
                    result.append(ne)
                    j += 1
                else:
                    # Complex reordering scenario
                    raise ValueError("Complex reordering scenario encountered in list elements at {_format_gdata_path(path)}")

        # Remaining old elements are absent
        while i < len(old_key_order):
            ok = old_key_order[i]
            if ok not in new_map:
                oe = old_map[ok]
                result.append(Absent(oe.key_children(old_list.keys)))
            i += 1

        # Remaining new elements are new
        while j < len(new_key_order):
            nk = new_key_order[j]
            if nk not in old_map:
                ne = new_map[nk]
                result.append(ne)
            j += 1

        if len(result) == 0:
            return None
        return result

    # Diff logic for each node type

    if isinstance(old, Container) and isinstance(new, Container):
        diff_children = diff_keyed_children(old.children, new.children)
        if diff_children is None:
            return None
        return Container(children=diff_children, presence=new.presence, ns=new.ns, module=new.module)

    elif isinstance(old, List) and isinstance(new, List):
        if old.user_order != new.user_order:
            raise ValueError("Cannot diff lists with different ordering types at {_format_gdata_path(path)}")

        if old.user_order:
            result = diff_user_ordered_list_elements(old, new)
        else:
            result = diff_system_ordered_list_elements(old, new)
        if result is None:
            return None
        return List(new.keys, elements=result, user_order=new.user_order, ns=new.ns, module=new.module)

    elif isinstance(old, Leaf) and isinstance(new, Leaf):
        if old.t != new.t:
            raise ValueError("Leaf types differ at {_format_gdata_path(path)}: {old.t} != {new.t}")
        if vals_equal(old.val, new.val):
            return None
        else:
            return new

    elif isinstance(old, LeafList) and isinstance(new, LeafList):
        if vals_list_equal(old.vals, new.vals):
            return None
        return new

    elif isinstance(old, Absent) and isinstance(new, Absent):
        diff_children = diff_keyed_children(old.children, new.children)
        if diff_children is not None:
            # TODO: can't call key_str(list_keys) without our parent List node!?
            raise ValueError("Absent keys differ at {_format_gdata_path(path)}: {str(old.children)} != {str(new.children)}")
        return None

    else:
        raise ValueError("Unhandled node type in diff at {_format_gdata_path(path)}: {type(old)}")


def diff(old: ?Node, new: Node) -> ?Node:
    return _diff_rec(old, new, [])


# TODO: Can we make patch return a Node instead of ?Node?
def _patch_rec(old: Node, p: ?Node, path: list[_PathElement]) -> ?Node:
    if p is None:
        return old

    if isinstance(p, Absent):
        # Patch says remove this node
        if isinstance(old, Absent):
            # Both absent means node was removed
            if p.children != old.children:
                # TODO: can't call key_str(list_keys) without our parent List node!?
                raise ValueError("Absent keys differ in patch at {_format_gdata_path(path)}: {str(old.children)} != {str(p.children)}")
        return None

    elif isinstance(old, Container) and isinstance(p, Container):
        # Start with old children
        new_children: dict[str, Node] = {}
        for key in old.children:
            new_children[key] = old.children[key]

        # Apply patch changes
        for key in p.children:
            cpatch = p.children[key]
            if key in new_children:
                # Patch existing child
                res = _patch_rec(new_children[key], cpatch, path + [_PathElement(key)])
                if res is not None:
                    new_children[key] = res
                else:
                    del new_children[key]
            else:
                # Key not in old
                if isinstance(cpatch, Absent):
                    # Trying to remove something not in old -> ignore
                    pass
                else:
                    # New child
                    new_children[key] = cpatch

        # No need to remove unchanged nodes; they are already in new_children
        if len(new_children) == 0:
            return None
        return Container(children=new_children, presence=old.presence, ns=old.ns, module=old.module)

    elif isinstance(old, List) and isinstance(p, List):
        if old.keys != p.keys:
            raise ValueError("List keys differ at {_format_gdata_path(path)}: {str(old.keys)} != {str(p.keys)}")

        old_map = {e.key_str(old.keys): e for e in old.elements}

        # Apply patch elements
        patch_elems = p.elements
        for pelem in patch_elems:
            if isinstance(pelem, Absent):
                # Remove this element if it exists
                k = pelem.key_str(p.keys)
                if k in old_map:
                    del old_map[k]
            else:
                # pelem is a ListElement
                k = pelem.key_str(p.keys)
                if k in old_map:
                    # Patch existing element
                    key_values = old_map[k].key_children(old.keys)
                    res = _patch_rec(old_map[k], pelem, path + [_PathElement(keys=key_values)])
                    if res is not None and isinstance(res, Container):
                        old_map[k] = res
                    else:
                        # Remove the element
                        del old_map[k]
                else:
                    # New element
                    old_map[k] = pelem

        # Rebuild elements in final order
        # Start with old's original order for unchanged and patched elements
        final_key_order = []
        chosen = {}
        for e in old.elements:
            k = e.key_str(old.keys)
            if k in old_map:
                final_key_order.append(k)
                chosen[k] = True

        # Now check if patch introduced new elements not in old.
        # Add them in the order they appear in patch.
        for pelem in patch_elems:
            if isinstance(pelem, Absent):
                continue
            k = pelem.key_str(p.keys)
            if k in old_map and k not in chosen:
                final_key_order.append(k)
                chosen[k] = True

        new_elements: list[Node] = []
        for k in final_key_order:
            new_elements.append(old_map[k])

        if len(new_elements) == 0:
            return None
        return List(old.keys, elements=new_elements, user_order=old.user_order, ns=old.ns, module=old.module)

    elif isinstance(old, Leaf) and isinstance(p, Leaf):
        # Patch leaf replaces old leaf value
        if old.t != p.t:
            raise ValueError("Leaf types differ in patch at {_format_gdata_path(path)}: {old.t} != {p.t}")
        return p

    elif isinstance(old, LeafList) and isinstance(p, LeafList):
        # Patch leaf-list replaces old leaf-list values
        return p

    elif isinstance(old, Absent) and isinstance(p, Absent):
        # Both absent means node was removed
        return None

    else:
        if p is not None:
            raise ValueError("Unhandled node type in patch at {_format_gdata_path(path)}: {type(p)}")


def patch(old: Node, p: ?Node) -> ?Node:
    return _patch_rec(old, p, [])


class TreeProvider(object):
    rpc: proc(action(?Node, ?Exception) -> None, Node) -> None
    rpc_xml: proc(action(?xml.Node, ?Exception) -> None, xml.Node) -> None


def _node_match(n: xml.Node, name: str, ns: ?str) -> bool:
    """Check if an XML node matches the given name and namespace

    It will match either on the default (nameless) namespace, or the node prefix
    & a named namespace. For example:
    <foo xmlns="urn:foo"> and <ns:foo xmlns:ns="urn:foo"> both match with name="foo", ns="urn:foo"
    """
    if n.tag == name:
        if ns is not None:
            for nsdef in n.nsdefs:
                n0 = nsdef.0
                n1 = nsdef.1
                if n0 is not None and n0 == n.prefix and n1 == ns:
                    return True
                elif n0 is None and n1 == ns:
                    return True
        else:
            return True
    return False


def get_xml_opt_child(n: xml.Node, name: str, ns: ?str) -> ?xml.Node:
    for child in n.children:
        if _node_match(child, name, ns):
            return child
    return None


def get_xml_children(n: xml.Node, name: str, ns: ?str) -> list[xml.Node]:
    res = []
    for child in n.children:
        if _node_match(child, name, ns):
            res.append(child)
    return res


def _test_format_gdata_path():
    path = [
        _PathElement("config"),
        _PathElement("interfaces"),
        _PathElement(keys={"name": Leaf("str", "eth0"), "vlan": Leaf("int", bigint(100))}),
        _PathElement("ipv4"),
        _PathElement(keys={"ip": Leaf("str", "10.0.0.1"), "prefix": Leaf("int", bigint(24))})
    ]
    testing.assertEqual("/config/interfaces[name='eth0',vlan=100]/ipv4[ip='10.0.0.1',prefix=24]", _format_gdata_path(path))


def _test_merge1():
    y1 = Container({
        "a": Leaf("int", bigint(1)),
        "l1": List(["name"], [
            Container({
                "name": Leaf("str", "k1"),
                "n1": Leaf("int", bigint(1)),
                "n2": Leaf("int", bigint(2))
            }),
            Container({
                "name": Leaf("str", "k4"),
                "n4": Leaf("int", bigint(4)),
            }),
        ])
    }, ns="http://example.com/acme", module="acme")

    y2 = Container({
        "b": Leaf("int", bigint(2)),
        "c": Leaf("int", bigint(3)),
        "l1": List(["name"], [
            Container({
                "name": Leaf("str", "k2"),
                "n1": Leaf("int", bigint(1)),
                "n3": Leaf("int", bigint(3))
            }),
        ]),
        "d": LeafList("str", ["a", "b", "c"])
    }, ns="http://example.com/acme", module="acme")

    res = merge(y1, y2)

    exp = Container({
        "a": Leaf("int", bigint(1)),
        "b": Leaf("int", bigint(2)),
        "c": Leaf("int", bigint(3)),
        "l1": List(["name"], [
            Container({
                "name": Leaf("str", "k1"),
                "n1": Leaf("int", bigint(1)),
                "n2": Leaf("int", bigint(2))
            }),
            Container({
                "name": Leaf("str", "k2"),
                "n1": Leaf("int", bigint(1)),
                "n3": Leaf("int", bigint(3))
            }),
            Container({
                "name": Leaf("str", "k4"),
                "n4": Leaf("int", bigint(4)),
            }),
        ]),
        "d": LeafList("str", ["a", "b", "c"])
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(res.prsrc(deterministic=True), exp.prsrc(deterministic=True))

def _test_merge_list1():
    y1 = List(["name"], [
        Container({
            "name": Leaf("str", "first"),
            "n1": Leaf("int", bigint(1))
        }),
        Container({
            "name": Leaf("str", "breaker"),
            "n1": Leaf("int", bigint(1))
        }),
        Container({
            "name": Leaf("str", "fourth"),
            "n1": Leaf("int", bigint(1))
        }),
        Container({
            "name": Leaf("str", "common"),
            "n2": Leaf("int", bigint(2))
        }),
        Container({
            "name": Leaf("str", "last"),
            "n1": Leaf("int", bigint(1))
        }),
    ], user_order=True, ns="http://example.com/acme", module="acme")

    y2 = List(["name"], [
        Container({
            "name": Leaf("str", "breaker")
        }),
        Container({
            "name": Leaf("str", "second"),
            "n1": Leaf("int", bigint(1))
        }),
        Container({
            "name": Leaf("str", "third"),
            "n1": Leaf("int", bigint(1))
        }),
        Container({
            "name": Leaf("str", "common"),
            "n1": Leaf("int", bigint(1))
        }),
        Container({
            "name": Leaf("str", "last")
        })
    ], user_order=True, ns="http://example.com/acme", module="acme")

    exp = List(["name"], [
        Container({
            "name": Leaf("str", "first"),
            "n1": Leaf("int", bigint(1))
        }),
        Container({
            "name": Leaf("str", "breaker"),
            "n1": Leaf("int", bigint(1))
        }),
        Container({
            "name": Leaf("str", "fourth"),
            "n1": Leaf("int", bigint(1))
        }),
        Container({
            "name": Leaf("str", "common"),
            "n2": Leaf("int", bigint(2)),
            "n1": Leaf("int", bigint(1))
        }),
        Container({
            "name": Leaf("str", "last"),
            "n1": Leaf("int", bigint(1))
        }),
        Container({
            "name": Leaf("str", "second"),
            "n1": Leaf("int", bigint(1))
        }),
        Container({
            "name": Leaf("str", "third"),
            "n1": Leaf("int", bigint(1))
        }),
    ], user_order=True, ns="http://example.com/acme", module="acme")

    testing.assertEqual(exp, merge(y1, y2))

def _test_merge_leaf_conflict():
    y1 = Container({
        "a": Leaf("int", bigint(1))
    })
    y2 = Container({
        "a": Leaf("int", bigint(2))
    })

    try:
        merge(y1, y2)
        testing.assertFalse(True, "Expected ValueError but merge succeeded")
    except ValueError as e:
        testing.assertEqual("Cannot merge leaves with different values at /a: 1 != 2", e.error_message)

def _test_eq_list():
    l1 = List(["name"], [
        Container({
            "name": Leaf("str", "a"),
            "x": Leaf("int", bigint(1))
        }),
        Container({
            "name": Leaf("str", "b"),
            "x": Leaf("int", bigint(2))
        })
    ])
    l2 = List(["name"], [
        Container({
            "name": Leaf("str", "b"),
            "x": Leaf("int", bigint(2))
        }),
        Container({
            "name": Leaf("str", "a"),
            "x": Leaf("int", bigint(1))
        })
    ])
    testing.assertEqual(l1, l1)
    testing.assertEqual(l1, l2)

def _test_eq_list_user_order():
    l1 = List(["name"], user_order=True, elements=[
        Container({
            "x": Leaf("int", bigint(1))
        }),
        Container({
            "x": Leaf("int", bigint(2))
        })
    ])
    l2 = List(["name"], user_order=True, elements=[
        Container({
            "x": Leaf("int", bigint(2))
        }),
        Container({
            "x": Leaf("int", bigint(1))
        })
    ])
    testing.assertEqual(l1, l1)
    testing.assertNotEqual(l1, l2)

def _test_vals_list_sorted():
    l1 = LeafList("str", ["a", "b", "c"])
    l2 = LeafList("str", ["c", "b", "a"])
    testing.assertEqual(l1.prsrc(deterministic=True), l1.prsrc(deterministic=True))
    testing.assertEqual(l1.prsrc(deterministic=True), l2.prsrc(deterministic=True))

def _test_eq_leaf_list_user_order():
    l1 = LeafList("str", ["a", "b", "c"], user_order=True)
    l2 = LeafList("str", ["c", "b", "a"], user_order=True)
    testing.assertEqual(l1, l1)
    testing.assertNotEqual(l1, l2)

def _test_diff_no_change():
    """In this test, old and new are identical. We expect diff to return None
    since there are no differences.
    """
    old = Container({
        "a": Leaf("int", bigint(1)),
        "b": Leaf("int", bigint(2))
    }, ns="http://example.com/acme", module="acme")

    new = Container({
        "a": Leaf("int", bigint(1)),
        "b": Leaf("int", bigint(2))
    }, ns="http://example.com/acme", module="acme")

    d = diff(old, new)
    testing.assertEqual(d, None)

def _test_diff_leaf_change():
    """Only one leaf changes its value. We expect diff to return a container
    with just that leaf changed.
    """
    old = Container({
        "a": Leaf("int", bigint(1)),
        "b": Leaf("int", bigint(2))
    }, ns="http://example.com/acme", module="acme")

    new = Container({
        "a": Leaf("int", bigint(42)), # Changed from 1 to 42
        "b": Leaf("int", bigint(2))
    }, ns="http://example.com/acme", module="acme")

    d = diff(old, new)

    exp = Container({
        "a": Leaf("int", bigint(42))
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(d, exp)

def _test_diff_node_removal():
    """A node c is removed from old to new. We expect an Absent() node in the
    diff at the place where c was.
    """
    old = Container({
        "a": Leaf("int", bigint(1)),
        "c": Leaf("int", bigint(3)),
        "d": Leaf("int", bigint(4))
    }, ns="http://example.com/acme", module="acme")

    new = Container({
        "a": Leaf("int", bigint(1)),
        "d": Leaf("int", bigint(4))
    }, ns="http://example.com/acme", module="acme")

    d = diff(old, new)

    # c is removed
    exp = Container({
        "c": Absent({
            "c": Leaf("int", bigint(3))
        })
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(d, exp)

def _test_diff_list_removal():
    """The entire list (all entries) is removed."""
    old = Container({
        "l": List(["name"], [
        Container({
            "name": Leaf("str", "k1"),
            "n1": Leaf("int", bigint(1)),
            "n2": Leaf("int", bigint(2)),
        }),
        Container({
            "name": Leaf("str", "k4"),
            "n4": Leaf("int", bigint(4)),
        }),
    ], ns="http://example.com/acme", module="acme")
    })

    new = Container()

    d = diff(old, new)

    # Entire list is removed
    exp = Container({
        "l": Absent({
            "l": List(["name"], [
                Container({
                    "name": Leaf("str", "k1"),
                    "n1": Leaf("int", bigint(1)),
                    "n2": Leaf("int", bigint(2)),
                }),
                Container({
                    "name": Leaf("str", "k4"),
                    "n4": Leaf("int", bigint(4)),
                }),
            ], ns="http://example.com/acme", module="acme")
        }, ns="http://example.com/acme", module="acme")
    })

    if d is not None:
        testing.assertEqual(d.prsrc(), exp.prsrc())
    testing.assertEqual(d, exp)

def _test_diff_elem_removal():
    """A list element k1 is removed from old to new. We expect an Absent("k1")
    node in the diff at the place where k1 was.
    """
    old = List(["name"], [
        Container({
            "name": Leaf("str", "k1"),
            "n1": Leaf("int", bigint(1)),
            "n2": Leaf("int", bigint(2)),
        }),
        Container({
            "name": Leaf("str", "k4"),
            "n4": Leaf("int", bigint(4)),
        }),
    ], ns="http://example.com/acme", module="acme")

    new = List(["name"], [
        Container({
            "name": Leaf("str", "k4"),
            "n4": Leaf("int", bigint(4)),
        }),
    ], ns="http://example.com/acme", module="acme")

    d = diff(old, new)

    # k1 is removed
    exp = List(["name"], [
        Absent({
            "name": Leaf("str", "k1")
        })
    ], ns="http://example.com/acme", module="acme")

    testing.assertEqual(d, exp)

def _test_diff_node_addition():
    """A new node e is added in new. We expect the diff to have that new node.
    """
    old = Container({
        "a": Leaf("int", bigint(1))
    }, ns="http://example.com/acme", module="acme")

    new = Container({
        "a": Leaf("int", bigint(1)),
        "e": Leaf("int", bigint(5))
    }, ns="http://example.com/acme", module="acme")

    d = diff(old, new)

    # e is new
    exp = Container({
        "e": Leaf("int", bigint(5))
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(d, exp)

def _test_diff_leaflist():
    """Testing differences in a leaf-list. One value changes and one is
    added.
    """
    old = Container({
        "l": LeafList("str", ["a", "b", "c"])
    }, ns="http://example.com/acme", module="acme")

    new = Container({
        "l": LeafList("str", ["a", "x", "c", "d"]) # "b" changed to "x" and "d" added
    }, ns="http://example.com/acme", module="acme")

    d = diff(old, new)

    exp = Container({
        "l": LeafList("str", ["a", "x", "c", "d"])
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(d, exp)

def _test_diff_complex_ordering():
    """A more complex scenario where the old container has nodes [a, b, c] and
    the new container has [a, c, d]. We expect the absent node b to appear
    before the new node d in the diff.
    """
    old = Container({
        "a": Leaf("int", bigint(1)),
        "b": Leaf("int", bigint(2)),
        "c": Leaf("int", bigint(3))
    }, ns="http://example.com/acme", module="acme")

    new = Container({
        "a": Leaf("int", bigint(1)),
        "c": Leaf("int", bigint(3)),
        "d": Leaf("int", bigint(4))
    }, ns="http://example.com/acme", module="acme")

    d = diff(old, new)

    # "b" is absent before "d" is introduced
    exp = Container({
        "b": Absent({
            "b": Leaf("int", bigint(2))
        }),
        "d": Leaf("int", bigint(4))
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(d, exp)

def _test_patch_no_change():
    old = Container({
        "a": Leaf("int", bigint(1)),
        "b": Leaf("int", bigint(2)),
    }, ns="http://example.com/acme", module="acme")

    # diff is None means no changes
    p = None

    res = patch(old, p)
    testing.assertEqual(res, old)

def _test_patch_leaf_change():
    old = Container({
        "a": Leaf("int", bigint(1)),
        "b": Leaf("int", bigint(2)),
    }, ns="http://example.com/acme", module="acme")

    # Suppose we want to change leaf 'a' from 1 to 42
    # diff would look like this:
    p = Container({
        "a": Leaf("int", bigint(42)),
    }, ns="http://example.com/acme", module="acme")

    res = patch(old, p)
    exp = Container({
        "a": Leaf("int", bigint(42)),
        "b": Leaf("int", bigint(2)),
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(res, exp)

def _test_patch_node_removal():
    old = Container({
        "a": Leaf("int", bigint(1)),
        "c": Leaf("int", bigint(3)),
    }, ns="http://example.com/acme", module="acme")

    # Suppose we remove 'c'
    # patch would be:
    p = Container({
        "c": Absent()
    }, ns="http://example.com/acme", module="acme")

    res = patch(old, p)
    exp = Container({
        "a": Leaf("int", bigint(1)),
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(res, exp)

def _test_patch_elem_removal():
    old = List(["name"], [
        Container({
            "name": Leaf("str", "k1"),
            "n1": Leaf("int", bigint(1)),
            "n2": Leaf("int", bigint(2))
        }),
        Container({
            "name": Leaf("str", "k4"),
            "n4": Leaf("int", bigint(4)),
        }),
    ], ns="http://example.com/acme", module="acme")

    # Suppose we remove 'k1'
    # patch would be:
    p = List(["name"], [
        Absent({
            "name": Leaf("str", "k1")
        })
    ], ns="http://example.com/acme", module="acme")

    res = patch(old, p)
    exp = List(["name"], [
        Container({
            "name": Leaf("str", "k4"),
            "n4": Leaf("int", bigint(4)),
        }),
    ], ns="http://example.com/acme", module="acme")

    testing.assertEqual(res, exp)

def _test_patch_elem_removal2():
    old = Container({
        "n1": Leaf("int", bigint(1)),
        "n2": Leaf("int", bigint(2))
    })

    p = Absent({
        "name": Leaf("str", "k1")
    })

    res = patch(old, p)

    testing.assertEqual(res, None)

def _test_patch_node_addition():
    old = Container({
        "a": Leaf("int", bigint(1)),
    }, ns="http://example.com/acme", module="acme")

    # Add a new leaf 'e':
    p = Container({
        "e": Leaf("int", bigint(5))
    }, ns="http://example.com/acme", module="acme")

    res = patch(old, p)
    exp = Container({
        "a": Leaf("int", bigint(1)),
        "e": Leaf("int", bigint(5)),
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(res, exp)

def _test_patch_complex_ordering():
    # old: a, b, c
    old = Container({
        "a": Leaf("int", bigint(1)),
        "b": Leaf("int", bigint(2)),
        "c": Leaf("int", bigint(3)),
    }, ns="http://example.com/acme", module="acme")

    # new: a, c, d
    # diff: remove b, add d
    p = Container({
        "b": Absent(),
        "d": Leaf("int", bigint(4))
    }, ns="http://example.com/acme", module="acme")

    res = patch(old, p)
    exp = Container({
        "a": Leaf("int", bigint(1)),
        "c": Leaf("int", bigint(3)),
        "d": Leaf("int", bigint(4)),
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(res, exp)

def _test_patch_leaflist():
    old = Container({
        "l": LeafList("str", ["a", "b", "c"])
    }, ns="http://example.com/acme", module="acme")

    # new: l = [a, x, c, d]
    # diff would be a leaflist replace:
    p = Container({
        "l": LeafList("str", ["a", "x", "c", "d"])
    }, ns="http://example.com/acme", module="acme")

    res = patch(old, p)
    exp = Container({
        "l": LeafList("str", ["a", "x", "c", "d"])
    }, ns="http://example.com/acme", module="acme")

    testing.assertEqual(res, exp)

def _test_diff_system_ordered_list_no_diff():
    """Test that diff returns None for reordered elements in system-ordered lists.

    System-ordered lists (user_order=False, which is the default) should not care about
    element ordering. The system is free to reorder elements, so reordering should not
    generate any diff. The diff should be None when comparing two system-ordered lists
    with the same elements in different order.
    """
    elem1 = Container({
        "id": Leaf("string", "1"),
        "name": Leaf("string", "first")
    })
    elem2 = Container({
        "id": Leaf("string", "2"),
        "name": Leaf("string", "second")
    })
    elem3 = Container({
        "id": Leaf("string", "3"),
        "name": Leaf("string", "third")
    })

    old_list = List(
        keys=["id"],
        elements=[elem1, elem2, elem3],
        user_order=False
    )

    new_list = List(
        keys=["id"],
        elements=[elem2, elem1, elem3],
        user_order=False
    )

    result = diff(old_list, new_list)
    testing.assertNone(result, "System-ordered list reordering should not generate a diff")

def _test_diff_and_patch_large_tree():
    # Construct a large 'old' data tree under a Container node
    old = Container({
        "mod1": Container(children={
            "conf": Container(children={
                "settings": Container({
                    "hostname": Leaf("str", "old-router"),
                    "motd": Leaf("str", "Welcome!")
                }),
                "interfaces": List(["name"], elements=[
                    Container({
                        "name": Leaf("str", "eth0"),
                        "desc": Leaf("str", "Uplink interface"),
                        "enabled": Leaf("bool", True)
                    }),
                    Container({
                        "name": Leaf("str", "eth1"),
                        "desc": Leaf("str", "Internal interface"),
                        "enabled": Leaf("bool", True)
                    }),
                ])
            }, ns="http://example.com/yang/mod1", module="mod1")
        }),
        "mod2": Container(children={
            "acl": Container(children={
                "rules": List(["id"], elements=[
                    Container({
                        "id": Leaf("int", bigint(10)),
                        "action": Leaf("str", "permit"),
                        "src": Leaf("str", "10.0.0.0/24"),
                        "dst": Leaf("str", "10.0.1.0/24"),
                    }),
                    Container({
                        "id": Leaf("int", bigint(20)),
                        "action": Leaf("str", "deny"),
                        "src": Leaf("str", "any"),
                        "dst": Leaf("str", "any"),
                    }),
                ])
            }, ns="http://example.com/yang/mod2", module="mod2")
        }),
    })

    # Construct a large 'new' data tree under a Container node
    # Changes from old:
    # - hostname changed from "old-router" to "new-router"
    # - motd removed
    # - eth1 is removed
    # - a new interface eth2 is added
    # - mod2 acl rule 20 changes action from deny to drop
    # - a new acl rule 30 is added
    # - add a LeafList in settings "ntp-servers"
    new = Container(children={
        "mod1": Container(children={
            "conf": Container(children={
                "settings": Container(children={
                    "hostname": Leaf("str", "new-router"),
                    # motd removed
                    "ntp-servers": LeafList("str", ["192.168.100.1", "192.168.100.2"])
                }),
                "interfaces": List(["name"], elements=[
                    Container({
                        "name": Leaf("str", "eth0"),
                        "desc": Leaf("str", "Uplink interface"),
                        "enabled": Leaf("bool", True)
                    }),
                    # eth1 removed
                    Container({
                        "name": Leaf("str", "eth2"),
                        "desc": Leaf("str", "DMZ interface"),
                        "enabled": Leaf("bool", False)
                    }),
                ])
            }, ns="http://example.com/yang/mod1", module="mod1")
        }),
        "mod2": Container(children={
            "acl": Container(children={
                "rules": List(["id"], elements=[
                    Container({
                        "id": Leaf("int", bigint(10)),
                        "action": Leaf("str", "permit"),
                        "src": Leaf("str", "10.0.0.0/24"),
                        "dst": Leaf("str", "10.0.1.0/24"),
                    }),
                    Container({
                        "id": Leaf("int", bigint(20)),
                        "action": Leaf("str", "drop"),  # changed from deny
                        "src": Leaf("str", "any"),
                        "dst": Leaf("str", "any"),
                    }),
                    Container({
                        "id": Leaf("int", bigint(30)),
                        "action": Leaf("str", "permit"),
                        "src": Leaf("str", "192.0.2.0/24"),
                        "dst": Leaf("str", "198.51.100.0/24"),
                    }),
                ])
            }, ns="http://example.com/yang/mod2", module="mod2")
        })
    })

    # Compute diff
    print("Old: ", old.prsrc())
    d = diff(old, new)
    if d is not None:
        print("Diff result: ", d.prsrc())
    else:
        print("Diff result: None")

    # Check that patching old with d results in new
    res = patch(old, d)
    if res is not None:
        testing.assertEqual(res.prsrc(deterministic=True), new.prsrc(deterministic=True))

    # Also check that if we apply diff(new, old), and patch(new, diff(new, old)) we get old back.
    # This ensures round-trip behavior.
    #d2 = diff(new, old)
    #res2 = patch(new, d2)
    #testing.assertEqual(res2, old)

def _test_prsrc():
    y1 = Container({
        "foo": Container({
            "a": Leaf("int", bigint(1)),
            "l1": List(["name"], [
                Container({
                    "name": Leaf("str", "k1"),
                    "n1": Leaf("int", bigint(1)),
                    "n2": Leaf("int", bigint(2))
                }),
                Container({
                    "name": Leaf("str", "k4"),
                    "n4": Leaf("int", bigint(4)),
                }),
            ])
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.prsrc()

def _test_prsrc_absent():
    y1 = Container({
        "foo": Container({
            "a": Absent(),
            "l1": List(["name"], [
                Absent({
                    "name": Leaf("str", "k1")
                }),
                Container({
                    "name": Leaf("str", "k4"),
                    "n4": Leaf("int", bigint(4)),
                }),
            ])
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.prsrc()

def _test_prsrc_root():
    y1 = Container({
        "foo": Container({
            "a": Leaf("int", bigint(1)),
            "b": LeafList("str", ["a", "b", "c"]),
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.prsrc()

def _test_prsrc_leaf_ns():
    y1 = Container({
        "foo": Container({
            "a": Leaf("int", bigint(1), ns="http://example.com/foo", module="foo"),
            "b": Leaf("int", bigint(2))
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.prsrc()

def _test_prsrc_identityref():
    y1 = Container({
        "identity-local": Leaf("identityref", Identityref("foo", "http://example.com/acme", "acme", "acme")),
        "identity-other": Leaf("identityref", Identityref("bar", "http://example.com/bar", "bar", "bar")),
        "augmented-identity-other": Leaf("identityref", Identityref("bar", "http://example.com/bar", "bar", "bar"), "http://example.com/augmentor", "augmentor"),
    }, ns="http://example.com/acme", module="acme")

    return y1.prsrc()

def _test_to_json():
    y1 = Container({
        "acme:foo": Container({
            "a": Leaf("int", bigint(1)),
            "l1": List(["name", "name_two"], [
                Container({
                    "name": Leaf("str", "k1"),
                    "name_two": Leaf("str", "k1a"),
                    "n1": Leaf("int", bigint(1)),
                    "n2": Leaf("int", bigint(2))
                }),
                Container({
                    "name": Leaf("str", "k4"),
                    "name_two": Leaf("str", "k4a"),
                    "n4": Leaf("int", bigint(4)),
                }),
            ]),
            "b": Leaf("bool", False),
            "lb": Leaf("binary", b"Hello Acton \xf0\x9f\xab\xa1"),
            "llb": LeafList("binary", [b"Hello Acton \xf0\x9f\xab\xa1"]),
            "c": Leaf("uint64", bigint(18446744073709551615)),
        }, ns="http://example.com/acme", module="acme"),
        "beep:foo": Container({
            "a": Leaf("int", bigint(1))
        }, ns="http://example.com/beep", module="beep")
    })

    return y1.to_json(pretty=True)

def _test_to_json_empty_leaf():
    y1 = Container({
        "e1": Leaf("empty", True),
        "e2": Leaf("empty", False)
    })

    return y1.to_json(pretty=True)

def _test_to_json_identityref():
    y1 = Container({
        "identity-local": Leaf("identityref", Identityref("foo", "http://example.com/acme", "acme", "acme")),
        "identity-other": Leaf("identityref", Identityref("bar", "http://example.com/bar", "bar", "bar")),
        "augmented-identity-other": Leaf("identityref", Identityref("bar", "http://example.com/bar", "bar", "bar"), "http://example.com/augmentor", "augmentor"),
    }, ns="http://example.com/acme", module="acme")

    return y1.to_json(pretty=True)

def _test_to_xmlstr():
    y1 = Container({
        "acme:foo": Container({
            "a": Leaf("int", bigint(1)),
            "l1": List(["name", "name_two"], [
                Container({
                    "name": Leaf("str", "k1"),
                    "name_two": Leaf("str", "k1a"),
                    "n1": Leaf("int", bigint(1)),
                    "n2": Leaf("int", bigint(2))
                }),
                Container({
                    "name": Leaf("str", "k4"),
                    "name_two": Leaf("str", "k4a"),
                    "n4": Leaf("int", bigint(4)),
                }),
            ]),
            "b": Leaf("bool", False),
            "lb": Leaf("binary", b"Hello Acton \xf0\x9f\xab\xa1"),
            "llb": LeafList("binary", [b"Hello Acton \xf0\x9f\xab\xa1"]),
            "c": Leaf("uint64", bigint(18446744073709551615)),
        }, ns="http://example.com/acme", module="acme"),
        "beep:foo": Container({
            "a": Leaf("int", bigint(1))
        }, ns="http://example.com/beep", module="beep")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_root():
    y1 = Container({
        "foo": Container({
            "a": Leaf("int", bigint(1)),
            "b": LeafList("binary", ["a", "b", "c"]),
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_module():
    y1 = Container({
        "foo": Container({
            "a": Leaf("int", bigint(1)),
            "b": LeafList("str", ["a", "b", "c"]),
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_leaf_ns():
    y1 = Container({
        "foo": Container({
            "a": Leaf("int", bigint(1), ns="http://example.com/foo", module="foo"),
            "b": Leaf("int", bigint(2))
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_mixed():
    y1 = Container({
        "device": List(["name"], [
            Container({
                "name": Leaf("str", "dev1"),
                "config": Container({
                    "hostname": Container({
                        "system-network-name": Leaf("str", "dev1")
                    }, ns="http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg")
                }),
            }),
            Container({
                "name": Leaf("str", "dev2"),
                "config": Container({
                    "hostname": Container({
                        "system-network-name": Leaf("str", "dev2")
                    }, ns="http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg")
                }),
            }),
        ], ns="http://orchestron.org/yang/orchestron-device.yang")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_root_merge():
    y1 = Container({
        "foo": Container({
            "a": Leaf("int", bigint(1)),
            "b": LeafList("str", ["a", "b", "c"]),
        }, ns="http://example.com/acme", module="acme")
    })
    y2 = Container({
        "bar": Container({
            "b": Leaf("int", bigint(42)),
        }, ns="http://example.com/bar", module="bar")
    })
    ym = merge(y1, y2)

    return ym.to_xmlstr()

def _test_to_xmlstr_presence():
    y1 = Container({
        "foo": Container({
            "a": Leaf("int", bigint(1))
        }, presence=True, ns="http://example.com/acme", module="acme")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_presence_childless():
    y1 = Container({
        "foo": Container(presence=True, ns="http://example.com/acme", module="acme")
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_empty_leaf():
    y1 = Container({
        "e1": Leaf("empty", True),
        "e2": Leaf("empty", False)
    })

    return y1.to_xmlstr()

def _test_to_xmlstr_identityref():
    y1 = Container({
        "identity-local": Leaf("identityref", Identityref("foo", "http://example.com/acme", "acme", "acme")),
        "identity-other": Leaf("identityref", Identityref("bar", "http://example.com/bar", "bar", "bar")),
        "augmented-identity-other": Leaf("identityref", Identityref("bar", "http://example.com/bar", "bar", "bar"), "http://example.com/augmentor", "augmentor"),
    }, ns="http://example.com/acme", module="acme")

    return y1.to_xmlstr()

def _test_to_xmlstr_list_removal():
    y1 = Container({
        "l": Absent({
            "l": List(["name"], [
                Container({
                    "name": Leaf("str", "k1"),
                    "n1": Leaf("int", bigint(1)),
                    "n2": Leaf("int", bigint(2)),
                }),
                Container({
                    "name": Leaf("str", "k4"),
                    "n4": Leaf("int", bigint(4)),
                }),
            ], ns="http://example.com/acme", module="acme")
        }, ns="http://example.com/acme", module="acme")
    })

    return y1.to_xmlstr()
