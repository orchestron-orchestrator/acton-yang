class Identityref:
    val: str
    ns: ?str
    mod: ?str

    def __init__(self, val, ns, mod):
        self.val = val
        self.ns = ns
        self.mod = mod

    def __str__(self):
        return "Identityref({repr(self.val)}, {repr(self.ns)}, {repr(self.mod)})"

    def __repr__(self):
        return str(self)

    @staticmethod
    def complete(partial: Identityref, ns_to_mod, mod_to_ns):
        partial_ns = partial.ns
        partial_mod = partial.mod
        if partial_ns is not None and partial_mod is None:
            return Identityref(partial.val, partial_ns, ns_to_mod[partial_ns])
        elif partial_ns is None and partial_mod is not None:
            return Identityref(partial.val, mod_to_ns[partial_mod], partial_mod)
        else:
            return partial

    @staticmethod
    def from_json(val):
        """Create Identityref from JSON-encoded value
        """
        parts = val.split(":")
        if len(parts) == 1:
            return Identityref(parts[0], None, None)
        elif len(parts) == 2:
            return Identityref(parts[1], None, parts[0])
        raise ValueError("Invalid identityref format: {val}")

    @staticmethod
    def from_xml(val: str, nsdefs: list[(?str, str)]):
        parts = val.split(":")
        if len(parts) == 1:
            return Identityref(parts[0], None, None)
        elif len(parts) == 2:
            for nsname, nsuri in nsdefs:
                if nsname == parts[0]:
                    return Identityref(parts[1], nsuri, None)
        raise ValueError("Namespace {parts[0]} not defined in node: {nsdefs}")


extension Identityref (Ord):
    def __eq__(self, other: Identityref) -> bool:
        self_ns = self.ns
        self_mod = self.mod
        other_ns = other.ns
        other_mod = other.mod
        return self.val == other.val and self_ns == other_ns and self_mod == other_mod

    def __lt__(self, other: Identityref) -> bool:
        return self.val < other.val
