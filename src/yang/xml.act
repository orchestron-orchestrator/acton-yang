import base64
import testing
import xml

from yang.identityref import Identityref, PartialIdentityref
from yang.type import Decimal
from yang.data import from_data, YangData, PathElement, YangValidationError
from yang.data import coerce_integer_value, unwrap_key
from yang.data import OP_CREATE, OP_DELETE, OP_REMOVE, OP_REPLACE, OP_MERGE
import yang.gdata
import yang.schema


NETCONF_OPS = {OP_CREATE, OP_DELETE, OP_REMOVE, OP_REPLACE, OP_MERGE}
NETCONF_NS = "urn:ietf:params:xml:ns:netconf:base:1.0"


def _get_netconf_operation(node: xml.Node) -> str:
    """Extract NETCONF operation from an XML node
    """
    def ns_uri(prefix: ?str) -> ?str:
        for p, uri in node.nsdefs:
            # default namespace is stored with prefix == None
            if (prefix is None and p is None) or (prefix is not None and p is not None and prefix == p):
                return uri
        return None

    for attr_key, attr_val in node.attributes:
        if attr_key == "operation":
            # Unprefixed operation; must be in default NETCONF namespace
            if attr_val in NETCONF_OPS and ns_uri(None) == NETCONF_NS:
                return attr_val
        elif attr_key.endswith(":operation"):
            # Prefixed operation; resolve prefix and validate NETCONF namespace
            prefix = attr_key.split(":", 1)[0]
            if attr_val in NETCONF_OPS and ns_uri(prefix) == NETCONF_NS:
                return attr_val

    return OP_MERGE


def _test_get_nc_op_def():
    xml_in = xml.decode('<cfg xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" operation="delete"/>')
    op = _get_netconf_operation(xml_in)
    testing.assertEqual(op, "delete")


def _test_get_nc_op_pref():
    xml_in = xml.decode('<cfg xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="replace"/>')
    op = _get_netconf_operation(xml_in)
    testing.assertEqual(op, "replace")


def _test_get_nc_op_pref_ancestor():
    xml_in = xml.decode('<cfg xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0"><item nc:operation="create"/></cfg>')
    op = _get_netconf_operation(xml_in.children[0])
    # TODO: fix!
    #testing.assertEqual(op, "create")


extension xml.Node (YangData):
    def take_container(self, schema: yang.schema.DContainer, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> ?(op: str, val: ?value):
        child_node = yang.gdata.get_xml_opt_child(self, name, schema.namespace if ns_qualified else None)
        if child_node is not None:
            op = _get_netconf_operation(child_node)
            return (op=op, val=child_node)
        return None

    def take_list(self, schema: yang.schema.DList, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> list[(op: str, key: dict[str, value], val: value)]:
        new_path = path + [PathElement(schema)]
        elements = yang.gdata.get_xml_children(self, name, schema.namespace if ns_qualified else None)

        def extract_key(element_data):
            key_values = {}
            for key_name in schema.key:
                key_node = unwrap_key(key_name, yang.gdata.get_xml_opt_child(element_data, key_name), new_path)
                key_values[key_name] = unwrap_key(key_name, key_node.text, new_path)
            return key_values

        return [(op=_get_netconf_operation(e), key=extract_key(e), val=e) for e in elements]

    mut def take_leaf(self, root: yang.schema.DRoot, schema: yang.schema.DLeaf, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> ?(op: str, t: str, val: ?value):
        new_path = path + [PathElement(schema)]
        maybe_node = yang.gdata.get_xml_opt_child(self, name, schema.namespace if ns_qualified else None)
        if maybe_node is not None:
            op = _get_netconf_operation(maybe_node)
            tv = try_parse_xml_value(maybe_node.text, schema, schema.type_, new_path, maybe_node.nsdefs, root)
            if tv is not None:
                return (op=op, t=tv.t, val=tv.val)
            # TODO: schema.type_.name may not be correct (union), but it's going away soon ...
            return (op=op, t=schema.type_.name, val=None)
        else:
            return None

    def take_leaflist(self, root: yang.schema.DRoot, schema: yang.schema.DLeafList, name: str, ns_qualified: bool, is_unique: bool, path: list[PathElement]=[]) -> list[(op: str, t: str, val: ?value)]:
        new_path = path + [PathElement(schema)]
        values: list[(op: str, t: str, val: ?value)] = []
        children = yang.gdata.get_xml_children(self, name, schema.namespace if ns_qualified else None)
        for child in children:
            if isinstance(child, xml.Node):
                op = _get_netconf_operation(child)
                text_value = child.text
                tv = try_parse_xml_value(text_value, schema, schema.type_, new_path, child.nsdefs, root)
                if tv is not None:
                    values.append((op=op, t=tv.t, val=tv.val))
                else:
                    # TODO: schema.type_.name may not be correct (union), but it's going away soon ...
                    values.append((op=op, t=schema.type_.name, val=None))
        return values


def try_parse_xml_value(text_value: ?str, schema_node: yang.schema.DNodeLeaf, schema_type: yang.schema.DType, path: list[PathElement], nsdefs: list[(?str, str)], root: yang.schema.DRoot) -> ?(t: str, val: value):
    """Parse a textual value according to the provided schema type.

    Returns:
        (t, val): A typed tuple with the concrete type name and native value
                  (e.g. ("uint8", 42)). For unions, returns the successful
                  member type and parsed value.

    Errors:
        Raises YangValidationError with a message including the formatted
        schema path (from the path parameter) and a textual description of the
        expected type (including range constraints if present).
    """
    type_name = schema_type.builtin_type

    if isinstance(schema_type, yang.schema.DTypeUnion):
        for alt_type in schema_type.types:
            try:
                return try_parse_xml_value(text_value, schema_node, alt_type, path, nsdefs, root)
            except YangValidationError:
                continue
        if text_value is not None:
            raise YangValidationError(path, schema_type, text_value)
        return None
    elif isinstance(schema_type, yang.schema.DTypeEmpty):
        if text_value is not None and len(text_value) != 0:
            raise YangValidationError(path, schema_type, text_value)
        return (t=type_name, val=yang.gdata.Present())

    if text_value is not None:
        val: ?value = None
        if isinstance(schema_type, yang.schema.DTypeString):
            val = text_value
        elif isinstance(schema_type, yang.schema.DTypeInteger):
            val = coerce_integer_value(text_value, schema_type, path)
        elif isinstance(schema_type, yang.schema.DTypeEnum):
            val = text_value
        elif isinstance(schema_type, yang.schema.DTypeDecimal64):
            val = Decimal.try_parse(text_value)
        elif isinstance(schema_type, yang.schema.DTypeBoolean):
            if text_value == "true":
                val = True
            elif text_value == "false":
                val = False
        elif isinstance(schema_type, yang.schema.DTypeBinary):
            try:
                val = base64.decode(text_value.encode())
            except ValueError:
                pass
        elif isinstance(schema_type, yang.schema.DTypeIdentityref):
            partial = Identityref.from_xml(text_value, nsdefs)
            res = yang.schema.complete_identityref(partial, root.identities, schema_node.module)
            val = res.0
        elif isinstance(schema_type, yang.schema.DTypeLeafref):
            val = text_value
        elif isinstance(schema_type, yang.schema.DTypeInstanceIdentifier):
            val = text_value
        elif isinstance(schema_type, yang.schema.DTypeBits):
            bits_val = set(None)
            for bit in text_value.split(" "):
                if bit in schema_type.name_to_pos:
                    bits_val.add(bit)
                else:
                    raise YangValidationError(path, schema_type, text_value)
            val = bits_val

        if val is not None and schema_type.validate_value(val):
            return (t=type_name, val=val)

        raise YangValidationError(path, schema_type, text_value)

    return None


def from_xml(root: yang.schema.DRoot, data: xml.Node, loose: bool=False, root_path: list[str]=[]) -> yang.gdata.Container:
    def type_narrower(v):
        if isinstance(v, xml.Node):
            return v
        raise ValueError("Value is not an xml.Node: {type(v)}")

    return from_data(root, data, type_narrower, loose, root_path)

