from yang.identityref import *
import yang.schema


def get_bases(identities: list[yang.schema.DIdentity], base: list[str]):
    bases = []
    for b in base:
        prefix, name = yang.schema.split_prefix_name(b)
        bases.extend([id for id in identities if id.name == name and id.prefix == prefix])
    return bases


def find_identity_by_ref(identities: list[yang.schema.DIdentity], name: str, namespace: ?str=None, module: ?str=None, prefix: ?str=None) -> ?yang.schema.DIdentity:
    """Find an identity by name and optionally namespace or module"""
    for identity in identities:
        if identity.name == name:
            if namespace is not None and identity.namespace == namespace:
                return identity
            elif module is not None and identity.module == module:
                return identity
            elif prefix is not None and identity.prefix == prefix:
                return identity
    return None


def complete_identityref(partial: Identityref, identities: list[yang.schema.DIdentity], current_module: str) -> (?Identityref, ?yang.schema.DIdentity, ?str):
    """Complete an Identityref by filling in missing namespace or module, if only one is set"""
    partial_ns = partial.ns
    partial_mod = partial.mod
    partial_pfx = partial.pfx
    if partial_ns is None and partial_mod is None and partial_pfx is None:
        identity = find_identity_by_ref(identities, partial.val, module=current_module)
        if identity is not None:
            return partial, identity, None
        else:
            return None, None, "Identityref {partial.val} not found in current module {current_module}"
    else:
        # Have namespace or module (also both, but that doesn't happen when we parse XML / JSON)
        identity = find_identity_by_ref(identities, partial.val, namespace=partial_ns, module=partial_mod, prefix=partial_pfx)
        if identity is not None:
            # Strip namespace qualifiers if matching identity is defined in the same module
            if identity.module == current_module:
                complete = Identityref(partial.val)
            else:
                complete = Identityref(partial.val, identity.namespace, identity.module, identity.prefix)
            return complete, identity, None
        else:
            return None, None, "Identityref {partial.val} not found in namespace={partial.ns} module={partial.mod} prefix={partial.pfx}"


def is_derived_from(identity: yang.schema.DIdentity, bases: list[yang.schema.DIdentity]) -> bool:
    """Check if an identity is derived from any of the given base identities"""
    for b in bases:
        if b.module == identity.module and b.name == identity.name:
            return True

    for base in identity.base:
        # Check direct match
        for b in bases:
            if b.module == base.module and b.name == base.name:
                return True
        # Check recursive derivation
        if is_derived_from(base, bases):
            return True
    return False


def complete_and_validate_identityref(partial: Identityref, identities: list[yang.schema.DIdentity], base: list[str], current_module: str):
    identityref, identity, error = complete_identityref(partial, identities, current_module)
    if identity is not None:
        bases = get_bases(identities, base)
        if is_derived_from(identity, bases):
            return identityref, None
        else:
            return None, "Identityref {identityref} not derived from any of the valid bases: {base}"
    return None, error
