
import yang.parser
import yang.schema


def compile(yang_sources: list[str]) -> yang.schema.DRoot:
    ctx = yang.schema.Context()
    for yang_source in yang_sources:
        yang_module = yang.schema.stmt_to_snode(yang.parser.parse(yang_source))
        if isinstance(yang_module, yang.schema.Module):
            ctx.add_module(yang_module)
        elif isinstance(yang_module, yang.schema.Submodule):
            ctx.add_submodule(yang_module)

    # merge submodules into their main module
    for y in ctx.get_modules():
        if isinstance(y, yang.schema.Module):
            for include in y.include:
                submod = ctx.get_submodule(include.module, include.revision_date)
                y.augment.extend(submod.augment)
                # discard contact
                # discard description
                y.deviation.extend(submod.deviation)
                y.extension_.extend(submod.extension_)
                y.feature.extend(submod.feature)
                y.import_.extend(submod.import_)
                # ignore include
                # TODO: we can safely ignore include, right? like the main module MUST list all submodules, riiiight?
                # discard organization
                # discard reference
                # discard revision
                y.exts.extend(submod.exts)
                y.children.extend(submod.children)
            y.include = []

    def deps_done(m: yang.schema.Module, ctx: yang.schema.Context, compiled: set[yang.schema.Module]) -> bool:
        for imp in m.import_:
            dep = ctx.get_module(imp.module, imp.revision_date)
            # If the dependency is not yet compiled, the current module 'm'
            # is not ready to be compiled... so continue
            if dep not in compiled:
                continue
        return True

    # We need to compile all modules but should do so in order of dependencies,
    # so we iteratively compile modules that have all their dependencies compiled
    to_compile = set(ctx.get_modules())
    compiled: set[yang.schema.Module] = set()
    while len(to_compile) > 0:
        for m in to_compile:
            if deps_done(m, ctx, compiled):
                mc = m.compile(ctx)
                if isinstance(mc, yang.schema.Module):
                    compiled.add(mc)
                else:
                    raise ValueError("Expected a Module, got a %s" % type(mc))
                to_compile.discard(m)

    dnodes = []
    for m in compiled:
        dnodes.append(m.to_dnode())
    return yang.schema.DRoot(dnodes)
