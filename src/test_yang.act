import testing

import yang.identity
import yang.parser
import yang.schema
import yang


test_yang = r"""module test_yang {
  yang-version "1.1";
  namespace "http://example.com/test_yang";
  prefix "test_yang";
  description "test yang module";
  revision 2019-01-01 {
    description "test revision";
    reference "ref1";
  }
  import ietf-inet-types {
    prefix "inet";
    revision-date 2013-07-15;
  }
  include example-types;
  feature fe1 {
    description "feature 1";
  }
  feature fe2 {
    description "feature 2";
  }
  typedef t1 {
    type string;
  }
  identity i1 {
    description "identity 1";
  }
  identity i1c {
    description "identity 1";
    base i1;
  }
  extension ext1 {
    description "extension 1";
    argument "arg1";
  }
  grouping g1 {
    description "grouping 1";
    leaf gl1 {
      type string;
      description "grouping leaf 1";
    }
  }
  grouping g2 {
    description "grouping 2";
    container gc1 {
      description "empty container";
    }
  }
  container c1 {
    description "container 1";
    leaf l1 {
      type string;
      description "leaf 1";
      if-feature "fe1 or fe2";
    }
    container c2 {
      description "container 2";
      config false;
      leaf l2 {
        type string;
        description "leaf 2";
      }
      uses g1;
      uses g2 {
        augment "gl2" {
          leaf al1 {
            type string;
          }
        }
        refine "gl2" {
          if-feature "foo";
          description "refined description for gl2";
        }
      }
    }
  }
  container c3 {
    config false;
    ext1:bob "Robert Johansson";
    action a1 {
      description "action 1";
    }
    list li1 {
      description "list 1";
    }
    leaf-list lli1 {
      description "leaf-list 1";
      type int32;
    }
    choice ch1 {
      description "choice 1";
    }
  }
  container c4 {
    presence single-unquoted-word;
    container c5 {
      presence "And you can quote me on that!";
    }
    leaf ql1 {
      type inet:ipv4-address;
      description "some 'quotes'";
    }
    leaf ql2 {
      type string;
      description "contains \"quotes\"";
      must "have \"quotes\"";
      when "does it \"work\"?";
    }
    leaf ql3 {
      type string {
        length "1..10";
        pattern "foo.*";
      }
      default "/tmp/foo";
    }
    list li1 {
      key k1;
      leaf k1 {
        type string;
      }
    }
    list li2 {
      key "k1 k2";
      leaf k1 {
        type string;
      }
      leaf k2 {
        type string;
      }
    }
  }
  rpc rpc1 {
    description "rpc 1";
    input {
      leaf rli1 {
        type string;
        description "rpc input leaf 1";
      }
    }
    output {
      leaf rlo1 {
        type string;
        description "rpc output leaf 1";
      }
    }
  }
  notification n1 {
    description "notification 1";
    anydata n1ad {
      description "notification anydata 1";
    }
    anyxml n1ax {
      description "notification anyxml 1";
    }
  }
}
"""

test_submodule = r"""submodule test_submodule {
  yang-version "1.1";
  belongs-to test_yang {
    prefix "sub1";
  }
}
"""

test_yang_simple = r"""module test_yang {
  yang-version "1.1";
  namespace "http://example.com/test_yang";
  prefix "test_yang";
  description "test yang module";
  revision 2019-01-01 {
    description "test revision";
    reference "ref1";
  }
  import ietf-inet-types {
    prefix "inet";
    revision-date 2013-07-15;
  }
  container c1 {
    description "container 1";
    leaf l1 {
      type string;
      description "leaf 1";
      mandatory true;
    }
    container c2 {
      description "container 2";
      config false;
      leaf l2 {
        type string;
        description "leaf 2";
        default "foo";
      }
      leaf l3 {
        type uint32;
        description "leaf 3";
        default "42";
      }
    }
  }
}
"""

def mwrap(s):
    """Wrap some YANG in a module definition"""
    header = r"""module test_yang {
  yang-version "1.1";
  namespace "http://example.com/test_yang";
  prefix "test_yang";
"""
    footer = r"""
}
"""
    return header + s + footer

def _test_parse_pryang():
    original = test_yang
    y = yang.parser.parse(original)
    yang_out = y.pryang()
    testing.assertEqual(original, yang_out, f"YANG round trip failed\n{original}\n===\n{yang_out}")

def _test_parse_pryang_submodule():
    original = test_submodule
    y = yang.parser.parse(original)
    yang_out = y.pryang()
    testing.assertEqual(original, yang_out, f"YANG round trip failed\n{original}\n===\n{yang_out}")

def _test_snode_to_statement():
    original = test_yang
    n = yang.schema_from_src(original)
    yy = n.to_statement()
    return yy.pryang()

def _test_parse_snode_pryang_twice():
    # YANG -> Statement -> SchemaNode -> Statement -> YANG -> Statement -> SchemaNode -> Statement -> YANG
    original = test_yang
    n1 = yang.schema_from_src(original)
    ys1 = n1.to_statement()
    yy1 = ys1.pryang()
    n2 = yang.schema_from_src(yy1)
    ys2 = n2.to_statement()
    yy2 = ys2.pryang()
    testing.assertEqual(yy1, yy2, f"YANG round trip^2 failed\n{yy1}\n===\n{yy2}")

def _test_parse_pryang_non_idempotent():
    # YANG -> Statement -> SchemaNode -> Statement -> YANG -> Statement -> SchemaNode -> Statement -> YANG
    # The single quoted keyword arguments will be converted to use double
    # quotes after a single roundtrip, as we do not preserve the quotes used in
    # our schema representation. This is fine, as long as the resulting YANG is
    # still valid - \ is escaped as \\.
    original = r"""module test_yang {
    yang-version "1.1";
    namespace "http://example.com/test_yang";
    prefix "test_yang";
    container c1 {
        leaf l1 {
            type string {
                pattern 'example\.com';
            }
            description 'leaf with single quote';
        }
    }
}"""
    n1 = yang.schema_from_src(original)
    ys1 = n1.to_statement()
    yy1 = ys1.pryang()
    print(yy1, err=True)
    testing.assertNotEqual(original, yy1, "YANG round trip not failed")
    n2 = yang.schema_from_src(yy1)
    ys2 = n2.to_statement()
    yy2 = ys2.pryang()
    testing.assertEqual(yy1, yy2, "YANG round trip^2 failed")
    return yy1

def _test_prsrc():
    s = yang.schema_from_src(test_yang)
    return s.prsrc()

def _test_schema_node_submodule():
    s = yang.schema_from_src(test_submodule)
    return s.prsrc()

def _test_fail_leaf_invalid():
    """Invalid statement under leaf"""
    t = mwrap(r"""leaf l1 {
  type string;
  description "leaf 1";
  foo "bar";
}
""")
    try:
        y = yang.parser.parse(t)
    except ValueError as exc:
        testing.assertEqual("Invalid statement under leaf", str(exc), "Expected ValueError")
        return

def _test_unexpected_eof():
    ys = r"""container c1 {
"""
    try:
        y = yang.parser.parse(ys)
    except ValueError as exc:
        testing.assertEqual("ValueError: Unexpected end of file", str(exc), "Expected ValueError")
        return
    testing.error("Expected ValueError")

def _test_prsrc_action_1():
    ys = r"""action action1 {
  description "action 1";
  input {
    leaf rli1 {
      type string;
      description "action input leaf 1";
    }
  }
  output {
    leaf rlo1 {
      type string;
      description "action output leaf 1";
    }
    leaf rlo2 {
      type string;
      description "action output leaf 2";
    }
  }
}"""
    root = yang.schema_from_src(ys)
    return root.prsrc()

def _test_prsrc_augment_1():
    ys = r"""augment "/if:interfaces/if:interface" {
  if-feature "iffy";
  description "aug1";
  reference "ref1";
  when 'derived-from-or-self(if:type, "mymod:some-new-iftype")';
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_bit_1():
    ys = r"""bit b1 {
  description "bit1";
  if-feature "iffy";
  position 1;
  reference "ref1";
  status current;
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_case_1():
    ys = r"""case case1 {
  description "choice1";
  if-feature "iffy";
  reference "ref1";
  status current;
  when 'derived-from-or-self(if:type, "mymod:some-new-iftype")';
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_choice_1():
    ys = r"""choice c1 {
  config true;
  default case1;
  description "choice1";
  if-feature "iffy";
  mandatory true;
  reference "ref1";
  status current;
  when 'derived-from-or-self(if:type, "mymod:some-new-iftype")';
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_choice_case():
    ys = r"""container transfer {
  choice how {
    default interval;
    case interval {
    }
    case daily {
    }
    case manual {
    }
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_enum_1():
    ys = r"""enum foo {
    description "bar";
    if-feature baz;
    reference "qux";
    status current;
    value 42;
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_input_1():
    ys = r"""input {
  must 'foo' {
    description "bar";
    error-app-tag "baz";
    error-message "bax";
    reference "qux";
  }
  leaf l1 {
    type string;
    description "leaf 1";
    if-feature baz;
    reference "ref1";
    status current;
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_grouping_1():
    ys = r"""grouping g1 {
  description "g1 desc";
  reference "ref1";
  status current;
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_module_1():
    ys = r"""module test_yang {
  yang-version "1.1";
  namespace "http://example.com/test_yang";
  prefix "test_yang";
  description "test yang module";
  revision 2019-01-01 {
    description "test revision";
    reference "ref1";
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_must_1():
    ys = r"""must 'foo' {
  description "bar";
  error-app-tag "baz";
  error-message "bax";
  reference "qux";
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_notification_1():
    ys = r"""notification n1 {
  description "notification 1";
  if-feature baz;
  must 'foo' {
    description "bar";
    error-app-tag "baz";
    error-message "bax";
    reference "qux";
  }
  reference "ref1";
  status current;
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_revision_1():
    ys = r"""revision 2019-01-01 {
  description "test revision";
  reference "ref1";
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_leaf_type_bit():
    ys = r"""leaf foo {
  type bits {
    bit "bar" {
      description "bar";
      if-feature baz;
      position 1;
      reference "qux";
      status current;
    }
    bit "bax" {
      description "bax";
      position 2;
    }
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_leaf_type_decimal_fract():
    ys = r"""leaf foo {
  type decimal {
    fraction-digits 3;
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_leaf_type_enum():
    ys = r"""leaf foo {
  type enumeration {
    enum "bar" {
      description "bar";
      if-feature baz;
      reference "qux";
      status current;
      value 42;
    }
    enum "bax" {
      description "bax";
      value 43;
    }
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_leaf_type_leafref():
    ys = r"""leaf foo {
  type leafref {
    path "/foo/bar";
    require-instance false;
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_leaf_type_string_length():
    ys = r"""leaf foo {
  type string {
    length "1..10";
    pattern "foo.*";
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_leaf_type_uint():
    ys = r"""leaf foo {
  type uint32 {
    range "1..10";
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_rpc_1():
    ys = r"""rpc rpc1 {
  description "rpc 1";
  input {
    leaf rli1 {
      type string;
      description "rpc input leaf 1";
    }
  }
  output {
    leaf rlo1 {
      type string;
      description "rpc output leaf 1";
    }
    leaf rlo2 {
      type string;
      description "rpc output leaf 2";
    }
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_typedef_1():
    ys = r"""typedef t1 {
  default "foo";
  description "t1 desc";
  reference "ref1";
  status current;
  type string;
  units "m/s";
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_uses():
    ys = r"""uses g1 {
  description "uses g1";
  if-feature baz;
  reference "ref1";
  status current;
  when 'derived-from-or-self(if:type, "mymod:some-new-iftype")';
  augment "gl2" {
    leaf al1 {
      type string;
    }
  }
  refine "gl2" {
    if-feature "foo";
    description "refined description for gl2";
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_is_config1():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container c1 {
    container c2 {
      leaf l1 {
        type string;
        description "leaf 1";
      }
    }
  }
}"""
    s = yang.schema_from_src(ys)

    testing.assertEqual(s.get("c1").is_config(), True)
    testing.assertEqual(s.get("c1").get("c2").is_config(), True)
    testing.assertEqual(s.get("c1").get("c2").get("l1").is_config(), True)

def _test_is_config2():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container c1 {
    container c2 {
      config false;
      leaf l1 {
        type string;
        description "leaf 1";
      }
    }
  }
}"""
    s = yang.schema_from_src(ys)

    testing.assertEqual(s.get("c1").is_config(), True)
    testing.assertEqual(s.get("c1").get("c2").is_config(), False)
    testing.assertEqual(s.get("c1").get("c2").get("l1").is_config(), False)

def _test_ns():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container c1 {
    container c2 {
      config false;
      leaf l1 {
        type string;
        description "leaf 1";
      }
    }
  }
}"""
    y = yang.parser.parse(ys)
    n = yang.schema.stmt_to_snode(y)
    if isinstance(n, yang.schema.Module):
        testing.assertEqual(n.namespace, "http://example.com/foo")
        testing.assertEqual(n.prefix, "foo")
    else:
        testing.error("Expected Module instance")
    c1 = n.get("c1")
    testing.assertEqual(c1.ns, "http://example.com/foo")


def _test_compile_type1():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  typedef domain-name {
    type string {
      length "1..253";
    }
  }
  container c1 {
    leaf l1 {
      type domain-name;
    }
    leaf-list ll1 {
      type domain-name;
    }
  }
}"""
    n = yang.schema.stmt_to_snode(yang.parser.parse(ys))
    ctx = yang.schema.Context([])
    nc = n.compile(ctx)

    l1 = nc.get("c1").get("l1")
    if isinstance(l1, yang.schema.Leaf):
        l1_type = l1.type_
        if isinstance(l1_type, yang.schema.Type):
            testing.assertEqual(l1_type.name, "string")
        else:
            testing.error("Expected Type instance")
    else:
        testing.error("Expected Leaf instance")

    ll1 = nc.get("c1").get("ll1")
    if isinstance(ll1, yang.schema.LeafList):
        ll1_type = ll1.type_
        if isinstance(ll1_type, yang.schema.Type):
            testing.assertEqual(ll1_type.name, "string")
        else:
            testing.error("Expected Type instance")
    else:
        testing.error("Expected LeafList instance")

def _test_compile_type2():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  typedef td1 {
    type string {
      length "1..10";
    }
  }
  typedef td2 {
    type td1 {
      length "1..10";
    }
  }
  container c1 {
    leaf l1 {
      type td2;
    }
    leaf-list ll1 {
      type td2;
    }
  }
}"""
    n = yang.schema.stmt_to_snode(yang.parser.parse(ys))
    ctx = yang.schema.Context([])
    nc = n.compile(ctx)

    l1 = nc.get("c1").get("l1")
    if isinstance(l1, yang.schema.Leaf):
        l1_type = l1.type_
        if isinstance(l1_type, yang.schema.Type):
            testing.assertEqual(l1_type.name, "string")
        else:
            testing.error("Expected Type instance")
    else:
        testing.error("Expected Leaf instance")

    ll1 = nc.get("c1").get("ll1")
    if isinstance(ll1, yang.schema.LeafList):
        ll1_type = ll1.type_
        if isinstance(ll1_type, yang.schema.Type):
            testing.assertEqual(ll1_type.name, "string")
        else:
            testing.error("Expected Type instance")
    else:
        testing.error("Expected LeafList instance")

def _test_compile_type3():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  typedef td1 {
    type string {
      length "1..10";
    }
  }
  typedef td2 {
    type td1 {
      length "1..9";
    }
  }
  container c1 {
    leaf l1 {
      type union {
        type td2;
        type string;
      }
    }
  }
}"""
    n = yang.schema.stmt_to_snode(yang.parser.parse(ys))
    ctx = yang.schema.Context([])
    nc = n.compile(ctx)

    l1 = nc.get("c1").get("l1")
    if isinstance(l1, yang.schema.Leaf):
        l1_type = l1.type_
        if isinstance(l1_type, yang.schema.Type):
            testing.assertEqual(l1_type.name, "union")
            testing.assertEqual(len(l1_type.type_), 2)
            testing.assertEqual(l1_type.type_[0].name, "string")
            testing.assertEqual(l1_type.type_[1].name, "string")
        else:
            testing.error("Expected Type instance")
    else:
        testing.error("Expected Leaf instance")

def _test_compile_type_in_imported_module():
    ys_foo = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  typedef td1 {
    type string {
      length "1..10";
    }
  }
}"""
    ys_bar = r"""module bar {
  yang-version "1.1";
  namespace "http://example.com/bar";
  prefix "bar";
  import foo {
    prefix "f";
  }
  container c1 {
    leaf l1 {
      type f:td1;
    }
  }
}"""
    n_foo = yang.schema.stmt_to_smodule(yang.parser.parse(ys_foo))
    n_bar = yang.schema.stmt_to_smodule(yang.parser.parse(ys_bar))
    ctx = yang.schema.Context([n_foo, n_bar])
    nc_bar = n_bar.compile(ctx)

    l1 = nc_bar.get("c1").get("l1")
    if isinstance(l1, yang.schema.Leaf):
        l1_type = l1.type_
        if isinstance(l1_type, yang.schema.Type):
            testing.assertEqual(l1_type.name, "string")
        else:
            testing.error("Expected Type instance")
    else:
        testing.error("Expected Leaf instance")


def _test_compile_uses():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  grouping g1 {
    container c1 {
      list li1 {
        key l1;
        leaf l1 {
          type string;
          description "leaf 1";
        }
      }
    }
  }
  grouping g2 {
    uses g1;
  }
  uses g2;
}"""
    root = yang.compile([ys])
    testing.assertEqual(root.get("c1").get("li1").get("l1").config, True)
    return root.prdaclass()

def _test_compile_imported_grouping():
    ys_foo = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  grouping g1 {
    container c1 {
      list li1 {
        key l1;
        leaf l1 {
          type string;
          description "leaf 1";
        }
      }
    }
  }
  grouping g2 {
    uses g1;
  }
}"""
    ys_bar = r"""module bar {
  yang-version "1.1";
  namespace "http://example.com/bar";
  prefix "bar";
  import foo {
    prefix "f";
  }
  grouping g1 {
    uses f:g2;
  }
  uses g1;
}"""
    root = yang.compile([ys_foo, ys_bar])

    testing.assertEqual(root.get("c1").get("li1").get("l1").config, True)
    return root.prdaclass()

def _test_compile_augment():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container c1 {
    leaf l1 {
      type string;
      description "leaf 1";
    }
  }
  augment "/c1" {
    leaf l2 {
      type string;
      description "leaf 2";
    }
  }
}"""
    root = yang.compile([ys])

    testing.assertEqual(root.get("c1").get("l1").config, True)
    testing.assertEqual(root.get("c1").get("l2").config, True)
    return root.prdaclass()

def _test_compile_augment_import():
    ys_foo = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container c1 {
    leaf l1 {
      type string;
      description "leaf 1";
    }
  }
}"""
    ys_bar = r"""module bar {
  yang-version "1.1";
  namespace "http://example.com/bar";
  prefix "bar";
  import foo {
    prefix "f";
  }
  augment "/f:c1" {
    leaf l2 {
      type string;
      description "leaf 2";
    }
  }
}"""
    root = yang.compile([ys_foo, ys_bar])

    testing.assertEqual(root.get("c1").get("l1").config, True)
    testing.assertEqual(root.get("c1").get("l2").config, True)
    return root.prdaclass()

def _test_compile_uses_augment():
    """Augmenting a grouping"""
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  grouping g1 {
    container c1 {
      leaf l1 {
        type string;
        description "leaf 1";
      }
    }
  }
  uses g1 {
    augment "c1" {
      some:ext "foo.bar";
      leaf l2 {
        type string;
        description "leaf 2";
      }
    }
  }
}"""
    #n = yang.schema.stmt_to_snode(yang.parser.parse(ys))
    #ctx = yang.schema.Context([])
    #nc = n.compile(ctx)
    #print(nc.prsrc())
    root = yang.compile([ys])

    testing.assertEqual(root.get("c1").get("l1").config, True)
    testing.assertEqual(root.get("c1").get("l2").config, True)
    testing.assertEqual(root.get("c1").exts, [yang.schema.Ext("some", "ext", "foo.bar")])
    return root.prdaclass()

def _test_compile_augment_uses():
    """Augmenting a grouping"""
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  grouping g1 {
    container c2 {
      leaf l1 {
        type string;
        description "leaf 1";
      }
    }
  }
  container c1 {
    description "container 1";
  }
  augment "/c1" {
    some:ext "foo.bar";
    uses g1;
  }
}"""
    n = yang.schema.stmt_to_snode(yang.parser.parse(ys))
    ctx = yang.schema.Context([])
    nc = n.compile(ctx)
    root = yang.compile([ys])

    c1 = nc.get("c1")
    c2 = c1.get("c2")
    l1 = c2.get("l1")
    testing.assertEqual(nc, c1.parent)
    testing.assertEqual(c1, c2.parent)
    testing.assertEqual(c2, l1.parent)
    testing.assertEqual(c1.exts, [yang.schema.Ext("some", "ext", "foo.bar")])
    if isinstance(l1, yang.schema.Leaf):
        testing.assertEqual(l1.description, "leaf 1")
    else:
        testing.error("Expected Leaf instance")
    return root.prdaclass()

def _test_compile_augment_absolute_path_under_uses():
    """Augmenting a grouping"""
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  grouping g1 {
    container c1 {
      leaf l1 {
        type string;
        description "leaf 1";
      }
    }
  }
  uses g1 {
    augment "/c1" {
      leaf l2 {
        type string;
        description "leaf 2";
      }
    }
  }
}"""
    try:
        root = yang.compile([ys])
    except ValueError as exc:
        # We expect an error here, because the augment path is absolute which is
        # not allowed under a uses statement
        return
    testing.error("Expected ValueError")

def _test_compile_augment_relative_path_under_module():
    """Augmenting a grouping"""
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  grouping g1 {
    container c1 {
      leaf l1 {
        type string;
        description "leaf 1";
      }
    }
  }
  augment "c1" {
    leaf l2 {
      type string;
      description "leaf 2";
    }
  }
}"""
    try:
        root = yang.compile([ys])
    except ValueError as exc:
        # We expect an error here, because the augment path is absolute which is
        # not allowed under a uses statement
        return
    testing.error("Expected ValueError")

def _test_compile_augment_implicit_input_output():
    """Augmenting under implicit input/output of action/rpc"""
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";

  container c1 {
    action a1 {
    }
  }

  rpc r1 {
  }

  augment "/c1/a1/input" {
    leaf l1 {
      type string;
    }
  }

  augment "/c1/a1/output" {
    container c2 {
      leaf l2 {
        type string;
      }
    }
  }

  augment "/r1/input" {
    container c3 {
      leaf l3 {
        type string;
      }
    }
  }

  augment "/r1/output" {
    leaf l4 {
        type string;
    }
  }
}"""
    root = yang.compile([ys])
    return root.prdaclass()

def _test_compile_refine():
    """Refining a grouping"""
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  grouping g1 {
    container c1 {
      leaf-list l1 {
        type string;
      }
    }
  }
  uses g1 {
    refine "c1/l1" {
        description "refined description";
        default "a";
        default "b";
        some:ext "foo.bar";
    }
  }
}"""
    root = yang.compile([ys])
    l1 = root.get("c1").get("l1")
    if isinstance(l1, yang.schema.DLeafList):
        testing.assertEqual(l1.description, "refined description")
        testing.assertEqual(l1.default, ["a", "b"])
        testing.assertEqual(l1.exts, [yang.schema.Ext("some", "ext", "foo.bar")])
    else:
        testing.error("Expected LeafList instance")
    return root.prdaclass()

def _test_compile_choice():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container c1 {
    choice ch1 {
      case cs1 {
        leaf l1 {
          type string;
          description "leaf 1";
        }
      }
      case cs2 {
        leaf l2 {
          type string;
          description "leaf 2";
        }
      }
    }
  }
}"""
    n = yang.schema.stmt_to_snode(yang.parser.parse(ys))
    ctx = yang.schema.Context([])
    nc = n.compile(ctx)

    c1 = nc.get("c1")
    ch1 = c1.get("ch1")
    cs1 = ch1.get("cs1")
    l1 = cs1.get("l1")
    cs2 = ch1.get("cs2")
    l2 = cs2.get("l2")
    testing.assertEqual(c1.parent, nc)
    testing.assertEqual(ch1.parent, c1)
    testing.assertEqual(cs1.parent, ch1)
    testing.assertEqual(l1.parent, cs1)
    testing.assertEqual(cs2.parent, ch1)
    testing.assertEqual(l2.parent, cs2)


def _test_resolve_type_union_of_string():
    """Test resolution of a union type where all base types are string"""
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";

  typedef ipv4-address {
    type string;
  }
  typedef ipv6-address {
    type string;
  }
  typedef domain-name {
    type string;
  }
  typedef ip-address {
    type union {
      type ipv4-address;
      type ipv6-address;
    }
  }
  typedef host {
    type union {
      type ip-address;
      type domain-name;
    }
  }
  leaf l1 {
    type host;
  }
}
"""
    root = yang.compile([ys])
    l1 = root.get("l1")

    if isinstance(l1, yang.schema.DLeaf):
        acton_type = yang.schema.yang_leaf_to_acton_type(l1)
        testing.assertEqual(acton_type, "?str")
    return root.prdaclass()

def _test_resolve_type_union_of_intX():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";

  leaf l1 {
    type union {
      type int8;
      type int32;
    }
  }

  leaf l2 {
    type union {
      type uint8;
      type uint32;
    }
  }

  leaf l3 {
    type union {
      type uint8;
      type int16;
    }
  }

  leaf l4 {
    type union {
      type uint32;
      type int16;
    }
  }
}
"""
    root = yang.compile([ys])
    l1 = root.get("l1")
    l2 = root.get("l2")
    l3 = root.get("l3")
    l4 = root.get("l4")

    if isinstance(l1, yang.schema.DLeaf):
        acton_type = yang.schema.yang_leaf_to_acton_type(l1)
        # TODO: once we have integer subtyping, expect...
        #testing.assertEqual(acton_type, "?i32")
        testing.assertEqual(acton_type, "?int")

    if isinstance(l2, yang.schema.DLeaf):
        acton_type = yang.schema.yang_leaf_to_acton_type(l2)
        # TODO: once we have integer subtyping, expect...
        #testing.assertEqual(acton_type, "?u32")
        testing.assertEqual(acton_type, "?int")

    if isinstance(l3, yang.schema.DLeaf):
        acton_type = yang.schema.yang_leaf_to_acton_type(l3)
        # TODO: once we have integer subtyping, expect...
        #testing.assertEqual(acton_type, "?i16")
        testing.assertEqual(acton_type, "?int")

    if isinstance(l4, yang.schema.DLeaf):
        acton_type = yang.schema.yang_leaf_to_acton_type(l4)
        # TODO: once we have integer subtyping, expect...
        #testing.assertEqual(acton_type, "?i64")
        testing.assertEqual(acton_type, "?int")
    return root.prdaclass()

def _test_resolve_type_union_of_string_and_int():
    """Test resolution of a union type where one base type is string and the other is int"""
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";

  typedef ipv4-address {
    type string;
  }

  leaf l1 {
    type union {
      type ipv4-address;
      type int32;
    }
    default 42;
  }
}
"""
    root = yang.compile([ys])
    return root.prdaclass()

def _test_prdaclass_union_list_key():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";

  container c1 {
    list l1 {
      key "k1 k2";
      leaf k1 {
type string;
      }
      leaf k2 {
        type union {
          type uint32;
          type enumeration {
            enum "unlimited";
          }
          type string;
        }
      }
      leaf l1 {
        type string;
        mandatory true;
      }
    }
  }
}
"""
    root = yang.compile([ys])
    return root.prdaclass()

def _test_prdaclass_identityref_list_key():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";

  identity id1 {
    description "Identity 1";
  }

  identity id2 {
    description "Identity 2";
    base id1;
  }

  container c1 {
    list l1 {
      key "k1 k2";
      leaf k1 {
        type string;
      }
      leaf k2 {
        type identityref {
          base id1;
        }
      }
    }
  }
}
"""
    root = yang.compile([ys])
    return root.prdaclass()

def _test_compile_bundle1():
    ys_foo = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    revision 2019-01-01 {
        description "test revision";
        reference "ref1";
    }
    typedef td1 {
        type string;
    }
    container c1 {
        leaf l1 {
            type td1;
        }
    }
}"""

    ys_bar = r"""module bar {
    yang-version "1.1";
    namespace "http://example.com/bar";
    prefix "bar";
    revision 2020-01-01 {
        description "bar revision";
        reference "bar1";
    }
    import foo {
        prefix "foo";
    }

    augment "/foo:c1" {
        leaf l2 {
            type foo:td1;
        }
    }
}"""
    # Compile in different order
    root1 = yang.compile([ys_foo, ys_bar])
    root2 = yang.compile([ys_bar, ys_foo])
    src = root1.prdaclass()
    if not len(list(filter(lambda x: "    c1: foo__c1" == x, src.splitlines()))) == 1:
        testing.error("Expected exactly one 'c1: foo__c1'")
    return src

def _test_compile_extension():
    ys = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    revision 2019-01-01 {
        description "test revision";
        reference "ref1";
    }
    container c1 {
        list things {
            key name;

            some:exty foo.bar;

            leaf name {
                type string;
            }
            leaf id {
                type string;
            }
        }
    }
}"""
    s = yang.schema_from_src(ys)
    things_slist = s.get("c1").get("things")
    testing.assertEqual(things_slist.exts, [yang.schema.Ext("some", "exty", "foo.bar")])
    root = yang.compile([ys])
    things_list = root.get("c1").get("things")
    testing.assertEqual(things_list.exts, [yang.schema.Ext("some", "exty", "foo.bar")])
    return root.prdaclass()

def _test_compile_augment_on_augment():
    ys_foo = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    revision 2019-01-01 {
        description "test revision";
        reference "ref1";
    }

    augment "/c1/c2" {
        leaf l3 {
            type string;
        }
    }

    augment "/c1" {
        container c2 {
            leaf l2 {
                type string;
            }
        }
    }

    container c1 {
        leaf l1 {
            type string;
        }
    }
}"""

    root = yang.compile([ys_foo])
    l3 = root.get("c1").get("c2").get("l3")
    testing.assertEqual(l3.config, True)
    return root.prdaclass()

def _test_compile_augment_on_augment_across_modules():
    ys_foo = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    revision 2019-01-01 {
        description "test revision";
        reference "ref1";
    }

    container c1 {
        leaf l1 {
            type string;
        }
    }
}"""

    ys_bar = r"""module bar {
    yang-version "1.1";
    namespace "http://example.com/bar";
    prefix "bar";

    import foo {
        prefix "foo";
    }

    augment "/foo:c1" {
        container c2 {
            leaf l2 {
                type string;
            }
        }
    }
}"""

    ys_baz = r"""module baz {
    yang-version "1.1";
    namespace "http://example.com/baz";
    prefix "baz";

    import foo {
        prefix "foo";
    }

    import bar {
        prefix "bar";
    }

    augment "/foo:c1/bar:c2" {
        leaf l3 {
            type string;
        }
    }
}"""

    # Compile in different order to make sure we sort out the dependencies, we
    # would get some error if we didn't.
    nc_baz = yang.schema.stmt_to_smodule(yang.parser.parse(ys_baz))
    nc_baz_aug = nc_baz.augment[0]
    nc_baz_l3 = nc_baz.augment[0].get("l3")
    print(nc_baz_aug, "namespace: ", nc_baz_aug.ns, nc_baz_aug.parent)
    print(nc_baz_l3, "namespace: ", nc_baz_l3.ns, nc_baz_l3.parent)
    print("---")

    nc_bar = yang.schema.stmt_to_smodule(yang.parser.parse(ys_bar))
    nc_bar_c2 = nc_bar.augment[0].get("c2")
    print("---")

    root = yang.compile([ys_foo, ys_bar, ys_baz])
    root = yang.compile([ys_baz, ys_bar, ys_foo])
    l1 = root.get("c1").get("l1")
    l2 = root.get("c1").get("c2").get("l2")
    l3 = root.get("c1").get("c2").get("l3")
    print(l1.namespace)
    print(l2.namespace)
    print(l3.namespace)
    testing.assertEqual(l1.config, True)
    testing.assertEqual(l2.config, True)
    testing.assertEqual(l3.config, True)
    testing.assertEqual(l1.namespace, "http://example.com/foo")
    testing.assertEqual(l2.namespace, "http://example.com/bar")
    testing.assertEqual(l3.namespace, "http://example.com/baz")
    return root.prdaclass()

def _test_compile_submodules1():
    ys_foo = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    include bar;
    revision 2019-01-01 {
        description "test revision";
        reference "ref1";
    }
    container c1 {
        leaf l1 {
            type string;
        }
    }
}"""

    ys_bar = r"""submodule bar {
    yang-version "1.1";
    belongs-to foo {
        prefix "foo";
    }
    container c2 {
        leaf l2 {
            type string;
        }
    }
}"""
    # Test compilation in different order, should not matter
    root = yang.compile([ys_foo, ys_bar])
    root = yang.compile([ys_bar, ys_foo])
    l1 = root.get("c1").get("l1")
    l2 = root.get("c2").get("l2")
    testing.assertEqual(l1.config, True)
    testing.assertEqual(l2.config, True)
    return root.prdaclass()

def _test_compile_submodules2():
    ys_foo = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    include bar;
    revision 2019-01-01 {
        description "test revision";
        reference "ref1";
    }
    container c1 {
        leaf l1 {
            type string;
        }
    }
}"""

    ys_bar = r"""submodule bar {
    yang-version "1.1";
    belongs-to foo {
        prefix "foo";
    }
    container c1 {
        leaf l2 {
            type string;
        }
    }
}"""
    try:
        root = yang.compile([ys_foo, ys_bar])
    except ValueError as exc:
        return
    # TODO: This conflict should be detected during compilation
    #testing.error("Expected ValueError")

def _test_compile_import_hyphenated_prefix():
    ys_foo = r"""module acme_foo-bar {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "acme_foo-bar";
  import acme_qux-baz {
    prefix "acme_qux-baz";
  }
  uses acme_qux-baz:g1;
}"""
    ys_qux = r"""module acme_qux-baz {
  yang-version "1.1";
  namespace "http://example.com/qux";
  prefix "acme_qux-baz";
  grouping g1 {
    container c1 {
      leaf l1 {
        type string;
      }
    }
  }
}"""
    root = yang.compile([ys_foo, ys_qux])

    testing.assertEqual(root.get("c1").get("l1").config, True)
    return root.prdaclass()

def _test_prdaclass_req_arg():
    """Required arguments must come before optional arguments

    For list l1 we generate a create() that takes some args, primarily the list
    key but also other args. The default argument ordering is based on the
    lexical ordering. Since the bar container has a mandatory leaf, it is
    mandatory and needs to be a required argument which should all go before the
    optional args that have a default value.
    """
    ys_foo = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    list l1 {
        key name;
        leaf name {
            type string;
        }
        leaf id {
            type string;
        }
        container bar {
            leaf hi {
                type string;
                mandatory true;
            }
        }
    }
}"""
    root = yang.compile([ys_foo])
    src = root.prdaclass(loose=True)
    return src

def _test_prdaclass_loose_p_container_with_mandatory_leaf():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container foo {
    presence "foo presence";
    container bar {
      presence "bar presence";
      leaf l1 {
        type string;
        mandatory true;
      }
    }
  }
}"""
    root = yang.compile([ys])
    bar = root.get("foo")
    src = bar.prdaclass(loose=True, top=False)
    return src

def _test_prdaclass_loose_container_in_container():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container foo {
    container bar {
      leaf l1 {
        type string;
        mandatory true;
      }
    }
  }
}"""
    root = yang.compile([ys])
    bar = root.get("foo")
    src = bar.prdaclass(loose=True, top=False)
    return src

def _test_prdaclass_strict_list_mandatory():
    ys = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    list l1 {
        key name;
        leaf name {
            type string;
        }
        leaf id {
            type string;
            mandatory true;
        }
    }
}"""
    root = yang.compile([ys])
    l1 = root.get("l1")
    src = l1.prdaclass(top=False)
    return src

def _test_prdaclass_strict_p_container_with_mandatory_leaf():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container foo {
    presence "foo presence";
    container bar {
      presence "bar presence";
      leaf l1 {
        type string;
        mandatory true;
      }
    }
  }
}"""

    ys_bar = r"""module bar {
  yang-version "1.1";
  namespace "http://example.com/bar";
  prefix "bar";
  import foo {
    prefix "foo";
  }
  augment "/foo:foo/bar" {
    // conflicts with /foo:foo/bar/l1
    leaf l1 {
      type string;
      mandatory true;
    }
    leaf l2 {
      type string;
      mandatory true;
    }
  }
}"""
    root = yang.compile([ys, ys_bar])
    src = root.prdaclass()
    return src

def _test_prdaclass_strict_list_p_container_with_mandatory_leaf():
    ys = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    list l1 {
        key name;
        leaf name {
            type string;
        }
        container bar {
            presence "bar presence";
            leaf hi {
                type string;
                mandatory true;
            }
        }
    }
}"""
    root = yang.compile([ys])
    l1 = root.get("l1")
    src = l1.prdaclass(top=False)
    return src

def _test_prdaclass_keyword_name_import():
    ys_foo = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    container c1 {
        leaf as {
            type string;
        }
        leaf for {
            type string;
        }
        leaf import {
            type string;
        }
        leaf in {
            type string;
        }
        leaf with {
            type string;
        }
    }
}"""
    root = yang.compile([ys_foo])
    c1 = root.get("c1")
    src = c1.prdaclass(top=False)
    return src

def _test_prdaclass_list_key_mandatory():
    ys = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    list l1 {
        key name;
        leaf name {
            type string;
            mandatory true;
        }
    }
}"""
    root = yang.compile([ys])
    l1 = root.get("l1")
    src = l1.prdaclass(top=False)
    return src

def _test_prdaclass_list_key_reorder():
    ys = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    list l1 {
        key name;
        leaf id {
            type string;
        }
        leaf name {
            type string;
        }
    }
}"""
    root = yang.compile([ys])
    l1 = root.get("l1")
    src = l1.prdaclass(top=False)
    return src

def _test_prdaclass_top_conflict():
    ys_foo = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    container c1 {
        leaf l1 {
            type string;
        }
    }
}"""
    ys_bar = r"""module bar {
    yang-version "1.1";
    namespace "http://example.com/bar";
    prefix "bar";
    container c1 {
        leaf l1 {
            type string;
        }
    }
}"""
    root = yang.compile([ys_foo, ys_bar])
    src = root.prdaclass()
    return src

def _test_prdaclass_augment_name_conflict():
    ys_base = r"""module base {
    yang-version "1.1";
    namespace "http://example.com/base";
    prefix "base";
    container c1 {
    }
}"""

    ys_foo = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    import base {
        prefix "b";
    }
    augment "/b:c1" {
        leaf foo {
            type string;
        }
    }
}"""

    ys_bar = r"""module bar {
    yang-version "1.1";
    namespace "http://example.com/bar";
    prefix "bar";
    import base {
        prefix "b";
    }
    augment "/b:c1" {
        leaf foo {
            type string;
        }
    }
}"""

    root = yang.compile([ys_base, ys_foo, ys_bar])
    c1 = root.get("c1")
    src = c1.prdaclass(top=False)
    return src

def _test_prdaclass_augment_inner_name_conflict():
    ys_base = r"""module base {
    yang-version "1.1";
    namespace "http://example.com/base";
    prefix "base";
    container c1 {
        container c2 {
            leaf foo {
                type string;
            }
        }
    }
}"""

    ys_foo = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    import base {
      prefix "b";
    }
    augment "/b:c1" {
        container c2 {
            leaf foo {
                type string;
            }
        }
    }
}"""

    root = yang.compile([ys_base, ys_foo])
    # c2 = root.get("c2")
    src = root.prdaclass(top=False)
    return src

def _test_prdaclass_augment_inner_list_conflict():
    ys_base = r"""module base {
    yang-version "1.1";
    namespace "http://example.com/base";
    prefix "base";
    container c1 {
        list l1 {
            key k1;
            leaf k1 {
                type string;
            }
        }
    }
}"""

    ys_foo = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    import base {
      prefix "b";
    }
    augment "/b:c1" {
        list l1 {
            key k2;
            leaf k2 {
                type string;
            }
        }
    }
    augment "/b:c1/l1" {
        leaf k1 {
            type string;
            mandatory true;
        }
    }
}"""

    root = yang.compile([ys_base, ys_foo])
    src = root.prdaclass(top=False)
    return src

def _test_prdaclass_top_container_from_xml_opt():
    ys_base = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    container c1 {
        leaf l1 {
            type string;
        }
    }
    container pc1 {
        presence "p";
        container foo {
            leaf l1 {
                type string;
            }
        }
    }
}"""
    root = yang.compile([ys_base])
    src = root.prdaclass()
    return src


def _test_leaf_defaults():
    ys_base = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    identity id1;
    container c {
        leaf l_str_def {
            type string;
            default "foo";
        }
        leaf l_boolean_def {
            type boolean;
            default "true";
        }
        leaf l_identityref_def {
            type identityref {
                base id1;
            }
            default id1;
        }
    }
}"""
    root = yang.compile([ys_base])

    l_str_def = root.get("c").get("l_str_def")
    if isinstance(l_str_def, yang.schema.DLeaf):
        testing.assertEqual(l_str_def.default, "foo")
    else:
        testing.error("Expected Leaf instance for l_str_def")

    l_boolean_def = root.get("c").get("l_boolean_def")
    if isinstance(l_boolean_def, yang.schema.DLeaf):
        testing.assertEqual(l_boolean_def.default, "true")
    else:
        testing.error("Expected Leaf instance for l_boolean_def")

    l_identityref_def = root.get("c").get("l_identityref_def")
    if isinstance(l_identityref_def, yang.schema.DLeaf):
        testing.assertEqual(l_identityref_def.default, "id1")
    else:
        testing.error("Expected Leaf instance for l_identityref_def")

def _test_prdaclass_max_elements_unbounded():
    ys_base = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    list li1 {
        key l1;
        leaf l1 {
            type string;
        }
        max-elements unbounded;
    }
    leaf-list ll1 {
        type string;
        max-elements unbounded;
    }
}"""
    root = yang.compile([ys_base])
    src = root.prdaclass()
    return src

def _test_prdaclass_min_elements():
    ys_base = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    list li1 {
        key l1;
        leaf l1 {
            type string;
        }
        min-elements 1;
    }
    leaf-list ll1 {
        type string;
        min-elements 1;
    }
}"""
    root = yang.compile([ys_base])
    src = root.prdaclass()
    return src

def _test_mixed_req_args():
    ys_base = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    container c {
        list li {
            key name;
            leaf name {
                type string;
            }

            leaf foo {
                description "Since this has a default value, it should be an optional object argument";
                type string;
                default "banana";
            }

            container bar {
                leaf man {
                    type string;
                    mandatory true;
                }
            }
        }
    }
}"""
    root = yang.compile([ys_base])

    li = root.get("c").get("li")
    src = li.prdaclass(top=False)
    return src

def _test_prdaclass_dot():
    ys_base = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    container ieee-802.3 {
        leaf ieee-802.3 {
            type string;
        }
    }
}"""
    root = yang.compile([ys_base])
    src = root.prdaclass()
    return src

def _test_prdaclass_rpc():
    ys = r"""module yangrpc {
  yang-version "1.1";
  namespace "http://example.com/yangrpc";
  prefix "yrpc";
  rpc foo {
    input {
      leaf a { type string; }
      container woo {
        leaf woo_b { type int64; }
      }
    }
    output {
      leaf outoo { type string; }
    }
  }
  rpc silent;
}"""
    root = yang.compile([ys])
    src = root.prdaclass()
    return src

def _test_identityref():
    # Base module with base identity and a leaf that references it
    ys_base = r"""module base {
    yang-version "1.1";
    namespace "http://example.com/base";
    prefix "base";

    identity protocol-type {
        description "Base identity for protocol types";
    }

    container config {
        leaf active-protocol {
            type identityref {
                base protocol-type;
            }
            description "Currently active protocol";
        }
    }
}"""

    # First module extending the base identity
    ys_foo = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    import base {
        prefix "base";
    }

    identity tcp {
        base base:protocol-type;
        description "TCP protocol";
    }

    identity udp {
        base base:protocol-type;
        description "UDP protocol";
    }
}"""

    # Second module extending the base identity
    ys_bar = r"""module bar {
    yang-version "1.1";
    namespace "http://example.com/bar";
    prefix "bar";
    import base {
        prefix "base";
    }

    identity sctp {
        base base:protocol-type;
        description "SCTP protocol";
    }

    identity dccp {
        base base:protocol-type;
        description "DCCP protocol";
    }
}"""

    # Compile all modules together
    root = yang.compile([ys_base, ys_foo, ys_bar])

    # Get the leaf with identityref type
    config = root.get("config")
    active_protocol = config.get("active-protocol")

    # Verify the leaf has the correct type
    if isinstance(active_protocol, yang.schema.DLeaf):
        leaf_type = active_protocol.type_
        if isinstance(leaf_type, yang.schema.Type):
            testing.assertEqual(leaf_type.name, "identityref")
        else:
            testing.error("Expected Type instance")
    else:
        testing.error("Expected DLeaf instance")

    src = root.prdaclass()
    return src

def _test_fail_identityref_undefined_base():
    """Test that compilation fails when identityref references undefined base identity"""
    ys = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";

    container c1 {
        leaf protocol {
            type identityref {
                base undefined-identity;
            }
            description "Protocol type - references undefined base identity";
        }
    }
}"""
    try:
        root = yang.compile([ys])
    except ValueError as exc:
        testing.assertEqual(exc.error_message, "foo - Compile - Failed: Unable to find identity 'undefined-identity' in module 'foo'")
    else:
        testing.error("Expected ValueError for undefined base identity")

def _test_fail_identity_duplicate():
    """Test that compilation fails when the identity graphs is cyclic"""
    ys = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";

    identity a;
    identity a;
}"""
    try:
        root = yang.compile([ys])
        print(root.prdaclass())
    except ValueError as exc:
        testing.assertEqual(exc.error_message, "Identity foo:a is duplicated")
    else:
        testing.error("Expected ValueError for duplicate identity")

def _test_fail_identity_cyclic():
    """Test that compilation fails when the identity graphs is cyclic"""
    ys = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";

    identity a {
      base b;
    }

    identity b {
      base a;
    }
}"""
    try:
        root = yang.compile([ys])
        print(root.prdaclass())
    except ValueError as exc:
        testing.assertEqual(exc.error_message, "Cycle detected in identity hierarchy: foo:a -> foo:b -> foo:a")
    else:
        testing.error("Expected ValueError for cycle in identity hierarchy")

def assert_true_with_error(result):
    testing.assertTrue(result.0, result.1)

def _test_is_derived_from():
    # Test the is_derived_from function
    base = yang.schema.DIdentity("example-one", "uri:example:one", "example-one", "base", base=[])
    base_two = yang.schema.DIdentity("example-two", "uri:example:two", "example-two", "base-two", base=[])
    one = yang.schema.DIdentity("example-one", "uri:example:one", "example-one", "one", base=[base])
    two = yang.schema.DIdentity("example-two", "uri:example:two", "example-two", "two", base=[base, base_two])
    unrelated = yang.schema.DIdentity("example-three", "uri:example:three", "example-three", "unrelated", base=[])

    # Test direct base identity
    testing.assertTrue(yang.identity.is_derived_from(base, [base]), "base should be derived from itself")

    # Test derived identity
    testing.assertTrue(yang.identity.is_derived_from(one, [base]), "one should be derived from base")

    # Test multi-base derived identity
    testing.assertTrue(yang.identity.is_derived_from(two, [base]), "two should be derived from base")
    testing.assertTrue(yang.identity.is_derived_from(two, [base_two]), "two should be derived from base_two")
    testing.assertTrue(yang.identity.is_derived_from(two, [base, base_two]), "two should be derived from base or base_two")

    # Test unrelated identity
    testing.assertFalse(yang.identity.is_derived_from(unrelated, [base]), "unrelated should not be derived from base")
    testing.assertFalse(yang.identity.is_derived_from(unrelated, [base_two]), "unrelated should not be derived from base_two")

    # Test transitive derivation
    three = yang.schema.DIdentity("example-one", "uri:example:one", "example-one", "three", base=[one])
    testing.assertTrue(yang.identity.is_derived_from(three, [base]), "three should be transitively derived from base through one")
    testing.assertTrue(yang.identity.is_derived_from(three, [one]), "three should be directly derived from one")

def _test_fail_identity_missing_imported_base():
    """Test that compilation fails when identity references a missing base from imported module"""
    ys_base = r"""module base {
    yang-version "1.1";
    namespace "http://example.com/base";
    prefix "base";

    identity interface-type {
        description "Base identity for interface types";
    }
}"""

    ys_derived = r"""module derived {
    yang-version "1.1";
    namespace "http://example.com/derived";
    prefix "derived";
    import base {
        prefix "base";
    }

    identity ethernet {
        base base:network-type;  // References non-existent identity
        description "Ethernet interface type";
    }
}"""

    try:
        root = yang.compile([ys_base, ys_derived])
    except ValueError as exc:
        testing.assertEqual(exc.error_message, "derived - Compile - Failed: Unable to find identity 'network-type' in module 'base'")
    else:
        testing.error("Expected ValueError for undefined imported base identity")
