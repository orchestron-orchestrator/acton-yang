import testing

import yang.parser
import yang.schema
import yang


test_yang = """module test_yang {
  yang-version "1.1";
  namespace "http://example.com/test_yang";
  prefix "test_yang";
  description "test yang module";
  revision 2019-01-01 {
    description "test revision";
    reference "ref1";
  }
  import ietf-inet-types {
    prefix "inet";
    revision-date 2013-07-15;
  }
  include example-types;
  feature fe1 {
    description "feature 1";
  }
  feature fe2 {
    description "feature 2";
  }
  typedef t1 {
    type string;
  }
  identity i1 {
    description "identity 1";
  }
  identity i1c {
    description "identity 1";
    base i1;
  }
  extension ext1 {
    description "extension 1";
    argument "arg1";
  }
  grouping g1 {
    description "grouping 1";
    leaf gl1 {
      type string;
      description "grouping leaf 1";
    }
  }
  grouping g2 {
    description "grouping 2";
    container gc1 {
      description "empty container";
    }
  }
  container c1 {
    description "container 1";
    leaf l1 {
      type string;
      description "leaf 1";
      if-feature "fe1 or fe2";
    }
    container c2 {
      description "container 2";
      config false;
      leaf l2 {
        type string;
        description "leaf 2";
      }
      uses g1;
      uses g2 {
        augment "gl2" {
          leaf al1 {
            type string;
          }
        }
        refine "gl2" {
          if-feature "foo";
          description "refined description for gl2";
        }
      }
    }
  }
  container c3 {
    action a1 {
      description "action 1";
    }
    list li1 {
      description "list 1";
    }
    leaf-list lli1 {
      description "leaf-list 1";
      type int32;
    }
    choice ch1 {
      description "choice 1";
    }
  }
  rpc rpc1 {
    description "rpc 1";
    input {
      leaf rli1 {
        type string;
        description "rpc input leaf 1";
      }
    }
    output {
      leaf rlo1 {
        type string;
        description "rpc output leaf 1";
      }
    }
  }
  notification n1 {
    description "notification 1";
    anydata n1ad {
      description "notification anydata 1";
    }
    anyxml n1ax {
      description "notification anyxml 1";
    }
  }
}
"""

test_submodule = """submodule test_submodule {
  yang-version "1.1";
  belongs-to test_yang {
    prefix "sub1";
  }
}
"""

test_yang_simple = """module test_yang {
  yang-version "1.1";
  namespace "http://example.com/test_yang";
  prefix "test_yang";
  description "test yang module";
  revision 2019-01-01 {
    description "test revision";
    reference "ref1";
  }
  import ietf-inet-types {
    prefix "inet";
    revision-date 2013-07-15;
  }
  container c1 {
    description "container 1";
    leaf l1 {
      type string;
      description "leaf 1";
      mandatory true;
    }
    container c2 {
      description "container 2";
      config false;
      leaf l2 {
        type string;
        description "leaf 2";
        default "foo";
      }
      leaf l3 {
        type uint32;
        description "leaf 3";
        default "42";
      }
    }
  }
}
"""

def mwrap(s):
    """Wrap some YANG in a module definition"""
    header = """module test_yang {
  yang-version "1.1";
  namespace "http://example.com/test_yang";
  prefix "test_yang";
"""
    footer = """
}
"""
    return header + s + footer

def _test_parse_pryang():
    original = test_yang
    y = yang.parser.parse(original)
    yang_out = y.pryang()
    testing.assertEqual(original, yang_out, "YANG round trip failed\n" + original + "\n===\n" + yang_out)

def _test_parse_pryang_submodule():
    original = test_submodule
    y = yang.parser.parse(original)
    yang_out = y.pryang()
    testing.assertEqual(original, yang_out, "YANG round trip failed\n" + original + "\n===\n" + yang_out)

def _test_prsrc():
    s = yang.schema_from_src(test_yang)
    return s.prsrc()

def _test_schema_node_submodule():
    s = yang.schema_from_src(test_submodule)
    return s.prsrc()

def _test_fail_leaf_invalid():
    """Invalid statement under leaf"""
    t = mwrap("""leaf l1 {
  type string;
  description "leaf 1";
  foo "bar";
}
""")
    try:
        y = yang.parser.parse(t)
    except ValueError as exc:
        testing.assertEqual("Invalid statement under leaf", str(exc), "Expected ValueError")
        return

def _test_unexpected_eof():
    ys = """container c1 {
"""
    try:
        y = yang.parser.parse(ys)
    except ValueError as exc:
        testing.assertEqual("ValueError: Unexpected end of file", str(exc), "Expected ValueError")
        return
    testing.error("Expected ValueError")

def _test_prsrc_action_1():
    ys = """action action1 {
  description "action 1";
  input {
    leaf rli1 {
      type string;
      description "action input leaf 1";
    }
  }
  output {
    leaf rlo1 {
      type string;
      description "action output leaf 1";
    }
    leaf rlo2 {
      type string;
      description "action output leaf 2";
    }
  }
}"""
    root = yang.schema_from_src(ys)
    return root.prsrc()

def _test_prsrc_augment_1():
    ys = """augment "/if:interfaces/if:interface" {
  if-feature "iffy";
  description "aug1";
  reference "ref1";
  when 'derived-from-or-self(if:type, "mymod:some-new-iftype")';
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_bit_1():
    ys = """bit b1 {
  description "bit1";
  if-feature "iffy";
  position 1;
  reference "ref1";
  status current;
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_case_1():
    ys = """case case1 {
  description "choice1";
  if-feature "iffy";
  reference "ref1";
  status current;
  when 'derived-from-or-self(if:type, "mymod:some-new-iftype")';
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_choice_1():
    ys = """choice c1 {
  config true;
  default case1;
  description "choice1";
  if-feature "iffy";
  mandatory true;
  reference "ref1";
  status current;
  when 'derived-from-or-self(if:type, "mymod:some-new-iftype")';
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_choice_case():
    ys = """container transfer {
  choice how {
    default interval;
    case interval {
    }
    case daily {
    }
    case manual {
    }
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_enum_1():
    ys = """enum foo {
    description "bar";
    if-feature baz;
    reference "qux";
    status current;
    value 42;
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_input_1():
    ys = """input {
  must 'foo' {
    description "bar";
    error-app-tag "baz";
    error-message "bax";
    reference "qux";
  }
  leaf l1 {
    type string;
    description "leaf 1";
    if-feature baz;
    reference "ref1";
    status current;
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_grouping_1():
    ys = """grouping g1 {
  description "g1 desc";
  reference "ref1";
  status current;
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_module_1():
    ys = """module test_yang {
  yang-version "1.1";
  namespace "http://example.com/test_yang";
  prefix "test_yang";
  description "test yang module";
  revision 2019-01-01 {
    description "test revision";
    reference "ref1";
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_must_1():
    ys = """must 'foo' {
  description "bar";
  error-app-tag "baz";
  error-message "bax";
  reference "qux";
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_notification_1():
    ys = """notification n1 {
  description "notification 1";
  if-feature baz;
  must 'foo' {
    description "bar";
    error-app-tag "baz";
    error-message "bax";
    reference "qux";
  }
  reference "ref1";
  status current;
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_revision_1():
    ys = """revision 2019-01-01 {
  description "test revision";
  reference "ref1";
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_leaf_type_bit():
    ys = """leaf foo {
  type bits {
    bit "bar" {
      description "bar";
      if-feature baz;
      position 1;
      reference "qux";
      status current;
    }
    bit "bax" {
      description "bax";
      position 2;
    }
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_leaf_type_decimal_fract():
    ys = """leaf foo {
  type decimal {
    fraction-digits 3;
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_leaf_type_enum():
    ys = """leaf foo {
  type enumeration {
    enum "bar" {
      description "bar";
      if-feature baz;
      reference "qux";
      status current;
      value 42;
    }
    enum "bax" {
      description "bax";
      value 43;
    }
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_leaf_type_leafref():
    ys = """leaf foo {
  type leafref {
    path "/foo/bar";
    require-instance false;
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_leaf_type_string_length():
    ys = """leaf foo {
  type string {
    length "1..10";
    pattern "foo.*";
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_leaf_type_uint():
    ys = """leaf foo {
  type uint32 {
    range "1..10";
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_rpc_1():
    ys = """rpc rpc1 {
  description "rpc 1";
  input {
    leaf rli1 {
      type string;
      description "rpc input leaf 1";
    }
  }
  output {
    leaf rlo1 {
      type string;
      description "rpc output leaf 1";
    }
    leaf rlo2 {
      type string;
      description "rpc output leaf 2";
    }
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_typedef_1():
    ys = """typedef t1 {
  default "foo";
  description "t1 desc";
  reference "ref1";
  status current;
  type string;
  units "m/s";
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_uses():
    ys = """uses g1 {
  description "uses g1";
  if-feature baz;
  reference "ref1";
  status current;
  when 'derived-from-or-self(if:type, "mymod:some-new-iftype")';
  augment "gl2" {
    leaf al1 {
      type string;
    }
  }
  refine "gl2" {
    if-feature "foo";
    description "refined description for gl2";
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_is_config1():
    ys = """module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container c1 {
    container c2 {
      leaf l1 {
        type string;
        description "leaf 1";
      }
    }
  }
}"""
    s = yang.schema_from_src(ys)

    testing.assertEqual(s.get("c1").is_config(), True)
    testing.assertEqual(s.get("c1").get("c2").is_config(), True)
    testing.assertEqual(s.get("c1").get("c2").get("l1").is_config(), True)

def _test_is_config2():
    ys = """module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container c1 {
    container c2 {
      config false;
      leaf l1 {
        type string;
        description "leaf 1";
      }
    }
  }
}"""
    s = yang.schema_from_src(ys)

    testing.assertEqual(s.get("c1").is_config(), True)
    testing.assertEqual(s.get("c1").get("c2").is_config(), False)
    testing.assertEqual(s.get("c1").get("c2").get("l1").is_config(), False)

def _test_ns():
    ys = """module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container c1 {
    container c2 {
      config false;
      leaf l1 {
        type string;
        description "leaf 1";
      }
    }
  }
}"""
    y = yang.parser.parse(ys)
    n = yang.schema.stmt_to_snode(y)
    if isinstance(n, yang.schema.Module):
        testing.assertEqual(n.namespace, "http://example.com/foo")
        testing.assertEqual(n.prefix, "foo")
    else:
        testing.error("Expected Module instance")
    c1 = n.get("c1")
    testing.assertEqual(c1.ns, "http://example.com/foo")


def _test_compile_type1():
    ys = """module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  typedef domain-name {
    type string {
      length "1..253";
    }
  }
  container c1 {
    leaf l1 {
      type domain-name;
    }
    leaf-list ll1 {
      type domain-name;
    }
  }
}"""
    n = yang.schema.stmt_to_snode(yang.parser.parse(ys))
    ctx = yang.schema.Context([])
    nc = n.compile(ctx)

    l1 = nc.get("c1").get("l1")
    if isinstance(l1, yang.schema.Leaf):
        l1_type = l1.type_
        if isinstance(l1_type, yang.schema.Type):
            testing.assertEqual(l1_type.name, "string")
        else:
            testing.error("Expected Type instance")
    else:
        testing.error("Expected Leaf instance")

    ll1 = nc.get("c1").get("ll1")
    if isinstance(ll1, yang.schema.LeafList):
        ll1_type = ll1.type_
        if isinstance(ll1_type, yang.schema.Type):
            testing.assertEqual(ll1_type.name, "string")
        else:
            testing.error("Expected Type instance")
    else:
        testing.error("Expected LeafList instance")

def _test_compile_type2():
    ys = """module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  typedef td1 {
    type string {
      length "1..10";
    }
  }
  typedef td2 {
    type td1 {
      length "1..10";
    }
  }
  container c1 {
    leaf l1 {
      type td2;
    }
    leaf-list ll1 {
      type td2;
    }
  }
}"""
    n = yang.schema.stmt_to_snode(yang.parser.parse(ys))
    ctx = yang.schema.Context([])
    nc = n.compile(ctx)

    l1 = nc.get("c1").get("l1")
    if isinstance(l1, yang.schema.Leaf):
        l1_type = l1.type_
        if isinstance(l1_type, yang.schema.Type):
            testing.assertEqual(l1_type.name, "string")
        else:
            testing.error("Expected Type instance")
    else:
        testing.error("Expected Leaf instance")

    ll1 = nc.get("c1").get("ll1")
    if isinstance(ll1, yang.schema.LeafList):
        ll1_type = ll1.type_
        if isinstance(ll1_type, yang.schema.Type):
            testing.assertEqual(ll1_type.name, "string")
        else:
            testing.error("Expected Type instance")
    else:
        testing.error("Expected LeafList instance")

def _test_compile_type3():
    ys = """module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  typedef td1 {
    type string {
      length "1..10";
    }
  }
  typedef td2 {
    type td1 {
      length "1..9";
    }
  }
  container c1 {
    leaf l1 {
      type union {
        type td2;
        type string;
      }
    }
  }
}"""
    n = yang.schema.stmt_to_snode(yang.parser.parse(ys))
    ctx = yang.schema.Context([])
    nc = n.compile(ctx)

    l1 = nc.get("c1").get("l1")
    if isinstance(l1, yang.schema.Leaf):
        l1_type = l1.type_
        if isinstance(l1_type, yang.schema.Type):
            testing.assertEqual(l1_type.name, "union")
            testing.assertEqual(len(l1_type.type_), 2)
            testing.assertEqual(l1_type.type_[0].name, "string")
            testing.assertEqual(l1_type.type_[1].name, "string")
        else:
            testing.error("Expected Type instance")
    else:
        testing.error("Expected Leaf instance")

def _test_compile_type_in_imported_module():
    ys_foo = """module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  typedef td1 {
    type string {
      length "1..10";
    }
  }
}"""
    ys_bar = """module bar {
  yang-version "1.1";
  namespace "http://example.com/bar";
  prefix "bar";
  import foo {
    prefix "f";
  }
  container c1 {
    leaf l1 {
      type f:td1;
    }
  }
}"""
    n_foo = yang.schema.stmt_to_smodule(yang.parser.parse(ys_foo))
    n_bar = yang.schema.stmt_to_smodule(yang.parser.parse(ys_bar))
    ctx = yang.schema.Context([n_foo, n_bar])
    nc_bar = n_bar.compile(ctx)

    l1 = nc_bar.get("c1").get("l1")
    if isinstance(l1, yang.schema.Leaf):
        l1_type = l1.type_
        if isinstance(l1_type, yang.schema.Type):
            testing.assertEqual(l1_type.name, "string")
        else:
            testing.error("Expected Type instance")
    else:
        testing.error("Expected Leaf instance")


def _test_compile_uses():
    ys = """module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  grouping g1 {
    container c1 {
      list li1 {
        key l1;
        leaf l1 {
          type string;
          description "leaf 1";
        }
      }
    }
  }
  grouping g2 {
    uses g1;
  }
  uses g2;
}"""
    root = yang.compile([ys])
    testing.assertEqual(root.get("c1").get("li1").get("l1").config, True)


def _test_compile_imported_grouping():
    ys_foo = """module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  grouping g1 {
    container c1 {
      list li1 {
        key l1;
        leaf l1 {
          type string;
          description "leaf 1";
        }
      }
    }
  }
  grouping g2 {
    uses g1;
  }
}"""
    ys_bar = """module bar {
  yang-version "1.1";
  namespace "http://example.com/bar";
  prefix "bar";
  import foo {
    prefix "f";
  }
  grouping g1 {
    uses f:g2;
  }
  uses g1;
}"""
    root = yang.compile([ys_foo, ys_bar])

    testing.assertEqual(root.get("c1").get("li1").get("l1").config, True)


def _test_compile_augment():
    ys = """module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container c1 {
    leaf l1 {
      type string;
      description "leaf 1";
    }
  }
  augment "/c1" {
    leaf l2 {
      type string;
      description "leaf 2";
    }
  }
}"""
    root = yang.compile([ys])

    testing.assertEqual(root.get("c1").get("l1").config, True)
    testing.assertEqual(root.get("c1").get("l2").config, True)

def _test_compile_augment_import():
    ys_foo = """module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container c1 {
    leaf l1 {
      type string;
      description "leaf 1";
    }
  }
}"""
    ys_bar = """module bar {
  yang-version "1.1";
  namespace "http://example.com/bar";
  prefix "bar";
  import foo {
    prefix "f";
  }
  augment "/f:c1" {
    leaf l2 {
      type string;
      description "leaf 2";
    }
  }
}"""
    root = yang.compile([ys_foo, ys_bar])

    testing.assertEqual(root.get("c1").get("l1").config, True)
    testing.assertEqual(root.get("c1").get("l2").config, True)

def _test_compile_uses_augment():
    """Augmenting a grouping"""
    ys = """module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  grouping g1 {
    container c1 {
      leaf l1 {
        type string;
        description "leaf 1";
      }
    }
  }
  uses g1 {
    augment "c1" {
      leaf l2 {
        type string;
        description "leaf 2";
      }
    }
  }
}"""
    #n = yang.schema.stmt_to_snode(yang.parser.parse(ys))
    #ctx = yang.schema.Context([])
    #nc = n.compile(ctx)
    #print(nc.prsrc())
    root = yang.compile([ys])

    testing.assertEqual(root.get("c1").get("l1").config, True)
    testing.assertEqual(root.get("c1").get("l2").config, True)

def _test_compile_augment_uses():
    """Augmenting a grouping"""
    ys = """module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  grouping g1 {
    container c2 {
      leaf l1 {
        type string;
        description "leaf 1";
      }
    }
  }
  container c1 {
    description "container 1";
  }
  augment "/c1" {
    uses g1;
  }
}"""
    n = yang.schema.stmt_to_snode(yang.parser.parse(ys))
    ctx = yang.schema.Context([])
    nc = n.compile(ctx)
    root = yang.compile([ys])

    c1 = nc.get("c1")
    c2 = c1.get("c2")
    l1 = c2.get("l1")
    testing.assertEqual(nc, c1.parent)
    testing.assertEqual(c1, c2.parent)
    testing.assertEqual(c2, l1.parent)
    if isinstance(l1, yang.schema.Leaf):
        testing.assertEqual(l1.description, "leaf 1")
    else:
        testing.error("Expected Leaf instance")

def _test_compile_augment_absolute_path_under_uses():
    """Augmenting a grouping"""
    ys = """module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  grouping g1 {
    container c1 {
      leaf l1 {
        type string;
        description "leaf 1";
      }
    }
  }
  uses g1 {
    augment "/c1" {
      leaf l2 {
        type string;
        description "leaf 2";
      }
    }
  }
}"""
    try:
        root = yang.compile([ys])
    except ValueError as exc:
        # We expect an error here, because the augment path is absolute which is
        # not allowed under a uses statement
        return
    testing.error("Expected ValueError")

def _test_compile_augment_relative_path_under_module():
    """Augmenting a grouping"""
    ys = """module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  grouping g1 {
    container c1 {
      leaf l1 {
        type string;
        description "leaf 1";
      }
    }
  }
  augment "c1" {
    leaf l2 {
      type string;
      description "leaf 2";
    }
  }
}"""
    try:
        root = yang.compile([ys])
    except ValueError as exc:
        # We expect an error here, because the augment path is absolute which is
        # not allowed under a uses statement
        return
    testing.error("Expected ValueError")

def _test_compile_augment_implicit_input_output():
    """Augmenting under implicit input/output of action/rpc"""
    ys = """module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";

  container c1 {
    action a1 {
    }
  }

  rpc r1 {
  }

  augment "/c1/a1/input" {
    leaf l1 {
      type string;
    }
  }

  augment "/c1/a1/output" {
    container c2 {
      leaf l2 {
        type string;
      }
    }
  }

  augment "/r1/input" {
    container c3 {
      leaf l3 {
        type string;
      }
    }
  }

  augment "/r1/output" {
    leaf l4 {
        type string;
    }
  }
}"""
    root = yang.compile([ys])

def _test_compile_refine():
    """Augmenting a grouping"""
    ys = """module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  grouping g1 {
    container c1 {
      leaf-list l1 {
        type string;
      }
    }
  }
  uses g1 {
    refine "c1/l1" {
        default "a";
        default "b";
    }
  }
}"""
    root = yang.compile([ys])

def _test_compile_choice():
    ys = """module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container c1 {
    choice ch1 {
      case cs1 {
        leaf l1 {
          type string;
          description "leaf 1";
        }
      }
      case cs2 {
        leaf l2 {
          type string;
          description "leaf 2";
        }
      }
    }
  }
}"""
    n = yang.schema.stmt_to_snode(yang.parser.parse(ys))
    ctx = yang.schema.Context([])
    nc = n.compile(ctx)

    c1 = nc.get("c1")
    ch1 = c1.get("ch1")
    cs1 = ch1.get("cs1")
    l1 = cs1.get("l1")
    cs2 = ch1.get("cs2")
    l2 = cs2.get("l2")
    testing.assertEqual(c1.parent, nc)
    testing.assertEqual(ch1.parent, c1)
    testing.assertEqual(cs1.parent, ch1)
    testing.assertEqual(l1.parent, cs1)
    testing.assertEqual(cs2.parent, ch1)
    testing.assertEqual(l2.parent, cs2)


def _test_resolve_type_union_of_string():
    """Test resolution of a union type where all base types are string"""
    ys = """module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";

  typedef ipv4-address {
    type string;
  }
  typedef ipv6-address {
    type string;
  }
  typedef domain-name {
    type string;
  }
  typedef ip-address {
    type union {
      type ipv4-address;
      type ipv6-address;
    }
  }
  typedef host {
    type union {
      type ip-address;
      type domain-name;
    }
  }
  leaf l1 {
    type host;
  }
}
"""
    root = yang.compile([ys])
    l1 = root.get("l1")

    if isinstance(l1, yang.schema.DLeaf):
        acton_type = yang.schema.yang_leaf_to_acton_type(l1)
        testing.assertEqual(acton_type, "?str")


def _test_resolve_type_union_of_intX():
    ys = """module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";

  leaf l1 {
    type union {
      type int8;
      type int32;
    }
  }

  leaf l2 {
    type union {
      type uint8;
      type uint32;
    }
  }

  leaf l3 {
    type union {
      type uint8;
      type int16;
    }
  }

  leaf l4 {
    type union {
      type uint32;
      type int16;
    }
  }
}
"""
    root = yang.compile([ys])
    l1 = root.get("l1")
    l2 = root.get("l2")
    l3 = root.get("l3")
    l4 = root.get("l4")

    if isinstance(l1, yang.schema.DLeaf):
        acton_type = yang.schema.yang_leaf_to_acton_type(l1)
        # TODO: once we have integer subtyping, expect...
        #testing.assertEqual(acton_type, "?i32")
        testing.assertEqual(acton_type, "?int")

    if isinstance(l2, yang.schema.DLeaf):
        acton_type = yang.schema.yang_leaf_to_acton_type(l2)
        # TODO: once we have integer subtyping, expect...
        #testing.assertEqual(acton_type, "?u32")
        testing.assertEqual(acton_type, "?int")

    if isinstance(l3, yang.schema.DLeaf):
        acton_type = yang.schema.yang_leaf_to_acton_type(l3)
        # TODO: once we have integer subtyping, expect...
        #testing.assertEqual(acton_type, "?i16")
        testing.assertEqual(acton_type, "?int")

    if isinstance(l4, yang.schema.DLeaf):
        acton_type = yang.schema.yang_leaf_to_acton_type(l4)
        # TODO: once we have integer subtyping, expect...
        #testing.assertEqual(acton_type, "?i64")
        testing.assertEqual(acton_type, "?int")

def _test_compile_bundle1():
    ys_foo = """module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    revision 2019-01-01 {
        description "test revision";
        reference "ref1";
    }
    typedef td1 {
        type string;
    }
    container c1 {
        leaf l1 {
            type td1;
        }
    }
}"""

    ys_bar = """module bar {
    yang-version "1.1";
    namespace "http://example.com/bar";
    prefix "bar";
    revision 2020-01-01 {
        description "bar revision";
        reference "bar1";
    }
    import foo {
        prefix "foo";
    }

    augment "/foo:c1" {
        leaf l2 {
            type foo:td1;
        }
    }
}"""
    # Compile in different order
    root1 = yang.compile([ys_foo, ys_bar])
    root2 = yang.compile([ys_bar, ys_foo])
    src = root1.prdaclass()
    if not len(list(filter(lambda x: "    c1: foo__c1" == x, src.splitlines()))) == 1:
        testing.error("Expected exactly one 'c1: foo__c1'")

def _test_compile_extension():
    ys = """module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    revision 2019-01-01 {
        description "test revision";
        reference "ref1";
    }
    container c1 {
        list things {
            key name;

            some:exty foo.bar;

            leaf name {
                type string;
            }
            leaf id {
                type string;
            }
        }
    }
}"""
    s = yang.schema_from_src(ys)
    things_slist = s.get("c1").get("things")
    testing.assertEqual(things_slist.exts, [yang.schema.Ext("some", "exty", "foo.bar")])
    root = yang.compile([ys])
    things_list = root.get("c1").get("things")
    testing.assertEqual(things_list.exts, [yang.schema.Ext("some", "exty", "foo.bar")])

def _test_compile_augment_on_augment():
    ys_foo = """module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    revision 2019-01-01 {
        description "test revision";
        reference "ref1";
    }

    augment "/c1/c2" {
        leaf l3 {
            type string;
        }
    }

    augment "/c1" {
        container c2 {
            leaf l2 {
                type string;
            }
        }
    }

    container c1 {
        leaf l1 {
            type string;
        }
    }
}"""

    root = yang.compile([ys_foo])
    l3 = root.get("c1").get("c2").get("l3")
    testing.assertEqual(l3.config, True)


def _test_compile_augment_on_augment_across_modules():
    ys_foo = """module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    revision 2019-01-01 {
        description "test revision";
        reference "ref1";
    }

    container c1 {
        leaf l1 {
            type string;
        }
    }
}"""

    ys_bar = """module bar {
    yang-version "1.1";
    namespace "http://example.com/bar";
    prefix "bar";

    import foo {
        prefix "foo";
    }

    augment "/foo:c1" {
        container c2 {
            leaf l2 {
                type string;
            }
        }
    }
}"""

    ys_baz = """module baz {
    yang-version "1.1";
    namespace "http://example.com/baz";
    prefix "baz";

    import foo {
        prefix "foo";
    }

    import bar {
        prefix "bar";
    }

    augment "/foo:c1/bar:c2" {
        leaf l3 {
            type string;
        }
    }
}"""

    # Compile in different order to make sure we sort out the dependencies, we
    # would get some error if we didn't.
    nc_baz = yang.schema.stmt_to_smodule(yang.parser.parse(ys_baz))
    nc_baz_aug = nc_baz.augment[0]
    nc_baz_l3 = nc_baz.augment[0].get("l3")
    print(nc_baz_aug, "namespace: ", nc_baz_aug.ns, nc_baz_aug.parent)
    print(nc_baz_l3, "namespace: ", nc_baz_l3.ns, nc_baz_l3.parent)
    print("---")

    nc_bar = yang.schema.stmt_to_smodule(yang.parser.parse(ys_bar))
    nc_bar_c2 = nc_bar.augment[0].get("c2")
    print("---")

    root = yang.compile([ys_foo, ys_bar, ys_baz])
    root = yang.compile([ys_baz, ys_bar, ys_foo])
    l1 = root.get("c1").get("l1")
    l2 = root.get("c1").get("c2").get("l2")
    l3 = root.get("c1").get("c2").get("l3")
    print(l1.namespace)
    print(l2.namespace)
    print(l3.namespace)
    testing.assertEqual(l1.config, True)
    testing.assertEqual(l2.config, True)
    testing.assertEqual(l3.config, True)
    testing.assertEqual(l1.namespace, "http://example.com/foo")
    testing.assertEqual(l2.namespace, "http://example.com/bar")
    testing.assertEqual(l3.namespace, "http://example.com/baz")


def _test_compile_submodules1():
    ys_foo = """module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    include bar;
    revision 2019-01-01 {
        description "test revision";
        reference "ref1";
    }
    container c1 {
        leaf l1 {
            type string;
        }
    }
}"""

    ys_bar = """submodule bar {
    yang-version "1.1";
    belongs-to foo {
        prefix "foo";
    }
    container c2 {
        leaf l2 {
            type string;
        }
    }
}"""
    # Test compilation in different order, should not matter
    root = yang.compile([ys_foo, ys_bar])
    root = yang.compile([ys_bar, ys_foo])
    l1 = root.get("c1").get("l1")
    l2 = root.get("c2").get("l2")
    testing.assertEqual(l1.config, True)
    testing.assertEqual(l2.config, True)

def _test_compile_submodules2():
    ys_foo = """module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    include bar;
    revision 2019-01-01 {
        description "test revision";
        reference "ref1";
    }
    container c1 {
        leaf l1 {
            type string;
        }
    }
}"""

    ys_bar = """submodule bar {
    yang-version "1.1";
    belongs-to foo {
        prefix "foo";
    }
    container c1 {
        leaf l2 {
            type string;
        }
    }
}"""
    try:
        root = yang.compile([ys_foo, ys_bar])
    except ValueError as exc:
        return
    # TODO: This conflict should be detected during compilation
    #testing.error("Expected ValueError")


def _test_prdaclass_req_arg():
    """Required arguments must come before optional arguments

    For list l1 we generate a create() that takes some args, primarily the list
    key but also other args. The default argument ordering is based on the
    lexical ordering. Since the bar container has a mandatory leaf, it is
    mandatory and needs to be a required argument which should all go before the
    optional args that have a default value.
    """
    ys_foo = """module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    list l1 {
        key name;
        leaf name {
            type string;
        }
        leaf id {
            type string;
        }
        container bar {
            leaf hi {
                type string;
                mandatory true;
            }
        }
    }
}"""
    root = yang.compile([ys_foo])
    src = root.prdaclass(loose=True)
    return src

def _test_prdaclass_loose_p_container_with_mandatory_leaf():
    ys = """module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container foo {
    presence "foo presence";
    container bar {
      presence "bar presence";
      leaf l1 {
        type string;
        mandatory true;
      }
    }
  }
}"""
    root = yang.compile([ys])
    bar = root.get("foo")
    src = bar.prdaclass(loose=True, top=False)
    return src

def _test_prdaclass_loose_container_in_container():
    ys = """module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container foo {
    container bar {
      leaf l1 {
        type string;
        mandatory true;
      }
    }
  }
}"""
    root = yang.compile([ys])
    bar = root.get("foo")
    src = bar.prdaclass(loose=True, top=False)
    return src

def _test_prdaclass_strict_list_mandatory():
    ys = """module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    list l1 {
        key name;
        leaf name {
            type string;
        }
        leaf id {
            type string;
            mandatory true;
        }
    }
}"""
    root = yang.compile([ys])
    l1 = root.get("l1")
    src = l1.prdaclass(top=False)
    return src

def _test_prdaclass_strict_list_p_container_with_mandatory_leaf():
    ys = """module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    list l1 {
        key name;
        leaf name {
            type string;
        }
        container bar {
            presence "bar presence";
            leaf hi {
                type string;
                mandatory true;
            }
        }
    }
}"""
    root = yang.compile([ys])
    l1 = root.get("l1")
    src = l1.prdaclass(top=False)
    return src

def _test_prdaclass_keyword_name_import():
    ys_foo = """module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    container c1 {
        leaf as {
            type string;
        }
        leaf for {
            type string;
        }
        leaf import {
            type string;
        }
        leaf in {
            type string;
        }
        leaf with {
            type string;
        }
    }
}"""
    root = yang.compile([ys_foo])
    c1 = root.get("c1")
    src = c1.prdaclass(top=False)
    return src

def _test_prdaclass_list_key_mandatory():
    ys = """module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    list l1 {
        key name;
        leaf name {
            type string;
            mandatory true;
        }
    }
}"""
    root = yang.compile([ys])
    l1 = root.get("l1")
    src = l1.prdaclass(top=False)
    return src

def _test_prdaclass_augment_name_conflict():
    ys_base = """module base {
    yang-version "1.1";
    namespace "http://example.com/base";
    prefix "base";
    container c1 {
    }
}"""

    ys_foo = """module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    import base {
        prefix "b";
    }
    augment "/b:c1" {
        leaf foo {
            type string;
        }
    }
}"""

    ys_bar = """module bar {
    yang-version "1.1";
    namespace "http://example.com/bar";
    prefix "bar";
    import base {
        prefix "b";
    }
    augment "/b:c1" {
        leaf foo {
            type string;
        }
    }
}"""

    # TODO: sort out the resulting conflict by using a prefix
    root = yang.compile([ys_base, ys_foo, ys_bar])
    c1 = root.get("c1")
    src = c1.prdaclass(top=False)
    return src
