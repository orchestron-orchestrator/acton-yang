import testing

import yang.identity
import yang.parser
import yang.schema
import yang


test_yang = r"""module test_yang {
  yang-version "1.1";
  namespace "http://example.com/test_yang";
  prefix "test_yang";
  description "test yang module";
  revision 2019-01-01 {
    description "test revision";
    reference "ref1";
  }
  import ietf-inet-types {
    prefix "inet";
    revision-date 2013-07-15;
  }
  include example-types;
  feature fe1 {
    description "feature 1";
  }
  feature fe2 {
    description "feature 2";
  }
  typedef t1 {
    type string;
  }
  identity i1 {
    description "identity 1";
  }
  identity i1c {
    description "identity 1";
    base i1;
  }
  extension ext1 {
    description "extension 1";
    argument "arg1";
  }
  grouping g1 {
    description "grouping 1";
    leaf gl1 {
      type string;
      description "grouping leaf 1";
    }
  }
  grouping g2 {
    description "grouping 2";
    container gc1 {
      description "empty container";
    }
  }
  container c1 {
    description "container 1";
    leaf l1 {
      type string;
      description "leaf 1";
      if-feature "fe1 or fe2";
    }
    container c2 {
      description "container 2";
      config false;
      leaf l2 {
        type string;
        description "leaf 2";
      }
      uses g1;
      uses g2 {
        augment "gl2" {
          leaf al1 {
            type string;
          }
        }
        refine "gl2" {
          if-feature "foo";
          description "refined description for gl2";
        }
      }
    }
  }
  container c3 {
    config false;
    ext1:bob "Robert Johansson";
    action a1 {
      description "action 1";
    }
    list li1 {
      description "list 1";
    }
    leaf-list lli1 {
      description "leaf-list 1";
      type int32;
    }
    choice ch1 {
      description "choice 1";
    }
  }
  container c4 {
    presence single-unquoted-word;
    container c5 {
      presence "And you can quote me on that!";
    }
    leaf ql1 {
      type inet:ipv4-address;
      description "some 'quotes'";
    }
    leaf ql2 {
      type string;
      description "contains \"quotes\"";
      must "have \"quotes\"";
      when "does it \"work\"?";
    }
    leaf ql3 {
      type string {
        length "1..10";
        pattern "foo.*";
      }
      default "/tmp/foo";
    }
    list li1 {
      key k1;
      leaf k1 {
        type string;
      }
    }
    list li2 {
      key "k1 k2";
      leaf k1 {
        type string;
      }
      leaf k2 {
        type string;
      }
    }
  }
  rpc rpc1 {
    description "rpc 1";
    input {
      leaf rli1 {
        type string;
        description "rpc input leaf 1";
      }
    }
    output {
      leaf rlo1 {
        type string;
        description "rpc output leaf 1";
      }
    }
  }
  notification n1 {
    description "notification 1";
    anydata n1ad {
      description "notification anydata 1";
    }
    anyxml n1ax {
      description "notification anyxml 1";
    }
  }
}
"""

test_submodule = r"""submodule test_submodule {
  yang-version "1.1";
  belongs-to test_yang {
    prefix "sub1";
  }
}
"""

test_yang_simple = r"""module test_yang {
  yang-version "1.1";
  namespace "http://example.com/test_yang";
  prefix "test_yang";
  description "test yang module";
  revision 2019-01-01 {
    description "test revision";
    reference "ref1";
  }
  import ietf-inet-types {
    prefix "inet";
    revision-date 2013-07-15;
  }
  container c1 {
    description "container 1";
    leaf l1 {
      type string;
      description "leaf 1";
      mandatory true;
    }
    container c2 {
      description "container 2";
      config false;
      leaf l2 {
        type string;
        description "leaf 2";
        default "foo";
      }
      leaf l3 {
        type uint32;
        description "leaf 3";
        default "42";
      }
    }
  }
}
"""

def mwrap(s):
    """Wrap some YANG in a module definition"""
    header = r"""module test_yang {
  yang-version "1.1";
  namespace "http://example.com/test_yang";
  prefix "test_yang";
"""
    footer = r"""
}
"""
    return header + s + footer

def _test_parse_pryang():
    original = test_yang
    y = yang.parser.parse(original)
    yang_out = y.pryang()
    testing.assertEqual(original, yang_out, f"YANG round trip failed\n{original}\n===\n{yang_out}")

def _test_parse_pryang_submodule():
    original = test_submodule
    y = yang.parser.parse(original)
    yang_out = y.pryang()
    testing.assertEqual(original, yang_out, f"YANG round trip failed\n{original}\n===\n{yang_out}")

def _test_snode_to_statement():
    original = test_yang
    n = yang.schema_from_src(original)
    yy = n.to_statement()
    return yy.pryang()

def _test_parse_snode_pryang_twice():
    # YANG -> Statement -> SchemaNode -> Statement -> YANG -> Statement -> SchemaNode -> Statement -> YANG
    original = test_yang
    n1 = yang.schema_from_src(original)
    ys1 = n1.to_statement()
    yy1 = ys1.pryang()
    n2 = yang.schema_from_src(yy1)
    ys2 = n2.to_statement()
    yy2 = ys2.pryang()
    testing.assertEqual(yy1, yy2, f"YANG round trip^2 failed\n{yy1}\n===\n{yy2}")

def _test_parse_pryang_non_idempotent():
    # YANG -> Statement -> SchemaNode -> Statement -> YANG -> Statement -> SchemaNode -> Statement -> YANG
    # The single quoted keyword arguments will be converted to use double
    # quotes after a single roundtrip, as we do not preserve the quotes used in
    # our schema representation. This is fine, as long as the resulting YANG is
    # still valid - \ is escaped as \\.
    original = r"""module test_yang {
    yang-version "1.1";
    namespace "http://example.com/test_yang";
    prefix "test_yang";
    container c1 {
        leaf l1 {
            type string {
                pattern 'example\.com';
            }
            description 'leaf with single quote';
        }
    }
}"""
    n1 = yang.schema_from_src(original)
    ys1 = n1.to_statement()
    yy1 = ys1.pryang()
    print(yy1, err=True)
    testing.assertNotEqual(original, yy1, "YANG round trip not failed")
    n2 = yang.schema_from_src(yy1)
    ys2 = n2.to_statement()
    yy2 = ys2.pryang()
    testing.assertEqual(yy1, yy2, "YANG round trip^2 failed")
    return yy1

def _test_statement_dict_roundtrip():
    s1 = yang.parser.parse(test_yang)
    s2 = yang.schema.Statement.from_dict(s1.to_dict())
    testing.assertEqual(s1.prsrc(), s2.prsrc())

def _test_prsrc():
    s = yang.schema_from_src(test_yang)
    return s.prsrc()

def _test_schema_node_submodule():
    s = yang.schema_from_src(test_submodule)
    return s.prsrc()

def _test_tab_separator():
    s = yang.parser.parse(mwrap(r"	leaf foo { type 	string; }"))
    return s.prsrc()

def _test_fail_leaf_invalid():
    """Invalid statement under leaf"""
    t = mwrap(r"""leaf l1 {
  type string;
  description "leaf 1";
  foo "bar";
}
""")
    try:
        y = yang.parser.parse(t)
    except ValueError as exc:
        testing.assertEqual("Invalid statement under leaf", str(exc), "Expected ValueError")
        return

def _test_unexpected_eof():
    ys = r"""container c1 {
"""
    try:
        y = yang.parser.parse(ys)
    except ValueError as exc:
        testing.assertEqual("ValueError: Unexpected end of file", str(exc), "Expected ValueError")
        return
    testing.error("Expected ValueError")

def _test_prsrc_action_1():
    ys = r"""action action1 {
  description "action 1";
  input {
    leaf rli1 {
      type string;
      description "action input leaf 1";
    }
  }
  output {
    leaf rlo1 {
      type string;
      description "action output leaf 1";
    }
    leaf rlo2 {
      type string;
      description "action output leaf 2";
    }
  }
}"""
    root = yang.schema_from_src(ys)
    return root.prsrc()

def _test_prsrc_augment_1():
    ys = r"""augment "/if:interfaces/if:interface" {
  if-feature "iffy";
  description "aug1";
  reference "ref1";
  when 'derived-from-or-self(if:type, "mymod:some-new-iftype")';
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_bit_1():
    ys = r"""bit b1 {
  description "bit1";
  if-feature "iffy";
  position 1;
  reference "ref1";
  status current;
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_case_1():
    ys = r"""case case1 {
  description "choice1";
  if-feature "iffy";
  reference "ref1";
  status current;
  when 'derived-from-or-self(if:type, "mymod:some-new-iftype")';
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_choice_1():
    ys = r"""choice c1 {
  config true;
  default case1;
  description "choice1";
  if-feature "iffy";
  mandatory true;
  reference "ref1";
  status current;
  when 'derived-from-or-self(if:type, "mymod:some-new-iftype")';
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_choice_case():
    ys = r"""container transfer {
  choice how {
    default interval;
    case interval {
    }
    case daily {
    }
    case manual {
    }
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_enum_1():
    ys = r"""enum foo {
    description "bar";
    if-feature baz;
    reference "qux";
    status current;
    value 42;
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_input_1():
    ys = r"""input {
  must 'foo' {
    description "bar";
    error-app-tag "baz";
    error-message "bax";
    reference "qux";
  }
  leaf l1 {
    type string;
    description "leaf 1";
    if-feature baz;
    reference "ref1";
    status current;
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_grouping_1():
    ys = r"""grouping g1 {
  description "g1 desc";
  reference "ref1";
  status current;
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_module_1():
    ys = r"""module test_yang {
  yang-version "1.1";
  namespace "http://example.com/test_yang";
  prefix "test_yang";
  description "test yang module";
  revision 2019-01-01 {
    description "test revision";
    reference "ref1";
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_must_1():
    ys = r"""must 'foo' {
  description "bar";
  error-app-tag "baz";
  error-message "bax";
  reference "qux";
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_notification_1():
    ys = r"""notification n1 {
  description "notification 1";
  if-feature baz;
  must 'foo' {
    description "bar";
    error-app-tag "baz";
    error-message "bax";
    reference "qux";
  }
  reference "ref1";
  status current;
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_revision_1():
    ys = r"""revision 2019-01-01 {
  description "test revision";
  reference "ref1";
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_leaf_type_bit():
    ys = r"""leaf foo {
  type bits {
    bit "bar" {
      description "bar";
      if-feature baz;
      position 1;
      reference "qux";
      status current;
    }
    bit "bax" {
      description "bax";
      position 2;
    }
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_leaf_type_decimal_fract():
    ys = r"""leaf foo {
  type decimal {
    fraction-digits 3;
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_leaf_type_enum():
    ys = r"""leaf foo {
  type enumeration {
    enum "bar" {
      description "bar";
      if-feature baz;
      reference "qux";
      status current;
      value 42;
    }
    enum "bax" {
      description "bax";
      value 43;
    }
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_leaf_type_leafref():
    ys = r"""leaf foo {
  type leafref {
    path "/foo/bar";
    require-instance false;
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_leaf_type_string_length():
    ys = r"""leaf foo {
  type string {
    length "1..10";
    pattern "foo.*";
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_leaf_type_uint():
    ys = r"""leaf foo {
  type uint32 {
    range "1..10";
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_rpc_1():
    ys = r"""rpc rpc1 {
  description "rpc 1";
  input {
    leaf rli1 {
      type string;
      description "rpc input leaf 1";
    }
  }
  output {
    leaf rlo1 {
      type string;
      description "rpc output leaf 1";
    }
    leaf rlo2 {
      type string;
      description "rpc output leaf 2";
    }
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_typedef_1():
    ys = r"""typedef t1 {
  default "foo";
  description "t1 desc";
  reference "ref1";
  status current;
  type string;
  units "m/s";
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_prsrc_uses():
    ys = r"""uses g1 {
  description "uses g1";
  if-feature baz;
  reference "ref1";
  status current;
  when 'derived-from-or-self(if:type, "mymod:some-new-iftype")';
  augment "gl2" {
    leaf al1 {
      type string;
    }
  }
  refine "gl2" {
    if-feature "foo";
    description "refined description for gl2";
  }
}"""
    s = yang.schema_from_src(ys)
    return s.prsrc()

def _test_is_config1():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container c1 {
    container c2 {
      leaf l1 {
        type string;
        description "leaf 1";
      }
    }
  }
}"""
    s = yang.schema_from_src(ys)

    testing.assertEqual(s.get("c1").is_config(), True)
    testing.assertEqual(s.get("c1").get("c2").is_config(), True)
    testing.assertEqual(s.get("c1").get("c2").get("l1").is_config(), True)

def _test_is_config2():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container c1 {
    container c2 {
      config false;
      leaf l1 {
        type string;
        description "leaf 1";
      }
    }
  }
}"""
    s = yang.schema_from_src(ys)

    testing.assertEqual(s.get("c1").is_config(), True)
    testing.assertEqual(s.get("c1").get("c2").is_config(), False)
    testing.assertEqual(s.get("c1").get("c2").get("l1").is_config(), False)

def _test_ns():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container c1 {
    container c2 {
      config false;
      leaf l1 {
        type string;
        description "leaf 1";
      }
    }
  }
}"""
    y = yang.parser.parse(ys)
    n = yang.schema.stmt_to_snode(y)
    if isinstance(n, yang.schema.Module):
        testing.assertEqual(n.namespace, "http://example.com/foo")
        testing.assertEqual(n.prefix, "foo")
    else:
        testing.error("Expected Module instance")
    c1 = n.get("c1")
    testing.assertEqual(c1.ns, "http://example.com/foo")

def _test_quote():
    ys = r"""module foo {
  yang-version "1";
  namespace "http://example.com/foo";
  prefix "foo";
  leaf l1 {
    type string {
      // The "\." sequence is not valid in double-quoted strings, "\" must be escaped like "\\"
      pattern "foo\.bar";
    }
  }
}"""
    y = yang.parser.parse(ys, strict_quoting=False)
    return y.prsrc()

def _test_compile_type1():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  typedef domain-name {
    type string {
      length "1..253";
    }
  }
  container c1 {
    leaf l1 {
      type domain-name;
    }
    leaf-list ll1 {
      type domain-name;
    }
  }
}"""
    n = yang.schema.stmt_to_snode(yang.parser.parse(ys))
    ctx = yang.schema.Context([])
    nc = n.compile(ctx)

    l1 = nc.get("c1").get("l1")
    if isinstance(l1, yang.schema.Leaf):
        l1_type = l1.type_
        if isinstance(l1_type, yang.schema.Type):
            testing.assertEqual(l1_type.name, "string")
        else:
            testing.error("Expected Type instance")
    else:
        testing.error("Expected Leaf instance")

    ll1 = nc.get("c1").get("ll1")
    if isinstance(ll1, yang.schema.LeafList):
        ll1_type = ll1.type_
        if isinstance(ll1_type, yang.schema.Type):
            testing.assertEqual(ll1_type.name, "string")
        else:
            testing.error("Expected Type instance")
    else:
        testing.error("Expected LeafList instance")

def _test_compile_type2():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  typedef td1 {
    type string {
      length "1..10";
    }
  }
  typedef td2 {
    type td1 {
      length "1..10";
    }
  }
  container c1 {
    leaf l1 {
      type td2;
    }
    leaf-list ll1 {
      type td2;
    }
  }
}"""
    n = yang.schema.stmt_to_snode(yang.parser.parse(ys))
    ctx = yang.schema.Context([])
    nc = n.compile(ctx)

    l1 = nc.get("c1").get("l1")
    if isinstance(l1, yang.schema.Leaf):
        l1_type = l1.type_
        if isinstance(l1_type, yang.schema.Type):
            testing.assertEqual(l1_type.name, "string")
        else:
            testing.error("Expected Type instance")
    else:
        testing.error("Expected Leaf instance")

    ll1 = nc.get("c1").get("ll1")
    if isinstance(ll1, yang.schema.LeafList):
        ll1_type = ll1.type_
        if isinstance(ll1_type, yang.schema.Type):
            testing.assertEqual(ll1_type.name, "string")
        else:
            testing.error("Expected Type instance")
    else:
        testing.error("Expected LeafList instance")

def _test_compile_type3():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  typedef td1 {
    type string {
      length "1..10";
    }
  }
  typedef td2 {
    type td1 {
      length "1..9";
    }
  }
  container c1 {
    leaf l1 {
      type union {
        type td2;
        type string;
      }
    }
  }
}"""
    n = yang.schema.stmt_to_snode(yang.parser.parse(ys))
    ctx = yang.schema.Context([])
    nc = n.compile(ctx)

    l1 = nc.get("c1").get("l1")
    if isinstance(l1, yang.schema.Leaf):
        l1_type = l1.type_
        if isinstance(l1_type, yang.schema.Type):
            testing.assertEqual(l1_type.name, "union")
            testing.assertEqual(len(l1_type.type_), 2)
            testing.assertEqual(l1_type.type_[0].name, "string")
            testing.assertEqual(l1_type.type_[1].name, "string")
        else:
            testing.error("Expected Type instance")
    else:
        testing.error("Expected Leaf instance")

def _test_compile_type_in_imported_module():
    ys_foo = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  typedef td1 {
    type string {
      length "1..10";
    }
  }
}"""
    ys_bar = r"""module bar {
  yang-version "1.1";
  namespace "http://example.com/bar";
  prefix "bar";
  import foo {
    prefix "f";
  }
  container c1 {
    leaf l1 {
      type f:td1;
    }
  }
}"""
    n_foo = yang.schema.stmt_to_smodule(yang.parser.parse(ys_foo))
    n_bar = yang.schema.stmt_to_smodule(yang.parser.parse(ys_bar))
    ctx = yang.schema.Context([n_foo, n_bar])
    nc_bar = n_bar.compile(ctx)

    l1 = nc_bar.get("c1").get("l1")
    if isinstance(l1, yang.schema.Leaf):
        l1_type = l1.type_
        if isinstance(l1_type, yang.schema.Type):
            testing.assertEqual(l1_type.name, "string")
        else:
            testing.error("Expected Type instance")
    else:
        testing.error("Expected Leaf instance")


def _test_compile_uses():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  grouping g1 {
    container c1 {
      list li1 {
        key l1;
        leaf l1 {
          type string;
          description "leaf 1";
        }
      }
    }
  }
  grouping g2 {
    uses g1;
  }
  uses g2;
}"""
    root = yang.compile([ys])
    testing.assertEqual(root.get("c1").get("li1").get("l1").config, True)
    return root.prdaclass()

def _test_compile_imported_grouping():
    ys_foo = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  grouping g1 {
    container c1 {
      list li1 {
        key l1;
        leaf l1 {
          type string;
          description "leaf 1";
        }
      }
    }
  }
  grouping g2 {
    uses g1;
  }
}"""
    ys_bar = r"""module bar {
  yang-version "1.1";
  namespace "http://example.com/bar";
  prefix "bar";
  import foo {
    prefix "f";
  }
  grouping g1 {
    uses f:g2;
  }
  uses g1;
}"""
    root = yang.compile([ys_foo, ys_bar])

    testing.assertEqual(root.get("c1").get("li1").get("l1").config, True)
    return root.prdaclass()

def _test_compile_augment():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container c1 {
    leaf l1 {
      type string;
      description "leaf 1";
    }
  }
  augment "/c1" {
    leaf l2 {
      type string;
      description "leaf 2";
    }
  }
}"""
    root = yang.compile([ys])

    testing.assertEqual(root.get("c1").get("l1").config, True)
    testing.assertEqual(root.get("c1").get("l2").config, True)
    return root.prdaclass()

def _test_compile_augment_import():
    ys_foo = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container c1 {
    leaf l1 {
      type string;
      description "leaf 1";
    }
  }
}"""
    ys_bar = r"""module bar {
  yang-version "1.1";
  namespace "http://example.com/bar";
  prefix "bar";
  import foo {
    prefix "f";
  }
  augment "/f:c1" {
    leaf l2 {
      type string;
      description "leaf 2";
    }
  }
}"""
    root = yang.compile([ys_foo, ys_bar])

    testing.assertEqual(root.get("c1").get("l1").config, True)
    testing.assertEqual(root.get("c1").get("l2").config, True)
    return root.prdaclass()

def _test_compile_uses_augment():
    """Augmenting a grouping"""
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  grouping g1 {
    container c1 {
      leaf l1 {
        type string;
        description "leaf 1";
      }
    }
  }
  uses g1 {
    augment "c1" {
      some:ext "foo.bar";
      leaf l2 {
        type string;
        description "leaf 2";
      }
    }
  }
}"""
    #n = yang.schema.stmt_to_snode(yang.parser.parse(ys))
    #ctx = yang.schema.Context([])
    #nc = n.compile(ctx)
    #print(nc.prsrc())
    root = yang.compile([ys])

    testing.assertEqual(root.get("c1").get("l1").config, True)
    testing.assertEqual(root.get("c1").get("l2").config, True)
    testing.assertEqual(root.get("c1").exts, [yang.schema.Ext("some", "ext", "foo.bar")])
    return root.prdaclass()

def _test_compile_augment_uses():
    """Augmenting a grouping"""
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  grouping g1 {
    container c2 {
      leaf l1 {
        type string;
        description "leaf 1";
      }
    }
  }
  container c1 {
    description "container 1";
  }
  augment "/c1" {
    some:ext "foo.bar";
    uses g1;
  }
}"""
    n = yang.schema.stmt_to_snode(yang.parser.parse(ys))
    ctx = yang.schema.Context([])
    nc = n.compile(ctx)
    root = yang.compile([ys])

    c1 = nc.get("c1")
    c2 = c1.get("c2")
    l1 = c2.get("l1")
    testing.assertEqual(nc, c1.parent)
    testing.assertEqual(c1, c2.parent)
    testing.assertEqual(c2, l1.parent)
    testing.assertEqual(c1.exts, [yang.schema.Ext("some", "ext", "foo.bar")])
    if isinstance(l1, yang.schema.Leaf):
        testing.assertEqual(l1.description, "leaf 1")
    else:
        testing.error("Expected Leaf instance")
    return root.prdaclass()

def _test_compile_augment_absolute_path_under_uses():
    """Augmenting a grouping"""
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  grouping g1 {
    container c1 {
      leaf l1 {
        type string;
        description "leaf 1";
      }
    }
  }
  uses g1 {
    augment "/c1" {
      leaf l2 {
        type string;
        description "leaf 2";
      }
    }
  }
}"""
    try:
        root = yang.compile([ys])
    except ValueError as exc:
        # We expect an error here, because the augment path is absolute which is
        # not allowed under a uses statement
        return
    testing.error("Expected ValueError")

def _test_compile_augment_relative_path_under_module():
    """Augmenting a grouping"""
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  grouping g1 {
    container c1 {
      leaf l1 {
        type string;
        description "leaf 1";
      }
    }
  }
  augment "c1" {
    leaf l2 {
      type string;
      description "leaf 2";
    }
  }
}"""
    try:
        root = yang.compile([ys])
    except ValueError as exc:
        # We expect an error here, because the augment path is absolute which is
        # not allowed under a uses statement
        return
    testing.error("Expected ValueError")

def _test_compile_augment_implicit_input_output():
    """Augmenting under implicit input/output of action/rpc"""
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";

  container c1 {
    action a1 {
    }
  }

  rpc r1 {
  }

  augment "/c1/a1/input" {
    leaf l1 {
      type string;
    }
  }

  augment "/c1/a1/output" {
    container c2 {
      leaf l2 {
        type string;
      }
    }
  }

  augment "/r1/input" {
    container c3 {
      leaf l3 {
        type string;
      }
    }
  }

  augment "/r1/output" {
    leaf l4 {
        type string;
    }
  }
}"""
    root = yang.compile([ys])
    return root.prdaclass()

def _test_compile_augment_augmented_node():
    """Test augmenting with grouping, then augmenting nodes added by that grouping
    """
    ys_base = r"""module base {
  yang-version 1.1;
  namespace "http://example.com/base";
  prefix base;

  container native {
  }
}"""

    ys_voice = r"""module voice {
  yang-version 1.1;
  namespace "http://example.com/voice";
  prefix voice;

  import base {
    prefix base;
  }

  grouping voice-config-grouping {
    container voice {
      container service {
        container voip {
          leaf enabled {
            type boolean;
            default false;
          }
        }
      }
    }
  }

  // First augment: add voice container using grouping
  augment "/base:native" {
    uses voice-config-grouping;
  }

  // Second augment: augment the voice/service/voip container
  // that was just added by the first augment+grouping
  augment "/base:native/voice/service/voip" {
    container sip {
      leaf bind {
        type string;
      }
      leaf port {
        type uint16;
        default 5060;
      }
    }
  }
}"""

    root = yang.compile([ys_base, ys_voice])
    src = root.prdaclass()
    return src

def _test_compile_refine():
    """Refining a grouping"""
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  grouping g1 {
    container c1 {
      leaf-list l1 {
        type string;
      }
    }
  }
  uses g1 {
    refine "c1/l1" {
        description "refined description";
        default "a";
        default "b";
        some:ext "foo.bar";
    }
  }
}"""
    root = yang.compile([ys])
    l1 = root.get("c1").get("l1")
    if isinstance(l1, yang.schema.DLeafList):
        testing.assertEqual(l1.description, "refined description")
        testing.assertEqual(l1.default, ["a", "b"])
        testing.assertEqual(l1.exts, [yang.schema.Ext("some", "ext", "foo.bar")])
    else:
        testing.error("Expected LeafList instance")
    return root.prdaclass()

def _test_compile_choice():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container c1 {
    choice ch1 {
      case cs1 {
        leaf l1 {
          type string;
          description "leaf 1";
        }
      }
      case cs2 {
        leaf l2 {
          type string;
          description "leaf 2";
        }
      }
    }
  }
}"""
    n = yang.schema.stmt_to_snode(yang.parser.parse(ys))
    ctx = yang.schema.Context([])
    nc = n.compile(ctx)

    c1 = nc.get("c1")
    ch1 = c1.get("ch1")
    cs1 = ch1.get("cs1")
    l1 = cs1.get("l1")
    cs2 = ch1.get("cs2")
    l2 = cs2.get("l2")
    testing.assertEqual(c1.parent, nc)
    testing.assertEqual(ch1.parent, c1)
    testing.assertEqual(cs1.parent, ch1)
    testing.assertEqual(l1.parent, cs1)
    testing.assertEqual(cs2.parent, ch1)
    testing.assertEqual(l2.parent, cs2)


def _test_resolve_type_union_of_string():
    """Test resolution of a union type where all base types are string"""
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";

  typedef ipv4-address {
    type string;
  }
  typedef ipv6-address {
    type string;
  }
  typedef domain-name {
    type string;
  }
  typedef ip-address {
    type union {
      type ipv4-address;
      type ipv6-address;
    }
  }
  typedef host {
    type union {
      type ip-address;
      type domain-name;
    }
  }
  leaf l1 {
    type host;
  }
}
"""
    root = yang.compile([ys])
    l1 = root.get("l1")

    if isinstance(l1, yang.schema.DLeaf):
        acton_type = yang.schema.yang_leaf_to_acton_type(l1)
        testing.assertEqual(acton_type, "?str")
    return root.prdaclass()

def _test_resolve_type_union_of_intX():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";

  leaf l1 {
    type union {
      type int8;
      type int32;
    }
  }

  leaf l2 {
    type union {
      type uint8;
      type uint32;
    }
  }

  leaf l3 {
    type union {
      type uint8;
      type int16;
    }
  }

  leaf l4 {
    type union {
      type uint32;
      type int16;
    }
  }
}
"""
    root = yang.compile([ys])
    l1 = root.get("l1")
    l2 = root.get("l2")
    l3 = root.get("l3")
    l4 = root.get("l4")

    if isinstance(l1, yang.schema.DLeaf):
        acton_type = yang.schema.yang_leaf_to_acton_type(l1)
        # TODO: once we have integer subtyping, expect...
        #testing.assertEqual(acton_type, "?i32")
        testing.assertEqual(acton_type, "?int")

    if isinstance(l2, yang.schema.DLeaf):
        acton_type = yang.schema.yang_leaf_to_acton_type(l2)
        # TODO: once we have integer subtyping, expect...
        #testing.assertEqual(acton_type, "?u32")
        testing.assertEqual(acton_type, "?int")

    if isinstance(l3, yang.schema.DLeaf):
        acton_type = yang.schema.yang_leaf_to_acton_type(l3)
        # TODO: once we have integer subtyping, expect...
        #testing.assertEqual(acton_type, "?i16")
        testing.assertEqual(acton_type, "?int")

    if isinstance(l4, yang.schema.DLeaf):
        acton_type = yang.schema.yang_leaf_to_acton_type(l4)
        # TODO: once we have integer subtyping, expect...
        #testing.assertEqual(acton_type, "?i64")
        testing.assertEqual(acton_type, "?int")
    return root.prdaclass()

def _test_resolve_type_union_of_string_and_int():
    """Test resolution of a union type where one base type is string and the other is int"""
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";

  typedef ipv4-address {
    type string;
  }

  leaf l1 {
    type union {
      type ipv4-address;
      type int32;
    }
    default 42;
  }
}
"""
    root = yang.compile([ys])
    return root.prdaclass()

def _test_prdaclass_union_list_key():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";

  container c1 {
    list l1 {
      key "k1 k2";
      leaf k1 {
type string;
      }
      leaf k2 {
        type union {
          type uint32;
          type enumeration {
            enum "unlimited";
          }
          type string;
        }
      }
      leaf l1 {
        type string;
        mandatory true;
      }
    }
  }
}
"""
    root = yang.compile([ys])
    return root.prdaclass()

def _test_prdaclass_identityref_list_key():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";

  identity id1 {
    description "Identity 1";
  }

  identity id2 {
    description "Identity 2";
    base id1;
  }

  container c1 {
    list l1 {
      key "k1 k2";
      leaf k1 {
        type string;
      }
      leaf k2 {
        type identityref {
          base id1;
        }
      }
    }
  }
}
"""
    root = yang.compile([ys])
    return root.prdaclass()

def _test_compile_bundle1():
    ys_foo = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    revision 2019-01-01 {
        description "test revision";
        reference "ref1";
    }
    typedef td1 {
        type string;
    }
    container c1 {
        leaf l1 {
            type td1;
        }
    }
}"""

    ys_bar = r"""module bar {
    yang-version "1.1";
    namespace "http://example.com/bar";
    prefix "bar";
    revision 2020-01-01 {
        description "bar revision";
        reference "bar1";
    }
    import foo {
        prefix "foo";
    }

    augment "/foo:c1" {
        leaf l2 {
            type foo:td1;
        }
    }
}"""
    # Compile in different order
    root1 = yang.compile([ys_foo, ys_bar])
    root2 = yang.compile([ys_bar, ys_foo])
    src = root1.prdaclass()
    if not len(list(filter(lambda x: "    c1: foo__c1" == x, src.splitlines()))) == 1:
        testing.error("Expected exactly one 'c1: foo__c1'")
    return src

def _test_compile_extension():
    ys = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    revision 2019-01-01 {
        description "test revision";
        reference "ref1";
    }
    container c1 {
        list things {
            key name;

            some:exty foo.bar;

            leaf name {
                type string;
            }
            leaf id {
                type string;
            }
        }
    }
}"""
    s = yang.schema_from_src(ys)
    things_slist = s.get("c1").get("things")
    testing.assertEqual(things_slist.exts, [yang.schema.Ext("some", "exty", "foo.bar")])
    root = yang.compile([ys])
    things_list = root.get("c1").get("things")
    testing.assertEqual(things_list.exts, [yang.schema.Ext("some", "exty", "foo.bar")])
    return root.prdaclass()

def _test_compile_augment_on_augment():
    ys_foo = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    revision 2019-01-01 {
        description "test revision";
        reference "ref1";
    }

    augment "/c1/c2" {
        leaf l3 {
            type string;
        }
    }

    augment "/c1" {
        container c2 {
            leaf l2 {
                type string;
            }
        }
    }

    container c1 {
        leaf l1 {
            type string;
        }
    }
}"""

    root = yang.compile([ys_foo])
    l3 = root.get("c1").get("c2").get("l3")
    testing.assertEqual(l3.config, True)
    return root.prdaclass()

def _test_compile_augment_on_augment_across_modules():
    ys_foo = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    revision 2019-01-01 {
        description "test revision";
        reference "ref1";
    }

    container c1 {
        leaf l1 {
            type string;
        }
    }
}"""

    ys_bar = r"""module bar {
    yang-version "1.1";
    namespace "http://example.com/bar";
    prefix "bar";

    import foo {
        prefix "foo";
    }

    augment "/foo:c1" {
        container c2 {
            leaf l2 {
                type string;
            }
        }
    }
}"""

    ys_baz = r"""module baz {
    yang-version "1.1";
    namespace "http://example.com/baz";
    prefix "baz";

    import foo {
        prefix "foo";
    }

    import bar {
        prefix "bar";
    }

    augment "/foo:c1/bar:c2" {
        leaf l3 {
            type string;
        }
    }
}"""

    # Compile in different order to make sure we sort out the dependencies, we
    # would get some error if we didn't.
    nc_baz = yang.schema.stmt_to_smodule(yang.parser.parse(ys_baz))
    nc_baz_aug = nc_baz.augment[0]
    nc_baz_l3 = nc_baz.augment[0].get("l3")
    print(nc_baz_aug, "namespace: ", nc_baz_aug.ns, nc_baz_aug.parent)
    print(nc_baz_l3, "namespace: ", nc_baz_l3.ns, nc_baz_l3.parent)
    print("---")

    nc_bar = yang.schema.stmt_to_smodule(yang.parser.parse(ys_bar))
    nc_bar_c2 = nc_bar.augment[0].get("c2")
    print("---")

    root = yang.compile([ys_foo, ys_bar, ys_baz])
    root = yang.compile([ys_baz, ys_bar, ys_foo])
    l1 = root.get("c1").get("l1")
    l2 = root.get("c1").get("c2").get("l2")
    l3 = root.get("c1").get("c2").get("l3")
    print(l1.namespace)
    print(l2.namespace)
    print(l3.namespace)
    testing.assertEqual(l1.config, True)
    testing.assertEqual(l2.config, True)
    testing.assertEqual(l3.config, True)
    testing.assertEqual(l1.namespace, "http://example.com/foo")
    testing.assertEqual(l2.namespace, "http://example.com/bar")
    testing.assertEqual(l3.namespace, "http://example.com/baz")
    return root.prdaclass()

def _test_compile_submodules1():
    ys_foo = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    include bar;
    revision 2019-01-01 {
        description "test revision";
        reference "ref1";
    }
    container c1 {
        leaf l1 {
            type string;
        }
    }
}"""

    ys_bar = r"""submodule bar {
    yang-version "1.1";
    belongs-to foo {
        prefix "foo";
    }
    container c2 {
        leaf l2 {
            type string;
        }
    }
}"""
    # Test compilation in different order, should not matter
    root = yang.compile([ys_foo, ys_bar])
    root = yang.compile([ys_bar, ys_foo])
    l1 = root.get("c1").get("l1")
    l2 = root.get("c2").get("l2")
    testing.assertEqual(l1.config, True)
    testing.assertEqual(l2.config, True)
    return root.prdaclass()

def _test_compile_submodule_same_module_different_prefix():
    """Test that submodule imports of same module with different prefix are remapped to parent's prefix"""
    # Module 'shared' that will be imported by both parent and submodule
    ys_shared = r"""module shared {
        yang-version "1.1";
        namespace "http://example.com/shared";
        prefix "shared";

        typedef shared-type {
            type string {
                length "1..100";
            }
        }

        grouping shared-group {
            leaf shared-leaf {
                type string;
                default "from-shared";
            }
        }
    }"""

    # Parent module imports 'shared' with prefix 'sh'
    ys_parent = r"""module parent {
        yang-version "1.1";
        namespace "http://example.com/parent";
        prefix "parent";

        import shared {
            prefix "sh";
        }

        include sub-parent;

        container parent-container {
            leaf parent-leaf {
                type sh:shared-type;
            }
        }
    }"""

    # Submodule imports same 'shared' module with different prefix 'shr'
    ys_sub = r"""submodule sub-parent {
        yang-version "1.1";
        belongs-to parent {
            prefix "p";
        }

        import shared {
            prefix "shr";  // Different prefix for same module as parent!
        }

        container sub-container {
            leaf sub-leaf {
                type shr:shared-type;  // Should be remapped to 'sh:shared-type'
            }
            uses shr:shared-group;  // Should be remapped to 'sh:shared-group'
        }

        augment "/p:parent-container" {
            leaf augmented-leaf {
                type shr:shared-type;  // Should be remapped to 'sh:shared-type'
            }
        }
    }"""

    # Compile all modules together
    root = yang.compile([ys_shared, ys_parent, ys_sub])

    # Verify the parent container exists
    parent_container = root.get("parent-container")
    testing.assertNotNone(parent_container, "parent-container should exist")

    parent_leaf = parent_container.get("parent-leaf")
    testing.assertNotNone(parent_leaf, "parent-leaf should exist")

    # Verify the submodule's container exists
    sub_container = root.get("sub-container")
    testing.assertNotNone(sub_container, "sub-container should exist")

    sub_leaf = sub_container.get("sub-leaf")
    testing.assertNotNone(sub_leaf, "sub-leaf should exist")

    # Verify the augmented leaf exists
    augmented_leaf = parent_container.get("augmented-leaf")
    testing.assertNotNone(augmented_leaf, "augmented-leaf should exist after augment")

    # Verify uses from the shared import works
    shared_leaf = sub_container.get("shared-leaf")
    testing.assertNotNone(shared_leaf, "shared-leaf from uses should exist")

    # Generate and return the Acton data classes to verify it compiles
    return root.prdaclass()

def _test_compile_submodule_different_prefix():
    """Test that submodules can use different prefixes for their parent module"""
    ys_main = r"""module main-module {
    yang-version "1.1";
    namespace "http://example.com/main";
    prefix "main";

    include sub-module;

    grouping main-group {
        container group-container {
            leaf group-leaf {
                type string;
            }
        }
    }

    container main-container {
        leaf main-leaf {
            type string;
        }
        uses sub-group;  // Use grouping from submodule
    }
}"""

    ys_sub = r"""submodule sub-module {
    yang-version "1.1";
    belongs-to main-module {
        prefix "m";  // Different prefix than parent module uses
    }

    grouping sub-group {
        container sub-group-container {
            leaf sub-group-leaf {
                type string;
                default "from-submodule";
            }
        }
    }

    augment "/m:main-container" {
        leaf sub-leaf {
            type string;
            when "../m:main-leaf = 'trigger'";
            must "string-length(.) > 5" {
                description "Sub-leaf must be longer than 5 characters";
            }
        }

        list sub-list {
            key "name";
            unique "m:main-leaf sub-value";

            leaf name {
                type string;
            }

            leaf sub-value {
                type string;
            }

            leaf ref-to-main {
                type leafref {
                    path "/m:main-container/m:main-leaf";
                }
            }
        }

        uses m:main-group {
            when "m:main-leaf = 'use-group'";
            refine "group-container/group-leaf" {
                must "string-length(.) > 3";
                default "refined-default";
            }
            augment "group-container" {
                when "../m:main-leaf";
                leaf augmented-in-group {
                    type string;
                }
            }
        }
    }

    deviation "/m:main-container/m:main-leaf" {
        deviate add {
            default "default-value";
        }
    }
}"""

    # Compile the module with its submodule
    root = yang.compile([ys_main, ys_sub])

    # Verify the augmented structure exists
    main_container = root.get("main-container")
    testing.assertNotNone(main_container, "main-container should exist")

    # Verify augmented leaf exists
    sub_leaf = main_container.get("sub-leaf")
    testing.assertNotNone(sub_leaf, "sub-leaf should exist after augment")

    # Verify the sub-list exists
    sub_list = main_container.get("sub-list")
    testing.assertNotNone(sub_list, "sub-list should exist after augment")

    # Generate and return the Acton data classes to verify it works end-to-end
    return root.prdaclass()

def _test_compile_submodule_conflicting_import_prefix():
    """Test that submodule imports with conflicting prefixes are properly remapped"""
    # Module 'other' that will be imported by the parent module
    ys_other = r"""module other {
        yang-version "1.1";
        namespace "http://example.com/other";
        prefix "other";

        typedef other-type {
            type string {
                length "1..100";
            }
        }
    }"""

    # Module 'another' that will be imported by the submodule with conflicting prefix
    ys_another = r"""module another {
        yang-version "1.1";
        namespace "http://example.com/another";
        prefix "another";

        typedef another-type {
            type string {
                pattern "[a-z]+";
            }
        }

        grouping another-group {
            leaf another-leaf {
                type string;
            }
        }
    }"""

    # Parent module imports 'other' with prefix 'ext'
    ys_parent = r"""module parent {
        yang-version "1.1";
        namespace "http://example.com/parent";
        prefix "parent";

        import other {
            prefix "ext";
        }

        include sub-parent;

        container parent-container {
            leaf parent-leaf {
                type ext:other-type;
            }
        }
    }"""

    # Submodule imports 'another' with same prefix 'ext' (conflict!)
    ys_sub = r"""submodule sub-parent {
        yang-version "1.1";
        belongs-to parent {
            prefix "p";
        }

        import another {
            prefix "ext";  // Same prefix as parent uses for different module!
        }

        container sub-container {
            leaf sub-leaf {
                type ext:another-type;  // Should reference 'another' module after remapping
            }
            uses ext:another-group;  // Should also work after prefix remapping
        }

        augment "/p:parent-container" {
            leaf augmented-leaf {
                type ext:another-type;  // References 'another' via remapped prefix
            }
        }
    }"""

    # Compile all modules together
    root = yang.compile([ys_other, ys_another, ys_parent, ys_sub])

    # Verify the parent container exists and has correct type
    parent_container = root.get("parent-container")
    testing.assertNotNone(parent_container, "parent-container should exist")

    parent_leaf = parent_container.get("parent-leaf")
    testing.assertNotNone(parent_leaf, "parent-leaf should exist")

    # Verify the submodule's container exists
    sub_container = root.get("sub-container")
    testing.assertNotNone(sub_container, "sub-container should exist")

    sub_leaf = sub_container.get("sub-leaf")
    testing.assertNotNone(sub_leaf, "sub-leaf should exist")

    # Verify the augmented leaf exists
    augmented_leaf = parent_container.get("augmented-leaf")
    testing.assertNotNone(augmented_leaf, "augmented-leaf should exist after augment")

    # Verify uses from the remapped import works
    another_leaf = sub_container.get("another-leaf")
    testing.assertNotNone(another_leaf, "another-leaf from uses should exist")

    # Generate and return the Acton data classes to verify it compiles
    return root.prdaclass()

def _test_compile_submodules2():
    ys_foo = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    include bar;
    revision 2019-01-01 {
        description "test revision";
        reference "ref1";
    }
    container c1 {
        leaf l1 {
            type string;
        }
    }
}"""

    ys_bar = r"""submodule bar {
    yang-version "1.1";
    belongs-to foo {
        prefix "foo";
    }
    container c1 {
        leaf l2 {
            type string;
        }
    }
}"""
    try:
        root = yang.compile([ys_foo, ys_bar])
    except ValueError as exc:
        return
    # TODO: This conflict should be detected during compilation
    #testing.error("Expected ValueError")

def _test_compile_import_hyphenated_prefix():
    ys_foo = r"""module acme_foo-bar {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "acme_foo-bar";
  import acme_qux-baz {
    prefix "acme_qux-baz";
  }
  uses acme_qux-baz:g1;
}"""
    ys_qux = r"""module acme_qux-baz {
  yang-version "1.1";
  namespace "http://example.com/qux";
  prefix "acme_qux-baz";
  grouping g1 {
    container c1 {
      leaf l1 {
        type string;
      }
    }
  }
}"""
    root = yang.compile([ys_foo, ys_qux])

    testing.assertEqual(root.get("c1").get("l1").config, True)
    return root.prdaclass()

def _test_prdaclass_req_arg():
    """Required arguments must come before optional arguments

    For list l1 we generate a create() that takes some args, primarily the list
    key but also other args. The default argument ordering is based on the
    lexical ordering. Since the bar container has a mandatory leaf, it is
    mandatory and needs to be a required argument which should all go before the
    optional args that have a default value.
    """
    ys_foo = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    list l1 {
        key name;
        leaf name {
            type string;
        }
        leaf id {
            type string;
        }
        container bar {
            leaf hi {
                type string;
                mandatory true;
            }
        }
    }
}"""
    root = yang.compile([ys_foo])
    src = root.prdaclass(loose=True)
    return src

def _test_prdaclass_loose_p_container_with_mandatory_leaf():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container foo {
    presence "foo presence";
    container bar {
      presence "bar presence";
      leaf l1 {
        type string;
        mandatory true;
      }
    }
  }
}"""
    root = yang.compile([ys])
    bar = root.get("foo")
    src = bar.prdaclass(loose=True, top=False)
    return src

def _test_prdaclass_loose_container_in_container():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container foo {
    container bar {
      leaf l1 {
        type string;
        mandatory true;
      }
    }
  }
}"""
    root = yang.compile([ys])
    bar = root.get("foo")
    src = bar.prdaclass(loose=True, top=False)
    return src

def _test_prdaclass_strict_list_mandatory():
    ys = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    list l1 {
        key name;
        leaf name {
            type string;
        }
        leaf id {
            type string;
            mandatory true;
        }
    }
}"""
    root = yang.compile([ys])
    l1 = root.get("l1")
    src = l1.prdaclass(top=False)
    return src

def _test_prdaclass_strict_p_container_with_mandatory_leaf():
    ys = r"""module foo {
  yang-version "1.1";
  namespace "http://example.com/foo";
  prefix "foo";
  container foo {
    presence "foo presence";
    container bar {
      presence "bar presence";
      leaf l1 {
        type string;
        mandatory true;
      }
    }
  }
}"""

    ys_bar = r"""module bar {
  yang-version "1.1";
  namespace "http://example.com/bar";
  prefix "bar";
  import foo {
    prefix "foo";
  }
  augment "/foo:foo/foo:bar" {
    // conflicts with /foo:foo/foo:bar/foo:l1
    leaf l1 {
      type string;
      mandatory true;
    }
    leaf l2 {
      type string;
      mandatory true;
    }
  }
}"""
    root = yang.compile([ys, ys_bar])
    src = root.prdaclass()
    return src

def _test_prdaclass_strict_list_p_container_with_mandatory_leaf():
    ys = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    list l1 {
        key name;
        leaf name {
            type string;
        }
        container bar {
            presence "bar presence";
            leaf hi {
                type string;
                mandatory true;
            }
        }
    }
}"""
    root = yang.compile([ys])
    l1 = root.get("l1")
    src = l1.prdaclass(top=False)
    return src

def _test_prdaclass_keyword_name_import():
    ys_foo = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    container c1 {
        leaf as {
            type string;
        }
        leaf for {
            type string;
        }
        leaf import {
            type string;
        }
        leaf in {
            type string;
        }
        leaf with {
            type string;
        }
    }
}"""
    root = yang.compile([ys_foo])
    c1 = root.get("c1")
    src = c1.prdaclass(top=False)
    return src

def _test_prdaclass_list_key_mandatory():
    ys = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    list l1 {
        key name;
        leaf name {
            type string;
            mandatory true;
        }
    }
}"""
    root = yang.compile([ys])
    l1 = root.get("l1")
    src = l1.prdaclass(top=False)
    return src

def _test_prdaclass_list_key_reorder():
    ys = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    list l1 {
        key name;
        leaf id {
            type string;
        }
        leaf name {
            type string;
        }
    }
}"""
    root = yang.compile([ys])
    l1 = root.get("l1")
    src = l1.prdaclass(top=False)
    return src

def _test_prdaclass_top_conflict():
    ys_foo = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    container c1 {
        leaf l1 {
            type string;
        }
    }
}"""
    ys_bar = r"""module bar {
    yang-version "1.1";
    namespace "http://example.com/bar";
    prefix "bar";
    container c1 {
        leaf l1 {
            type string;
        }
    }
}"""
    root = yang.compile([ys_foo, ys_bar])
    src = root.prdaclass()
    return src

def _test_prdaclass_augment_name_conflict():
    ys_base = r"""module base {
    yang-version "1.1";
    namespace "http://example.com/base";
    prefix "base";
    container c1 {
    }
}"""

    ys_foo = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    import base {
        prefix "b";
    }
    augment "/b:c1" {
        leaf foo {
            type string;
        }
    }
}"""

    ys_bar = r"""module bar {
    yang-version "1.1";
    namespace "http://example.com/bar";
    prefix "bar";
    import base {
        prefix "b";
    }
    augment "/b:c1" {
        leaf foo {
            type string;
        }
    }
}"""

    root = yang.compile([ys_base, ys_foo, ys_bar])
    c1 = root.get("c1")
    src = c1.prdaclass(top=False)
    return src

def _test_prdaclass_augment_inner_name_conflict():
    ys_base = r"""module base {
    yang-version "1.1";
    namespace "http://example.com/base";
    prefix "base";
    container c1 {
        container c2 {
            leaf foo {
                type string;
            }
        }
    }
}"""

    ys_foo = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    import base {
      prefix "b";
    }
    augment "/b:c1" {
        container c2 {
            leaf foo {
                type string;
            }
        }
    }
}"""

    root = yang.compile([ys_base, ys_foo])
    # c2 = root.get("c2")
    src = root.prdaclass(top=False)
    return src

def _test_prdaclass_augment_inner_list_conflict():
    ys_base = r"""module base {
    yang-version "1.1";
    namespace "http://example.com/base";
    prefix "base";
    container c1 {
        list l1 {
            key k1;
            leaf k1 {
                type string;
            }
        }
    }
}"""

    ys_foo = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    import base {
      prefix "b";
    }
    augment "/b:c1" {
        list l1 {
            key k2;
            leaf k2 {
                type string;
            }
        }
    }
    augment "/b:c1/b:l1" {
        leaf k1 {
            type string;
            mandatory true;
        }
    }
}"""

    root = yang.compile([ys_base, ys_foo])
    src = root.prdaclass(top=False)
    return src

def _test_prdaclass_top_container_from_xml_opt():
    ys_base = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    container c1 {
        leaf l1 {
            type string;
        }
    }
    container pc1 {
        presence "p";
        container foo {
            leaf l1 {
                type string;
            }
        }
    }
}"""
    root = yang.compile([ys_base])
    src = root.prdaclass()
    return src


def _test_leaf_defaults():
    ys_base = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    identity id1;
    container c {
        leaf l_str_def {
            type string;
            default "foo";
        }
        leaf l_boolean_def {
            type boolean;
            default "true";
        }
        leaf l_identityref_def {
            type identityref {
                base id1;
            }
            default id1;
        }
    }
}"""
    root = yang.compile([ys_base])

    l_str_def = root.get("c").get("l_str_def")
    if isinstance(l_str_def, yang.schema.DLeaf):
        testing.assertEqual(l_str_def.default, "foo")
    else:
        testing.error("Expected Leaf instance for l_str_def")

    l_boolean_def = root.get("c").get("l_boolean_def")
    if isinstance(l_boolean_def, yang.schema.DLeaf):
        testing.assertEqual(l_boolean_def.default, "true")
    else:
        testing.error("Expected Leaf instance for l_boolean_def")

    l_identityref_def = root.get("c").get("l_identityref_def")
    if isinstance(l_identityref_def, yang.schema.DLeaf):
        testing.assertEqual(l_identityref_def.default, "id1")
    else:
        testing.error("Expected Leaf instance for l_identityref_def")

def _test_prdaclass_max_elements_unbounded():
    ys_base = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    list li1 {
        key l1;
        leaf l1 {
            type string;
        }
        max-elements unbounded;
    }
    leaf-list ll1 {
        type string;
        max-elements unbounded;
    }
}"""
    root = yang.compile([ys_base])
    src = root.prdaclass()
    return src

def _test_prdaclass_min_elements():
    ys_base = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    list li1 {
        key l1;
        leaf l1 {
            type string;
        }
        min-elements 1;
    }
    leaf-list ll1 {
        type string;
        min-elements 1;
    }
}"""
    root = yang.compile([ys_base])
    src = root.prdaclass()
    return src

def _test_mixed_req_args():
    ys_base = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    container c {
        list li {
            key name;
            leaf name {
                type string;
            }

            leaf foo {
                description "Since this has a default value, it should be an optional object argument";
                type string;
                default "banana";
            }

            container bar {
                leaf man {
                    type string;
                    mandatory true;
                }
            }
        }
    }
}"""
    root = yang.compile([ys_base])

    li = root.get("c").get("li")
    src = li.prdaclass(top=False)
    return src

def _test_prdaclass_dot():
    ys_base = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    container ieee-802.3 {
        leaf ieee-802.3 {
            type string;
        }
    }
}"""
    root = yang.compile([ys_base])
    src = root.prdaclass()
    return src

def _test_prdaclass_rpc():
    ys = r"""module yangrpc {
  yang-version "1.1";
  namespace "http://example.com/yangrpc";
  prefix "yrpc";
  rpc foo {
    input {
      leaf a { type string; }
      container woo {
        leaf woo_b { type int64; }
      }
    }
    output {
      leaf outoo { type string; }
    }
  }
  rpc silent;
}"""
    root = yang.compile([ys])
    src = root.prdaclass()
    return src

def _test_identityref():
    # Base module with base identity and a leaf that references it
    ys_base = r"""module base {
    yang-version "1.1";
    namespace "http://example.com/base";
    prefix "base";

    identity protocol-type {
        description "Base identity for protocol types";
    }

    container config {
        leaf active-protocol {
            type identityref {
                base protocol-type;
            }
            description "Currently active protocol";
        }
    }
}"""

    # First module extending the base identity
    ys_foo = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";
    import base {
        prefix "base";
    }

    identity tcp {
        base base:protocol-type;
        description "TCP protocol";
    }

    identity udp {
        base base:protocol-type;
        description "UDP protocol";
    }
}"""

    # Second module extending the base identity
    ys_bar = r"""module bar {
    yang-version "1.1";
    namespace "http://example.com/bar";
    prefix "bar";
    import base {
        prefix "base";
    }

    identity sctp {
        base base:protocol-type;
        description "SCTP protocol";
    }

    identity dccp {
        base base:protocol-type;
        description "DCCP protocol";
    }
}"""

    # Compile all modules together
    root = yang.compile([ys_base, ys_foo, ys_bar])

    # Get the leaf with identityref type
    config = root.get("config")
    active_protocol = config.get("active-protocol")

    # Verify the leaf has the correct type
    if isinstance(active_protocol, yang.schema.DLeaf):
        leaf_type = active_protocol.type_
        if isinstance(leaf_type, yang.schema.Type):
            testing.assertEqual(leaf_type.name, "identityref")
        else:
            testing.error("Expected Type instance")
    else:
        testing.error("Expected DLeaf instance")

    src = root.prdaclass()
    return src

def _test_fail_identityref_undefined_base():
    """Test that compilation fails when identityref references undefined base identity"""
    ys = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";

    container c1 {
        leaf protocol {
            type identityref {
                base undefined-identity;
            }
            description "Protocol type - references undefined base identity";
        }
    }
}"""
    try:
        root = yang.compile([ys])
    except ValueError as exc:
        testing.assertEqual(exc.error_message, "foo - Compile - Failed: Unable to find identity 'undefined-identity' in module 'foo'")
    else:
        testing.error("Expected ValueError for undefined base identity")

def _test_fail_identity_duplicate():
    """Test that compilation fails when the identity graphs is cyclic"""
    ys = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";

    identity a;
    identity a;
}"""
    try:
        root = yang.compile([ys])
        print(root.prdaclass())
    except ValueError as exc:
        testing.assertEqual(exc.error_message, "Identity foo:a is duplicated")
    else:
        testing.error("Expected ValueError for duplicate identity")

def _test_fail_identity_cyclic():
    """Test that compilation fails when the identity graphs is cyclic"""
    ys = r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "foo";

    identity a {
      base b;
    }

    identity b {
      base a;
    }
}"""
    try:
        root = yang.compile([ys])
        print(root.prdaclass())
    except ValueError as exc:
        testing.assertEqual(exc.error_message, "Cycle detected in identity hierarchy: foo:a -> foo:b -> foo:a")
    else:
        testing.error("Expected ValueError for cycle in identity hierarchy")

def assert_true_with_error(result):
    testing.assertTrue(result.0, result.1)

def _test_is_derived_from():
    # Test the is_derived_from function
    base = yang.schema.DIdentity("example-one", "uri:example:one", "example-one", "base", base=[])
    base_two = yang.schema.DIdentity("example-two", "uri:example:two", "example-two", "base-two", base=[])
    one = yang.schema.DIdentity("example-one", "uri:example:one", "example-one", "one", base=[base])
    two = yang.schema.DIdentity("example-two", "uri:example:two", "example-two", "two", base=[base, base_two])
    unrelated = yang.schema.DIdentity("example-three", "uri:example:three", "example-three", "unrelated", base=[])

    # Test direct base identity
    testing.assertTrue(yang.identity.is_derived_from(base, [base]), "base should be derived from itself")

    # Test derived identity
    testing.assertTrue(yang.identity.is_derived_from(one, [base]), "one should be derived from base")

    # Test multi-base derived identity
    testing.assertTrue(yang.identity.is_derived_from(two, [base]), "two should be derived from base")
    testing.assertTrue(yang.identity.is_derived_from(two, [base_two]), "two should be derived from base_two")
    testing.assertTrue(yang.identity.is_derived_from(two, [base, base_two]), "two should be derived from base or base_two")

    # Test unrelated identity
    testing.assertFalse(yang.identity.is_derived_from(unrelated, [base]), "unrelated should not be derived from base")
    testing.assertFalse(yang.identity.is_derived_from(unrelated, [base_two]), "unrelated should not be derived from base_two")

    # Test transitive derivation
    three = yang.schema.DIdentity("example-one", "uri:example:one", "example-one", "three", base=[one])
    testing.assertTrue(yang.identity.is_derived_from(three, [base]), "three should be transitively derived from base through one")
    testing.assertTrue(yang.identity.is_derived_from(three, [one]), "three should be directly derived from one")

def _test_identity_base_resolution_import_prefix():
    """Test that identity base references using import prefixes are correctly resolved"""
    # Base module with identity using its own prefix
    ys_base = r"""module base-module {
        yang-version "1.1";
        namespace "http://example.com/base";
        prefix "base-pfx";

        identity PROTOCOL {
            description "Base protocol identity";
        }

        identity TCP {
            base PROTOCOL;
            description "TCP protocol";
        }
    }"""

    # Another module that imports base with different prefix
    ys_derived = r"""module derived-module {
        yang-version "1.1";
        namespace "http://example.com/derived";
        prefix "derived";

        import base-module {
            prefix "bm";  // Different prefix than base-module's actual prefix!
        }

        identity HTTP {
            base "bm:TCP";  // Uses import prefix "bm", not actual prefix "base-pfx"
            description "HTTP protocol over TCP";
        }

        identity HTTPS {
            base HTTP;  // Local reference without prefix
            description "Secure HTTP";
        }
    }"""

    root = yang.compile([ys_base, ys_derived])
    src = root.prdaclass()
    return src

def _test_fail_identity_missing_imported_base():
    """Test that compilation fails when identity references a missing base from imported module"""
    ys_base = r"""module base {
    yang-version "1.1";
    namespace "http://example.com/base";
    prefix "base";

    identity interface-type {
        description "Base identity for interface types";
    }
}"""

    ys_derived = r"""module derived {
    yang-version "1.1";
    namespace "http://example.com/derived";
    prefix "derived";
    import base {
        prefix "base";
    }

    identity ethernet {
        base base:network-type;  // References non-existent identity
        description "Ethernet interface type";
    }
}"""

    try:
        root = yang.compile([ys_base, ys_derived])
    except ValueError as exc:
        testing.assertEqual(exc.error_message, "Could not resolve base 'base:network-type' for identity 'derived:ethernet'")
    else:
        testing.error("Expected ValueError for undefined imported base identity")


def _test_augment_with_uses_refine():
    """Test cross-module augment with uses and refine

    This test verifies that refine statements correctly find nodes when:
    1. Module 'augmenter' augments a node in module 'base'
    2. The augment uses a grouping with refine statements
    3. The expanded nodes have 'augmenter' namespace but are added to 'base' tree
    """
    ys_base = r"""module base {
  yang-version 1.1;
  namespace "http://example.com/base";
  prefix base;

  container system-capabilities {
    description "System capabilities";

    list per-node-capabilities {
      description "Per-node capabilities";
    }
  }
}"""

    ys_augmenter = r"""module augmenter {
  yang-version 1.1;
  namespace "http://example.com/augmenter";
  prefix aug;

  import base {
    prefix base;
  }

  grouping subscription-capabilities {
    container subscription-capabilities {
      leaf max-nodes {
        type uint32;
      }
      leaf-list supported-excluded-change-type {
        type string;
      }
    }
  }

  augment "/base:system-capabilities" {
    uses subscription-capabilities {
      refine "subscription-capabilities/supported-excluded-change-type" {
        default "leaf-list default doesn't work right now";
      }
      refine "subscription-capabilities/max-nodes" {
        default 42;
      }
    }
  }
}"""

    root = yang.compile([ys_base, ys_augmenter])
    return root.prdaclass()

netinfra_inter_yang = r"""module netinfra-inter {
  yang-version "1.1";
  namespace "http://example.com/netinfra-inter";
  prefix "netinfra-inter";
  description "Network Infrastructure intermediate";
  revision 2019-01-01 {
    description "test revision";
    reference "ref1";
  }

  typedef mocks {
    type enumeration {
        enum cisco-ios-xr;
        enum juniper-junos;
    }
   }

  grouping backbone-link {
    leaf left-router {
      type string;
    }
    leaf right-router {
      type string;
    }
    uses backbone-link-interface;
  }

  grouping backbone-link-interface {
    leaf left-interface {
      type string;
    }
    leaf right-interface {
      type string;
    }
    grouping foo {
      leaf bar {
        type string;
      }
    }
    uses foo;
  }

  container netinfra {
    description "Network infrastructure";
    list routers {
      key name;

      orchestron:transform respnet.inter.Router;

      leaf name {
        type string;
      }
      leaf id {
        type string;
        description "router id";
      }
      leaf role {
        type string;
      }
      leaf mock {
        type mocks;
      }
    }

    list backbone-link {
      key "left-router left-interface right-router right-interface";

      orchestron:transform respnet.inter.BBLink;

      uses backbone-link;

      container isis {
        presence "isis presence";
        leaf level {
          type enumeration {
            enum level-1;
            enum level-2;
          }
          mandatory true;
        }
      }
    }
    container full-mesh {
      list router {
        key name;

        leaf name {
          type string;
        }
      }
    }
  }
}
"""

def _test_print_tree_simple_dnode():
    dmodules = yang.compile_to_dmodules(yang.compile_modules(yang.parse_modules(yang.parse_statements([test_yang_simple]))))
    res = []
    for dm in dmodules:
        res.append(dm.print_tree())
    return "\n".join(res)

def _test_print_tree_simple_schemanode():
    modules = yang.compile_modules(yang.parse_modules(yang.parse_statements([test_yang_simple])))
    res = []
    for m in modules:
        res.append(m.print_tree())
	return "\n".join(res)

def _test_print_tree_netinfra_inter_dnode():
    dmodules = yang.compile_to_dmodules(yang.compile_modules(yang.parse_modules(yang.parse_statements([netinfra_inter_yang]))))
    res = []
    for dm in dmodules:
        res.append(dm.print_tree())
    return "\n".join(res)

def _test_print_tree_netinfra_inter_schemanode():
	# Use partial compilation (skip type resolution) for intermediate SchemaNode tree inspection
	modules = yang.compile_modules(yang.parse_modules(yang.parse_statements([netinfra_inter_yang])), skip_type_resolution=True)
	res = []
	for m in modules:
		res.append(m.print_tree())
	return "\n".join(res)
