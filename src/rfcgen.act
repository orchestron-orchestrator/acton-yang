import re

import rfc

"""This module generates the source code for the Acton YANG module that in turn
can be used to parse YANG modules and represent YANG schemas as Acton classes
and objects.

This is pretty meta (like meta-meta-meta), since the YANG module can print
source code of itself and the code that prints source code is in turn generated
by the code in this module. Have a decent amount of coffee before attempting to
work on this.
"""

child_stmts = {
    "action",
    "anydata",
    "anyxml",
    "choice",
    "container",
    "identity",
    "leaf",
    "leaf-list",
    "list",
    "notification",
    "rpc",
    "typedef",
    "uses",
}

class Stmt(object):
    name: str
    section: str
    argument_name: ?str
    substmts: dict[str, SubStmt]
    def __init__(self, name: str, section: str, argument_name: ?str):
        self.name = name
        self.section = section
        self.argument_name = argument_name
        self.substmts = {}

    def __str__(self):
        argname = "None"
        argument_name = self.argument_name
        if argument_name is not None:
            argname = argument_name
        return "<Stmt name: %s  section: %s  argument_name: %s  substmts: %s>" % (self.name, self.section, argname, str(self.substmts))

class SubStmt(object):
    name: str
    section: str
    cardinality: str

    def __init__(self, name: str, argument_name: ?str, section: str, cardinality: str):
        self.name = name
        self.argument_name = argument_name
        self.section = section
        self.cardinality = cardinality

    def __str__(self):
        argname = "None"
        return "<SubStmt name: %s  section: %s  argument_name: %s  cardinality: %s>" % (self.name, self.section, argname, self.cardinality)

    def __repr__(self):
        argname = "None"
        return "<SubStmt name: %s  section: %s  argument_name: %s  cardinality: %s>" % (self.name, self.section, argname, self.cardinality)

reserved_names = {
    "Container",
    "Identity",
}

def parse_stmts(rfc_text: str) -> dict[str, Stmt]:
    """
    """
    arg_names = parse_arg_names(rfc_text)
    section = ""
    stmt_name = ""
    tables = {}
    in_table = False
    skip_lines = 1000
    nr = 0
    for line in rfc_text.splitlines():
        nr += 1
        if skip_lines > 0:
            skip_lines -= 1
            continue
        #        +--------------+---------+-------------+
        if in_table:
            m = re.match(r"\+--------------+\+---------\+-------------\+", line)
            if m is not None:
                in_table = False
            else:
                m = re.match(r"\| (\S+) +\| (\S+) +\| (\S+) +\|", line)
                if m is not None:
                    gname = m.group[1]
                    gsection = m.group[2]
                    gcardinality = m.group[3]
                    if gname is not None and gsection is not None and gcardinality is not None:
                        t = SubStmt(name=gname, section=gsection, cardinality=gcardinality)
                        tables[stmt_name].substmts[t.name] = t

        # Match statement chapters to find the start of a statement definition.
        # They look like:
        # 7.1.1.  The module's Substatements
        # 7.1.6.  The "include" Statement
        m = re.match(r"(\d+(\.\d+)+)\.\s+The \"?([a-z-]+)(\"|'s) (Subs|S)tatement", line)
        if m is not None:
            #print("Found statement:", m.group[2], line)
            gsection = m.group[1]
            gstmt_name = m.group[3]
            if gsection is not None and gstmt_name is not None:
                section = gsection
                stmt_name = gstmt_name
        # Find the table of substatements, header looks like:
        #        +--------------+---------+-------------+
        #        | substatement | section | cardinality |
        #        +--------------+---------+-------------+
        m = re.match(r"\| substatement +\| section \| cardinality \|", line)
        if m is not None:
            #print("Found substatement table for", stmt_name)
            in_table = True
            skip_lines = 1
            if stmt_name not in tables:
                arg_name = None
                if stmt_name in arg_names:
                    arg_name = arg_names[stmt_name]
                s = Stmt(name=stmt_name, section=section, argument_name=arg_name)
                if arg_name is not None:
                    s.substmts[arg_name] = SubStmt(name=arg_name, section="", cardinality="1")
                tables[stmt_name] = s
            else:
                print("Warning: duplicate table for", stmt_name, "at line", nr)

    return tables

def parse_arg_names(rfc_text: str) -> dict[str, str]:
    """Parse argument names from RFC
    """
    in_yin = False
    skip_lines = 0
    res = {}
    for line in rfc_text.splitlines():
        if skip_lines > 0:
            skip_lines -= 1
            continue

        if in_yin:
            # Check for end of table
            # +------------------+---------------+-------------+
            m = re.match(r"\+------------------\+---------------\+-------------\+", line)
            if m is not None:
                in_yin = False
                break
            else:
                # Grab table from YIN section that contains the argument name
                # | action           | name          | false       |
                m = re.match(r"\| (\S+) +\| (\S+) +\| (\S+) +\|", line)
                if m is not None:
                    name = m.group[1]
                    arg = m.group[2]
                    if name is not None and arg is not None:
                        res[name] = arg

        # Grab table from YIN section that contains the argument name
        # Match table header
        #             | keyword          | argument name | yin-element |
        m = re.match(r"\| keyword +\| argument name +\| yin-element +\|", line)
        if m is not None:
            in_yin = True
            skip_lines = 1
    return res


def _class_name(name: str):
    res = ""
    i = 0
    while True:
        if i == 0:
            res += name[i].upper()
        elif name[i] == "-":
            i += 1
            res += name[i].upper()
        else:
            res += name[i]
        i += 1
        if i == len(name):
            break
    if res in reserved_names:
        res = res + "_"
    return res

def _attr_name(name: str) -> str:
    res = ""
    i = 0
    while True:
        if name[i] == "-":
            res += "_"
        else:
            res += name[i]
        i += 1
        if i == len(name):
            break
    if res in {"extension", "import", "type"}:
        res = res + "_"

    return res

def _attr_type(name, stmt, stmts) -> str:
    t = "str"
    # If the name is the argument name, it's always a string
    if name == stmt.argument_name:
        return "str"
    cardinality = stmt.substmts[name].cardinality
    if name in stmts:
        t = _class_name(name)
    elif name in {"config", "mandatory", "require-instance"}:
        t = "bool"
    elif name in {"fraction-digits", "length", "position"}:
        t = "int"


    if cardinality in {"0..1", "1"}:
        return "?" + t
    elif cardinality == "0..n":
        return "list[%s]" % t
    return "?str"

def _attr_taker_name(name: str):
    res = ""
    i = 0
    while True:
        if name[i] == "-":
            res += "_"
        else:
            res += name[i]
        i += 1
        if i == len(name):
            break

    return res

def _attr_taker(name, stmt, stmts) -> str:
    cardinality = stmt.substmts[name].cardinality
    t = "str"
    #if name in stmt.substmts:
    if name in stmts:
        t = _attr_taker_name(name)
    elif name in {"config", "mandatory", "require-instance"}:
        t = "bool"
    elif name in {"fraction-digits", "length", "position"}:
        t = "int"

    if cardinality in {"0..1", "1"}:
        if name in stmts:
            return "take_%s(ss)" % t
        return "take_%s(ss, \"%s\")" % (t, name)
    elif cardinality == "0..n":
        if name in stmts:
            return "take_%ss(ss)" % t
        return "take_strlist(ss, \"%s\")" % name
    else:
        raise ValueError("Unknown cardinality: %s" % cardinality)

def _attr_defval(name, stmt, stms) -> str:
    if name == stmt.argument_name:
        return ""
    cardinality = stmt.substmts[name].cardinality
    if cardinality in {"0..1", "1"}:
        return "=None"
    elif cardinality == "0..n":
        return "=[]"
    raise ValueError("Unknown cardinality: %s" % cardinality)

header = """
def _prsrc_attrs(attrs):
    res = []
    for attr in attrs:
        name, value = attr
        if isinstance(value, list):
            if len(value) > 0:
                res.append(name + "=[" + ", ".join(value) + "]")
        else:
            if value is not None:
                res.append(name + "=" + repr(value))
    return res

def _ind(indent):
    return "    " * indent

class SchemaNode(object):
    def prsrc(self, indent=0) -> list[str]:
        raise NotImplementedError("prsrc")

"""

snode_methods = {
    "action": {
        "expand": """    def expand(self):
        new_children = []
        for child in self.children:
            new_children.extend(child.expand())
        new = Action(
            name=self.name,
            description=self.description,
            if_feature=self.if_feature,
            input=self.input,
            output=self.output,
            reference=self.reference,
            status=self.status
        )
        return [new]

""",
    },
    "container": {
        "expand": """    def expand(self):
        new_children = []
        for child in self.children:
            new_children.extend(child.expand())
        new_container = Container_(
            name=self.name,
            config=self.config,
            description=self.description,
            if_feature=self.if_feature,
            must=self.must,
            presence=self.presence,
            reference=self.reference,
            status=self.status,
            when=self.when,
            children=new_children
        )
        return [new_container]

""",
        "is_presence": """    def is_presence(self) -> bool:
        selfpresence = self.presence
        if selfpresence is not None:
            return True
        return False

""",
        "to_dnode": """    def to_dnode(self) -> DContainer:
        new_children = []
        for child in self.children:
            new_children.append(child.to_dnode())
        new_dnode = DContainer(
            name=self.name,
            config=self.is_config(),
            description=self.description,
            if_feature=self.if_feature,
            must=self.must,
            presence=self.is_presence(),
            reference=self.reference,
            status=self.status,
            when=self.when,
            children=new_children
        )
        for child in new_children:
            child.parent = new_dnode
        return new_dnode

"""
    },
    "module": {
        "expand": """    def expand(self):
        new_children = []
        for child in self.children:
            new_children.extend(child.expand())
        new_module = Module(
            name=self.name,
            contact=self.contact,
            description=self.description,
            deviation=self.deviation,
            extension_=self.extension_,
            feature=self.feature,
            import_=self.import_,
            include=self.include,
            namespace=self.namespace,
            organization=self.organization,
            prefix=self.prefix,
            reference=self.reference,
            revision=self.revision,
            yang_version=self.yang_version,
            children=new_children
        )
        return [new_module]

""",
        "get_namespace": """    def get_namespace(self) -> str:
        selfnamespace = self.namespace
        if selfnamespace is not None:
            return selfnamespace
        raise ValueError("Module %s has no namespace" % self.name)

""",
        "get_prefix": """    def get_prefix(self) -> str:
        selfprefix = self.prefix
        if selfprefix is not None:
            return selfprefix
        raise ValueError("Module %s has no prefix" % self.name)

""",
        "to_dnode": """    def to_dnode(self) -> DModule:
        new_children = []
        for child in self.children:
            new_children.append(child.to_dnode())
        new_dnode = DModule(
            name=self.name,
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            description=self.description,
            revision=self.revision,
            reference=self.reference,
            children=new_children
        )
        for child in new_children:
            child.parent = new_dnode
        return new_dnode

"""
    },
    "list": {
        "expand": """    def expand(self):
        new_children = []
        for child in self.children:
            new_children.extend(child.expand())
        new_list = List(
            name=self.name,
            config=self.config,
            description=self.description,
            if_feature=self.if_feature,
            key=self.key,
            max_elements=self.max_elements,
            min_elements=self.min_elements,
            must=self.must,
            reference=self.reference,
            status=self.status,
            when=self.when,
            children=new_children
        )
        return [new_list]

""",
        "keys": """    def keys(self) -> list[str]:
        selfkey = self.key
        if selfkey is not None:
            return selfkey.split(" ")
        return []

""",
        "get_max_elements": """    def get_max_elements(self) -> ?int:
        selfmax_elements = self.max_elements
        if selfmax_elements is not None:
            return int(selfmax_elements)
        return None

""",
        "get_min_elements": """    def get_min_elements(self) -> int:
        selfmin_elements = self.min_elements
        if selfmin_elements is not None:
            return int(selfmin_elements)
        return 0

""",
        "to_dnode": """    def to_dnode(self) -> DList:
        new_children = []
        for child in self.children:
            new_children.append(child.to_dnode())
        new_dnode = DList(
            name=self.name,
            key=self.keys(),
            config=self.is_config(),
            description=self.description,
            if_feature=self.if_feature,
            max_elements=self.get_max_elements(),
            min_elements=self.get_min_elements(),
            must=self.must,
            reference=self.reference,
            status=self.status,
            when=self.when,
            children=new_children
        )
        for child in new_children:
            child.parent = new_dnode
        return new_dnode

""",
    },
    # TODO: resolve leaf type
    "leaf": {
        "expand": """    def expand(self):
        return [self]
""",
        "get_type": """    def get_type(self) -> Type:
        selftype = self.type_
        if selftype is not None:
            return selftype
        raise ValueError("Leaf %s has no type" % self.name)

""",
        "to_dnode": """    def to_dnode(self) -> DLeaf:
        return DLeaf(
            name=self.name,
            config=self.is_config(),
            description=self.description,
            if_feature=self.if_feature,
            must=self.must,
            reference=self.reference,
            status=self.status,
            type_=self.get_type(),
            units=self.units,
            when=self.when
        )

"""
    },
    "leaf-list": {
        "get_type": """    def get_type(self) -> Type:
        selftype = self.type_
        if selftype is not None:
            return selftype
        raise ValueError("Leaf-list %s has no type" % self.name)

""",
        "get_max_elements": """    def get_max_elements(self) -> ?int:
        selfmax_elements = self.max_elements
        if selfmax_elements is not None:
            return int(selfmax_elements)
        return None

""",
        "get_min_elements": """    def get_min_elements(self) -> int:
        selfmin_elements = self.min_elements
        if selfmin_elements is not None:
            return int(selfmin_elements)
        return 0

""",
        "to_dnode": """    def to_dnode(self) -> DLeafList:
        return DLeafList(
            name=self.name,
            config=self.is_config(),
            description=self.description,
            if_feature=self.if_feature,
            max_elements=self.get_max_elements(),
            min_elements=self.get_min_elements(),
            must=self.must,
            reference=self.reference,
            status=self.status,
            type_=self.get_type(),
            units=self.units,
            when=self.when
        )

"""
    },
    "uses": {
        "expand": """    def expand(self):
        grouping = self.get_grouping(self.name)
        return grouping.children

""",
    },

}

def gen(stmts: dict[str, Stmt]) -> list[str]:
    res = ["", ""]
##    for line in header.splitlines():
##        res.append(line)

    need_takers = []

    res.append("def snode_name(sn: SchemaNode) -> str:")
    for stmt_name in sorted(stmts):
        stmt = stmts[stmt_name]
        arg_name = stmt.argument_name
        if arg_name is not None:
            res.append("    if isinstance(sn, %s):" % _class_name(stmt_name))
            res.append("        return sn.%s" % _attr_name(arg_name))
    res.append("    raise ValueError(\"Unknown SchemaNode type in snode_name\")")
    res.append("")

    res.append("def snode_type_name(sn: SchemaNode) -> str:")
    for stmt_name in sorted(stmts):
        stmt = stmts[stmt_name]
        arg_name = stmt.argument_name
        if arg_name is not None:
            res.append("    if isinstance(sn, %s):" % _class_name(stmt_name))
            res.append("        return \"%s\"" % _class_name(stmt_name))
    res.append("    raise ValueError(\"Unknown SchemaNode type in snode_type_name\")")
    res.append("")

    for stmt_name in sorted(stmts):
        stmt = stmts[stmt_name]
        arg_name = stmt.argument_name
        have_children = False
        cattrs = []
        for substmt in stmt.substmts.values():
            if substmt.name in child_stmts:
                have_children = True
            else:
                cattrs.append(substmt.name)
        kwattrs = cattrs if arg_name is None else cattrs[1:]

        parent_class = "SchemaNodeInner" if have_children else "SchemaNodeOuter"
        res.append("class %s(%s):" % (_class_name(stmt_name), parent_class))
        res.append("    \"\"\"YANG %s" % stmt_name)
        res.append("")
        res.append("    https://tools.ietf.org/html/rfc7950#section-%s" % stmt.section)
        res.append("    \"\"\"")

        for attr in cattrs:
            res.append("    %s: %s" % (_attr_name(attr), _attr_type(attr, stmt, stmts)))


        res.append("")
        init_attrs = ["self"]
        if arg_name is not None:
            init_attrs += [_attr_name(arg_name)]
        init_attrs += list(map(lambda x: _attr_name(x) + _attr_defval(x, stmt, stmts), kwattrs))
        if have_children:
            init_attrs.append("children=[]")
        res.append("    def __init__(" + ", ".join(init_attrs) + "):")
        res.append("        self.parent = None")
#        res.append("        self.cname = \"%s\"" % _class_name(stmt_name))
#        res.append("        self.yname = \"%s\"" % stmt_name)
        for attr in cattrs:
            res.append("        self.%s = %s" % (_attr_name(attr), _attr_name(attr)))
        if have_children:
            res.append("        self.children = children")
            res.append("        for child in self.children:")
            res.append("            child.parent = self")
        res.append("")

        # -- prsrc
        res.append("    def prsrc(self, indent=0):")
        res.append('        """Print Acton source of this node"""')
        res.append("        res = []")

        args = []
        res.append("        attrs: list[(str, ?value)] = [")
        for attr in kwattrs:
            res.append("            (\"%s\", self.%s)," % (attr, _attr_name(attr)))
        res.append("        ]")

        if arg_name is not None:
            res.append("        args = [\"'\" + str(self.%s) + \"'\"]" % _attr_name(arg_name))
        else:
            res.append("        args = []")
        res.append("        attrs_text = _prsrc_attrs(indent, attrs)")
        res.append("        if len(attrs_text) > 0:")
        res.append("            args.append(_prsrc_attrs(indent, attrs))")
        if have_children:
            res.append("        if len(self.children) > 0:")
            res.append("            args.append(\"children=[\")")
        res.append("        args_text = \", \".join(args)")
        text_prscr_attrs = "        text_line = _ind(indent) + \"%s(\" + args_text" % (_class_name(stmt_name))
        if not have_children:
            text_prscr_attrs += " + \")\""
        res.append(text_prscr_attrs)
        if have_children:
            res.append("        if len(self.children) == 0:")
            res.append("            text_line += ')'")
        res.append("        res.append(text_line)")
        if have_children:
            res.append("        if len(self.children) > 0:")
            res.append("            child_res = []")
            res.append("            for child in self.children:")
            res.append("                child_res.append(child.prsrc(indent+1))")
            res.append("            res.append(\",\\n\".join(child_res))")
            res.append("            res.append(_ind(indent) + \"])\")")
        res.append("        return \"\\n\".join(res)")
        res.append("")

        # == Statement specific methods ================================
        for method_name in snode_methods.get(stmt_name, {}):
            method = snode_methods[stmt_name][method_name]
            for line in method.splitlines():
                res.append(line)
        # ==============================================================


        res.append("    def _get_argname(self) -> ?str:")
        if arg_name is not None:
            res.append("        return '%s'" % _attr_name(arg_name))
        else:
            res.append("        return None")
        res.append("")

        res.append("    def _get_arg(self) -> ?str:")
        if arg_name is not None:
            res.append("        return self.%s" % _attr_name(arg_name))
        else:
            res.append("        return None")
        res.append("")

    # Generate takers, both singular and plural (i.e. a list)
    for stmt_name in sorted(stmts):
        res.append("def take_%s(stmts: list[Statement]) -> ?%s:" % (_attr_taker_name(stmt_name), _class_name(stmt_name)))
        res.append("    for node in take_nodes(stmts, [\"%s\"]):" % stmt_name)
        res.append("        if isinstance(node, %s):" % _class_name(stmt_name))
        res.append("            return node")
        res.append("")
        res.append("def take_%ss(stmts: list[Statement]) -> list[%s]:" % (_attr_taker_name(stmt_name), _class_name(stmt_name)))
        res.append("    res = []")
        res.append("    for node in take_nodes(stmts, [\"%s\"]):" % stmt_name)
        res.append("        if isinstance(node, %s):" % _class_name(stmt_name))
        res.append("            res.append(node)")
        res.append("    return res")
        res.append("")

    res.append("def stmt_to_snode(stmt: Statement) -> SchemaNode:")
    res.append("    arg = stmt.arg")
    res.append("    ss = stmt.substatements.copy()")
    for stmt_name in sorted(stmts):
        stmt = stmts[stmt_name]
        arg_name = stmt.argument_name
        have_children = False
        cattrs = []
        valid_children = []
        for substmt in stmt.substmts.values():
            if substmt.name in child_stmts:
                have_children = True
                valid_children.append(substmt.name)
            else:
                cattrs.append(substmt.name)
        kwattrs = cattrs if arg_name is None else cattrs[1:]

        res.append("    if stmt.kw == \"%s\":" % stmt_name)

        if arg_name is not None:
            res.append("        if arg is not None:")
        else:
            res.append("        if arg is None:")

        # take attributes
        attrs_takers = []
        if arg_name is not None:
            attrs_takers.append("arg")
        for attr in kwattrs:
            attr_take = ""
            if attr != arg_name:
                attr_take = _attr_name(attr) + "=" + _attr_taker(attr, stmt, stmts)
            attrs_takers.append(attr_take)

        if have_children:
            valid_children_list = ", ".join(map(lambda x: "\"%s\"" % x, valid_children))
            attrs_takers.append("children=take_nodes(ss, [%s])" % valid_children_list)
        indent = " " * (17+len(stmt_name))
        joiner = ",\n" + indent
        res.append("            n = %s(%s\n" % (_class_name(stmt_name), joiner.join(attrs_takers)) + indent + ")")

        res.append("            if len(ss) > 0:")
        res.append("                raise ValueError(\"Invalid statement under %s: \" + ss[0].kw)" % stmt_name)
        res.append("            return n")
    res.append("    raise ValueError(\"Unknown statement:\" + stmt.kw)")

    return res


# LOL, RFC7950 is missing a table definitions for the substatements of refine,
# so here's our very own bis! =)
rfc7950bis = """
7.13.999.  The refine's Substatements
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | config       | 7.21.1  | 0..1        |
                 | default      | 7.6.4   | 0..1        |
                 | description  | 7.21.3  | 0..1        |
                 | if-feature   | 7.20.2  | 0..n        |
                 | mandatory    | 7.6.5   | 0..1        |
                 | max-elements | 7.7.6   | 0..1        |
                 | min-elements | 7.7.5   | 0..1        |
                 | must         | 7.5.3   | 0..n        |
                 | presence     | 7.5.5   | 0..1        |
                 | reference    | 7.21.4  | 0..1        |
                 +--------------+---------+-------------+
"""

actor main(env):
    y = gen(parse_stmts(rfc.rfc7950 + rfc7950bis))
    print("\n".join(y))
    env.exit(0)
