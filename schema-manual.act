# schema-manual.act is the manually defined part of the schema.act where the
# bottom half of the file is generated by reading the RFC
#
# YANG schema
#
# This is an object model for YANG schema, based on YANG 1.1 although it should
# mostly work for YANG 1.0 just fine. There is no logic for either schema or
# data validation, so it is possible to represent an invalid schema using this
# model.
#
# There are two levels of object representation. The first level is that of
# statements and is represented by the Statement class. Everything in a YANG
# model is pretty much a statement, so this is a representation fairly close to
# the YANG source code. For example, the order of all statements is preserved,
# so this model:
#
#    module foo {
#      prefix "f";
#      namespace "http://example.com/foo";
#    }
#
# Would become:
#
#   Statement("module", "foo", substatements=[
#     Statement("prefix", "f"),
#     Statement("namespace", "http://example.com/foo")
#   ])
#
# Whitespace, indentation and comments are not preserved but all parsed
# statements are. Thus if the Statements are rendered back to YANG source, it
# would look exactly like the original source code, presuming the use of
# canonical YANG formatting.
#
# The second level is that of schema nodes and is represented by the SchemaNode
# class. The SchemaNode class is a base class for all schema node types, such as
# Module, Container, List, Leaf, etc. Different statements are modeled using
# discrete classes and statements that relate to a particular statement are
# attributes of that object class rather than being seen as just a tree of
# statements. For example, the following model:
#
#    module foo {
#      prefix "f";
#      namespace "http://example.com/foo";
#      container c1 {
#        leaf l1 {
#          type string;
#        }
#      }
#    }
#
# Would become:
#
#   Module("foo", namespace="http://example.com/foo", prefix="f", children=[
#     Container("c1", children=[
#       Leaf("l1", type="string")
#     ])
#   ])
#
# Rendering that back to YANG source code will render the namespace & prefix
# statements in the canonical order specified by the YANG RFC, thus rendering
# the following:
#
#    module foo {
#      prefix "f";
#      namespace "http://example.com/foo";
#      container c1 {
#        leaf l1 {
#          type string;
#        }
#      }
#    }
#
# This higher layer SchemaNode representation is not suitable if it is desirable
# to keep statement order from the original source document (be aware that even
# with the lower leve Statement representation, whitespace & comments are still
# lost).

def _yind(n):
    return "  " * n

def _ind(n):
    return "    " * n

_quoted_arg_keywords = set([
    "argument",
    "augment",
    "contact",
    "description",
    "if-feature",
    "namespace",
    "organization",
    "prefix",
    "reference",
    "refine",
    "yang-version",
])

class Statement(object):
    kw: str
    arg: ?str
    prefix: ?str
    substatements: list[Statement]
    def __init__(self, kw: str, arg: ?str=None, prefix: ?str=None):
        self.kw = kw
        self.arg = arg
        self.prefix = prefix
        self.substatements = []

    def get_subarg(self, kw: str) -> ?str:
        for substatement in self.substatements:
            if substatement.kw == kw:
                return substatement.arg

    def get_subarg_bool(self, kw: str) -> ?bool:
        for substatement in self.substatements:
            if substatement.kw == kw:
                arg = substatement.arg
                if arg is not None:
                    return bool(arg)

    def pryang(self, indent=0):
        """Print YANG source code for this statement and its substatements
        """
        res = _yind(indent) + self.kw
        arg = self.arg
        if arg is not None:
            quoted_arg = True if self.kw in _quoted_arg_keywords else False
            res += " "
            if quoted_arg:
                res += '"'
            res += arg
            if quoted_arg:
                res += '"'
        if len(self.substatements) == 0:
            res += ";\n"
        else:
            res += " {\n"
            for substatement in self.substatements:
                res += substatement.pryang(indent+1)
            res += _yind(indent) + "}\n"
        return res


class SchemaNode(object):

    def prsrc(self, indent=0) -> str:
        """Print Acton source code for this schema node and its subnodes
        """
        raise NotImplementedError('SchemaNode')

    def print_data_classes(self):
        """Print the data class for this schema node
        """
        raise NotImplementedError('SchemaNode pdc')

def take_bool(stmts: list[Statement], kw: str) -> ?bool:
    v = take_str(stmts, kw)
    if v is not None:
        if v == "true":
            return True
        elif v == "false":
            return False

def take_int(stmts: list[Statement], kw: str) -> ?int:
    v = take_str(stmts, kw)
    if v is not None:
        return int(v)

def take_str(stmts: list[Statement], kw: str) -> ?str:
    for i in range(len(stmts)):
        if stmts[i].kw == kw:
            arg = stmts[i].arg
            if arg is not None:
                del stmts[i]
                return arg

def take_strlist(stmts: list[Statement], kw: str) -> list[str]:
    res = []
    todel = []
    for i in range(len(stmts)):
        if stmts[i].kw == kw:
            arg = stmts[i].arg
            if arg is not None:
                todel.append(i)
                res.append(arg)
    for d in reversed(todel):
        del stmts[d]
    return res

def take_node(stmts: list[Statement], kw: str) -> ?SchemaNode:
    for i in range(len(stmts)):
        if stmts[i].kw == kw:
            n = stmt_to_snode(stmts[i])
            del stmts[i]
            return n

def take_nodes(stmts: list[Statement], kw: list[str]) -> list[SchemaNode]:
    res = []
    todel = []
    for i in range(len(stmts)):
        if stmts[i].kw in kw:
            res.append(stmt_to_snode(stmts[i]))
            todel.append(i)
    for i in reversed(todel):
        del stmts[i]
    return res

def _attr_name(name: str):
    res = ""
    i = 0
    while True:
        if name[i] == "-":
            res += "_"
        else:
            res += name[i]
        i += 1
        if i == len(name):
            break
    if res in {"extension", "import", "type"}:
        res = res + "_"

    return res

def _prsrc_attrs(indent, attrs):
    """Print source code for a list of SchemaNode attributes"""
    res = []
    for attr in attrs:
        raw_name, value = attr
        name = _attr_name(raw_name)
        if value is not None:
            if isinstance(value, list):
                if len(value) == 0:
                    continue
                else:
                    list_val = []
                    content_is_snode = False
                    for e in value:
                        if isinstance(e, SchemaNode):
                            list_val.append(e.prsrc(indent+2))
                        else:
                            list_val.append(repr(e))
                    list_val_str = "[]"
                    if len(list_val) == 1 and list_val[0][0] != " " and len(list_val[0]) < 20:
                        list_val_str = "[" + list_val[0] + "]"
                    else:
                        list_val_str = "[\n" + ",\n".join(list_val) + "\n" + _ind(indent + 1) + "]"
                    res.append(name + "=" + list_val_str)
            elif isinstance(value, SchemaNode):
                res.append(name + "=" + value.prsrc(0))
            else:
                res.append(name + "=" + repr(value))
    return ", ".join(res)

# -- end of manually defined schema functions, automatically generated code follows
