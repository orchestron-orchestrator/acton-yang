# schema-manual.act is the manually defined part of the schema.act where the
# bottom half of the file is generated by reading the RFC
#
# YANG schema
#
# This is an object model for YANG schema, based on YANG 1.1 although it should
# mostly work for YANG 1.0 just fine. There is no logic for either schema or
# data validation, so it is possible to represent an invalid schema using this
# model.
#
# There are two levels of object representation. The first level is that of
# statements and is represented by the Statement class. Everything in a YANG
# model is pretty much a statement, so this is a representation fairly close to
# the YANG source code. For example, the order of all statements is preserved,
# so this model:
#
#    module foo {
#      prefix "f";
#      namespace "http://example.com/foo";
#    }
#
# Would become:
#
#   Statement("module", "foo", substatements=[
#     Statement("prefix", "f"),
#     Statement("namespace", "http://example.com/foo")
#   ])
#
# Whitespace, indentation and comments are not preserved but all parsed
# statements are. Thus if the Statements are rendered back to YANG source, it
# would look exactly like the original source code, presuming the use of
# canonical YANG formatting.
#
# The second level is that of schema nodes and is represented by the SchemaNode
# class. The SchemaNode class is a base class for all schema node types, such as
# Module, Container, List, Leaf, etc. Different statements are modeled using
# discrete classes and statements that relate to a particular statement are
# attributes of that object class rather than being seen as just a tree of
# statements. For example, the following model:
#
#    module foo {
#      prefix "f";
#      namespace "http://example.com/foo";
#      container c1 {
#        leaf l1 {
#          type string;
#        }
#      }
#    }
#
# Would become:
#
#   Module("foo", namespace="http://example.com/foo", prefix="f", children=[
#     Container("c1", children=[
#       Leaf("l1", type="string")
#     ])
#   ])
#
# Rendering that back to YANG source code will render the namespace & prefix
# statements in the canonical order specified by the YANG RFC, thus rendering
# the following:
#
#    module foo {
#      prefix "f";
#      namespace "http://example.com/foo";
#      container c1 {
#        leaf l1 {
#          type string;
#        }
#      }
#    }
#
# This higher layer SchemaNode representation is not suitable if it is desirable
# to keep statement order from the original source document (be aware that even
# with the lower leve Statement representation, whitespace & comments are still
# lost).

def _yind(n):
    return "  " * n

def _ind(n):
    return "    " * n

_quoted_arg_keywords = set([
    "argument",
    "augment",
    "contact",
    "description",
    "if-feature",
    "namespace",
    "organization",
    "prefix",
    "reference",
    "refine",
    "yang-version",
])

class Statement(object):
    kw: str
    arg: ?str
    prefix: ?str
    substatements: list[Statement]
    def __init__(self, kw: str, arg: ?str=None, prefix: ?str=None):
        self.kw = kw
        self.arg = arg
        self.prefix = prefix
        self.substatements = []

    def get_subarg(self, kw: str) -> ?str:
        for substatement in self.substatements:
            if substatement.kw == kw:
                return substatement.arg

    def get_subarg_bool(self, kw: str) -> ?bool:
        for substatement in self.substatements:
            if substatement.kw == kw:
                arg = substatement.arg
                if arg is not None:
                    return bool(arg)

    def pryang(self, indent=0):
        """Print YANG source code for this statement and its substatements
        """
        res = _yind(indent) + self.kw
        arg = self.arg
        if arg is not None:
            quoted_arg = True if self.kw in _quoted_arg_keywords else False
            res += " "
            if quoted_arg:
                res += '"'
            res += arg
            if quoted_arg:
                res += '"'
        if len(self.substatements) == 0:
            res += ";\n"
        else:
            res += " {\n"
            for substatement in self.substatements:
                res += substatement.pryang(indent+1)
            res += _yind(indent) + "}\n"
        return res


class SchemaNode(object):
    parent: ?SchemaNode

    def _get_argname(self) -> ?str:
        raise NotImplementedError('SchemaNode')

    def _get_arg(self) -> ?str:
        raise NotImplementedError('SchemaNode')

    def _get_data_name(self) -> str:
        raise NotImplementedError('SchemaNode')

    def prsrc(self, indent=0) -> str:
        """Print Acton source code for this schema node and its subnodes
        """
        raise NotImplementedError('SchemaNode')

    def prdaclass(self) -> str:
        """Print the data class for this schema node
        """
        raise NotImplementedError('SchemaNode pdc')

class SchemaNodeInner(SchemaNode):
    children: list[SchemaNode]

    def prdaclass(self) -> str:
        """Print the data class for this schema node
        """
        stmt_arg = self._get_arg()
        res = []
        for child in self.children:
            if isinstance(child, SchemaNodeInner):
                res.append(child.prdaclass())

        self_list_keys = set() # if we are a list, this is populated
        if isinstance(self, List):
            selfkey = self.key
            if selfkey is not None:
                for k in selfkey.split(" "):
                    self_list_keys.add(k)

        attrs: list[(name: str, inner: bool, type: str, optional: bool, constructor: str, data_class: str)] = []
        for child in self.children:
            if isinstance(child, Container_):
                if child.is_presence():
                    attrs.append((child.name, True, "?" + _get_full_name(child), True, _get_full_name(child), "Container_"))
                else:
                    attrs.append((child.name, True, _get_full_name(child), False, _get_full_name(child), "Container_"))
            elif isinstance(child, Leaf):
                optional = True
                childmandatory = child.mandatory
                if childmandatory is not None:
                    optional = childmandatory
                if child.name in self_list_keys:
                    optional = False
                optional_str = "?" if optional else ""
                attrs.append((child.name, False, optional_str + yang_type_to_acton_type(child.type_), optional, "", "Leaf"))
            elif isinstance(child, LeafList):
                attrs.append((child.name, False, "list[" + yang_type_to_acton_type(child.type_) + "]", False, "", "LeafList"))
            elif isinstance(child, List):
                attrs.append((child.name, True, _get_full_name(child), False, _get_full_name(child), "List"))
            else:
                raise ValueError("unreachable child type: " + str(type(child)))

        if isinstance(self, List):
            # List has special handling as it actually results in two classes:
            # - the list itself
            # - the list entry class
            # Here we create the list entry class, the list itself comes later
            res.append("class %s_entry(yang.adata.MNode):" % _get_full_name(self))
        else:
            res.append("class %s(yang.adata.MNode):" % _get_full_name(self))
        for attr in attrs:
            res.append("    %s: %s" % (attr.name, attr.type))
        res.append("")
        init_args = ["self"]
        for attr in attrs:
            if attr.name in self_list_keys:
                init_args.append("%s: %s" % (attr.name, attr.type))
            else:
                if attr.optional:
                    init_args.append("%s: %s=None" % (attr.name, attr.type))
                else:
                    init_args.append("%s: ?%s" % (attr.name, attr.type))
        init_args.append("children=[]")
        init_args_str = ", ".join(init_args)
        res.append("    def __init__(%s):" % init_args_str)
        if stmt_arg is not None:
            res.append("        self._name = " + repr(stmt_arg))
        else:
            if isinstance(self, Input):
                res.append("        self._name = 'input'")
            elif isinstance(self, Output):
                res.append("        self._name = 'output'")
            else:
                raise ValueError("unreachable")
#        for attr in attrs:
#            res.append("        self.%s = %s" % (attr.name, attr.name))
#
        for child in self.children:
            if isinstance(child, Container_):
                res.append("        if %s is not None:" % (child.name))
                res.append("            self.%s = %s" % (child.name, child.name))
                res.append("        else:")
                res.append("            self.%s = %s()" % (child.name, _get_full_name(child)))
            elif isinstance(child, Leaf):
                res.append("        self.%s = %s" % (child.name, child.name))
            elif isinstance(child, List):
                res.append("        if %s is not None:" % (child.name))
                res.append("            self.%s = %s" % (child.name, child.name))
                res.append("        else:")
                res.append("            self.%s = %s()" % (child.name, _get_full_name(child)))
        res.append("")
        res.append("    def to_gdata(self):")
        if stmt_arg is not None: # stmt_arg is the name of the statement
            if isinstance(self, List):
                selfkey = self.key
                if selfkey is not None:
                    list_keys = selfkey.split(" ")
                    # keys contains a yang spec of the keys, like "k1 k2"
                    # which are modeled as attributes of the list entry class and accessed via self.k1, self.k2
                    list_keys_list = []
                    for k in list_keys:
                        list_keys_list.append("self." + k)
                    list_keys_str = ", ".join(list_keys_list)
                    res.append("        res = yang.data.ListElement([%s])" % (list_keys_str))
                else:
                    raise ValueError("List without key not supported")
            else:
                res.append("        res = yang.data.%s('%s')" % (snode_type_name(self), stmt_arg))
        else: # the only inner schema nodes without stmt_arg are Input and Output
            res.append("        res = yang.data.%s()" % snode_type_name(self))
        for attr in attrs:
            res.append("        _%s = self.%s" % (attr.name, attr.name))
        for attr in attrs:
            res.append("        if _%s is not None:" % attr.name)
            if attr.inner:
                res.append("            res.children['%s'] = _%s.to_gdata()" % (attr.name, attr.name))
            else:
                res.append("            res.children['%s'] = yang.data.%s('%s', _%s)" % (attr.name, attr.data_class, attr.name, attr.name))
        res.append("        return res")
        res.append("")
        for child in self.children:
            if isinstance(child, Container_) and child.is_presence():
                res.append("    def create_%s(self):" % (child.name))
                res.append("        _%s = %s()" % (child.name, _get_full_name(child)))
                res.append("        self.%s = _%s" % (child.name, child.name))
                res.append("        return _%s" % (child.name))
                res.append("")
        res.append("")

        if isinstance(self, List):
            list_keys = []
            list_keys_str = ""

            selfkey = self.key
            if selfkey is not None:
                list_keys = selfkey.split(" ")
                # keys contains a yang spec of the keys, like "k1 k2"
                # which are modeled as attributes of the list entry class and accessed via self.k1, self.k2
                list_keys_str = repr(selfkey)

            # List has special handling as it actually results in two classes:
            # - the list itself
            # - the list entry class
            # Here we create the list entry class, the list itself comes later
            res.append("class %s(yang.adata.MNode):" % _get_full_name(self))
            res.append("    elements: list[%s_entry]" % _get_full_name(self))

            init_args = ["self"]
            init_args.append("elements=[]")
            init_args_str: str = ", ".join(init_args)
            res.append("    def __init__(%s):" % init_args_str)
            if stmt_arg is not None:
                res.append("        self._name = " + repr(stmt_arg))
            res.append("")
            res.append("        self.elements = []")
            res.append("")

            list_create_args = ["self"] + list_keys
            res.append("    def create(%s):" % (", ".join(list_create_args)))
            res.append("        res = %s_entry(%s)" % (_get_full_name(self), ", ".join(list_keys)))
            res.append("        self.elements.append(res)")
            res.append("        return res")
            res.append("")

            res.append("    def to_gdata(self):" % ())
            res.append("        res = yang.data.List('%s', [%s])" % (stmt_arg if stmt_arg is not None else "", list_keys_str))
            res.append("        for e in self.elements:")
            res.append("            e_gdata = e.to_gdata()")
            res.append("            if isinstance(e_gdata, yang.data.ListElement):")
            res.append("                res.elements.append(e_gdata)")
            res.append("        return res")
            res.append("")
        res.append("")

        return "\n".join(res)

class SchemaNodeOuter(SchemaNode):
    pass


def take_bool(stmts: list[Statement], kw: str) -> ?bool:
    v = take_str(stmts, kw)
    if v is not None:
        if v == "true":
            return True
        elif v == "false":
            return False

def take_int(stmts: list[Statement], kw: str) -> ?int:
    v = take_str(stmts, kw)
    if v is not None:
        return int(v)

def take_str(stmts: list[Statement], kw: str) -> ?str:
    for i in range(len(stmts)):
        if stmts[i].kw == kw:
            arg = stmts[i].arg
            if arg is not None:
                del stmts[i]
                return arg

def take_strlist(stmts: list[Statement], kw: str) -> list[str]:
    res = []
    todel = []
    for i in range(len(stmts)):
        if stmts[i].kw == kw:
            arg = stmts[i].arg
            if arg is not None:
                todel.append(i)
                res.append(arg)
    for d in reversed(todel):
        del stmts[d]
    return res

def take_node(stmts: list[Statement], kw: str) -> ?SchemaNode:
    for i in range(len(stmts)):
        if stmts[i].kw == kw:
            n = stmt_to_snode(stmts[i])
            del stmts[i]
            return n

def take_nodes(stmts: list[Statement], kw: list[str]) -> list[SchemaNode]:
    res = []
    todel = []
    for i in range(len(stmts)):
        if stmts[i].kw in kw:
            res.append(stmt_to_snode(stmts[i]))
            todel.append(i)
    for i in reversed(todel):
        del stmts[i]
    return res

def _attr_name(name: str):
    res = ""
    i = 0
    while True:
        if name[i] == "-":
            res += "_"
        else:
            res += name[i]
        i += 1
        if i == len(name):
            break
    if res in {"extension", "import", "type"}:
        res = res + "_"

    return res

def _prsrc_attrs(indent, attrs):
    """Print source code for a list of SchemaNode attributes"""
    res = []
    for attr in attrs:
        raw_name, value = attr
        name = _attr_name(raw_name)
        if value is not None:
            if isinstance(value, list):
                if len(value) == 0:
                    continue
                else:
                    list_val = []
                    content_is_snode = False
                    for e in value:
                        if isinstance(e, SchemaNode):
                            list_val.append(e.prsrc(indent+2))
                        else:
                            list_val.append(repr(e))
                    list_val_str = "[]"
                    if len(list_val) == 1 and list_val[0][0] != " " and len(list_val[0]) < 20:
                        list_val_str = "[" + list_val[0] + "]"
                    else:
                        list_val_str = "[\n" + ",\n".join(list_val) + "\n" + _ind(indent + 1) + "]"
                    res.append(name + "=" + list_val_str)
            elif isinstance(value, SchemaNode):
                res.append(name + "=" + value.prsrc(0))
            else:
                res.append(name + "=" + repr(value))
    return ", ".join(res)

def yang_type_to_acton_type(t: ?Type) -> str:
    # +---------------------+-------------------------------------+
    # | Name                | Description                         |
    # +---------------------+-------------------------------------+
    # | binary              | Any binary data                     |
    # | bits                | A set of bits or flags              |
    # | boolean             | "true" or "false"                   |
    # | decimal64           | 64-bit signed decimal number        |
    # | empty               | A leaf that does not have any value |
    # | enumeration         | One of an enumerated set of strings |
    # | identityref         | A reference to an abstract identity |
    # | instance-identifier | A reference to a data tree node     |
    # | int8                | 8-bit signed integer                |
    # | int16               | 16-bit signed integer               |
    # | int32               | 32-bit signed integer               |
    # | int64               | 64-bit signed integer               |
    # | leafref             | A reference to a leaf instance      |
    # | string              | A character string                  |
    # | uint8               | 8-bit unsigned integer              |
    # | uint16              | 16-bit unsigned integer             |
    # | uint32              | 32-bit unsigned integer             |
    # | uint64              | 64-bit unsigned integer             |
    # | union               | Choice of member types              |
    # +---------------------+-------------------------------------+
    if t is not None:
        if t.name == "binary":
            return "bytes"
        elif t.name == "bits":
            raise NotImplementedError('bits not supported')
        elif t.name == "boolean":
            return "bool"
        elif t.name == "decimal64":
            # TODO: do something better
            return "float"
        elif t.name == "empty":
            # TODO: is this right?
            return "bool"
        elif t.name == "enumeration":
            raise NotImplementedError('enumeration not supported')
        elif t.name == "identityref":
            raise NotImplementedError('identityref not supported')
        elif t.name == "instance-identifier":
            raise NotImplementedError('instance-identifier not supported')
        elif t.name == "int8":
            return "i8"
        elif t.name == "int16":
            return "i16"
        elif t.name == "int32":
            return "i32"
        elif t.name == "int64":
            return "i64"
        elif t.name == "leafref":
            return "str"
        elif t.name == "string":
            return "str"
        elif t.name == "uint8":
            return "u8"
        elif t.name == "uint16":
            return "u16"
        elif t.name == "uint32":
            return "u32"
        elif t.name == "uint64":
            return "u64"
        elif t.name == "union":
            # TODO: blargh, implement once we have unions in Acton
            raise NotImplementedError('union not supported')
        else:
            # TODO: resolve type -> typedefs -> basetype
            raise ValueError("Unknown YANG type: " + t.name)
    raise ValueError("type not defined")


def _get_full_name(snode: SchemaNode) -> str:
    """
    """
    path = []
    while True:
        path.append(snode_name(snode))
        parent = snode.parent
        if parent is not None:
            snode = parent
        else:
            break
    return "y_" + "__".join(reversed(path))

# -- end of manually defined schema functions, automatically generated code follows
