# schema-manual.act is the manually defined part of the schema.act where the
# bottom half of the file is generated by reading the RFC
#
# YANG schema
#
# This is an object model for YANG schema, based on YANG 1.1 although it should
# mostly work for YANG 1.0 just fine. There is no logic for either schema or
# data validation, so it is possible to represent an invalid schema using this
# model.
#
# There are two levels of object representation. The first level is that of
# statements and is represented by the Statement class. Everything in a YANG
# model is pretty much a statement, so this is a representation fairly close to
# the YANG source code. For example, the order of all statements is preserved,
# so this model:
#
#    module foo {
#      prefix "f";
#      namespace "http://example.com/foo";
#    }
#
# Would become:
#
#   Statement("module", "foo", substatements=[
#     Statement("prefix", "f"),
#     Statement("namespace", "http://example.com/foo")
#   ])
#
# Whitespace, indentation and comments are not preserved but all parsed
# statements are. Thus if the Statements are rendered back to YANG source, it
# would look exactly like the original source code, presuming the use of
# canonical YANG formatting.
#
# The second level is that of schema nodes and is represented by the SchemaNode
# class. The SchemaNode class is a base class for all schema node types, such as
# Module, Container, List, Leaf, etc. Different statements are modeled using
# discrete classes and statements that relate to a particular statement are
# attributes of that object class rather than being seen as just a tree of
# statements. For example, the following model:
#
#    module foo {
#      prefix "f";
#      namespace "http://example.com/foo";
#      container c1 {
#        leaf l1 {
#          type string;
#        }
#      }
#    }
#
# Would become:
#
#   Module("foo", namespace="http://example.com/foo", prefix="f", children=[
#     Container("c1", children=[
#       Leaf("l1", type_="string")
#     ])
#   ])
#
# Rendering that back to YANG source code will render the namespace & prefix
# statements in the canonical order specified by the YANG RFC, thus rendering
# the following:
#
#    module foo {
#      prefix "f";
#      namespace "http://example.com/foo";
#      container c1 {
#        leaf l1 {
#          type string;
#        }
#      }
#    }
#
# This higher layer SchemaNode representation is not suitable if it is desirable
# to keep statement order from the original source document (be aware that even
# with the lower leve Statement representation, whitespace & comments are still
# lost).

def _yind(n):
    return "  " * n

def _ind(n):
    return "    " * n

_quoted_arg_keywords = set([
    "argument",
    "augment",
    "contact",
    "description",
    "if-feature",
    "namespace",
    "organization",
    "prefix",
    "reference",
    "refine",
    "yang-version",
])

class Statement(object):
    kw: str
    arg: ?str
    prefix: ?str
    substatements: list[Statement]
    def __init__(self, kw: str, arg: ?str=None, prefix: ?str=None):
        self.kw = kw
        self.arg = arg
        self.prefix = prefix
        self.substatements = []

    def get_subarg(self, kw: str) -> ?str:
        for substatement in self.substatements:
            if substatement.kw == kw:
                return substatement.arg

    def get_subarg_bool(self, kw: str) -> ?bool:
        for substatement in self.substatements:
            if substatement.kw == kw:
                arg = substatement.arg
                if arg is not None:
                    return bool(arg)

    def pryang(self, indent=0):
        """Print YANG source code for this statement and its substatements
        """
        res = _yind(indent) + self.kw
        arg = self.arg
        if arg is not None:
            quoted_arg = True if self.kw in _quoted_arg_keywords else False
            res += " "
            if quoted_arg:
                res += '"'
            res += arg
            if quoted_arg:
                res += '"'
        if len(self.substatements) == 0:
            res += ";\n"
        else:
            res += " {\n"
            for substatement in self.substatements:
                res += substatement.pryang(indent+1)
            res += _yind(indent) + "}\n"
        return res


# Yang schema for data
#
# This module provides a concrete YANG schema representation of a data tree.
# Unlike the yang.schema module, which has a focus on properly representing the
# YANG schema document itself, including abstract concepts like imports, inherited
# types, groupings and augments, this module focuses on the statements relevant
# for representing a YANG modeled data tree. The data nodes in YANG are:
# - container, list, leaf, leaf-list, anydata, anyxml and the module itself can be
#   considered a form of container
# A YANG schema can be expanded into these data nodes, for example by expanding
# uses statements with the relevant groupings into the actual nodes and by
# applying augment statements to the relevant nodes.
#
# Similarly, concepts like config is represented as a boolean here, since all
# nodes are either config or not config, whereas in yang.schema, config is a
# tri-state value, since it can be None, meaning that the value is inherited from
# the parent node. Things like this makes it easier to work with the data tree
# from this module.
#
# Another concept is DTree which is a special node that acts as the virtual root
# of the data tree which can contain multiple YANG modules.

class DNode(object):
    parent: ?DNode
    name: str
    config: bool
    description: ?str
    reference: ?str

class DNodeInner(DNode):
    children: list[DNode]

class DNodeLeaf(DNode):
    pass

class DAnydata(DNodeLeaf):
    if_feature: list[str]
    mandatory: ?bool
    must: list[Must]
    status: ?str
    when: ?str

class DAnyxml(DNodeLeaf):
    if_feature: list[str]
    mandatory: ?bool
    must: list[Must]
    status: ?str
    when: ?str

class DContainer(DNodeInner):
    if_feature: list[str]
    must: list[Must]
    presence: ?str
    status: ?str
    when: ?str

    def __init__(self, name: str, config: bool, description: ?str=None, if_feature=[], must=[], presence=None, reference=None, status=None, when=None, children=[]):
        self.name = name
        self.config = config
        self.description = description
        self.if_feature = if_feature
        self.must = must
        self.presence = presence
        self.reference = reference
        self.status = status
        self.children = []

class DModule(DNodeInner):
    augment: list[Augment]
    contact: ?str
    deviation: list[str]
    extension_: list[Extension]
    feature: list[Feature]
    import_: list[Import]
    include: list[Include]
    namespace: ?str
    organization: ?str
    prefix: ?str
    revision: list[Revision]
    yang_version: ?str

class DList(DNodeInner):
    if_feature: list[str]
    key: ?str
    max_elements: ?str
    min_elements: ?str
    must: list[Must]
    ordered_by: ?str
    status: ?str
    unique: list[str]
    when: ?str

class DLeaf(DNodeLeaf):
    default: ?str
    if_feature: list[str]
    mandatory: bool
    must: list[Must]
    status: ?str
    type_: Type
    units: ?str
    when: ?str

    def __init__(self, name: str, config: bool, description: ?str=None, default=None, if_feature=[], mandatory=False, must=[], reference=None, status=None, type_: Type, units=None, when=None):
        self.name = name
        self.config = config
        self.description = description
        self.default = default
        self.if_feature = if_feature
        self.mandatory = mandatory
        self.must = must
        self.reference = reference
        self.status = status
        self.type_ = type_
        self.units = units
        self.when = when

class DLeafList(DNodeLeaf):
    default: list[str]
    if_feature: list[str]
    max_elements: ?str
    min_elements: ?str
    must: list[Must]
    ordered_by: ?str
    status: ?str
    type_: ?Type
    units: ?str
    when: ?str

class DTree(object):
    pass


# TODO: how to work with input / output for RPCs and actions?

# -------------------------------------------------------------------------------

class SchemaNode(object):
    parent: ?SchemaNode

    def _get_argname(self) -> ?str:
        raise NotImplementedError('SchemaNode')

    def _get_arg(self) -> ?str:
        raise NotImplementedError('SchemaNode')

    def _get_data_name(self) -> str:
        raise NotImplementedError('SchemaNode')

    def prsrc(self, indent=0) -> str:
        """Print Acton source code for this schema node and its subnodes
        """
        raise NotImplementedError('SchemaNode')

    def prdaclass(self) -> str:
        """Print the data class for this schema node
        """
        raise NotImplementedError('SchemaNode pdc')

    def to_dnode(self) -> DNode:
        raise NotImplementedError('SchemaNode to_dschema')

    def get_config(self) -> bool:
        n = self
        for i in range(10):
            if (isinstance(n, Anydata)
                or isinstance(n, Anyxml)
                or isinstance(n, Container_)
                or isinstance(n, Module)
                or isinstance(n, Leaf)
                or isinstance(n, LeafList)
                or isinstance(n, List)):
                found_config = True
                if isinstance(n, Anydata):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, Anyxml):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, Container_):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, Module):
                    return True
                elif isinstance(n, Leaf):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, LeafList):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, List):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False

                if not found_config:
                    nparent = n.parent
                    if nparent is not None:
                        n = nparent
                        continue
                    else:
                        if isinstance(n, Module):
                            return True
                        else:
                            raise ValueError("Reached some top data node ")
            else:
                raise ValueError("Non-data node %s does not have config statements" % type(n))
        raise ValueError("Unable to find config attribute")


    def get(self, name: str) -> SchemaNode:
        if isinstance(self, SchemaNodeInner):
            for child in self.children:
                if isinstance(child, Anydata) and child.name == name:
                    return child
                elif isinstance(child, Anyxml) and child.name == name:
                    return child
                elif isinstance(child, Container_) and child.name == name:
                    return child
                elif isinstance(child, Leaf) and child.name == name:
                    return child
                elif isinstance(child, LeafList) and child.name == name:
                    return child
                elif isinstance(child, List) and child.name == name:
                    return child
            raise ValueError("Child not found")

        raise ValueError("Unable to get child from non-inner node")


class SchemaNodeInner(SchemaNode):
    children: list[SchemaNode]

    def prdaclass(self) -> str:
        """Print the data class for this schema node
        """
        stmt_arg = self._get_arg()
        res = []
        for child in self.children:
            if isinstance(child, SchemaNodeInner):
                res.append(child.prdaclass())

        self_list_keys = set() # if we are a list, this is populated
        if isinstance(self, List):
            self_list_keys = set(self.keys())

        attrs: list[(name: str, inner: bool, type: str, optional: bool, constructor: str, data_class: str)] = []
        for child in self.children:
            if isinstance(child, Container_):
                if child.is_presence():
                    attrs.append((child.name, True, "?" + _get_full_name(child), True, _get_full_name(child), "Container_"))
                else:
                    attrs.append((child.name, True, _get_full_name(child), False, _get_full_name(child), "Container_"))
            elif isinstance(child, Leaf):
                optional = True
                childmandatory = child.mandatory
                if childmandatory is not None:
                    optional = childmandatory
                if child.name in self_list_keys:
                    optional = False
                optional_str = "?" if optional else ""
                attrs.append((child.name, False, optional_str + yang_type_to_acton_type(child.type_), optional, "", "Leaf"))
            elif isinstance(child, LeafList):
                attrs.append((child.name, False, "list[" + yang_type_to_acton_type(child.type_) + "]", False, "", "LeafList"))
            elif isinstance(child, List):
                attrs.append((child.name, True, _get_full_name(child), False, _get_full_name(child), "List"))
            else:
                raise ValueError("unreachable child type: " + str(type(child)))

        if isinstance(self, List):
            # List has special handling as it actually results in two classes:
            # - the list itself
            # - the list entry class
            # Here we create the list entry class, the list itself comes later
            res.append("class %s_entry(yang.adata.MNode):" % _get_full_name(self))
        else:
            res.append("class %s(yang.adata.MNode):" % _get_full_name(self))
        for attr in attrs:
            res.append("    %s: %s" % (attr.name, attr.type))
        res.append("")
        init_args = ["self"]
        for attr in attrs:
            if attr.name in self_list_keys:
                init_args.append("%s: %s" % (attr.name, attr.type))
            else:
                if attr.optional:
                    init_args.append("%s: %s=None" % (attr.name, attr.type))
                else:
                    init_args.append("%s: ?%s" % (attr.name, attr.type))
        init_args.append("children=[]")
        init_args_str = ", ".join(init_args)
        res.append("    def __init__(%s):" % init_args_str)
        if stmt_arg is not None:
            res.append("        self._name = " + repr(stmt_arg))
        else:
            if isinstance(self, Input):
                res.append("        self._name = 'input'")
            elif isinstance(self, Output):
                res.append("        self._name = 'output'")
            else:
                raise ValueError("unreachable")
#        for attr in attrs:
#            res.append("        self.%s = %s" % (attr.name, attr.name))
#
        for child in self.children:
            if isinstance(child, Container_):
                res.append("        if %s is not None:" % (child.name))
                res.append("            self.%s = %s" % (child.name, child.name))
                res.append("        else:")
                res.append("            self.%s = %s()" % (child.name, _get_full_name(child)))
            elif isinstance(child, Leaf):
                res.append("        self.%s = %s" % (child.name, child.name))
            elif isinstance(child, List):
                res.append("        if %s is not None:" % (child.name))
                res.append("            self.%s = %s" % (child.name, child.name))
                res.append("        else:")
                res.append("            self.%s = %s()" % (child.name, _get_full_name(child)))
        res.append("")

        # == .create_XXX() methods
        for child in self.children:
            if isinstance(child, Container_) and child.is_presence():
                res.append("    def create_%s(self):" % (child.name))
                res.append("        _%s = %s()" % (child.name, _get_full_name(child)))
                res.append("        self.%s = _%s" % (child.name, child.name))
                res.append("        return _%s" % (child.name))
                res.append("")
        res.append("")

        # .to_gdata()
        res.append("    def to_gdata(self) -> yang.data.Node:")
        if isinstance(self, List):
            # keys contains a yang spec of the keys, like "k1 k2"
            # which are modeled as attributes of the list entry class and accessed via self.k1, self.k2
            list_keys_str = ", ".join(map(lambda x: "self." + x, self.keys()))
            res.append("        res = yang.data.ListElement([%s])" % (list_keys_str))
        elif stmt_arg is not None: # stmt_arg is the name of the statement
            res.append("        res = yang.data.%s('%s')" % (snode_type_name(self), stmt_arg))
        else: # the only inner schema nodes without stmt_arg are Input and Output
            res.append("        res = yang.data.%s()" % snode_type_name(self))

        for attr in attrs:
            res.append("        _%s = self.%s" % (attr.name, attr.name))
        for attr in attrs:
            res.append("        if _%s is not None:" % attr.name)
            if attr.inner:
                res.append("            res.children['%s'] = _%s.to_gdata()" % (attr.name, attr.name))
            else:
                res.append("            res.children['%s'] = yang.data.%s('%s', _%s)" % (attr.name, attr.data_class, attr.name, attr.name))
        res.append("        return res")
        res.append("")

        # .from_gdata()
        # TODO: should .from_gdata() not take a specific data node instead, like Container_ instead of yang.data.Node?
        from_gdata_args_list = []
        for child in self.children:
            if isinstance(child, Leaf):
                from_gdata_args_list.append("%s=n.get_%s(\"%s\")" % (child.name, yang_leaf_to_getval(child), child.name))
            elif isinstance(child, Container_):
                from_gdata_args_list.append("%s=%s.from_gdata(n.get_container(\"%s\"))" % (child.name, _get_full_name(child), child.name))
        from_gdata_args = ", ".join(from_gdata_args_list)
        res.append("    @staticmethod")
        res.append("    def from_gdata(n: yang.data.Node) -> %s:" % _get_full_name(self))
        if isinstance(self, List):
            res.append("        res = %s()" % _get_full_name(self))
        else:
            res.append("        res = %s(%s)" % (_get_full_name(self), from_gdata_args))
        res.append("        return res")
        res.append("")

        if isinstance(self, List):
            # List has special handling as it actually results in two classes:
            # - the list itself
            # - the list entry class
            # Here we create the list entry class, the list itself comes later
            res.append("class %s(yang.adata.MNode):" % _get_full_name(self))
            res.append("    elements: list[%s_entry]" % _get_full_name(self))

            init_args = ["self"]
            init_args.append("elements=[]")
            init_args_str: str = ", ".join(init_args)
            res.append("    def __init__(%s):" % init_args_str)
            if stmt_arg is not None:
                res.append("        self._name = " + repr(stmt_arg))
            res.append("")
            res.append("        self.elements = []")
            res.append("")

            list_create_args = ["self"] + self.keys()
            res.append("    def create(%s):" % (", ".join(list_create_args)))
            res.append("        res = %s_entry(%s)" % (_get_full_name(self), ", ".join(self.keys())))
            res.append("        self.elements.append(res)")
            res.append("        return res")
            res.append("")

            res.append("    def to_gdata(self):" % ())
            res.append("        res = yang.data.List('%s', %s)" % (stmt_arg if stmt_arg is not None else "", repr(self.keys())))
            res.append("        for e in self.elements:")
            res.append("            e_gdata = e.to_gdata()")
            res.append("            if isinstance(e_gdata, yang.data.ListElement):")
            res.append("                res.elements.append(e_gdata)")
            res.append("        return res")
            res.append("")
        res.append("")

        return "\n".join(res)

class SchemaNodeOuter(SchemaNode):
    pass


def take_bool(stmts: list[Statement], kw: str) -> ?bool:
    v = take_str(stmts, kw)
    if v is not None:
        if v == "true":
            return True
        elif v == "false":
            return False

def take_int(stmts: list[Statement], kw: str) -> ?int:
    v = take_str(stmts, kw)
    if v is not None:
        return int(v)

def take_str(stmts: list[Statement], kw: str) -> ?str:
    for i in range(len(stmts)):
        if stmts[i].kw == kw:
            arg = stmts[i].arg
            if arg is not None:
                del stmts[i]
                return arg

def take_strlist(stmts: list[Statement], kw: str) -> list[str]:
    res = []
    todel = []
    for i in range(len(stmts)):
        if stmts[i].kw == kw:
            arg = stmts[i].arg
            if arg is not None:
                todel.append(i)
                res.append(arg)
    for d in reversed(todel):
        del stmts[d]
    return res

def take_node(stmts: list[Statement], kw: str) -> ?SchemaNode:
    for i in range(len(stmts)):
        if stmts[i].kw == kw:
            n = stmt_to_snode(stmts[i])
            del stmts[i]
            return n

def take_nodes(stmts: list[Statement], kw: list[str]) -> list[SchemaNode]:
    res = []
    todel = []
    for i in range(len(stmts)):
        if stmts[i].kw in kw:
            res.append(stmt_to_snode(stmts[i]))
            todel.append(i)
    for i in reversed(todel):
        del stmts[i]
    return res

def _attr_name(name: str):
    res = ""
    i = 0
    while True:
        if name[i] == "-":
            res += "_"
        else:
            res += name[i]
        i += 1
        if i == len(name):
            break
    if res in {"extension", "import", "type"}:
        res = res + "_"

    return res

def _prsrc_attrs(indent, attrs):
    """Print source code for a list of SchemaNode attributes"""
    res = []
    for attr in attrs:
        raw_name, value = attr
        name = _attr_name(raw_name)
        if value is not None:
            if isinstance(value, list):
                if len(value) == 0:
                    continue
                else:
                    list_val = []
                    content_is_snode = False
                    for e in value:
                        if isinstance(e, SchemaNode):
                            list_val.append(e.prsrc(indent+2))
                        else:
                            list_val.append(repr(e))
                    list_val_str = "[]"
                    if len(list_val) == 1 and list_val[0][0] != " " and len(list_val[0]) < 20:
                        list_val_str = "[" + list_val[0] + "]"
                    else:
                        list_val_str = "[\n" + ",\n".join(list_val) + "\n" + _ind(indent + 1) + "]"
                    res.append(name + "=" + list_val_str)
            elif isinstance(value, SchemaNode):
                res.append(name + "=" + value.prsrc(0))
            else:
                res.append(name + "=" + repr(value))
    return ", ".join(res)


def yang_leaf_to_acton_type(leaf: Leaf) -> str:
    optional = True
    leafmandatory = leaf.mandatory
    if leafmandatory is not None:
        optional = leafmandatory
    optional_str = "?" if optional else ""
    t = yang_type_to_acton_type(leaf.type_)
    return optional_str + t

def yang_leaf_to_getval(leaf: Leaf) -> str:
    optional = True
    leafmandatory = leaf.mandatory
    if leafmandatory is not None:
        optional = leafmandatory
    optional_str = "opt_" if optional else ""
    t = yang_type_to_acton_type(leaf.type_)
    return optional_str + t

def yang_type_to_acton_type(t: ?Type) -> str:
    # +---------------------+-------------------------------------+
    # | Name                | Description                         |
    # +---------------------+-------------------------------------+
    # | binary              | Any binary data                     |
    # | bits                | A set of bits or flags              |
    # | boolean             | "true" or "false"                   |
    # | decimal64           | 64-bit signed decimal number        |
    # | empty               | A leaf that does not have any value |
    # | enumeration         | One of an enumerated set of strings |
    # | identityref         | A reference to an abstract identity |
    # | instance-identifier | A reference to a data tree node     |
    # | int8                | 8-bit signed integer                |
    # | int16               | 16-bit signed integer               |
    # | int32               | 32-bit signed integer               |
    # | int64               | 64-bit signed integer               |
    # | leafref             | A reference to a leaf instance      |
    # | string              | A character string                  |
    # | uint8               | 8-bit unsigned integer              |
    # | uint16              | 16-bit unsigned integer             |
    # | uint32              | 32-bit unsigned integer             |
    # | uint64              | 64-bit unsigned integer             |
    # | union               | Choice of member types              |
    # +---------------------+-------------------------------------+
    if t is not None:
        if t.name == "binary":
            return "bytes"
        elif t.name == "bits":
            raise NotImplementedError('bits not supported')
        elif t.name == "boolean":
            return "bool"
        elif t.name == "decimal64":
            # TODO: do something better
            return "float"
        elif t.name == "empty":
            # TODO: is this right?
            return "bool"
        elif t.name == "enumeration":
            raise NotImplementedError('enumeration not supported')
        elif t.name == "identityref":
            raise NotImplementedError('identityref not supported')
        elif t.name == "instance-identifier":
            raise NotImplementedError('instance-identifier not supported')
        elif t.name == "int8":
            return "i8" # TODO: we don't have i8, right?
        elif t.name == "int16":
            return "i16"
        elif t.name == "int32":
            return "i32"
        elif t.name == "int64":
            return "i64"
        elif t.name == "leafref":
            return "str"
        elif t.name == "string":
            return "str"
        elif t.name == "uint8":
            return "u8" # TODO: we don't have u8, right?
        elif t.name == "uint16":
            return "u16"
        elif t.name == "uint32":
            return "u32"
        elif t.name == "uint64":
            return "u64"
        elif t.name == "union":
            # TODO: blargh, implement once we have unions in Acton
            raise NotImplementedError('union not supported')
        else:
            # TODO: resolve type -> typedefs -> basetype
            raise ValueError("Unknown YANG type: " + t.name)
    raise ValueError("type not defined")


def _get_full_name(snode: SchemaNode) -> str:
    """
    """
    path = []
    while True:
        path.append(snode_name(snode))
        parent = snode.parent
        if parent is not None:
            snode = parent
        else:
            break
    return "y_" + "__".join(reversed(path))


# -- end of manually defined schema functions, automatically generated code follows
