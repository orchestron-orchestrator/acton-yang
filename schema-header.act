# schema-header.act is the manually defined part of the schema.act that goes
# first, where the middle part of the file is generated by reading the RFC and
# finally schema-footer.act is appended at the end to produce the final
# schema.act module.
#
# YANG schema
#
# This is an object model for YANG schema, based on YANG 1.1 although it should
# mostly work for YANG 1.0 just fine. There is no logic for either schema or
# data validation, so it is possible to represent an invalid schema using this
# model.
#
# There are two levels of object representation. The first level is that of
# statements and is represented by the Statement class. Everything in a YANG
# model is pretty much a statement, so this is a representation fairly close to
# the YANG source code. For example, the order of all statements is preserved,
# so this model:
#
#    module foo {
#      prefix "f";
#      namespace "http://example.com/foo";
#    }
#
# Would become:
#
#   Statement("module", "foo", substatements=[
#     Statement("prefix", "f"),
#     Statement("namespace", "http://example.com/foo")
#   ])
#
# Whitespace, indentation and comments are not preserved but all parsed
# statements are. Thus if the Statements are rendered back to YANG source, it
# would look exactly like the original source code, presuming the use of
# canonical YANG formatting.
#
# The second level is that of schema nodes and is represented by the SchemaNode
# class. The SchemaNode class is a base class for all schema node types, such as
# Module, Container, List, Leaf, etc. Different statements are modeled using
# discrete classes and statements that relate to a particular statement are
# attributes of that object class rather than being seen as just a tree of
# statements. For example, the following model:
#
#    module foo {
#      prefix "f";
#      namespace "http://example.com/foo";
#      container c1 {
#        leaf l1 {
#          type string;
#        }
#      }
#    }
#
# Would become:
#
#   Module("foo", namespace="http://example.com/foo", prefix="f", children=[
#     Container("c1", children=[
#       Leaf("l1", type_="string")
#     ])
#   ])
#
# Rendering that back to YANG source code will render the namespace & prefix
# statements in the canonical order specified by the YANG RFC, thus rendering
# the following:
#
#    module foo {
#      prefix "f";
#      namespace "http://example.com/foo";
#      container c1 {
#        leaf l1 {
#          type string;
#        }
#      }
#    }
#
# This higher layer SchemaNode representation is not suitable if it is desirable
# to keep statement order from the original source document (be aware that even
# with the lower leve Statement representation, whitespace & comments are still
# lost).

RECURSION_LIMIT = 100

def _yind(n):
    return "  " * n

def _ind(n):
    return "    " * n

_builtin_types = {
    "binary",
    "bits",
    "boolean",
    "decimal64",
    "empty",
    "enumeration",
    "identityref",
    "instance-identifier",
    "int8",
    "int16",
    "int32",
    "int64",
    "leafref",
    "string",
    "uint8",
    "uint16",
    "uint32",
    "uint64",
}

_quoted_arg_keywords = set([
    "argument",
    "augment",
    "contact",
    "description",
    "if-feature",
    "namespace",
    "organization",
    "prefix",
    "reference",
    "refine",
    "yang-version",
])

class Statement(object):
    kw: str
    arg: ?str
    prefix: ?str
    substatements: list[Statement]
    def __init__(self, kw: str, arg: ?str=None, prefix: ?str=None):
        self.kw = kw
        self.arg = arg
        self.prefix = prefix
        self.substatements = []

    def get_subarg(self, kw: str) -> ?str:
        for substatement in self.substatements:
            if substatement.kw == kw:
                return substatement.arg

    def get_subarg_bool(self, kw: str) -> ?bool:
        for substatement in self.substatements:
            if substatement.kw == kw:
                arg = substatement.arg
                if arg is not None:
                    return bool(arg)

    def pryang(self, indent=0):
        """Print YANG source code for this statement and its substatements
        """
        res = _yind(indent) + self.kw
        arg = self.arg
        if arg is not None:
            quoted_arg = True if self.kw in _quoted_arg_keywords else False
            res += " "
            if quoted_arg:
                res += '"'
            res += arg
            if quoted_arg:
                res += '"'
        if len(self.substatements) == 0:
            res += ";\n"
        else:
            res += " {\n"
            for substatement in self.substatements:
                res += substatement.pryang(indent+1)
            res += _yind(indent) + "}\n"
        return res


# Yang schema for data
#
# This module provides a concrete YANG schema representation of a data tree.
# Unlike the yang.schema module, which has a focus on properly representing the
# YANG schema document itself, including abstract concepts like imports, inherited
# types, groupings and augments, this module focuses on the statements relevant
# for representing a YANG modeled data tree. The data nodes in YANG are:
# - container, list, leaf, leaf-list, anydata, anyxml and the module itself can be
#   considered a form of container
# A YANG schema can be expanded into these data nodes, for example by expanding
# uses statements with the relevant groupings into the actual nodes and by
# applying augment statements to the relevant nodes.
#
# Similarly, concepts like config is represented as a boolean here, since all
# nodes are either config or not config, whereas in yang.schema, config is a
# tri-state value, since it can be None, meaning that the value is inherited from
# the parent node. Things like this makes it easier to work with the data tree
# from this module.
#
# Another concept is DTree which is a special node that acts as the virtual root
# of the data tree which can contain multiple YANG modules.

class DNode(object):
    parent: ?DNode
    dname: str
    name: str
    config: bool
    description: ?str
    reference: ?str

    def prdaclass(self, strict=True, top=True) -> str:
        """Print the data class for this schema node
        """
        raise NotImplementedError('SchemaNode pdc')

class DNodeInner(DNode):
    children: list[DNode]

    def prdaclass(self, strict=True, top=True) -> str:
        """Print the data class for this schema node
        """
#        stmt_arg = self._get_arg()
        res = []
        if top:
            res.append("import xml")
            res.append("import yang.adata")
            res.append("import yang.data")
            res.append("")
            res.append("# == This file is generated ==")
            res.append("")
            res.append("")
        for child in self.children:
            if isinstance(child, DNodeInner):
                res.append(child.prdaclass(strict=strict, top=False))

        if isinstance(self, DList):
            # List has special handling as it actually results in two classes:
            # - the list itself
            # - the list entry class
            # Here we create the list entry class, the list itself comes later
            res.append("class %s_entry(yang.adata.MNode):" % _get_full_name(self))
        else:
            res.append("class %s(yang.adata.MNode):" % _get_full_name(self))
        for child in self.children:
            if isinstance(child, DNodeLeaf):
                res.append("    %s: %s" % (child.name, yang_leaf_to_acton_type(child)))
            elif isinstance(child, DNodeInner):
                res.append("    %s: %s" % (child.name, _get_full_name(child)))
            else:
                raise ValueError("unreachable, unknown child type: " + str(type(child)))
        res.append("")
        init_args = ["self"]
        for child in self.children:
            if isinstance(child, DContainer):
                if child.presence:
                    init_args.append("%s: ?%s=None" % (child.name, _get_full_name(child)))
                else:
                    init_args.append("%s: ?%s" % (child.name, _get_full_name(child)))
            elif isinstance(child, DLeaf):
                init_args.append("%s: %s" % (child.name, yang_leaf_to_acton_type(child)))
            elif isinstance(child, DList):
                init_args.append("%s: list[%s_entry]=[]" % (child.name, _get_full_name(child)))

        init_args_str = ", ".join(init_args)
        res.append("    def __init__(%s):" % init_args_str)

        for child in self.children:
            if isinstance(child, DContainer):
                # TODO: presence?
                res.append("        if %s is not None:" % (child.name))
                res.append("            self.%s = %s" % (child.name, child.name))
                res.append("        else:")
                res.append("            self.%s = %s()" % (child.name, _get_full_name(child)))
            elif isinstance(child, DLeaf):
                res.append("        self.%s = %s" % (child.name, child.name))
            elif isinstance(child, DList):
                res.append("        self.%s = %s(elements=%s)" % (child.name, _get_full_name(child), child.name))
        res.append("")

#        # == .create_XXX() methods
#        for child in self.children:
#            if isinstance(child, Container_) and child.is_presence():
#                res.append("    def create_%s(self):" % (child.name))
#                res.append("        _%s = %s()" % (child.name, _get_full_name(child)))
#                res.append("        self.%s = _%s" % (child.name, child.name))
#                res.append("        return _%s" % (child.name))
#                res.append("")
#        res.append("")

        # .to_gdata()
        res.append("    def to_gdata(self) -> yang.data.Node:")
        if isinstance(self, DList):
            # keys contains a yang spec of the keys, like "k1 k2"
            # which are modeled as attributes of the list entry class and accessed via self.k1, self.k2
            list_keys_str = ", ".join(map(lambda x: "self." + x, self.key))
            res.append("        res = yang.data.ListElement([%s])" % (list_keys_str))
        elif isinstance(self, DRoot):
            res.append("        res = yang.data.%s()" % (self.dname))
        else:
            res.append("        res = yang.data.%s('%s')" % (self.dname, self.name))

        for child in self.children:
            res.append("        _%s = self.%s" % (child.name, child.name))
        for child in self.children:
            res.append("        if _%s is not None:" % child.name)
            if isinstance(child, DNodeLeaf):
                res.append("            res.children['%s'] = yang.data.Leaf('%s', _%s)" % (child.name, child.name, child.name))
            elif isinstance(child, DContainer):
                res.append("            res.children['%s'] = self.%s.to_gdata()" % (child.name, child.name))
            elif isinstance(child, DList):
                res.append("            res.children['%s'] = self.%s.to_gdata()" % (child.name, child.name))
        res.append("        return res")
        res.append("")
#
        # .from_gdata()
        # TODO: should .from_gdata() not take a specific data node instead, like Container_ instead of yang.data.Node?
        from_gdata_args_list = []
        from_xml_args_list = []
        for child in self.children:
            if isinstance(child, DNodeLeaf):
                from_gdata_args_list.append("%s=n.get_%s(\"%s\")" % (child.name, yang_leaf_to_getval(child), child.name))
                from_xml_args_list.append("%s=yang.data.from_xml_%s(n, \"%s\")" % (child.name, yang_leaf_to_getval(child), child.name))
            elif isinstance(child, DContainer):
                # TODO: handle presence containers
                from_gdata_args_list.append("%s=%s.from_gdata(n.get_container(\"%s\"))" % (child.name, _get_full_name(child), child.name))
                # TODO: handle presence containers
                from_xml_args_list.append("%s=%s.from_xml(yang.data.get_xml_child(n, \"%s\"))" % (child.name, _get_full_name(child), child.name))
            elif isinstance(child, DList):
                from_gdata_args_list.append("%s=%s.from_gdata(n.get_list(\"%s\"))" % (child.name, _get_full_name(child), child.name))
                from_xml_args_list.append("%s=%s.from_xml(yang.data.get_xml_children(n, \"%s\"))" % (child.name, _get_full_name(child), child.name))
        from_gdata_args = ", ".join(from_gdata_args_list)
        from_xml_args = ", ".join(from_xml_args_list)
        res.append("    @staticmethod")
        if isinstance(self, DList):
            res.append("    def from_gdata(n: yang.data.Node) -> %s_entry:" % _get_full_name(self))
            res.append("        return %s_entry(%s)" % (_get_full_name(self), from_gdata_args))
        else:
            res.append("    def from_gdata(n: yang.data.Node) -> %s:" % _get_full_name(self))
            res.append("        return %s(%s)" % (_get_full_name(self), from_gdata_args))
        res.append("")

        res.append("    @staticmethod")
        if isinstance(self, DList):
            res.append("    def from_xml(n: xml.Node) -> %s_entry:" % _get_full_name(self))
            res.append("        return %s_entry(%s)" % (_get_full_name(self), from_xml_args))
        else:
            res.append("    def from_xml(n: xml.Node) -> %s:" % _get_full_name(self))
            res.append("        return %s(%s)" % (_get_full_name(self), from_xml_args))
        res.append("")

        if isinstance(self, DList):
            # List has special handling as it actually results in two classes:
            # - the list itself
            # - the list entry class
            # Here we create the list entry class, the list itself comes later
            res.append("class %s(yang.adata.MNode):" % _get_full_name(self))
            res.append("    elements: list[%s_entry]" % _get_full_name(self))

            init_args = ["self"]
            init_args.append("elements=[]")
            init_args_str: str = ", ".join(init_args)
            res.append("    def __init__(%s):" % init_args_str)
            res.append("        self._name = " + repr(self.name))
            res.append("        self.elements = elements")
            res.append("")

            list_create_args = ["self"] + self.key
            res.append("    def create(%s):" % (", ".join(list_create_args)))
            res.append("        res = %s_entry(%s)" % (_get_full_name(self), ", ".join(self.key)))
            res.append("        self.elements.append(res)")
            res.append("        return res")
            res.append("")

            res.append("    def to_gdata(self):" % ())
            res.append("        res = yang.data.List('%s', %s)" % (self.name, repr(self.key)))
            res.append("        for e in self.elements:")
            res.append("            e_gdata = e.to_gdata()")
            res.append("            if isinstance(e_gdata, yang.data.ListElement):")
            res.append("                res.elements.append(e_gdata)")
            res.append("        return res")
            res.append("")

#            # .from_gdata()
#            # TODO: should .from_gdata() not take a specific data node instead, like Container_ instead of yang.data.Node?
            from_gdata_args_list = []
            for child in self.children:
                if isinstance(child, DNodeLeaf):
                    from_gdata_args_list.append("%s=n.get_%s(\"%s\")" % (child.name, yang_leaf_to_getval(child), child.name))
                elif isinstance(child, DContainer):
                    from_gdata_args_list.append("%s=%s.from_gdata(n.get_container(\"%s\"))" % (child.name, _get_full_name(child), child.name))
                elif isinstance(child, DList):
                    from_gdata_args_list.append("%s=%s.from_gdata(n.get_list(\"%s\"))" % (child.name, _get_full_name(child), child.name))
#                elif isinstance(child, ListElement):
#                    from_gdata_args_list.append("%s=%s.from_gdata(n.get_list(\"%s\"))" % (child.name, _get_full_name(child), child.name))
            from_gdata_args = ", ".join(from_gdata_args_list)
            res.append("    @staticmethod")
            res.append("    def from_gdata(n: yang.data.List) -> list[%s_entry]:" % _get_full_name(self))
            res.append("        return list(map(lambda x: %s_entry.from_gdata(x), n.elements))" % _get_full_name(self))
            res.append("")
            res.append("    @staticmethod")
            res.append("    def from_xml(nodes: list[xml.Node]) -> list[%s_entry]:" % _get_full_name(self))
            res.append("        return list(map(lambda x: %s_entry.from_xml(x), nodes))" % _get_full_name(self))
            res.append("")
        res.append("")

        return "\n".join(res)


class DNodeLeaf(DNode):
    if_feature: list[str]
    mandatory: bool
    must: list[Must]
    status: ?str
    type_: Type
    when: ?str

class DAnydata(DNodeLeaf):
    pass

class DAnyxml(DNodeLeaf):
    pass

class DContainer(DNodeInner):
    if_feature: list[str]
    must: list[Must]
    presence: bool

    def __init__(self, name: str, config: bool, description: ?str=None, if_feature=[], must=[], presence: bool, reference=None, status=None, when=None, children=[]):
        self.name = name
        self.dname = "Container_"
        self.config = config
        self.description = description
        self.if_feature = if_feature
        self.must = must
        self.presence = presence
        self.reference = reference
        self.status = status
        self.children = children

class DModule(DNodeInner):
    augment: list[Augment]
    contact: ?str
    deviation: list[str]
    extension_: list[Extension]
    feature: list[Feature]
    import_: list[Import]
    include: list[Include]
    namespace: str
    organization: ?str
    prefix: str
    revision: list[Revision]
    yang_version: float

    def __init__(self, name: str, namespace: str, prefix: str, yang_version: ?float, description: ?str=None, contact=None, deviation=[], extension_=[], feature=[], import_=[], include=[], organization=None, reference=None, revision=[], children=[]):
        self.name = name
        self.namespace = namespace
        self.prefix = prefix
        if yang_version is not None:
            self.yang_version = yang_version
        else:
            self.yang_version = 1.1
        self.config = True # module is not config in itself, but it is the root
                           # of the data tree and the default is config=True, so
                           # we set it here
        self.description = description
        self.contact = contact
        self.deviation = deviation
        self.extension_ = extension_
        self.feature = feature
        self.import_ = import_
        self.include = include
        self.organization = organization
        self.reference = reference
        self.revision = revision
        self.children = children

class DList(DNodeInner):
    if_feature: list[str]
    key: list[str]
    max_elements: ?int
    min_elements: int
    must: list[Must]
    ordered_by: str
    status: ?str
    unique: list[str]
    when: ?str

    def __init__(self, name: str, key: list[str], config: bool, description: ?str=None, if_feature=[], max_elements: ?int=None, min_elements=0, must=[], ordered_by="system", reference=None, status=None, unique=[], when=None, children=[]):
        self.name = name
        self.dname = "List"
        self.key = key
        self.config = config
        self.description = description
        self.if_feature = if_feature
        self.max_elements = max_elements
        self.min_elements = min_elements
        self.must = must
        self.ordered_by = ordered_by
        self.reference = reference
        self.status = status
        self.unique = unique
        self.when = when
        self.children = children

class DLeaf(DNodeLeaf):
    default: ?str
    units: ?str

    def __init__(self, name: str, config: bool, description: ?str=None, default=None, if_feature=[], mandatory=False, must=[], reference=None, status=None, type_: Type, units=None, when=None):
        self.name = name
        self.dname = "Leaf"
        self.config = config
        self.description = description
        self.default = default
        self.if_feature = if_feature
        self.mandatory = mandatory
        self.must = must
        self.reference = reference
        self.status = status
        self.type_ = type_
        self.units = units
        self.when = when

class DLeafList(DNodeLeaf):
    default: list[str]
    max_elements: ?int
    min_elements: int
    ordered_by: str
    units: ?str

    def __init__(self, name: str, config: bool, description: ?str=None, default=[], if_feature=[], max_elements: ?int=None, min_elements=0, must=[], ordered_by="system", reference=None, status=None, type_: Type, units=None, when=None):
        self.name = name
        self.dname = "LeafList"
        self.config = config
        self.description = description
        self.default = default
        self.if_feature = if_feature
        self.max_elements = max_elements
        self.min_elements = min_elements
        self.must = must
        self.ordered_by = ordered_by
        self.reference = reference
        self.status = status
        self.type_ = type_
        self.units = units
        self.when = when

class DRoot(DNodeInner):
    def __init__(self, modules: list[DNode]=[]):
        self.name = "root"
        self.dname = "Root"
        self.config = True
        self.children=[]
        for module in modules:
            if isinstance(module, DModule):
                for child in module.children:
                    self.children.append(child)
            else:
                raise ValueError("DRoot can only contain DModule")


# TODO: how to work with input / output for RPCs and actions?

# -------------------------------------------------------------------------------

def split_prefix_name(name: str) -> (?str, str):
    if name.find(":") != -1:
        parts = name.split(":", 1)
        return (parts[0], parts[1])
    return None, name

# -------------------------------------------------------------------------------

class ModRev(object):
    modname: str
    rev: ?str

    def __init__(self, modname: str, rev: ?str):
        self.modname = modname
        self.rev = rev

extension ModRev (Hashable):
    def __eq__(self, other: ModRev) -> bool:
        return self.modname == other.modname and self.rev == other.rev

    def __hash__(self) -> int:
        selfrev = self.rev
        revstr = selfrev if selfrev is not None else ""
        # TODO: actually include revision in hash
        #return self.modname.__hash__() + revstr.__hash__()
        return self.modname.__hash__()

class Context(object):
    """Compilation context
    """
    modules: dict[ModRev, Module]

    def __init__(self, modules: list[Module]=[]):
        self.modules = {}
        for module in modules:
            self.add_module(module)

    def add_module(self, module: Module):
        # TODO: handle revision
        self.modules[ModRev(module.name, None)] = module

    def get_module(self, modname: str, rev: ?str) -> Module:
        return self.modules[ModRev(modname, rev)]


class SchemaNode(object):
    parent: ?SchemaNode
    namespace: ?str
    prefix: ?str

    def _get_argname(self) -> ?str:
        raise NotImplementedError('SchemaNode _get_argname')

    def _get_arg(self) -> ?str:
        raise NotImplementedError('SchemaNode _get_arg')

    def prsrc(self, indent=0) -> str:
        """Print Acton source code for this schema node and its subnodes
        """
        raise NotImplementedError('SchemaNode prsrc')

    def prdaclass(self, strict=True, top=True) -> str:
        """Print the data class for this schema node
        """
        raise NotImplementedError('SchemaNode pdc')

    mut def to_dnode(self) -> DNode:
        raise NotImplementedError('SchemaNode to_dschema')

    def get_namespace(self) -> str:
        n = self
        for i in range(RECURSION_LIMIT+1):
            nnamespace = n.namespace
            if nnamespace is not None:
                return nnamespace
            nparent = n.parent
            if nparent is not None:
                n = nparent
                continue
            if i > RECURSION_LIMIT:
                raise ValueError("Recursion limit reached")
        raise ValueError("Unable to find namespace")

    def get_prefix(self) -> str:
        n = self
        for i in range(RECURSION_LIMIT+1):
            nprefix = n.prefix
            if nprefix is not None:
                return nprefix
            nparent = n.parent
            if nparent is not None:
                n = nparent
                continue
            if i > RECURSION_LIMIT:
                raise ValueError("Recursion limit reached")
        raise ValueError("Unable to find namespace")

    def is_config(self) -> bool:
        n = self
        for i in range(RECURSION_LIMIT+1):
            if (isinstance(n, Anydata)
                or isinstance(n, Anyxml)
                or isinstance(n, Container_)
                or isinstance(n, Module)
                or isinstance(n, Leaf)
                or isinstance(n, LeafList)
                or isinstance(n, List)):
                found_config = True
                if isinstance(n, Anydata):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, Anyxml):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, Container_):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, Module):
                    return True
                elif isinstance(n, Leaf):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, LeafList):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, List):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False

                if not found_config:
                    nparent = n.parent
                    if nparent is not None:
                        n = nparent
                        continue
                    else:
                        if isinstance(n, Module):
                            return True
                        else:
                            raise ValueError("Reached some top data node of type %s" % type(n))
            else:
                raise ValueError("Non-data node %s does not have config statements" % type(n))
            if i > RECURSION_LIMIT:
                raise ValueError("Recursion limit reached")
        raise ValueError("Unable to find config attribute")

    def get(self, name: str) -> SchemaNode:
        """Get child node with name
        """
        if isinstance(self, SchemaNodeInner):
            for child in self.children:
                if isinstance(child, Anydata) and child.name == name:
                    return child
                elif isinstance(child, Anyxml) and child.name == name:
                    return child
                elif isinstance(child, Container_) and child.name == name:
                    return child
                elif isinstance(child, Leaf) and child.name == name:
                    return child
                elif isinstance(child, LeafList) and child.name == name:
                    return child
                elif isinstance(child, List) and child.name == name:
                    return child
            raise ValueError("Child not found")

        raise ValueError("Unable to get child from non-inner node")

    def get_module(self) -> Module:
        """Get the Module for the local module

        That is, climb up the ladder of parents from the current node until we
        reach the top Module.
        """
        n = self
        while True:
            if isinstance(n, Module):
                return n
            nparent = n.parent
            if nparent is not None:
                n = nparent
                continue
            break
        raise ValueError("Unable to find Module")

    def compile(self, context: Context) -> SchemaNode:
        """Compile an abstract YANG into a concrete one
        - expand uses / groupings
        - handle augments
        - resolve types to base types
        """
        raise NotImplementedError('SchemaNode compile')

    def expand_children(self, context: Context) -> list[SchemaNode]:
        """Expand abstract children into concrete nodes
        """
        if isinstance(self, SchemaNodeInner):
            res = []
            for child in self.children:
                if isinstance(child, Uses):
                    grouping = child.get_grouping(child.name, context)
                    res.extend(grouping.expand_children(context))
                else:
                    res.append(child.compile(context))
            return res
        raise ValueError("expand_children() called on non-inner node %s" % type(self))

    def get_module_by_prefix(self, prefix: str, context: Context) -> Module:
        """Get a Module from the import prefix in the local module"""
        local_module = self.get_module()
        imp = local_module.get_import_by_prefix(prefix)
        # TODO: fix revision
        return context.get_module(imp.module, None)

    def get_grouping(self, name: str, context: Context) -> Grouping:
        """Find a grouping in the local module or an imported module
        """
        prefix, group_name = split_prefix_name(name)
        if prefix is not None:
            imported_module = self.get_module_by_prefix(prefix, context)
            return imported_module.get_grouping(group_name, context)
        else: # local module
            return self.get_grouping_in_module(group_name)

    def get_grouping_in_module(self, name: str) -> Grouping:
        """Find a grouping in the current module
        """
        n = self
        for i in range(RECURSION_LIMIT+1):
            if isinstance(n, SchemaNodeInner):
                for child in n.children:
                    if isinstance(child, Grouping) and child.name == name:
                        return child
            nparent = n.parent
            if nparent is not None:
                n = nparent
                continue
            else:
                break
            if i == RECURSION_LIMIT:
                raise ValueError("Recursion limit reached")
        raise ValueError("Unable to find grouping '%s'" % name)

    def get_typedef(self, name: str, context: Context) -> Typedef:
        """Find a typedef in the local module or an imported module
        """
        prefix, typedef_name = split_prefix_name(name)
        if prefix is not None:
            imported_module = self.get_module_by_prefix(prefix, context)
            return imported_module.get_typedef(typedef_name, context)
        else:
            return self.get_typedef_in_module(typedef_name)

    def get_typedef_in_module(self, name: str) -> Typedef:
        """Find a typedef in the current module
        """
        n = self
        for i in range(RECURSION_LIMIT+1):
            typedefs: list[Typedef] = []
            if isinstance(n, SchemaNodeInner):
                for child in n.children:
                    if isinstance(child, Typedef) and child.name == name:
                        return child
            nparent = n.parent
            if nparent is not None:
                n = nparent
                continue
            else:
                break
            if i == RECURSION_LIMIT:
                raise ValueError("Recursion limit reached")
        raise ValueError("Unable to find typedef '%s'" % name)


class SchemaNodeInner(SchemaNode):
    children: list[SchemaNode]

class SchemaNodeOuter(SchemaNode):
    pass


def take_bool(stmts: list[Statement], kw: str) -> ?bool:
    v = take_str(stmts, kw)
    if v is not None:
        if v == "true":
            return True
        elif v == "false":
            return False

def take_int(stmts: list[Statement], kw: str) -> ?int:
    v = take_str(stmts, kw)
    if v is not None:
        return int(v)

def take_str(stmts: list[Statement], kw: str) -> ?str:
    for i in range(len(stmts)):
        if stmts[i].kw == kw:
            arg = stmts[i].arg
            if arg is not None:
                del stmts[i]
                return arg

def take_strlist(stmts: list[Statement], kw: str) -> list[str]:
    res = []
    todel = []
    for i in range(len(stmts)):
        if stmts[i].kw == kw:
            arg = stmts[i].arg
            if arg is not None:
                todel.append(i)
                res.append(arg)
    for d in reversed(todel):
        del stmts[d]
    return res

def take_node(stmts: list[Statement], kw: str) -> ?SchemaNode:
    for i in range(len(stmts)):
        if stmts[i].kw == kw:
            n = stmt_to_snode(stmts[i])
            del stmts[i]
            return n

def take_nodes(stmts: list[Statement], kw: list[str]) -> list[SchemaNode]:
    res = []
    todel = []
    for i in range(len(stmts)):
        if stmts[i].kw in kw:
            res.append(stmt_to_snode(stmts[i]))
            todel.append(i)
    for i in reversed(todel):
        del stmts[i]
    return res

def _attr_name(name: str):
    res = ""
    i = 0
    while True:
        if name[i] == "-":
            res += "_"
        else:
            res += name[i]
        i += 1
        if i == len(name):
            break
    if res in {"extension", "import", "type"}:
        res = res + "_"

    return res

def _prsrc_attrs(indent, attrs):
    """Print source code for a list of SchemaNode attributes"""
    res = []
    for attr in attrs:
        raw_name, value = attr
        name = _attr_name(raw_name)
        if value is not None:
            if isinstance(value, list):
                if len(value) == 0:
                    continue
                else:
                    list_val = []
                    content_is_snode = False
                    for e in value:
                        if isinstance(e, SchemaNode):
                            list_val.append(e.prsrc(indent+2))
                        else:
                            list_val.append(repr(e))
                    list_val_str = "[]"
                    if len(list_val) == 1 and list_val[0][0] != " " and len(list_val[0]) < 20:
                        list_val_str = "[" + list_val[0] + "]"
                    else:
                        list_val_str = "[\n" + ",\n".join(list_val) + "\n" + _ind(indent + 1) + "]"
                    res.append(name + "=" + list_val_str)
            elif isinstance(value, SchemaNode):
                res.append(name + "=" + value.prsrc(0))
            else:
                res.append(name + "=" + repr(value))
    return ", ".join(res)


def yang_leaf_to_acton_type(leaf: DNodeLeaf) -> str:
    optional = True
    leafmandatory = leaf.mandatory
    if leafmandatory is not None:
        optional = not leafmandatory
    parent = leaf.parent
    if isinstance(parent, DList):
        if leaf.name in parent.key:
            optional = False
    optional_str = "?" if optional else ""
    t = yang_type_to_acton_type(leaf.type_)
    return optional_str + t

def yang_leaf_to_getval(leaf: DNodeLeaf) -> str:
    optional = True
    leafmandatory = leaf.mandatory
    if leafmandatory is not None:
        optional = not leafmandatory
    parent = leaf.parent
    if isinstance(parent, DList):
        if leaf.name in parent.key:
            optional = False
    optional_str = "opt_" if optional else ""
    t = yang_type_to_acton_type(leaf.type_)
    return optional_str + t

def yang_type_to_acton_type(t: ?Type) -> str:
    # +---------------------+-------------------------------------+
    # | Name                | Description                         |
    # +---------------------+-------------------------------------+
    # | binary              | Any binary data                     |
    # | bits                | A set of bits or flags              |
    # | boolean             | "true" or "false"                   |
    # | decimal64           | 64-bit signed decimal number        |
    # | empty               | A leaf that does not have any value |
    # | enumeration         | One of an enumerated set of strings |
    # | identityref         | A reference to an abstract identity |
    # | instance-identifier | A reference to a data tree node     |
    # | int8                | 8-bit signed integer                |
    # | int16               | 16-bit signed integer               |
    # | int32               | 32-bit signed integer               |
    # | int64               | 64-bit signed integer               |
    # | leafref             | A reference to a leaf instance      |
    # | string              | A character string                  |
    # | uint8               | 8-bit unsigned integer              |
    # | uint16              | 16-bit unsigned integer             |
    # | uint32              | 32-bit unsigned integer             |
    # | uint64              | 64-bit unsigned integer             |
    # | union               | Choice of member types              |
    # +---------------------+-------------------------------------+
    if t is not None:
        if t.name == "binary":
            return "bytes"
        elif t.name == "bits":
            raise NotImplementedError('bits not supported')
        elif t.name == "boolean":
            return "bool"
        elif t.name == "decimal64":
            # TODO: do something better
            return "float"
        elif t.name == "empty":
            # TODO: is this right?
            return "bool"
        elif t.name == "enumeration":
            raise NotImplementedError('enumeration not supported')
        elif t.name == "identityref":
            raise NotImplementedError('identityref not supported')
        elif t.name == "instance-identifier":
            raise NotImplementedError('instance-identifier not supported')
        elif t.name == "int8":
            return "i8" # TODO: we don't have i8, right?
        elif t.name == "int16":
            return "i16"
        elif t.name == "int32":
            return "i32"
        elif t.name == "int64":
            return "i64"
        elif t.name == "leafref":
            return "str"
        elif t.name == "string":
            return "str"
        elif t.name == "uint8":
            return "u8" # TODO: we don't have u8, right?
        elif t.name == "uint16":
            return "u16"
        elif t.name == "uint32":
            return "u32"
        elif t.name == "uint64":
            return "u64"
        elif t.name == "union":
            # TODO: blargh, implement once we have unions in Acton
            raise NotImplementedError('union not supported')
        else:
            raise ValueError("Unknown YANG type: " + t.name)
    raise ValueError("type not defined")


def _get_full_name(dnode: DNode) -> str:
    """
    """
    path = []
    while True:
        path.append(dnode.name)
        parent = dnode.parent
        if parent is not None:
            dnode = parent
        else:
            break
    if len(path) == 0:
        raise ValueError("No path for DNode" + str(dnode))
    return "__".join(reversed(path))


# -- end of manually defined schema functions, automatically generated code follows
