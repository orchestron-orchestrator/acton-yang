

class ResolvedType(Type):
    resolved_base_typedef: ?Typedef
    resolved_path: ?xpath.AbsoluteLocationPath

    def __init__(self, name: str, base: list[str]=[], bit: list[Bit]=[], enum: list[Enum]=[], fraction_digits: ?int=None, length: ?Length=None, path: ?str=None, pattern: list[Pattern]=[], range_: ?Range=None, require_instance: ?bool=None, type_: list[Type]=[], exts=[], parent=None, mod=None, ns=None, pfx=None, resolved_base_typedef=None, resolved_path: ?xpath.AbsoluteLocationPath=None):
        Type.__init__(self, name, base, bit, enum, fraction_digits, length, path, pattern, range_, require_instance, type_, exts, parent, mod, ns, pfx)
        self.resolved_base_typedef = resolved_base_typedef
        self.resolved_path = resolved_path
        path = self.path

    def resolve_type(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None, recursion_level=0, _top_name: ?str=None):
        new_name = self.name

        if self.name not in _builtin_types:
            orig_prefix = self.get_prefix()
            if new_pfx is not None and new_pfx != orig_prefix:
                # Add explicit prefix when part of grouping expanded into other module
                prefix, name = split_prefix_name(self.name)
                if prefix is None:
                    new_name = "{orig_prefix}:{name}"

        new = ResolvedType(new_name,
                   base=self.base,
                   bit=self.bit,
                   enum=self.enum,
                   fraction_digits=self.fraction_digits,
                   length=self.length,
                   path=self.path,
                   pattern=self.pattern,
                   range_=self.range_,
                   require_instance=self.require_instance,
                   type_=self.type_,
                   exts=self.exts,
                   mod=new_mod if new_mod is not None else self.mod,
                   ns=new_ns if new_ns is not None else self.ns,
                   pfx=new_pfx if new_pfx is not None else self.pfx,
                   resolved_base_typedef=self.resolved_base_typedef,
                   resolved_path=self.resolved_path)
        return new

    def resolve_compiled_schema_path_dependencies(self):
        xpath_context_node = self.parent
        if xpath_context_node is not None:
            self.resolve_leafref_path(xpath_context_node)
        else:
            raise ValueError("Unable to find ancestor path due to unset parent")

    def to_dtype(self, context: DTypeContext) -> DType:
        try:
            return DType.from_resolved_type(self, context)
        except ValueError as ex:
            def get_path():
                path = []
                n = self.parent
                while True:
                    _n = n
                    if _n is not None:
                        if isinstance(_n, Module):
                            break
                        _argname = _n._get_argname()
                        if _argname is not None and _argname == 'name':
                            _name = _n._get_arg()
                            if _name is not None:
                                _prefix = _n.get_prefix()
                                path.append("{_prefix}:{_name}" if _prefix is not None else _name)
                        n = _n.parent
                    else:
                        break
                return "".join(["/{s}" for s in reversed(path)])
            raise ValueError("Failed to resolve type at {get_path()}: {ex.error_message}")

    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:
        """Remaps prefix references (in paths, defaults, ...) to true module prefix.
        """

        Type.remap_prefix_references(self, old_pfx, new_pfx)
        self_resolved_base_typedef = self.resolved_base_typedef
        if self_resolved_base_typedef is not None:
            self_resolved_base_typedef.remap_prefix_references(old_pfx, new_pfx)

    def resolve_leafref_path(self, xpath_context_node):
        # Resolve base
        _resolved_base_typedef = self.resolved_base_typedef
        if _resolved_base_typedef is not None:
            _base_type = _resolved_base_typedef.type_
            if isinstance(_base_type, ResolvedType):
                _base_type.resolve_leafref_path(xpath_context_node)
            else:
                raise ValueError("Expected ResolvedType")

        # Resolve union members
        for alt_type in self.type_:
            if isinstance(alt_type, ResolvedType):
                alt_type.resolve_leafref_path(xpath_context_node)
            else:
                raise ValueError("Expected ResolvedType")

        # Resolve self
        path = self.path
        if path is not None:
            location_path = xpath.try_parse_location_path(path)
            if location_path is not None:
                if isinstance(location_path, xpath.AbsoluteLocationPath):
                    absolute_path = location_path.steps
                elif isinstance(location_path, xpath.RelativeLocationPath):
                    reverse_base_path: list[xpath.Step] = []
                    n = xpath_context_node
                    while True:
                        _n = n
                        if _n is not None:
                            unalias_pfx = _n.pfx if _n.pfx != xpath_context_node.pfx else None
                            if isinstance(_n, Container):
                                reverse_base_path.append(xpath.NodeTestStep(unalias_pfx, _n.name, []))
                            elif isinstance(_n, List):
                                reverse_base_path.append(xpath.NodeTestStep(unalias_pfx, _n.name, []))
                            elif isinstance(_n, Leaf):
                                reverse_base_path.append(xpath.NodeTestStep(unalias_pfx, _n.name, []))
                            elif isinstance(_n, LeafList):
                                reverse_base_path.append(xpath.NodeTestStep(unalias_pfx, _n.name, []))
                            elif isinstance(_n, Module):
                                break
                            elif isinstance(_n, Grouping) or isinstance(_n, Augment) or isinstance(_n, Typedef):
                                return # Only resolve compiled data-path instances!
                            n = _n.parent
                        else:
                            break
                    absolute_path = list(reversed(reverse_base_path))
                    absolute_path.extend(location_path.steps)
                else:
                    raise NotImplementedError("Unhandled type {type(location_path)}")

                resolved_path = []
                for step in absolute_path:
                    if isinstance(step, xpath.NodeTestStep):
                        resolved_path.append(step)
                    elif isinstance(step, xpath.AbbreviatedStep):
                        if step.step == "..":
                            try:
                                resolved_path.pop()
                            except Exception:
                                raise ValueError("Unable to resolve leafref path: {path}")
                self.resolved_path = xpath.AbsoluteLocationPath(resolved_path)
            else:
                raise ValueError("Unable to parse leafref path: {path}")


extension ResolvedType(Hashable):
    def __eq__(self, other: ResolvedType) -> bool:
        return self.name == other.name \
            and self.mod == other.mod \
            and self.ns == other.ns \
            and self.pfx == other.pfx \
            and self.base == other.base \
            and self.bit == other.bit \
            and self.enum == other.enum \
            and self.fraction_digits == other.fraction_digits \
            and self.length == other.length \
            and self.path == other.path \
            and self.pattern == other.pattern \
            and self.range_ == other.range_ \
            and self.require_instance == other.require_instance \
            and self.type_ == other.type_ \
            and self.resolved_path == other.resolved_path

    def hash(self, hasher):
        # TODO: Cache Hash calculation?
        # Hash non-builtins right here as they implement Ord and therefore can't
        # implement Hashable until https://github.com/actonlang/acton/issues/1126 is solved
        self.name.hash(hasher)
        _mod = self.mod
        if _mod is not None:
            _mod.hash(hasher)
        _ns = self.ns
        if _ns is not None:
            _ns.hash(hasher)
        _pfx = self.pfx
        if _pfx is not None:
            _pfx.hash(hasher)
        for base in self.base:
            base.hash(hasher)
        for bit in self.bit:
            bit.name.hash(hasher)
            _position = bit.position
            if _position is not None:
                _position.hash(hasher)
        for enum in self.enum:
            enum.name.hash(hasher)
            _value = enum.value
            if _value is not None:
                _value.hash(hasher)
        _fraction_digits = self.fraction_digits
        if _fraction_digits is not None:
            _fraction_digits.hash(hasher)
        _length = self.length
        if _length is not None:
            _length.value.hash(hasher)
        _path = self.path
        if _path is not None:
            _path.hash(hasher)
        for pattern in self.pattern:
            pattern.value.hash(hasher)
            _modifier = pattern.modifier
            if _modifier is not None:
                _modifier.hash(hasher)
        _range = self.range_
        if _range is not None:
            _range.value.hash(hasher)
        _require_instance = self.require_instance
        if _require_instance is not None:
            _require_instance.hash(hasher)
        for alt_type in self.type_:
            if isinstance(alt_type, ResolvedType):
                alt_type.hash(hasher)
        _resolved_path = self.resolved_path
        if _resolved_path is not None:
            _resolved_path.hash(hasher)


def find_identity_by_ref(identities: list[DIdentity], name: str, namespace: ?str=None, module: ?str=None, prefix: ?str=None) -> ?DIdentity:
    """Find an identity by name and optionally namespace or module"""
    for identity in identities:
        if identity.name == name:
            if namespace is not None and identity.namespace == namespace:
                return identity
            elif module is not None and identity.module == module:
                return identity
            elif prefix is not None and identity.prefix == prefix:
                return identity
    return None


def complete_identityref(partial: value, identities: list[DIdentity], current_module: str) -> (?Identityref, ?DIdentity, ?str):
    """Complete an Identityref by filling in missing namespace or module, if only one is set"""
    if isinstance(partial, Identityref):
        identity = find_identity_by_ref(identities, partial.val, namespace=partial.ns, module=partial.mod, prefix=partial.pfx)
        if identity is not None:
            return partial, identity, None
        else:
            return None, None, "Identityref {partial.val} not found in namespace={partial.ns} module={partial.mod} prefix={partial.pfx}"
    elif isinstance(partial, PartialIdentityref):
        partial_ns = partial.ns
        partial_mod = partial.mod
        partial_pfx = partial.pfx
        if partial_ns is None and partial_mod is None and partial_pfx is None:
            identity = find_identity_by_ref(identities, partial.val, module=current_module)
            if identity is not None:
                complete = Identityref(partial.val, identity.namespace, identity.module, identity.prefix)
                return complete, identity, None
            else:
                return None, None, "Identityref {partial.val} not found in current module {current_module}"
        else:
            # Have namespace or module (also both, but that doesn't happen when we parse XML / JSON)
            identity = find_identity_by_ref(identities, partial.val, namespace=partial_ns, module=partial_mod, prefix=partial_pfx)
            if identity is not None:
                complete = Identityref(partial.val, identity.namespace, identity.module, identity.prefix)
                return complete, identity, None
            else:
                return None, None, "Identityref {partial.val} not found in namespace={partial.ns} module={partial.mod} prefix={partial.pfx}"
    else:
        raise ValueError('"partial" argument type is a union of Identityref, PartialIdentityref')


def is_derived_from(identity: DIdentity, bases: list[DIdentity]) -> bool:
    """Check if an identity is derived from all of the given base identities"""
    if len(bases) == 0:
        return False

    for base in bases:
        # Validate that identity is derived from all provided base identities.
        # Use depth-first search that requires at least one hop; base is not considered derived
        stack: list[(DIdentity, int)] = [(identity, 0)]
        visited = set()
        while len(stack) > 0:
            candidate, depth = stack.pop()
            key = candidate.module + ":" + candidate.name
            if key in visited:
                continue
            visited.add(key)

            if depth > 0 and candidate.module == base.module and candidate.name == base.name:
                break
            for parent in candidate.base:
                stack.append((parent, depth + 1))
        else:
            return False
    return True


# partial is a union of Identityref, PartialIdentityref
def complete_and_validate_identityref(partial: value, identities: list[DIdentity], bases: list[DIdentity], current_module: str) -> (?Identityref, ?str):
    identityref, identity, error = complete_identityref(partial, identities, current_module)
    if identity is not None:
        if is_derived_from(identity, bases):
            return identityref, None
        else:
            return None, "Identityref {identityref} not derived from all of the required bases: {bases}"
    return None, error


def list_keys(node: DNodeInner) -> ?list[str]:
    if isinstance(node, DList):
        return node.key


def remap_path_prefix(path: str, old_prefix: str, new_prefix: str) -> str:
    """Remap prefix in augment/deviation paths from old to new prefix

    Example: "/old:foo/old:bar/baz" -> "/new:foo/new:bar/baz"
    """
    if old_prefix == new_prefix:
        return path
    elif old_prefix not in path:
        return path

    # Split path into segments
    segments = path.split("/")
    result = []

    for segment in segments:
        sp = segment.split(":", 1)
        if len(sp) > 1:
            prefix = sp[0]
            name = sp[1]
            if prefix == old_prefix:
                result.append(new_prefix + ":" + name)
            else:
                result.append(segment)
        else:
            result.append(segment)

    return "/".join(result)


def stmt_to_smodule(stmt):
    m = stmt_to_snode(stmt)
    if isinstance(m, Module):
        return m
    raise ValueError("Expected a module, got {type(m)}")


def escape_as_fstr(s: str) -> str:
    parts = []
    s_len = len(s)
    b = 0

    def copy_until(b, i):
        if i > b:
           parts.append(s[b:i])
        return i

    def replace(b, i, p, skip=1):
        new_b = copy_until(b, i)
        parts.append(p)
        return new_b + skip

    for i in range(0, s_len):
        c = s[i]
        if c == '\\':
            b = replace(b, i, "\\\\")
        elif c == '{{':
            b = replace(b, i, "{{{{")
        elif c == '}}':
            b = replace(b, i, "}}}}")
        elif c == '\'':
            b = replace(b, i, "\\\'")
        elif c == '%':
            b = replace(b, i, "\\x25") # Workaround ...

    copy_until(b, s_len)

    return "".join(parts)
