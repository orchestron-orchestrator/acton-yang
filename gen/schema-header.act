# schema-header.act is the manually defined part of the schema.act that goes
# first, where the middle part of the file is generated by rfcgen by reading the
# RFC and finally schema-footer.act is appended at the end to produce the final
# schema.act module.
#
# YANG schema
#
# This is an object model for YANG schema, based on YANG 1.1 although it should
# mostly work for YANG 1.0 just fine. There is no logic for either schema or
# data validation, so it is possible to represent an invalid schema using this
# model.
#
# - Statement: low level representation of a YANG schema as a tree of statements
# - SchemaNode: higher level representation of a YANG schema as a tree of schema nodes
# - DNode: the derived data node schema, similar to SchemaNode but for data
#   - typedefs & leaf(-list) types are resolved to their base types
#   - uses / groupings are expanded
#   - augments are applied
#
# There are two "levels" of object representation where the first low level
# representation is that of Statement. Everything in a YANG model is a
# statement, so this representation is fairly close to the YANG source code.
# For example, the order of all statements is preserved, so this model:
#
#    module foo {
#      prefix "f";
#      namespace "http://example.com/foo";
#    }
#
# Would become:
#
#   Statement("module", "foo", substatements=[
#     Statement("prefix", "f"),
#     Statement("namespace", "http://example.com/foo")
#   ])
#
# Whitespace, indentation and comments are not preserved but all parsed
# statements are. Thus if the Statements are rendered back to YANG source, it
# would look exactly like the original source code, presuming the use of
# canonical YANG formatting.
#
# The second level is that of schema nodes and is represented by the SchemaNode
# class. The SchemaNode class is a base class for all schema node types, such as
# Module, Container, List, Leaf, etc. There is a broad division between
# SchemaNodeInner, which are "inner" nodes in the schema that contain other
# nodes, e.g. have children, and SchemaNodeOuter which are the "outer" / leaf
# nodes of the tree that do not have any children. Different statements are
# modeled using discrete classes and statements that relate to a particular
# statement are attributes of that object class rather than being seen as just a
# tree of statements. For example, the following model:
#
#   module foo {
#     prefix "f";
#     namespace "http://example.com/foo";
#     container c1 {
#       leaf l1 {
#         type string;
#       }
#     }
#   }
#
# Would become:
#
#   Module("foo", namespace="http://example.com/foo", prefix="f", children=[
#     Container("c1", children=[
#       Leaf("l1", type_="string")
#     ])
#   ])
#
# Rendering that back to YANG source code will render the namespace & prefix
# statements in the canonical order specified by the YANG RFC, thus rendering
# the following:
#
#    module foo {
#      prefix "f";
#      namespace "http://example.com/foo";
#      container c1 {
#        leaf l1 {
#          type string;
#        }
#      }
#    }
#
# This higher layer SchemaNode representation is not suitable if it is desirable
# to keep statement order from the original source document (be aware that even
# with the lower leve Statement representation, whitespace & comments are still
# lost).
#
# Finally, the DNode representation is similar to the SchemaNode but focuses
# solely on the data nodes. We can think of it as "data nodes" or the "derived"
# schema (a term commonly used in the IETF to describe the result of compiling a
# YANG module). We can convert a SchemaNode tree to DNode by first compiling it
# and then running .to_dnode().

import re

RECURSION_LIMIT = 512

def _yind(n):
    return "  " * n

def _ind(n):
    return "    " * n

_builtin_types = {
    "binary",
    "bits",
    "boolean",
    "decimal64",
    "empty",
    "enumeration",
    "identityref",
    "instance-identifier",
    "int8",
    "int16",
    "int32",
    "int64",
    "leafref",
    "string",
    "uint8",
    "uint16",
    "uint32",
    "uint64",
    "union"
}

# We always quote the arguments to these keywords regardless of the content.
# This is not a strict requirement but a preference of the authors, for example
# the argument "foo" is perfectly valid with out quotes.
_quoted_arg_keywords = set([
    "argument",
    "augment",
    "contact",
    "default",
    "description",
    "length",
    "if-feature",
    "must",
    "namespace",
    "organization",
    "pattern",
    "prefix",
    "range",
    "reference",
    "refine",
    "when",
    "yang-version",
])

class Statement(object):
    kw: str
    arg: ?str
    prefix: ?str
    substatements: list[Statement]
    def __init__(self, kw: str, arg: ?str=None, prefix: ?str=None):
        self.kw = kw
        self.arg = arg
        self.prefix = prefix
        self.substatements = []

    def get_subarg(self, kw: str) -> ?str:
        for substatement in self.substatements:
            if substatement.kw == kw:
                return substatement.arg

    def get_subarg_bool(self, kw: str) -> ?bool:
        for substatement in self.substatements:
            if substatement.kw == kw:
                arg = substatement.arg
                if arg is not None:
                    return bool(arg)

    def pryang(self, indent=0):
        """Print YANG source code for this statement and its substatements
        """
        res = _yind(indent)
        prefix = self.prefix
        if prefix != None:
            res += prefix + ":"
        res += self.kw
        arg = self.arg
        if arg is not None:
            # Always quote the argument if the argument contains any character
            # that require quoting to make it valid YANG (RFC 7950, section 6.1.3):
            res += " "
            m = re.match(r"[\s'\";{}]|//|/\\*|\\*/", arg)
            quoted_arg = True if self.kw in _quoted_arg_keywords or m != None else False
            if quoted_arg:
                res += '"' + arg.replace('\\', '\\\\').replace('"', '\\"') + '"'
            else:
                res += arg
        if len(self.substatements) == 0:
            res += ";\n"
        else:
            res += " {\n"
            for substatement in self.substatements:
                res += substatement.pryang(indent+1)
            res += _yind(indent) + "}\n"
        return res


# YANG schema for data / the derived schema
#
# DNode provides a concrete YANG schema representation of a data tree. Unlike
# SchemaNode, which has a focus on properly representing the YANG schema
# document itself, including abstract concepts like imports, inherited types,
# groupings and augments, this module focuses on the statements relevant for
# representing a YANG modeled data tree. The data nodes in YANG are:
# - container, list, leaf, leaf-list, anydata, anyxml and the module itself can be
#   considered a form of container
# A YANG schema can be compiled into these data nodes, for example by expanding
# uses statements with the relevant groupings into the actual nodes and by
# applying augment statements to the relevant nodes.
#
# Similarly, concepts like config is represented as a boolean here, since all
# nodes are either config or not config, whereas in yang.schema, config is a
# tri-state value, since it can be None, meaning that the value is inherited from
# the parent node. Things like this makes it easier to work with the data tree
# from this module.
#
# Another concept is DTree which is a special node that acts as the virtual root
# of the data tree which can contain multiple YANG modules.

def optional_subtree(node: DNodeInner) -> bool:
    """Checks if a subtree is optional

    Returns True if the subtree is optional or False if any child node (or
    grandchild etc) is mandatory.
    """
    for child in node.children:
        if isinstance(child, DLeaf):
            if child.mandatory:
                return False
        elif isinstance(child, DLeafList):
            if child.min_elements > 0:
                return False
        elif isinstance(child, DContainer):
            if child.presence:
                return True
            return optional_subtree(child)
        elif isinstance(child, DList):
            if child.min_elements > 0:
                return False
    return True

def dnode_to_gd_type(node: DNode) -> str:
    """Convert DNode to GData type
    """
    if isinstance(node, DLeaf):
        return "Leaf"
    elif isinstance(node, DLeafList):
        return "LeafList"
    elif isinstance(node, DContainer):
        return "Container"
    elif isinstance(node, DList):
        return "List"
    elif isinstance(node, DAnydata):
        return "Anydata"
    elif isinstance(node, DAnyxml):
        return "Anyxml"
    elif isinstance(node, DAction):
        return "Action"
    elif isinstance(node, DRoot):
        return "Container"
    elif isinstance(node, DRpc):
        return "Rpc"
    elif isinstance(node, DInput):
        return "Input"
    elif isinstance(node, DOutput):
        return "Output"
    else:
        raise ValueError("Unknown node type: " + str(type(node)))

def nest(n):
    return " " * n

class DNode(object):
    parent: ?DNode
    gname: str       # The name of the GData class, e.g. "Container" for yang.gdata.Container
    module: str      # The name of the module this node belongs to
    namespace: str
    prefix: str
    name: str
    config: bool
    description: ?str
    reference: ?str
    exts: list[Ext]

    def get(self, name: str) -> DNode:
        """Get child node by name
        """
        if isinstance(self, DNodeInner):
            for child in self.children:
                if isinstance(child, DAction) and child.name == name:
                    return child
                elif isinstance(child, DAnydata) and child.name == name:
                    return child
                elif isinstance(child, DAnyxml) and child.name == name:
                    return child
                elif isinstance(child, DContainer) and child.name == name:
                    return child
                elif isinstance(child, DInput) and name == 'input':
                    return child
                elif isinstance(child, DLeaf) and child.name == name:
                    return child
                elif isinstance(child, DLeafList) and child.name == name:
                    return child
                elif isinstance(child, DList) and child.name == name:
                    return child
                elif isinstance(child, DOutput) and name == 'output':
                    return child
                elif isinstance(child, DRpc) and child.name == name:
                    return child
            raise ValueError(f"Child {name} not found")

        raise ValueError("Unable to get child from non-inner node")

    def prdaclass(self, loose=False, top=True, set_ns=True, schema_ns=set(), gen_json=True, gen_xml=True, include_state=False) -> str:
        """Print the data class for this schema node
        """
        raise NotImplementedError('SchemaNode pdc')

class DNodeInner(DNode):
    children: list[DNode]

    def prdaclass(self, loose=False, top=True, set_ns=True, schema_ns=set(), gen_json=True, gen_xml=True, include_state=False) -> str:
        """Print the data class for this schema node
        """
        if self.namespace != "":
            schema_ns.add(self.namespace)
        res = []
        if top:
            res.append("import base64")
            res.append("import json")
            res.append("import xml")
            res.append("import yang.adata")
            res.append("import yang.gdata")
            res.append("")
            res.append("# == This file is generated ==")
            res.append("")
            res.append("")

        # Reorder children so that positional arguments, like list keys, come first
        new_children = []
        pos_child_idx = 0
        child_names = set()
        child_name_conflicts = set()
        for child in self.children:
            if include_state == False and child.config == False:
                continue
            if isinstance(child, DLeaf) and child.is_key():
                new_children.insert(pos_child_idx, child)
                pos_child_idx += 1
            else:
                new_children.append(child)
            if child.name in child_names:
                child_name_conflicts.add(child.name)
            else:
                child_names.add(child.name)
        self.children = new_children

        def _unique_name(name: str, prefix: str) -> str:
            if name not in child_name_conflicts:
                return name
            return f"{prefix}:{name}"

        def uname(n) -> str:
            return _unique_name(n.name, n.prefix)

        def _unique_safe_name(name: str, prefix: str) -> str:
            unique_name = _unique_name(name, prefix)
            return _safe_name(unique_name).replace(":", "_")

        def usname(n) -> str:
            return _unique_safe_name(n.name, n.prefix)

        def pname(n):
            return get_path_name(n)

        for child in self.children:
            res.append(child.prdaclass(loose=loose, top=False, set_ns=child.namespace!=self.namespace, schema_ns=schema_ns, gen_json=gen_json, gen_xml=gen_xml, include_state=include_state))

        if isinstance(self, DList):
            # List has special handling as it actually results in two classes:
            # - the list itself
            # - the list entry class
            # Here we create the list entry class, the list itself comes later
            res.append(f"class {pname(self)}_entry(yang.adata.MNode):")
        else:
            res.append(f"class {pname(self)}(yang.adata.MNode):")

        for child in self.children:
            if isinstance(child, DLeaf):
                res.append(f"    {usname(child)}: {yang_leaf_to_acton_type(child, loose)}")
            elif isinstance(child, DLeafList):
                res.append(f"    {usname(child)}: {yang_leaflist_to_acton_type(child)}")
            elif isinstance(child, DContainer):
                if child.presence:
                    res.append(f"    {usname(child)}: ?{pname(child)}")
                else:
                    res.append(f"    {usname(child)}: {pname(child)}")
            elif isinstance(child, DNodeInner):
                res.append(f"    {usname(child)}: {pname(child)}")
            elif isinstance(child, DAnydata):
                pass # TODO
            elif isinstance(child, DAnyxml):
                pass # TODO
            elif isinstance(child, DAction):
                pass # TODO
            elif isinstance(child, DRpc):
                pass # TODO
            elif isinstance(child, DInput):
                pass # TODO
            elif isinstance(child, DOutput):
                pass # TODO
            else:
                raise ValueError("unreachable, unknown child type: " + str(type(child)))
        res.append("")
        req_args = []
        opt_args = []
        for child in self.children:
            child_name = _unique_safe_name(child.name, child.prefix)
            if isinstance(child, DContainer):
                if loose or child.presence or optional_subtree(child):
                    opt_args.append(f"{usname(child)}: ?{pname(child)}=None")
                else:
                    req_args.append(f"{usname(child)}: {pname(child)}")
            elif isinstance(child, DLeaf):
                defval = ""
                child_default = child.default
                if not loose and child_default != None:
                    defval = "=None"
                child_arg = f"{usname(child)}: {yang_leaf_to_acton_arg_type(child, loose)}{defval}"
                if is_optional_arg_yang_leaf(child, loose):
                    opt_args.append(child_arg)
                else:
                    req_args.append(child_arg)
            elif isinstance(child, DLeafList):
                opt_args.append(f"{usname(child)}: ?{yang_leaflist_to_acton_type(child)}=None")
            elif isinstance(child, DList):
                opt_args.append(f"{usname(child)}: list[{pname(child)}_entry]=[]")

        init_args_str = ", ".join(["self"] + req_args + opt_args)
        res.append(f"    mut def __init__({init_args_str}):")
        # Set namespace from us
        res.append(f"        self._ns = '{self.namespace}'")

        for child in self.children:
            child_name = _unique_safe_name(child.name, child.prefix)
            if isinstance(child, DContainer):
                if (loose or optional_subtree(child)) and not child.presence:
                    res.append(f"        self.{usname(child)} = {usname(child)} if {usname(child)} is not None else {pname(child)}()")
                else:
                    # NOTE: the default argument for P-container is None, so
                    # although unconditionally set here, it can be None
                    res.append(f"        self.{usname(child)} = {usname(child)}")
            elif isinstance(child, DLeaf):
                child_default = child.default
                if not loose and child_default is not None:
                    res.append(f"        self.{usname(child)} = {usname(child)} if {usname(child)} is not None else {prsrc_literal(child.type_.name, child_default)}")
                else:
                    res.append(f"        self.{usname(child)} = {usname(child)}")
            elif isinstance(child, DLeafList):
                # TODO: this is where we can set the leaf-list to a default value, not []
                res.append(f"        self.{usname(child)} = {usname(child)} if {usname(child)} is not None else []")
            elif isinstance(child, DList):
                res.append(f"        self.{usname(child)} = {pname(child)}(elements={usname(child)})")
        if len(self.children) == 0:
            res.append("        pass")
        res.append("")

        # Handle all P-container children, we want a .create_XXX() method
        # for each that takes as arguments the mandatory children of the
        # container
        for child in self.children:
            if isinstance(child, DContainer) and child.presence:
                pc_args = ["self"]
                for cchild in child.children:
                    if isinstance(cchild, DLeaf):
                        if cchild.mandatory:
                            pc_args.append(_safe_name(cchild.name))
                    elif isinstance(cchild, DContainer):
                        if not (loose or optional_subtree(cchild)):
                            pc_args.append(_safe_name(cchild.name))
                pc_args_str = ", ".join(pc_args)
                pc_args_str1 = ", ".join(pc_args[1:])
                res.append(f"    mut def create_{usname(child)}({pc_args_str}):")
                res.append(f"        res = {pname(child)}({pc_args_str1})")
                res.append(f"        self.{usname(child)} = res")
                res.append("        return res")
                res.append("")

        # .to_gdata()
        res.append("    mut def to_gdata(self) -> yang.gdata.Node:")
        res.append("        children = {}")

        for child in self.children:
            if not isinstance(child, DLeafList):
                res.append(f"        _{usname(child)} = self.{usname(child)}")
            child_ns = ", ns='" + child.namespace + "'" if child.namespace != self.namespace else ""
            if isinstance(child, DLeafList):
                res.append(f"        children['{uname(child)}'] = yang.gdata.LeafList(self.{usname(child)}{child_ns})")
            else:
                res.append(f"        if _{usname(child)} is not None:")
                if isinstance(child, DLeaf):
                    res.append(f"            children['{uname(child)}'] = yang.gdata.Leaf('{child.type_.name}', _{usname(child)}{child_ns})")
                elif isinstance(child, DContainer):
                    res.append(f"            children['{uname(child)}'] = _{usname(child)}.to_gdata()")
                elif isinstance(child, DList):
                    res.append(f"            children['{uname(child)}'] = _{usname(child)}.to_gdata()")

        if isinstance(self, DList):
            # keys contains a yang spec of the keys, like "k1 k2"
            # which are modeled as attributes of the list entry class and accessed via self.k1, self.k2
            list_keys_str = ", ".join(map(lambda x: f"yang.gdata.yang_str(self.{_safe_name(x)})", self.key))
            res.append(f"        return yang.gdata.Container(children, [{list_keys_str}])")
        elif isinstance(self, DRoot):
            res.append(f"        return yang.gdata.{self.gname}(children)")
        elif set_ns:
            if isinstance(self, DContainer) and self.presence:
                res.append(f"        return yang.gdata.{self.gname}(children, presence=True, ns='{self.namespace}')")
            else:
                res.append(f"        return yang.gdata.{self.gname}(children, ns='{self.namespace}')")
        else:
            if isinstance(self, DContainer) and self.presence:
                res.append(f"        return yang.gdata.{self.gname}(children, presence=True)")
            else:
                res.append(f"        return yang.gdata.{self.gname}(children)")
        res.append("")
#
        def _maybe_ns(child: DNode) -> str:
            if child.namespace != self.namespace:
                return f", '{child.namespace}'"
            return ""

        # .from_gdata()
        # TODO: should .from_gdata() not take a specific data node instead, like Container instead of yang.gdata.Node?
        from_gdata_args_list = []
        from_xml_args_list = []
        for child in self.children:
            if isinstance(child, DLeaf):
                from_gdata_args_list.append(f"{usname(child)}=n.get_{yang_leaf_to_getval(child, loose)}('{uname(child)}')")
                from_xml_args_list.append(f"{usname(child)}=yang.gdata.from_xml_{yang_leaf_to_getval(child, loose)}(n, '{child.name}'{_maybe_ns(child)})")
            elif isinstance(child, DLeafList):
                from_gdata_args_list.append(f"{usname(child)}=n.get_{yang_leaf_to_getval(child, loose)}s('{uname(child)}')")
                from_xml_args_list.append(f"{usname(child)}=yang.gdata.from_xml_{yang_leaf_to_getval(child, loose)}s(n, '{child.name}'{_maybe_ns(child)})")
            elif isinstance(child, DContainer):
                if loose or child.presence or optional_subtree(child):
                    from_gdata_args_list.append(f"{usname(child)}={pname(child)}.from_gdata(n.get_opt_container('{uname(child)}'))")
                    from_xml_args_list.append(f"{usname(child)}={pname(child)}.from_xml(yang.gdata.get_xml_opt_child(n, '{child.name}'{_maybe_ns(child)}))")
                else:
                    from_gdata_args_list.append(f"{usname(child)}={pname(child)}.from_gdata(n.get_container('{uname(child)}'))")
                    from_xml_args_list.append(f"{usname(child)}={pname(child)}.from_xml(yang.gdata.get_xml_child(n, '{child.name}'{_maybe_ns(child)}))")
            elif isinstance(child, DList):
                from_gdata_args_list.append(f"{usname(child)}={pname(child)}.from_gdata(n.get_opt_list('{uname(child)}'))")
                from_xml_args_list.append(f"{usname(child)}={pname(child)}.from_xml(yang.gdata.get_xml_children(n, '{child.name}'{_maybe_ns(child)}))")
        from_gdata_args = ", ".join(from_gdata_args_list)
        from_xml_args = ", ".join(from_xml_args_list)
        res.append("    @staticmethod")
        if isinstance(self, DList):
            res.append(f"    mut def from_gdata(n: yang.gdata.Node) -> {pname(self)}_entry:")
            res.append(f"        return {pname(self)}_entry({from_gdata_args})")
        else:
            opt_cnt = True if isinstance(self, DContainer) and self.presence else False
            res.append(f"    mut def from_gdata(n: ?yang.gdata.Node) -> {'?' if opt_cnt else ''}{pname(self)}:")
            res.append("        if n != None:")
            res.append(f"            return {pname(self)}({from_gdata_args})")
            if opt_cnt:
                res.append("        return None")
            elif optional_subtree(self):
                res.append(f"        return {pname(self)}()")
            else:
                res.append(f"        raise ValueError('Missing required subtree {pname(self)}')")
        res.append("")

        res.append("    @staticmethod")
        if isinstance(self, DList):
            res.append(f"    mut def from_xml(n: xml.Node) -> {pname(self)}_entry:")
            res.append(f"        return {pname(self)}_entry({from_xml_args})")
        else:
            opt_cnt = True if isinstance(self, DContainer) and self.presence else False
            res.append(f"    mut def from_xml(n: ?xml.Node) -> {'?' if opt_cnt else ''}{pname(self)}:")
            res.append("        if n != None:")
            res.append(f"            return {pname(self)}({from_xml_args})")
            if opt_cnt:
                res.append("        return None")
            elif optional_subtree(self):
                res.append(f"        return {pname(self)}()")
            else:
                res.append(f"        raise ValueError('Missing required subtree {pname(self)}')")
        res.append("")

        if isinstance(self, DList):
            # List has special handling as it actually results in two classes:
            # - the list itself
            # - the list entry class
            # Here we create the list class, list entry class was created above
            res.append(f"class {pname(self)}(yang.adata.MNode):")
            res.append(f"    elements: list[{pname(self)}_entry]")

            init_args = ["self"]
            init_args.append("elements=[]")
            init_args_str: str = ", ".join(init_args)
            res.append(f"    mut def __init__({init_args_str}):")
            # Set namespace from us
            res.append(f"        self._ns = '{self.namespace}'")
            res.append("        self._name = " + repr(self.name))
            res.append("        self.elements = elements")
            res.append("")

            list_key_args = list(map(lambda x: _safe_name(x), self.key))
            list_key_types = {}
            for child in self.children:
                if isinstance(child, DLeaf):
                    if child.name in self.key:
                        list_key_types[child.name] = child.type_
                        continue
                    if child.mandatory:
                        list_key_args.append(_unique_safe_name(child.name, child.prefix))
                elif isinstance(child, DContainer):
                    if not (loose or optional_subtree(child)):
                        list_key_args.append(_unique_safe_name(child.name, child.prefix))
            list_create_args_str = ", ".join(["self"] + list_key_args)
            res.append(f"    mut def create({list_create_args_str}):")
            res.append("        for e in self.elements:")
            res.append("            match = True")
            for key in self.key:
                unique_base_types = set()
                for t in list_key_types[key].type_:
                    unique_base_types.add(yang_type_to_acton_type(t))
                if len(unique_base_types) <= 1:
                    # Class attribute is a not a "value" Acton type because it
                    # is either not an union or it an union that was resolved
                    # to a single builtin type, it has equality check
                    res.append(f"            if e.{_safe_name(key)} != {_safe_name(key)}:")
                    res.append("                match = False")
                    res.append("                continue")
                else:
                    # Union types for mixed unions are Acton "value" types, so
                    # we need to first attempt to bind them to a more specific type
                    # TODO: use Acton unions
                    for t in unique_base_types:
                        res.append(f"            e_{_safe_name(key)} = e.{_safe_name(key)}")
                        res.append(f"            if isinstance(e_{_safe_name(key)}, {t}) and isinstance({_safe_name(key)}, {t}):")
                        res.append(f"                if e_{_safe_name(key)} != {_safe_name(key)}:")
                        res.append("                    match = False")
                        res.append("                    continue")
            res.append("            if match:")
            res.append("                return e")
            res.append("")
            list_key_args_str = ", ".join(list_key_args)
            res.append(f"        res = {pname(self)}_entry({list_key_args_str})")
            res.append("        self.elements.append(res)")
            res.append("        return res")
            res.append("")

            res.append("    mut def to_gdata(self):")
            res.append("        elements = []")
            res.append("        for e in self.elements:")
            res.append("            e_gdata = e.to_gdata()")                                # child.namespace != self.namespace
            res.append("            if isinstance(e_gdata, yang.gdata.Container):")
            res.append("                elements.append(e_gdata)")
            if set_ns:
                res.append(f"        return yang.gdata.List({repr(self.key)}, elements, ns='{self.namespace}')")
            else:
                res.append(f"        return yang.gdata.List({repr(self.key)}, elements)")
            res.append("")

#            # .from_gdata()
#            # TODO: should .from_gdata() not take a specific data node instead, like Container instead of yang.gdata.Node?
            res.append("    @staticmethod")
            res.append(f"    mut def from_gdata(n: ?yang.gdata.List) -> list[{pname(self)}_entry]:")
            res.append("        res = []")
            res.append("        if n is not None:")
            res.append("            for e in n.elements:")
            res.append(f"                res.append({pname(self)}_entry.from_gdata(e))")
            res.append("        return res")
            #res.append("        return list(map(lambda x: %s_entry.from_gdata(x), n.elements))" % pname(self))
            res.append("")
            res.append("    @staticmethod")
            res.append(f"    mut def from_xml(nodes: list[xml.Node]) -> list[{pname(self)}_entry]:")
            res.append("        res = []")
            res.append("        for node in nodes:")
            res.append(f"            res.append({pname(self)}_entry.from_xml(node))")
            res.append("        return res")
            # TODO: trying to use list(map(lambda)) here results in an error,
            # why? Above code that iterates over n.elements works fine... Error is:
            # ERROR: Error when compiling y_cfs module: Type error
            # mut must be a subclass of pure
            #
            #res.append("        return list(map(lambda x: %s_entry.from_xml(x), nodes))" % pname(self))
            res.append("")
        res.append("")

        # == JSON serde ================================

        # from_json(): from JSON -> gdata
        if gen_json and isinstance(self, DNodeInner):
            fname = "from_json_path"
            if not top:
                fname += "_" + pname(self)

            if isinstance(self, DList):
                res += [f"mut def {fname}_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:"]
                # Unlike other nodes, where the path is consumed an element at a
                # time, we are passed the same path as the list itself, so we
                # can read the key. We are not ready to parse the JSON payload
                # at this point - we must be passed a key!
                res += ["    if len(path) == 1:"]
                res += ["        point = path[0]"]
                res += ["        keys = point.split(\",\")"]
                res += ["        jd_dict = yang.gdata.unwrap_dict(jd)"]
                res += [f"        val = from_json_{pname(self)}_element(jd_dict)"]
                res += ["        if op == \"merge\":"]
                res += ["            return val"]
                res += ["        elif op == \"remove\":"]
                res += ["            return yang.gdata.Absent(val.key)"]
                res += ["        raise ValueError(\"Invalid operation\")"]
                res += ["    elif len(path) > 1:"]
                res += ["        keys = path[0].split(\",\")"]
                res += ["        point = path[1]"]
                res += ["        rest_path = path[2:]"]
                res += ["        children: dict[str, yang.gdata.Node] = {}"]
                for child in self.children:
                    try:
                        idx = self.key.index(child.name)
                        res += [f"        children['{uname(child)}'] = from_json_{pname(child)}(keys[{idx}])"]
                    except KeyError:
                        res += [f"        if point == '{child.name}':"]
                        if isinstance(child, DNodeInner):
                            res += [f"            children['{uname(child)}'] = from_json_path_{pname(child)}(jd, rest_path, op)"]
                        else:
                            res += ["            raise ValueError(\"Invalid json path to non-inner node\")"]
                res += ["        return yang.gdata.Container(children, keys)"]
                res += ["    raise ValueError(\"unreachable - no keys to list element\")"]
                res += [""]

                res.append(f"mut def {fname}(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:")
                res.append("    if len(path) == 1:")
                res.append("        point = path[0]")
                # TODO: URI-unescape keys
                res.append("        keys = point.split(\",\")")
                res.append("        jd_dict = yang.gdata.unwrap_dict(jd)")
                res.append("        # Check that all keys are present in payload.")
                res.append("        # If present, they must equal the keys in the path")
                res.append("        # If not present, fill in from path")
                res.append(f"        for key in {repr(self.key)}:")
                res.append("            if key not in jd_dict:")
                res.append("                jd_dict[key] = keys.pop(0)")
                res.append("            else:")
                res.append("                if str(jd_dict[key]) != keys.pop(0):")
                res.append("                    raise ValueError(\"Key value mismatch between path and payload\")")
                res.append(f"        element = from_json_{pname(self)}_element(jd_dict)")
                res.append("        elements = []")
                res.append("        if op == \"merge\":")
                res.append("            elements.append(element)")
                res.append("        elif op == \"remove\":")
                res.append("            elements.append(yang.gdata.Absent(element.key))")
                res.append(f"        return yang.gdata.List({repr(self.key)}, elements)")
                res.append("    elif len(path) > 1:")
                res.append(f"        return yang.gdata.List({repr(self.key)}, [from_json_path_{pname(self)}_element(jd, path, op)])")
                res.append("    raise ValueError(\"Unable to resolve path, no keys provided\")")

            else:
                res.append(f"mut def {fname}(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:")
                res.append("    # path handling")
                res.append("    if len(path) > 0:")
                res.append("        point = path[0]")
                res.append("        rest_path = path[1:]")
                for child in self.children:
                    if top == True or child.namespace != self.namespace:
                        res.append(f"        if point == '{child.module}:{child.name}':")
                    else:
                        res.append(f"        if point == '{child.module}:{child.name}' or point == '{child.name}':")
                    if isinstance(child, DNodeInner):
                        res += [nest(12) + f"child = {{'{child.name}': from_json_path_{pname(child)}(jd, rest_path, op) }}"]
                        res += [nest(12) + "return yang.gdata." + dnode_to_gd_type(self) + "(child)"]
                    else:
                        res.append("            raise ValueError(\"Invalid json path to non-inner node\")")
                res.append("        raise ValueError(\"Invalid path\")")
                res.append("    elif len(path) == 0:")
                valfname = f"from_json_{pname(self)}" if not top else "from_json"
                val_farg = "[jd]" if isinstance(self, DList) else "yang.gdata.unwrap_dict(jd)"
                res += ["        if op == \"merge\":"]
                res += [f"            return {valfname}({val_farg})"]
                res += ["        elif op == \"remove\":"]
                res += ["            return yang.gdata.Absent()"]
                res += ["        raise ValueError(\"Invalid operation\")"]
                res += ["    raise ValueError(\"Unable to resolve path\")"]

            res.append("")

        if gen_json and isinstance(self, DNodeInner):
            fname = "from_json"
            if not top:
                fname += "_" + pname(self)

            if isinstance(self, DList):
                res.append(f"mut def {fname}_element(jd: dict[str, ?value]) -> yang.gdata.Node:")
            else:
                res.append(f"mut def {fname}(jd: dict[str, ?value]) -> yang.gdata.{dnode_to_gd_type(self)}:")

            res.append("    children = {}")
            for child in self.children:
                if top == True or child.namespace != self.namespace:
                    res.append(f"    child_{usname(child)} = jd.get('{child.module}:{child.name}')")
                else:
                    res.append(f"    child_{usname(child)}_full = jd.get('{child.module}:{child.name}')")
                    res.append(f"    child_{usname(child)} = child_{usname(child)}_full if child_{usname(child)}_full is not None else jd.get('{child.name}')")

                if isinstance(child, DContainer):
                    res.append(f"    if child_{usname(child)} is not None and isinstance(child_{usname(child)}, dict):")
                    res.append(f"        children['{uname(child)}'] = from_json_{pname(child)}(child_{usname(child)})")
                elif isinstance(child, DList):
                    res.append(f"    if child_{usname(child)} is not None and isinstance(child_{usname(child)}, list):")
                    res.append(f"        children['{uname(child)}'] = from_json_{pname(child)}(child_{usname(child)})")
                elif isinstance(child, DLeafList):
                    res.append(f"    if child_{usname(child)} is not None and isinstance(child_{usname(child)}, list):")
                    res.append(f"        children['{uname(child)}'] = from_json_{pname(child)}(child_{usname(child)})")
                else:
                    res.append(f"    if child_{usname(child)} is not None:")
                    res.append(f"        children['{uname(child)}'] = from_json_{pname(child)}(child_{usname(child)})")

            # TODO: need to better handle mandatory nodes... right now I think this JSON parsing is very naive
            #
            # TODO: can we do something like this instead and avoid local variables?
            #for child in self.children:
            #    res += ["    yang.gdata.maybe_add(children, '%s', lambda x: from_json_%s(unwrap_dict(x)) if x is not None else None, yang.gdata.take_json_%s(jd, '%s', '%s'))" % (child.name, taker_name(child, key_required=False), child.name, child.prefix)]

            if isinstance(self, DList):
                list_keys_str = ", ".join(map(lambda x: f"str(child_{_safe_name(x)} if child_{_safe_name(x)} is not None else '')", self.key))
                res.append(f"    return yang.gdata.Container(children, [{list_keys_str}])")
            else:
                res.append(f"    return yang.gdata.{dnode_to_gd_type(self)}(children)")
            res.append("")

        elif gen_json and isinstance(self, DLeaf):
            res.append("# leaf")
            res.append(f"mut def from_json_{pname(self)}(jd: dict[str, ?value]) -> yang.gdata.Leaf:")
            res.append(f"    return yang.gdata.Leaf(jd.get('{self.name}'))")
            res.append("")

        elif gen_json and isinstance(self, DLeafList):
            res.append("# leaflist")
            res.append(f"mut def from_json_{pname(self)}(jd: dict[str, ?value]) -> yang.gdata.LeafList:")
            res.append(f"    return yang.gdata.LeafList(jd.get('{self.name}'))")
            res.append("")

        if gen_json and isinstance(self, DList):
            res.append(f"mut def from_json_{pname(self)}(jd: list[dict[str, ?value]]) -> yang.gdata.List:")
            res.append(f"    elements = []")
            res.append(f"    for e in jd:")
            res.append(f"        if isinstance(e, dict):")
            res.append(f"            elements.append(from_json_{pname(self)}_element(e))")
            res.append(f"    return yang.gdata.List(keys={repr(self.key)}, elements=elements, user_order=False, ns=None, prefix=None)")
            res.append("")

        # to_json(): gdata -> JSON
        if gen_json and isinstance(self, DNodeInner):
            fname = "to_json"
            if not top:
                fname += "_" + pname(self)

            if isinstance(self, DList):
                res.append(f"mut def {fname}_element(n: yang.gdata.Node) -> dict[str, ?value]:")
            else: # DContainer, DModule, DRoot
                res.append(f"mut def {fname}(n: yang.gdata.Node) -> dict[str, ?value]:")

            res.append("    children = {}")
            for child in self.children:
                child_name = f"{child.module}:{child.name}" if child.namespace != self.namespace else child.name
                res.append(f"    child_{usname(child)} = n.children.get('{uname(child)}')")
                res.append(f"    if child_{usname(child)} is not None:")
                if isinstance(child, DLeaf):
                    res.append(f"        if isinstance(child_{usname(child)}, yang.gdata.Leaf):")
                    res.append(f"            children['{child_name}'] = child_{usname(child)}.val")
                elif isinstance(child, DLeafList):
                    res.append(f"        if isinstance(child_{usname(child)}, yang.gdata.LeafList):")
                    res.append(f"            children['{child_name}'] = child_{usname(child)}.vals")
                elif isinstance(child, DContainer):
                    res.append(f"        if isinstance(child_{usname(child)}, yang.gdata.Container):")
                    res.append(f"            children['{child_name}'] = to_json_{pname(child)}(child_{usname(child)})")
                elif isinstance(child, DList):
                    res.append(f"        if isinstance(child_{usname(child)}, yang.gdata.List):")
                    res.append(f"            children['{child_name}'] = to_json_{pname(child)}(child_{usname(child)})")
                else:
                    res.append("        pass")
#                    res.append("    if child_%s is not None:" % (_unique_safe_name(child.name, child.prefix)))
#                    res.append("        children['%s'] = to_json_%s(child_%s)" % (child.name, pname(child), _unique_safe_name(child.name, child.prefix)))

            if isinstance(self, DContainer):
                res.append("    return children")
            elif isinstance(self, DModule):
                res.append("    return children")
            elif isinstance(self, DRoot):
                res.append("    return children")
            elif isinstance(self, DList):
                res.append("    return children")
            res.append("")

        elif gen_json and isinstance(self, DLeaf):
            fname = "to_json_" + pname(self)
            res.append(f"mut def {fname}(ll: yang.gdata.Leaf) -> ?value:")
            res.append(f"    return jd.get('{self.name}'))")
            res.append("")

        elif gen_json and isinstance(self, DLeafList):
            fname = "to_json_" + pname(self)
            res.append(f"mut def {fname}(ll: yang.gdata.LeafList) -> list[value]:")
            res.append(f"    return jd.get('{self.name}'))")
            res.append("")

        if gen_json and isinstance(self, DList):
            fname = "to_json_" + pname(self)
            res.append(f"mut def {fname}(n: yang.gdata.List) -> list[dict[str, ?value]]:")
            res.append("    elements = []")
            res.append("    for e in n.elements:")
            res.append(f"        elements.append(to_json_{pname(self)}_element(e))")
            res.append("    return elements")
            res.append("")

        if top:
            res.append("schema_namespaces: set[str] = {")
            for ns in schema_ns:
                res.append(f"    '{ns}',")
            res.append("}")
            res.append("")

        return "\n".join(res)

class DNodeLeaf(DNode):
    if_feature: list[str]
    mandatory: bool
    must: list[Must]
    status: ?str
    type_: Type
    when: ?str

class DAction(DNodeInner):
    if_feature: list[str]
    must: list[Must]
    status: ?str

    def __init__(self, module: str, namespace: str, prefix: str, name: str, description: ?str=None, if_feature=[], reference=None, status=None, exts=[], children=[]):
        self.module = module
        self.namespace = namespace
        self.prefix = prefix
        self.name = name
        self.gname = "Action"
        self.config = False
        self.description = description
        self.if_feature = if_feature
        self.reference = reference
        self.status = status
        self.exts = exts
        self.children = children

class DAnydata(DNode):
    if_feature: list[str]
    mandatory: ?bool
    must: list[Must]
    status: ?str
    when: ?str

    def __init__(self, module: str, namespace: str, prefix: str, name: str, config: bool, description: ?str=None, if_feature: list[str]=[], mandatory: ?bool=None, must: list[Must]=[], reference: ?str=None, status: ?str=None, when: ?str=None, exts=[]):
        self.module = module
        self.namespace = namespace
        self.prefix = prefix
        self.name = name
        self.gname = "Anydata"
        self.config = config
        self.description = description
        self.if_feature = if_feature
        self.mandatory = mandatory
        self.must = must
        self.reference = reference
        self.status = status
        self.when = when
        self.exts = exts

class DAnyxml(DNode):
    if_feature: list[str]
    mandatory: ?bool
    must: list[Must]
    status: ?str
    when: ?str

    def __init__(self, module: str, namespace: str, prefix: str, name: str, config: bool, description: ?str=None, if_feature: list[str]=[], mandatory: ?bool=None, must: list[Must]=[], reference: ?str=None, status: ?str=None, when: ?str=None, exts=[]):
        self.module = module
        self.namespace = namespace
        self.prefix = prefix
        self.name = name
        self.gname = "Anyxml"
        self.config = config
        self.description = description
        self.if_feature = if_feature
        self.mandatory = mandatory
        self.must = must
        self.reference = reference
        self.status = status
        self.when = when
        self.exts = exts

class DContainer(DNodeInner):
    if_feature: list[str]
    must: list[Must]
    presence: bool
    status: ?str

    def __init__(self, module: str, namespace: str, prefix: str, name: str, config: bool, description: ?str=None, if_feature=[], must=[], presence: bool, reference=None, status=None, when=None, exts=[], children=[]):
        self.module = module
        self.namespace = namespace
        self.prefix = prefix
        self.name = name
        self.gname = "Container"
        self.config = config
        self.description = description
        self.if_feature = if_feature
        self.must = must
        self.presence = presence
        self.reference = reference
        self.status = status
        self.exts = exts
        self.children = children

class DInput(DNodeInner):
    must: list[Must]

    def __init__(self, module: str, namespace: str, prefix: str, must=[], exts=[], children=[]):
        self.module = module
        self.namespace = namespace
        self.prefix = prefix
        self.name = "input"
        self.gname = "Input"
        self.config = False
        self.must = must
        self.exts = exts
        self.children = children

class DModule(DNodeInner):
    augment: list[Augment]
    contact: ?str
    deviation: list[str]
    extension_: list[Extension]
    feature: list[Feature]
    import_: list[Import]
    include: list[Include]
    organization: ?str
    revision: list[Revision]
    yang_version: float

    def __init__(self, module: str, namespace: str, prefix: str, name: str, yang_version: ?float, description: ?str=None, contact=None, deviation=[], extension_=[], feature=[], import_=[], include=[], organization=None, reference=None, revision=[], exts=[], children=[]):
        self.module = module
        self.name = name
        self.gname = "Container"
        self.namespace = namespace
        self.prefix = prefix
        if yang_version is not None:
            self.yang_version = yang_version
        else:
            self.yang_version = 1.1
        self.config = True # module is not config in itself, but it is the root
                           # of the data tree and the default is config=True, so
                           # we set it here
        self.description = description
        self.contact = contact
        self.deviation = deviation
        self.extension_ = extension_
        self.feature = feature
        self.import_ = import_
        self.include = include
        self.organization = organization
        self.reference = reference
        self.revision = revision
        self.exts = exts
        self.children = children

class DList(DNodeInner):
    if_feature: list[str]
    key: list[str]
    max_elements: ?int
    min_elements: int
    must: list[Must]
    ordered_by: str
    status: ?str
    unique: list[str]
    when: ?str

    def __init__(self, module: str, namespace: str, prefix: str, name: str, key: list[str], config: bool, description: ?str=None, if_feature=[], max_elements: ?int=None, min_elements=0, must=[], ordered_by="system", reference=None, status=None, unique=[], when=None, exts=[], children=[]):
        self.module = module
        self.namespace = namespace
        self.prefix = prefix
        self.name = name
        self.gname = "List"
        self.key = key
        self.config = config
        self.description = description
        self.if_feature = if_feature
        self.max_elements = max_elements
        self.min_elements = min_elements
        self.must = must
        self.ordered_by = ordered_by
        self.reference = reference
        self.status = status
        self.unique = unique
        self.when = when
        self.exts = exts
        self.children = children

class DLeaf(DNodeLeaf):
    default: ?str
    units: ?str

    def __init__(self, module: str, namespace: str, prefix: str, name: str, config: bool, description: ?str=None, default=None, if_feature=[], mandatory=False, must=[], reference=None, status=None, type_: Type, units=None, when=None, exts=[]):
        self.module = module
        self.namespace = namespace
        self.prefix = prefix
        self.name = name
        self.gname = "Leaf"
        self.config = config
        self.description = description
        self.default = default
        self.if_feature = if_feature
        self.mandatory = mandatory
        self.must = must
        self.reference = reference
        self.status = status
        self.type_ = type_
        self.units = units
        self.when = when
        self.exts = exts

    def is_key(self) -> bool:
        parent = self.parent
        if isinstance(parent, DList):
            if self.name in parent.key:
                return True
        return False

    def prdaclass(self, loose=False, top=True, set_ns=True, schema_ns=set(), gen_json=True, gen_xml=True, include_state=False) -> str:
        if self.namespace != "":
            schema_ns.add(self.namespace)
        if include_state == False and self.config == False:
            return ""
        def pname(n):
            return get_path_name(n)
        res = []
        if gen_json:
            res.append(f"mut def from_json_{pname(self)}(val: value) -> yang.gdata.Leaf:")
            res.append(f"    return yang.gdata.Leaf('{self.type_.name}', val)")
            res.append("")
        return "\n".join(res)


class DLeafList(DNodeLeaf):
    default: ?list[str]
    max_elements: ?int
    min_elements: int
    ordered_by: str
    units: ?str

    def __init__(self, module: str, namespace: str, prefix: str, name: str, config: bool, description: ?str=None, default=None, if_feature=[], max_elements: ?int=None, min_elements=0, must=[], ordered_by="system", reference=None, status=None, type_: Type, units=None, when=None, exts=[]):
        self.module = module
        self.namespace = namespace
        self.prefix = prefix
        self.name = name
        self.gname = "LeafList"
        self.config = config
        self.description = description
        self.default = default
        self.if_feature = if_feature
        self.max_elements = max_elements
        self.min_elements = min_elements
        self.must = must
        self.ordered_by = ordered_by
        self.reference = reference
        self.status = status
        self.type_ = type_
        self.units = units
        self.when = when
        self.exts = exts

    def prdaclass(self, loose=False, top=True, set_ns=True, schema_ns=set(), gen_json=True, gen_xml=True, include_state=False) -> str:
        if self.namespace != "":
            schema_ns.add(self.namespace)
        if include_state == False and self.config == False:
            return ""
        def pname(n):
            return get_path_name(n)
        res = []
        if gen_json:
            res.append(f"mut def from_json_{pname(self)}(val: list[value]) -> yang.gdata.LeafList:")
            res.append("    return yang.gdata.LeafList(val)")
            res.append("")
        return "\n".join(res)


class DNotification(DNodeInner):
    status: ?str

    def __init__(self, module: str, namespace: str, prefix: str, name: str, description: ?str=None, if_feature=[], must=[], reference=None, status=None, exts=[], children=[]):
        self.module = module
        self.namespace = namespace
        self.prefix = prefix
        self.name = name
        self.gname = "Notification"
        self.description = description
        self.reference = reference
        self.status = status
        self.exts = exts
        self.children = children

class DOutput(DNodeInner):
    must: list[Must]

    def __init__(self, module: str, namespace: str, prefix: str, must=[], exts=[], children=[]):
        self.module = module
        self.namespace = namespace
        self.prefix = prefix
        self.name = "output"
        self.gname = "Output"
        self.config = False
        self.must = must
        self.exts = exts
        self.children = children

class DRoot(DNodeInner):
    def __init__(self, modules: list[DNode]=[]):
        self.namespace = ""
        self.prefix = ""
        self.name = "root"
        self.gname = "Container"
        self.config = True
        self.children=[]
        for module in modules:
            if isinstance(module, DModule):
                for child in module.children:
                    self.children.append(child)
            else:
                raise ValueError("DRoot can only contain DModule")

class DRpc(DNodeInner):
    if_feature: list[str]
    must: list[Must]
    status: ?str

    def __init__(self, module: str, namespace: str, prefix: str, name: str, description: ?str=None, if_feature=[], reference=None, status=None, exts=[], children=[]):
        self.module = module
        self.namespace = namespace
        self.prefix = prefix
        self.name = name
        self.gname = "Rpc"
        self.config = False
        self.description = description
        self.if_feature = if_feature
        self.reference = reference
        self.status = status
        self.exts = exts
        self.children = children

# -------------------------------------------------------------------------------

def split_prefix_name(name: str) -> (?str, str):
    if name.find(":") != -1:
        parts = name.split(":", 1)
        return (parts[0], parts[1])
    return None, name

# -------------------------------------------------------------------------------

class ModRev(object):
    modname: str
    rev: ?str

    def __init__(self, modname: str, rev: ?str):
        self.modname = modname
        self.rev = rev

extension ModRev (Hashable):
    def __eq__(self, other: ModRev) -> bool:
        return self.modname == other.modname and self.rev == other.rev

    def __hash__(self) -> int:
        selfrev = self.rev
        revstr = selfrev if selfrev is not None else ""
        # TODO: actually include revision in hash
        #return self.modname.__hash__() + revstr.__hash__()
        return self.modname.__hash__()

class Context(object):
    """Compilation context
    """
    modules: dict[ModRev, Module]

    def __init__(self, modules: list[Module]=[]):
        self.modules = {}
        for thing in modules:
            self.add_module(thing)

    def add_module(self, module: Module):
        latest_revision = module.get_revision()
        mod_rev = ModRev(module.name, latest_revision.date if latest_revision is not None else None)
        self.modules[mod_rev] = module

        # Now also add the module itself without revision
        no_rev_mod = ModRev(module.name, None)
        if no_rev_mod in self.modules:
            existing_revision = self.modules[no_rev_mod].get_revision()
            if existing_revision is not None and latest_revision is not None:
                if latest_revision.date > existing_revision.date:
                    # Currently added module has a revision that is newer, so it
                    # should replace the existing module
                    self.modules[no_rev_mod] = module
                # Otherwise, the existing module is newer, so we should keep it
                return
            elif existing_revision is None and latest_revision is not None:
                # Currently added module has a revision, but existing module does not
                # so we presume that we're adding a newer version of the module
                self.modules[no_rev_mod] = module
            # Otherwise, both modules have no revision, so we keep the existing one
            return
        else: # No module with this name exists yet
            self.modules[no_rev_mod] = module

    def get_module(self, modname: str, rev: ?str) -> Module:
        mod_rev = ModRev(modname, rev)
        try:
            mod = self.modules[mod_rev]
            return mod
        except KeyError:
            raise ValueError(f"Module {modname} rev {rev} not found in compilation context")

    def get_modules(self) -> list[Module]:
        return list(self.modules.values())


class SchemaNode(object):
    parent: ?SchemaNode
    mod: ?str
    ns: ?str
    pfx: ?str
    exts: list[Ext]
    _yname: str

    def _get_argname(self) -> ?str:
        raise NotImplementedError('SchemaNode _get_argname')

    def _get_arg(self) -> ?str:
        raise NotImplementedError('SchemaNode _get_arg')

    def get_attrs(self) -> list[(str, ?value)]:
        raise NotImplementedError('SchemaNode get_attrs')

    _get_class_name: pure() -> str

    def prsrc(self, indent=0):
        """Print Acton source code for this schema node and its subnodes
        """
        res = []
        self_arg = self._get_arg()
        if self_arg is not None:
            args = ["'" + self_arg + "'"]
        else:
            args = []
        attrs_text = _prsrc_attrs(indent, self.get_attrs())
        if len(attrs_text) > 0:
            args.append(_prsrc_attrs(indent, self.get_attrs()))
        have_children = True if isinstance(self, SchemaNodeInner) and len(self.children) > 0 else False
        if have_children:
            args.append("children=[")
        args_text = ", ".join(args)
        text_line = _ind(indent) + self._get_class_name() + "(" + args_text
        if not have_children:
            text_line += ')'
        res.append(text_line)
        if isinstance(self, SchemaNodeInner) and have_children:
            child_res = []
            for child in self.children:
                child_res.append(child.prsrc(indent+1))
            res.append(",\n".join(child_res))
            res.append(_ind(indent) + "])")
        return "\n".join(res)

    def prdaclass(self, loose=False, top=True, set_ns=True, schema_ns=set(), gen_json=True, gen_xml=True, include_state=False) -> str:
        """Print the data class for this schema node
        """
        raise NotImplementedError('SchemaNode pdc')

    mut def to_dnode(self) -> DNode:
        raise NotImplementedError(f'SchemaNode to_dschema not implemented for {type(self)}')

    def get_dnode_children(self, in_choice: bool=False):
        mut def unset_mandatory(node):
            """Unset the mandatory attribute if present
            """
            if isinstance(node, DLeaf):
                node.mandatory = False
            elif isinstance(node, DAnydata):
                node.mandatory = None
            elif isinstance(node, DAnyxml):
                node.mandatory = None

        if isinstance(self, SchemaNodeInner):
            new_children = []
            for child in self.children:
                if isinstance(child, Case):
                    # Direct descendants of case are data nodes, where we must
                    # unset mandatory
                    new_children.extend(child.get_dnode_children(in_choice=True))
                    continue
                if isinstance(child, Choice):
                    # Direct descendants of choice are either case or data node,
                    # like leaf, container, etc. We unset mandatory on these to
                    # avoid ending up with invalid mutually exclusive
                    # constraints in the data tree. Of course we then have no constraints ...
                    new_children.extend(child.get_dnode_children(in_choice=True))
                    continue
                if isinstance(child, Grouping):
                    continue
                if isinstance(child, Identity):
                    continue
                if isinstance(child, Typedef):
                    continue
                if isinstance(child, Uses):
                    continue
                dnode_child = child.to_dnode()
                if in_choice:
                    unset_mandatory(dnode_child)
                new_children.append(dnode_child)
            return new_children
        raise ValueError(f"get_dnode_children() called on non-inner node {type(self)}")

    def get_module_name(self) -> str:
        # TODO: return belongs_to.name for submodule??
        n = self
        for i in range(RECURSION_LIMIT+1):
            nmod = n.mod
            if nmod is not None:
                return nmod
            nparent = n.parent
            if nparent is not None:
                n = nparent
                continue
            else:
                raise ValueError("Unable to find module")
            if i > RECURSION_LIMIT:
                raise ValueError("Recursion limit reached")
        raise ValueError("Unable to find module")

    def get_namespace(self) -> str:
        n = self
        for i in range(RECURSION_LIMIT+1):
            nnamespace = n.ns
            if nnamespace is not None:
                return nnamespace
            nparent = n.parent
            if nparent is not None:
                n = nparent
                continue
            else:
                raise ValueError("Unable to find namespace")
            if i > RECURSION_LIMIT:
                raise ValueError("Recursion limit reached")
        raise ValueError("Unable to find namespace")

    def get_prefix(self) -> str:
        n = self
        for i in range(RECURSION_LIMIT+1):
            nprefix = n.pfx
            if nprefix is not None:
                return nprefix
            nparent = n.parent
            if nparent is not None:
                n = nparent
                continue
            else:
                raise ValueError("Unable to find prefix")
            if i > RECURSION_LIMIT:
                raise ValueError("Recursion limit reached")
        raise ValueError("Unable to find prefix")

    def is_config(self) -> bool:
        n = self
        for i in range(RECURSION_LIMIT+1):
            if (isinstance(n, Anydata)
                or isinstance(n, Anyxml)
                or isinstance(n, Case)
                or isinstance(n, Choice)
                or isinstance(n, Container)
                or isinstance(n, Module)
                or isinstance(n, Notification)
                or isinstance(n, Leaf)
                or isinstance(n, LeafList)
                or isinstance(n, List)):
                found_config = True
                if isinstance(n, Anydata):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, Anyxml):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, Case):
                    found_config = False
                elif isinstance(n, Choice):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, Container):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, Module):
                    return True
                elif isinstance(n, Notification):
                    return False
                elif isinstance(n, Leaf):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, LeafList):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False
                elif isinstance(n, List):
                    nconfig = n.config
                    if nconfig is not None:
                        return nconfig
                    found_config = False

                if not found_config:
                    nparent = n.parent
                    if nparent is not None:
                        n = nparent
                        continue
                    else:
                        if isinstance(n, Module):
                            return True
                        else:
                            raise ValueError(f"Reached some top data node of type {type(n)}")
            else:
                raise ValueError(f"Non-data node {type(n)} does not have config statements")
            if i > RECURSION_LIMIT:
                raise ValueError("Recursion limit reached")
        raise ValueError("Unable to find config attribute")

    def get_parent(self) -> SchemaNode:
        p = self.parent
        if p is not None:
            return p
        raise ValueError("No parent found")

    def get(self, name: str, ns: ?str=None) -> SchemaNode:
        """Get child node by name
        """
        # TODO: support looking up qualified by namespace
        #tns = ns if ns is not None else self.get_namespace()
        if isinstance(self, SchemaNodeInner):
            for child in self.children:
                #child_namespace = child.ns
                # TODO:
                if isinstance(child, Action) and child.name == name:
                    return child
                elif isinstance(child, Anydata) and child.name == name:
                    return child
                elif isinstance(child, Anyxml) and child.name == name:
                    return child
                elif isinstance(child, Case) and child.name == name:
                    return child
                elif isinstance(child, Choice) and child.name == name:
                    return child
                elif isinstance(child, Container) and child.name == name:
                    return child
                elif isinstance(child, Input) and name == 'input':
                    return child
                elif isinstance(child, Leaf) and child.name == name:
                    return child
                elif isinstance(child, LeafList) and child.name == name:
                    return child
                elif isinstance(child, List) and child.name == name:
                    return child
                elif isinstance(child, Notification) and child.name == name:
                    return child
                elif isinstance(child, Output) and name == 'output':
                    return child
                elif isinstance(child, Rpc) and child.name == name:
                    return child
            # Check extension with argument
            for ext in self.exts:
                ext_arg = ext.arg
                if ext_arg is not None and ext_arg == name:
                    return ext
            raise ValueError(f"Child {name} not found")

        raise ValueError(f"Unable to get child {name} from non-inner node")

    def get_module(self) -> Module:
        """Get the Module for the local module

        That is, climb up the ladder of parents from the current node until we
        reach the top Module.
        """
        n = self
        while True:
            if isinstance(n, Module):
                return n
            nparent = n.parent
            if nparent is not None:
                n = nparent
                continue
            break
        raise ValueError("Unable to find Module")

    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None) -> SchemaNode:
        """Compile an abstract YANG into a concrete one
        - expand uses / groupings
        - handle augments
        - resolve types to base types
        """
        raise NotImplementedError('SchemaNode compile')

    def expand_augments(self, context: Context, target_base: SchemaNode=self, in_uses=False):
        """Expand augment node"""
        def get_target(target_base, target: str) -> SchemaNode:

            parts = target.lstrip("/").split("/")
            current_node = target_base
            if target[0] == "/":
                if in_uses:
                    raise ValueError("Absolute path in augment under uses is not valid")

                for idx, part in enumerate(parts):
                    prefix, name = split_prefix_name(part)
                    if idx == 0:
                        if prefix is not None: # Handle augment targetting another module.
                            current_node = current_node.get_module_by_prefix(prefix, context)
                        else:
                            current_node = self.get_module()

                    if prefix is not None:
                        target_ns = self.get_module_by_prefix(prefix, context).get_namespace()
                        # TODO: resolve using namespace
                        # current_node = current_node.get(name, ns=target_ns)
                        current_node = current_node.get(name)
                    else:
                        current_node = current_node.get(name)

            else: # augment under uses
                if not in_uses:
                    raise ValueError("Relative path in augment under (sub-)module is not valid")

                for part in parts:
                    prefix, name = split_prefix_name(part)
                    if prefix is not None:
                        # TODO: or is prefix OK when it is the local prefix?
                        raise ValueError("Relative path in augment under uses cannot have prefixes")
                    current_node = current_node.get(name)

            return current_node

        def expand_augment(augments: list[Augment], target_base, context: Context):
            # There can be multiple augments which might have dependencies on
            # each other, for example:
            # container c1 {}
            # augment /c1/c2 { leaf l1 { type string; } }
            # augment /c1 { container c2 {} }
            #
            # The first augment targets /c1/c2 which depends on the second
            # augment below, so we must apply these augments in the right order.
            # We do this by looking at the length of the target path and
            # applying the augments in order of increasing path length.

            augments_by_path_length: dict[int, list[Augment]] = {}
            for augment in augments:
                parts = augment.target_node.lstrip("/").split("/")
                plen = len(parts)
                if plen not in augments_by_path_length:
                    augments_by_path_length[plen] = []
                augments_by_path_length[plen].append(augment)

            for plen in sorted(augments_by_path_length.keys()):
                plen_augments = augments_by_path_length[plen]
                for aug in plen_augments:
                    target = get_target(target_base, aug.target_node)
                    if isinstance(target, SchemaNodeInner):
                        # Just move the child to the target
                        aug.expand_children(context, target, new_mod=aug.get_module_name(), new_ns=aug.get_namespace(), new_pfx=aug.get_prefix())
                        target.exts.extend(aug.exts)
                    else:
                        raise ValueError("Augment target " + str(target) + " is not an inner node")

        # Look if node is of a type that has augment substatements
        if isinstance(self, Module):
            expand_augment(self.augment, self, context)
        elif isinstance(self, Submodule):
            expand_augment(self.augment, self, context)
        elif isinstance(self, Uses):
            expand_augment(self.augment, target_base, context)
        else:
            raise ValueError("Node type does not have augment substatements")

    def expand_children(self, context: Context, target: SchemaNodeInner, new_mod: ?str = None, new_ns: ?str = None, new_pfx: ?str = None):
        """Expand abstract children into concrete nodes
        """
        if isinstance(self, SchemaNodeInner):
            for child in self.children:
                if isinstance(child, Uses):
                    grouping = child.get_grouping(child.name, context)
                    grouping.expand_children(context, target, new_mod if new_mod is not None else target.mod, new_ns if new_ns is not None else target.ns, new_pfx if new_pfx is not None else target.pfx)
                    child.expand_augments(context, target, in_uses=True)
                    child.expand_refines(target)
                else:
                    c_child = child.compile(context, new_mod, new_ns, new_pfx)
                    c_child.parent = target
                    target.children.append(c_child)
        else:
            raise ValueError(f"expand_children() called on non-inner node {type(self)}")

    mut def apply_refine(self, refine: Refine):
        raise NotImplementedError(f'SchemaNode apply_refine not implemented for {type(self)}')

    def get_module_by_prefix(self, prefix: str, context: Context) -> Module:
        """Get a Module from the import prefix in the local module"""
        local_module = self.get_module()
        local_module_prefix = local_module.prefix
        if local_module_prefix is not None and local_module_prefix == prefix:
            return local_module
        imp = local_module.get_import_by_prefix(prefix)
        return context.get_module(imp.module, imp.revision_date)

    def get_grouping(self, name: str, context: Context) -> Grouping:
        """Find a grouping in the local module or an imported module
        """
        prefix, group_name = split_prefix_name(name)
        if prefix is not None:
            imported_module = self.get_module_by_prefix(prefix, context)
            return imported_module.get_grouping(group_name, context)
        else: # local module
            return self.get_grouping_in_module(group_name)

    def get_grouping_in_module(self, name: str) -> Grouping:
        """Find a grouping in the current module
        """
        n = self
        for i in range(RECURSION_LIMIT+1):
            if isinstance(n, SchemaNodeInner):
                for child in n.children:
                    if isinstance(child, Grouping) and child.name == name:
                        return child
            nparent = n.parent
            if nparent is not None:
                n = nparent
                continue
            else:
                break
            if i == RECURSION_LIMIT:
                raise ValueError("Recursion limit reached")
        raise ValueError(f"Unable to find grouping '{name}'")

    def get_typedef(self, name: str, context: Context) -> Typedef:
        """Find a typedef in the local module or an imported module
        """
        prefix, typedef_name = split_prefix_name(name)
        if prefix is not None:
            imported_module = self.get_module_by_prefix(prefix, context)
            return imported_module.get_typedef(typedef_name, context)
        else:
            return self.get_typedef_in_module(typedef_name)

    def get_typedef_in_module(self, name: str) -> Typedef:
        """Find a typedef in the current module
        """
        n = self
        for i in range(RECURSION_LIMIT+1):
            typedefs: list[Typedef] = []
            if isinstance(n, SchemaNodeInner):
                for child in n.children:
                    if isinstance(child, Typedef) and child.name == name:
                        return child
            nparent = n.parent
            if nparent is not None:
                n = nparent
                continue
            else:
                break
            if i == RECURSION_LIMIT:
                raise ValueError("Recursion limit reached")
        raise ValueError(f"Unable to find typedef '{name}'")

    def to_statement(self) -> Statement:
        """Convert this schema node to a Statement
        """
        stmt = Statement(self._yname, self._get_arg())
        for attr_name, attr_value in self.get_attrs():
            if attr_value is not None:
                if isinstance(attr_value, SchemaNode):
                    stmt.substatements.append(attr_value.to_statement())
                elif isinstance(attr_value, list):
                    for av in attr_value:
                        if isinstance(av, str):
                            stmt.substatements.append(Statement(attr_name, av))
                        elif isinstance(av, SchemaNode):
                            stmt.substatements.append(av.to_statement())
                        else:
                            raise ValueError(f"Unexpected type in list: {type(av)}")
                elif isinstance(attr_value, bool):
                    stmt.substatements.append(Statement(attr_name, "true" if attr_value else "false"))
                else:
                    stmt.substatements.append(Statement(attr_name, str(attr_value)))

        if isinstance(self, SchemaNodeInner):
            for c in self.children:
                stmt.substatements.append(c.to_statement())

        return stmt

class SchemaNodeInner(SchemaNode):
    children: list[SchemaNode]

class SchemaNodeOuter(SchemaNode):
    pass

class Ext(SchemaNode):
    """An extension statement

    This is not the definition of an extension, e.g. the "extension" keyword,
    but an instance of an extension, like "foo:bar 'test';"
    """
    prefix: str
    name: str
    arg: ?str

    def __init__(self, prefix: str, name: str, arg: ?str=None, exts=[]):
        self.prefix = prefix
        self.name = name
        self.arg = arg
        self.exts = exts

    @staticmethod
    def from_fullname(fullname: str, arg: ?str=None, exts=[]) -> Ext:
        parts = fullname.split(":", 1)
        if len(parts) != 2:
            raise ValueError(f"Invalid extension name {fullname}, extensions must always have a prefix like: foo:bar 'test';")
        return Ext(parts[0], parts[1], None)

    def _get_class_name(self):
        return "Ext"

    def prsrc(self, indent=0):
        """Print Acton source of this node"""
        res = []
        attrs: list[(str, ?value)] = [
            ("arg", self.arg),
            ("exts", self.exts),
            ]
        prefix = self.prefix
        args = []
        if prefix is not None:
            args = ["'" + str(prefix) + "', '" + str(self.name) + "'"]
        else:
            raise ValueError("No prefix in Ext.prsrc, this should never happen")
        attrs_text = _prsrc_attrs(indent, attrs)
        if len(attrs_text) > 0:
            args.append(attrs_text)
        args_text = ", ".join(args)
        text_line = _ind(indent) + "Ext(" + args_text + ")"
        res.append(text_line)
        return "\n".join(res)

    def to_statement(self) -> Statement:
        res = Statement(self.name, self.arg, self.prefix)
        for ext in self.exts:
            res.substatements.append(ext.to_statement())
        return res

    def __str__(self):
        self_arg = self.arg
        return "Ext " + self.name + ((" " + self_arg) if self_arg is not None else "")

extension Ext (Ord):
    def __eq__(self, other: Ext) -> bool:
        self_arg = self.arg
        other_arg = other.arg
        return self.name == other.name and (self_arg is None and other_arg is None or (self_arg is not None and other_arg is not None and self_arg == other_arg))

    def __lt__(self, other: Ext) -> bool:
        return self.name < other.name


def take_opt_bool(stmts: list[Statement], kw: str) -> ?bool:
    v = take_opt_str(stmts, kw)
    if v is not None:
        if v == "true":
            return True
        elif v == "false":
            return False

def take_bool(stmts: list[Statement], kw: str) -> bool:
    v = take_opt_str(stmts, kw)
    if v is not None:
        if v == "true":
            return True
        elif v == "false":
            return False
    raise ValueError(f"No {kw} in stmts")

def take_opt_int(stmts: list[Statement], kw: str) -> ?int:
    v = take_opt_str(stmts, kw)
    if v is not None:
        return int(v)

def take_int(stmts: list[Statement], kw: str) -> int:
    v = take_opt_str(stmts, kw)
    if v is not None:
        return int(v)
    raise ValueError(f"No {kw} in stmts")

def take_opt_str(stmts: list[Statement], kw: str) -> ?str:
    for i in range(len(stmts)):
        if stmts[i].kw == kw:
            arg = stmts[i].arg
            if arg is not None:
                del stmts[i]
                return arg

def take_str(stmts: list[Statement], kw: str) -> str:
    for i in range(len(stmts)):
        if stmts[i].kw == kw:
            arg = stmts[i].arg
            if arg is not None:
                del stmts[i]
                return arg
    raise ValueError(f"No {kw} in stmts")

def take_yang_version(stmts: list[Statement]) -> float:
    v = take_opt_str(stmts, "yang-version")
    if v is not None:
        # TODO: this should just be: return float(v)
        # but a compiler bug prevents that from working
        f = float(v)
        return f
    return 1.0

def take_strlist(stmts: list[Statement], kw: str) -> list[str]:
    res = []
    todel = []
    for i in range(len(stmts)):
        if stmts[i].kw == kw:
            arg = stmts[i].arg
            if arg is not None:
                todel.append(i)
                res.append(arg)
    for d in reversed(todel):
        del stmts[d]
    return res

def take_node(stmts: list[Statement], kw: str, parent: ?SchemaNode=None) -> ?SchemaNode:
    for i in range(len(stmts)):
        if stmts[i].kw == kw:
            n = stmt_to_snode(stmts[i], parent=parent)
            del stmts[i]
            return n

def take_nodes(stmts: list[Statement], kw: list[str], parent: ?SchemaNode=None) -> list[SchemaNode]:
    res = []
    todel = []
    for i in range(len(stmts)):
        if stmts[i].kw in kw:
            res.append(stmt_to_snode(stmts[i], parent=parent))
            todel.append(i)
    for i in reversed(todel):
        del stmts[i]
    return res

def take_exts(stmts: list[Statement]) -> list[Ext]:
    """Take all extension statements from a list of statements

    Extension statements always follow the form:

    prefix:extension arg;
    """
    res = []
    todel = []
    for i in range(len(stmts)):
        prefix = stmts[i].prefix
        name = stmts[i].kw
        arg = stmts[i].arg
        # TODO: I think prefix should be None, not "", right? prefix should be
        # the prefix of the statement and not the prefix of the module, like the
        # namespace prefix
        if prefix is not None and len(prefix) > 0:
            res.append(Ext(prefix, name, arg, exts=take_exts(stmts[i].substatements)))
            todel.append(i)
    for i in reversed(todel):
        del stmts[i]
    return res

def _attr_name(name: str):
    res = ""
    i = 0
    while True:
        if name[i] == "-":
            res += "_"
        else:
            res += name[i]
        i += 1
        if i == len(name):
            break
    if res in {"extension", "import", "type"}:
        res = res + "_"

    return res

def _prsrc_attrs(indent, attrs):
    """Print source code for a list of SchemaNode attributes"""
    res = []
    for attr in attrs:
        raw_name, value = attr
        name = _attr_name(raw_name)
        if value is not None:
            if isinstance(value, list):
                if len(value) == 0:
                    continue
                else:
                    list_val = []
                    content_is_snode = False
                    for e in value:
                        if isinstance(e, SchemaNode):
                            list_val.append(e.prsrc(indent+2))
                        else:
                            list_val.append(repr(e))
                    list_val_str = "[]"
                    if len(list_val) == 1 and list_val[0][0] != " " and len(list_val[0]) < 20:
                        list_val_str = "[" + list_val[0] + "]"
                    else:
                        list_val_str = "[\n" + ",\n".join(list_val) + "\n" + _ind(indent + 1) + "]"
                    res.append(name + "=" + list_val_str)
            elif isinstance(value, SchemaNode):
                res.append(name + "=" + value.prsrc(0))
            else:
                res.append(name + "=" + repr(value))
    return ", ".join(res)


def is_optional_yang_leaf(leaf: DNodeLeaf, loose: bool=False) -> bool:
    """Maps YANG leaf optionality to Acton type
    """
    optional = True

    # Mandatory leaf in YANG model are non-optional in Acton
    mandatory = False
    leafmandatory = leaf.mandatory
    if leafmandatory != None:
        mandatory = leafmandatory

    has_default = False
    if isinstance(leaf, DLeaf):
        if leaf.default != None:
            has_default = True

    optional = not (mandatory or has_default)
    # But with loose validation, even mandatory YANG leaves are optional!
    if loose:
        optional = True
    # ... although being part of a key always makes it non-optional
    parent = leaf.parent
    if isinstance(parent, DList):
        if leaf.name in parent.key:
            optional = False
    return optional

def is_optional_arg_yang_leaf(leaf: DNodeLeaf, loose: bool=False) -> bool:
    """Maps YANG leaf optionality to Acton type for object constructor arg

    This is different from the is_optional_yang_leaf because for YANG leafs with
    a default value, we require a difference depending on where the type is used.

    leaf foo {
      type string;
      default "banana";
    }

    the type is str, since even if we do not provide a value, it will get its
    default 'banana', so it is never optional. However, in the constructor
    argument, it is optional. This method is used to determine if the argument
    type should be optional.
    """
    optional = is_optional_yang_leaf(leaf, loose)

    if isinstance(leaf, DLeaf):
        if leaf.default != None:
            optional = True

    return optional

def yang_leaf_to_acton_type(leaf: DNodeLeaf, loose: bool=False) -> str:
    optional = is_optional_yang_leaf(leaf, loose)
    optional_str = "?" if optional else ""
    t = yang_type_to_acton_type(leaf.type_)
    return optional_str + t

def yang_leaf_to_acton_arg_type(leaf: DNodeLeaf, loose: bool=False) -> str:
    optional = is_optional_yang_leaf(leaf, loose)
    if isinstance(leaf, DLeaf):
        if leaf.default != None:
            optional = True
    optional_str = "?" if optional else ""
    t = yang_type_to_acton_type(leaf.type_)
    return optional_str + t

def taker_name(n: DNode, loose: bool=False, key_required=True) -> str:
    if isinstance(n, DContainer):
        optional = loose or optional_subtree(n)
        optional_str = "opt_" if optional else ""
        return optional_str + "cnt"
    if isinstance(n, DList):
        optional = loose or optional_subtree(n)
        optional_str = "opt_" if optional else ""
        return optional_str + "list"
    if isinstance(n, DLeaf):
        optional = is_optional_yang_leaf(n)
        optional_str = "opt_" if optional else ""
        return optional_str + yang_type_to_acton_type(n.type_)
    if isinstance(n, DLeafList):
        # TODO: optional?
        return yang_type_to_acton_type(n.type_) + "s"
    raise ValueError(f"unreachable - unknown node type {type(n)}")

def yang_leaf_to_getval(leaf: DNodeLeaf, loose: bool) -> str:
    optional = is_optional_arg_yang_leaf(leaf, loose)
    optional_str = "opt_" if optional else ""
    t = yang_type_to_acton_type(leaf.type_)
    return optional_str + t

def yang_leaflist_to_acton_type(leaf: DLeafList) -> str:
    t = yang_type_to_acton_type(leaf.type_)
    return f"list[{t}]"


def yang_typename_to_acton_type(type_name: str) -> str:
    if type_name == "binary":
        return "bytes"
    elif type_name == "bits":
        raise NotImplementedError('bits not supported')
    elif type_name == "boolean":
        return "bool"
    elif type_name == "decimal64":
        # TODO: do something better
        return "float"
    elif type_name == "empty":
        # TODO: is this right?
        return "bool"
    elif type_name == "enumeration":
        # TODO: use acton unions of fixed strings!?
        return "str"
    elif type_name == "identityref":
        return "str"
    elif type_name == "instance-identifier":
        return "str"
    elif type_name in {"int8", "int16", "int32", "int64", "uint8", "uint16", "uint32", "uint64"}:
        return "int"
    elif type_name == "leafref":
        return "str"
    elif type_name == "string":
        return "str"
    elif type_name == "union":
        # You should use yang_type_to_acton_type which can expand the union type for you!
        raise ValueError("Union type not supported")
    raise ValueError("Unknown YANG type: " + type_name)

def yang_type_to_acton_type(t: ?Type) -> str:
    # +---------------------+-------------------------------------+
    # | Name                | Description                         |
    # +---------------------+-------------------------------------+
    # | binary              | Any binary data                     |
    # | bits                | A set of bits or flags              |
    # | boolean             | "true" or "false"                   |
    # | decimal64           | 64-bit signed decimal number        |
    # | empty               | A leaf that does not have any value |
    # | enumeration         | One of an enumerated set of strings |
    # | identityref         | A reference to an abstract identity |
    # | instance-identifier | A reference to a data tree node     |
    # | int8                | 8-bit signed integer                |
    # | int16               | 16-bit signed integer               |
    # | int32               | 32-bit signed integer               |
    # | int64               | 64-bit signed integer               |
    # | leafref             | A reference to a leaf instance      |
    # | string              | A character string                  |
    # | uint8               | 8-bit unsigned integer              |
    # | uint16              | 16-bit unsigned integer             |
    # | uint32              | 32-bit unsigned integer             |
    # | uint64              | 64-bit unsigned integer             |
    # | union               | Choice of member types              |
    # +---------------------+-------------------------------------+
    if t is not None:
        if t.name == "union":
            def get_unique_types(tys: list[Type]) -> set[str]:
                """Recursively expand union to the base types"""
                res = set()
                for ty in tys:
                    if ty.name == "union":
                        res.update(get_unique_types(ty.type_))
                    else:
                        res.add(ty.name)
                return res

            # Recursively find unique base types, if they all map down to the
            # same base type, we can just use that as the Acton type
            unique_base_types = list(get_unique_types(t.type_))
            if len(unique_base_types) == 1:
                return yang_typename_to_acton_type(unique_base_types[0])

            # TODO: should we map in union of say u32 and i32 into i64?
            if all(map(lambda x: x in {"int8", "int16", "int32", "int64"}, unique_base_types)):
                max_size = max(list(map(lambda x: int(x[3:]), unique_base_types)))
                # TODO: once we have integer subtyping, return largest necessary iXX type
                #return f"i{max_size}"
                return "int"
            elif all(map(lambda x: x in {"uint8", "uint16", "uint32", "uint64"}, unique_base_types)):
                max_size = max(list(map(lambda x: int(x[4:]), unique_base_types)))
                # TODO: once we have integer subtyping, return largest necessary uXX type
                #return f"u{max_size}"
                return "int"
            elif all(map(lambda x: x in {"int8", "int16", "int32", "int64", "uint8", "uint16", "uint32", "uint64"}, unique_base_types)):
                # We have a union of a mix of signed and unsigned integers, so let's find the largest
                int_sizes = filter(lambda x: x in {"int8", "int16", "int32", "int64"}, unique_base_types)
                max_int_size = max(list(map(lambda x: int(x[3:]), int_sizes)))
                uint_sizes = filter(lambda x: x in {"uint8", "uint16", "uint32", "uint64"}, unique_base_types)
                max_uint_size = max(list(map(lambda x: int(x[4:]), uint_sizes)))
                # To map a uint into an signed int, we need twice the number of
                # bits, i.e. uint8 fits in int16 or uint32 fits in int64, so
                # just double the max size...
                max_int_mapped_uint_size = max_uint_size * 2
                # Total max size is the max between signed int and
                # integer-mapped-uint (which is already 2*uint max)
                max_size = max([max_int_size, max_int_mapped_uint_size])
                if max_size > 64:
                    # Need to use our int (a.k.a. "bigint")
                    return "int"
                # TODO: once we have integer subtyping, return largest necessary iXX type
                #return f"i{max_size}"
                return "int"

            # TODO: use atom when union consists of types that we represent with Acton built-in types
            # TODO: use Acton union
            return "value"
        else:
            return yang_typename_to_acton_type(t.name)
    raise ValueError("type not defined")

def prsrc_literal(ytype: str, value: str) -> str:
    if ytype == "boolean":
        if value.lower() == "true":
            return "True"
        return "False"
    elif ytype == "enumeration":
        return '"' + value + '"'
    elif ytype == "identityref":
        return '"' + value + '"'
    elif ytype in {"int8", "int16", "int32", "int64", "uint8", "uint16", "uint32", "uint64"}:
        return value
    elif ytype == "binary":
        # Binary values are encoded as base64 strings in YANG and NETCONF, but
        # stored as Acton bytes, so we need to decode it first
        return f"base64.decode('{value}'.encode())"
    elif ytype == "string":
        return '"' + value.replace('"', '\\"') + '"'
    elif ytype == "union":
        # Attempt to convert the default to one of Acton built-in types;
        # numeric types can be converted to float, pass verbatim
        # TODO: binary and other types?? The correct thing to do is to instead
        # pass the entire list of resolved types from the union and try to
        # convert to each in the order they are defined in the YANG model?
        try:
            a = float(value)
            return value
        except ValueError:
            pass
        # true, false is boolean,
        if value.lower() == "true":
            return str(True)
        elif value.lower() == "false":
            return str(False)
        # otherwise it is a string
        return '"' + value.replace('"', '\\"') + '"'
    raise ValueError("Unhandled prsrc literal of type " + ytype)

def _safe_name(name: str) -> str:
    new = name.replace("-", "_").replace(".", "_")
    if new in {"action",
               "actor",
               "as",
               "class",
               "del",
               "except",
               "for",
               "from",
               "import",
               "in",
               "mut",
               "None",
               "proc",
               "protocol",
               "pure",
               "with",
               "yield",
               }:
        new += "_"
    return new

def get_path_name(dnode: DNode) -> str:
    """Build the adata path name for a data node

    For example, for the following YANG model:

    module foo {
      prefix foo;
      container bar {
        leaf baz {
          type string;
        }
      }
    }

    the path name for the baz leaf is "foo__bar__baz".

    This function detects conflicting names across sibling nodes. If we add
    another module that augments a conflicting node like this:

    module m2 {
      import foo { prefix foo; }
      augment /foo:bar {
        leaf baz {
          type string;
        }
      }
    }

    Then the path name for the baz leaves in the two modules is:
    - foo__bar__foo_baz
    - foo__bar__m2_baz

    We do not rewrite the builtin keywords here (see _safe_name()) because it
    is not necessary.
    """
    path = []
    while True:
        self_unique_name = dnode.name
        parent = dnode.parent
        # if parent is not None then of course it is DNodeInner (= has children
        # attribute), but let's make that explicit for the compiler ...
        if parent is not None:
            if isinstance(parent, DNodeInner):
                sibling_names = set()
                sibling_names_conflicts = set()
                for sibling in parent.children:
                    if sibling.name in sibling_names:
                        sibling_names_conflicts.add(sibling.name)
                    else:
                        sibling_names.add(sibling.name)
                if dnode.name not in sibling_names_conflicts:
                    self_unique_name = dnode.name
                else:
                    self_unique_name = f"{dnode.prefix}:{dnode.name}"
                dnode = parent
        path.append(self_unique_name.replace("-", "_").replace(".", "_").replace(":", "_"))
        if parent is None:
            break

    # This never happens, we always get at least our name!
    if len(path) == 0:
        raise ValueError("No path for DNode" + str(dnode))

    return "__".join(reversed(path))


# -- end of manually defined schema functions, automatically generated code follows
