import file
import re

import rfc

"""This module generates the source code for the Acton YANG module that in turn
can be used to parse YANG modules and represent YANG schemas as Acton classes
and objects.

This is pretty meta (like meta-meta-meta), since the YANG module can print
source code of itself and the code that prints source code is in turn generated
by the code in this module. Have a decent amount of coffee before attempting to
work on this.
"""

child_stmts = {
    "action",
    "anydata",
    "anyxml",
    "case",
    "choice",
    "container",
    "grouping",
    "identity",
    "leaf",
    "leaf-list",
    "list",
    "notification",
    "rpc",
    "typedef",
    "uses",
}

class Stmt(object):
    name: str
    section: str
    argument_name: ?str
    substmts: dict[str, SubStmt]
    def __init__(self, name: str, section: str, argument_name: ?str):
        self.name = name
        self.section = section
        self.argument_name = argument_name
        self.substmts = {}

    def __str__(self):
        argname = "None"
        argument_name = self.argument_name
        if argument_name is not None:
            argname = argument_name
        return "<Stmt name: %s  section: %s  argument_name: %s  substmts: %s>" % (self.name, self.section, argname, str(self.substmts))

class SubStmt(object):
    name: str
    section: str
    cardinality: str

    def __init__(self, name: str, argument_name: ?str, section: str, cardinality: str):
        self.name = name
        self.argument_name = argument_name
        self.section = section
        self.cardinality = cardinality

    def __str__(self):
        argname = "None"
        return "<SubStmt name: %s  section: %s  argument_name: %s  cardinality: %s>" % (self.name, self.section, argname, self.cardinality)

    def __repr__(self):
        argname = "None"
        return "<SubStmt name: %s  section: %s  argument_name: %s  cardinality: %s>" % (self.name, self.section, argname, self.cardinality)

reserved_names = {
    "range",
}

def parse_stmts(rfc_text: str) -> dict[str, Stmt]:
    """
    """
    arg_names = parse_arg_names(rfc_text)
    section = ""
    stmt_name = ""
    tables = {}
    in_table = False
    skip_lines = 1000
    nr = 0
    for line in rfc_text.splitlines():
        nr += 1
        if skip_lines > 0:
            skip_lines -= 1
            continue
        #        +--------------+---------+-------------+
        if in_table:
            m = re.match(r"\+--------------+\+---------\+-------------\+", line)
            if m is not None:
                in_table = False
            else:
                m = re.match(r"\| (\S+) +\| (\S+) +\| (\S+) +\|", line)
                if m is not None:
                    gname = m.group[1]
                    gsection = m.group[2]
                    gcardinality = m.group[3]
                    if gname is not None and gsection is not None and gcardinality is not None:
                        t = SubStmt(name=gname, section=gsection, cardinality=gcardinality)
                        tables[stmt_name].substmts[t.name] = t

        # Match statement chapters to find the start of a statement definition.
        # They look like:
        # 7.1.1.  The module's Substatements
        # 7.1.6.  The "include" Statement
        m = re.match(r"(\d+(\.\d+)+)\.\s+The \"?([a-z-]+)(\"|'s) (Subs|S)tatement", line)
        if m is not None:
            #print("Found statement:", m.group[2], line)
            gsection = m.group[1]
            gstmt_name = m.group[3]
            if gsection is not None and gstmt_name is not None:
                section = gsection
                stmt_name = gstmt_name
        # Find the table of substatements, header looks like:
        #        +--------------+---------+-------------+
        #        | substatement | section | cardinality |
        #        +--------------+---------+-------------+
        m = re.match(r"\| substatement +\| section \| cardinality \|", line)
        if m is not None:
            #print("Found substatement table for", stmt_name)
            in_table = True
            skip_lines = 1
            if stmt_name not in tables:
                arg_name = None
                if stmt_name in arg_names:
                    arg_name = arg_names[stmt_name]
                s = Stmt(name=stmt_name, section=section, argument_name=arg_name)
                if arg_name is not None:
                    s.substmts[arg_name] = SubStmt(name=arg_name, section="", cardinality="1")
                tables[stmt_name] = s
            else:
                print("Warning: duplicate table for", stmt_name, "at line", nr)

    return tables

def parse_arg_names(rfc_text: str) -> dict[str, str]:
    """Parse argument names from RFC
    """
    in_yin = False
    skip_lines = 0
    res = {}
    for line in rfc_text.splitlines():
        if skip_lines > 0:
            skip_lines -= 1
            continue

        if in_yin:
            # Check for end of table
            # +------------------+---------------+-------------+
            m = re.match(r"\+------------------\+---------------\+-------------\+", line)
            if m is not None:
                in_yin = False
                break
            else:
                # Grab table from YIN section that contains the argument name
                # | action           | name          | false       |
                m = re.match(r"\| (\S+) +\| (\S+) +\| (\S+) +\|", line)
                if m is not None:
                    name = m.group[1]
                    arg = m.group[2]
                    if name is not None and arg is not None:
                        res[name] = arg

        # Grab table from YIN section that contains the argument name
        # Match table header
        #             | keyword          | argument name | yin-element |
        m = re.match(r"\| keyword +\| argument name +\| yin-element +\|", line)
        if m is not None:
            in_yin = True
            skip_lines = 1
    return res


def _class_name(name: str):
    res = ""
    i = 0
    while True:
        if i == 0:
            res += name[i].upper()
        elif name[i] == "-":
            i += 1
            res += name[i].upper()
        else:
            res += name[i]
        i += 1
        if i == len(name):
            break
    if res in reserved_names:
        res = res + "_"
    return res

def _attr_name(name: str) -> str:
    res = ""
    i = 0
    while True:
        if name[i] == "-":
            res += "_"
        else:
            res += name[i]
        i += 1
        if i == len(name):
            break
    if res in {"extension", "import", "range", "type"}:
        res = res + "_"

    return res

def _attr_type(name, stmt, stmts) -> str:
    t = "str"
    # If the name is the argument name, it's always a string
    if name == stmt.argument_name:
        return "str"
    cardinality = stmt.substmts[name].cardinality
    if name in stmts:
        t = _class_name(name)
    elif name in {"config", "mandatory", "require-instance"}:
        t = "bool"
    elif name in {"fraction-digits", "length", "position"}:
        t = "int"
    elif name in {"yang-version"}:
        t = "float"


    # TODO: change namespace and prefix cardinality to 1
    #if cardinality == "0..1":
    if cardinality == "0..1":
        return "?" + t
    elif cardinality == "1":
        return t
    elif cardinality == "0..n":
        return "list[%s]" % t
    return "?str"

def _attr_taker_name(name: str):
    res = ""
    i = 0
    while True:
        if name[i] == "-":
            res += "_"
        else:
            res += name[i]
        i += 1
        if i == len(name):
            break

    return res

def _attr_taker(name, stmt, stmts) -> str:
    cardinality = stmt.substmts[name].cardinality
    t = "str"
    #if name in stmt.substmts:
    if name in stmts:
        t = _attr_taker_name(name)
    elif name in {"config", "mandatory", "require-instance"}:
        t = "bool"
    elif name in {"fraction-digits", "length", "position"}:
        t = "int"

    if cardinality == "0..1":
        if name in stmts:
            return "take_opt_%s(ss)" % t
        return "take_opt_%s(ss, \"%s\")" % (t, name)
    elif cardinality == "1":
        if name in stmts:
            return "take_%s(ss)" % t
        return "take_str(ss, \"%s\")" % name
    elif cardinality == "0..n":
        if name in stmts:
            return "take_%ss(ss)" % t
        return "take_strlist(ss, \"%s\")" % name
    else:
        raise ValueError("Unknown cardinality: %s" % cardinality)

def _attr_defval(name, stmt, stms) -> str:
    if name == stmt.argument_name:
        return ""
    cardinality = stmt.substmts[name].cardinality
    if cardinality == "0..1":
        return "=None"
    elif name == "yang-version":
        return "=1.1"
    elif cardinality == "1":
        return ""
    elif cardinality == "0..n":
        return "=[]"
    raise ValueError("Unknown cardinality: %s" % cardinality)

header = """
def _prsrc_attrs(attrs):
    res = []
    for attr in attrs:
        name, value = attr
        if isinstance(value, list):
            if len(value) > 0:
                res.append(name + "=[" + ", ".join(value) + "]")
        else:
            if value is not None:
                res.append(name + "=" + repr(value))
    return res

def _ind(indent):
    return "    " * indent

class SchemaNode(object):
    def prsrc(self, indent=0) -> list[str]:
        raise NotImplementedError("prsrc")

"""

snode_methods = {
    "action": {
        "get": """    def get(self, name: str, ns: ?str=None) -> SchemaNode:
        # TODO: support looking up qualified by namespace
        #tns = ns if ns is not None else self.get_namespace()
        if name == 'input':
            _input = self.input
            if _input is not None:
                return _input
        if name == 'output':
            _output = self.output
            if _output is not None:
                return _output
        return SchemaNode.get(self, name, ns)

""",
        "compile": """    def compile(self, context: Context, new_ns: ?str=None, new_pfx: ?str=None):
        self_input = self.input
        self_output = self.output
        # new_input = self_input.compile(context) if self_input is not None else None # actonc codegen pre-evaluates before None-check
        new_input = None
        if self_input is not None:
            new_input = self_input.compile(context, new_ns)
        # new_output = self_output.compile(context) if self_output is not None else None # actonc codegen pre-evaluates before None-check
        new_output = None
        if self_output is not None:
            new_output = self_output.compile(context, new_ns)
        new = Action(self.name,
                     description=self.description,
                     if_feature=self.if_feature,
                     input=new_input if new_input is not None and isinstance(new_input, Input) else Input(),
                     output=new_output if new_output is not None and isinstance(new_output, Output) else Output(),
                     reference=self.reference,
                     status=self.status,
                     exts=self.exts,
                     ns=new_ns if new_ns is not None else self.ns,
                     pfx=new_pfx if new_pfx is not None else self.pfx)
        self.expand_children(context, new, new_ns, new_pfx)
        return new

""",
        "to_dnode": """    def to_dnode(self) -> DAction:
        new_dnode = DAction(
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            description=self.description,
            if_feature=self.if_feature,
            reference=self.reference,
            status=self.status,
            exts=self.exts,
            children=self.get_dnode_children()
        )
        for child in new_dnode.children:
            child.parent = new_dnode
        return new_dnode

""",
        "is_config": """    def is_config(self) -> bool:
        return False

"""
    },
    "anydata": {
        "to_dnode": """    def to_dnode(self) -> DAnydata:
        return DAnydata(
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            config=self.is_config(),
            description=self.description,
            if_feature=self.if_feature,
            mandatory=self.mandatory,
            must=self.must,
            reference=self.reference,
            status=self.status,
            when=self.when,
            exts=self.exts
        )

"""
    },
    "anyxml": {
        "to_dnode": """    def to_dnode(self) -> DAnyxml:
        return DAnyxml(
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            config=self.is_config(),
            description=self.description,
            if_feature=self.if_feature,
            mandatory=self.mandatory,
            must=self.must,
            reference=self.reference,
            status=self.status,
            when=self.when,
            exts=self.exts
        )

"""
    },
    "container": {
        "is_presence": """    def is_presence(self) -> bool:
        selfpresence = self.presence
        if selfpresence is not None:
            return True
        return False

""",
        "to_dnode": """    def to_dnode(self) -> DContainer:
        new_dnode = DContainer(
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            config=self.is_config(),
            description=self.description,
            if_feature=self.if_feature,
            must=self.must,
            presence=self.is_presence(),
            reference=self.reference,
            status=self.status,
            when=self.when,
            exts=self.exts,
            children=self.get_dnode_children()
        )
        for child in new_dnode.children:
            child.parent = new_dnode
        return new_dnode

"""
    },
    "input": {
        "to_dnode": """    def to_dnode(self) -> DInput:
        new_dnode = DInput(
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            must=self.must,
            exts=self.exts,
            children=self.get_dnode_children()
        )
        for child in new_dnode.children:
            child.parent = new_dnode
        return new_dnode

"""
    },
    "module": {
        "get_import_by_prefix": """    def get_import_by_prefix(self, prefix: str) -> Import:
        for imp in self.import_:
            if imp.prefix == prefix:
                return imp
        raise ValueError("No import with prefix %s in module %s" % (prefix, self.name))

""",
        "get_modrev": """    def get_modrev(self) -> ModRev:
        rev = self.get_revision()
        rev_date = rev.date if rev is not None else None
        return ModRev(self.name, rev_date)

""",
        "get_namespace": """    def get_namespace(self) -> str:
        self_ns = self.ns
        if self_ns is not None:
            return self_ns
        selfnamespace = self.namespace
        if selfnamespace is not None:
            return selfnamespace
        raise ValueError("Module %s has no namespace" % self.name)

""",
        "get_prefix": """    def get_prefix(self) -> str:
        self_pfx = self.pfx
        if self_pfx is not None:
            return self_pfx
        selfprefix = self.prefix
        if selfprefix is not None:
            return selfprefix
        raise ValueError("Module %s has no prefix" % self.name)

""",
        "get_revision": """    def get_revision(self) -> ?Revision:
        latest = None
        for rev in self.revision:
            if latest is None or (latest is not None and rev.date > latest.date):
                latest = rev
        return latest

""",
        "to_dnode": """    def to_dnode(self) -> DModule:
        new_dnode = DModule(
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            description=self.description,
            revision=self.revision,
            reference=self.reference,
            exts=self.exts,
            children=self.get_dnode_children()
        )
        for child in new_dnode.children:
            child.parent = new_dnode
        return new_dnode

""",
        "is_config": """    def is_config(self) -> bool:
        return False

"""
    },
    "notification": {
        "to_dnode": """    def to_dnode(self) -> DNotification:
        new_dnode = DNotification(
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            description=self.description,
            if_feature=self.if_feature,
            reference=self.reference,
            status=self.status,
            exts=self.exts,
            children=self.get_dnode_children()
        )
        for child in new_dnode.children:
            child.parent = new_dnode
        return new_dnode

""",
        "is_config": """    def is_config(self) -> bool:
        return False

"""
    },
    "list": {
        "keys": """    def keys(self) -> list[str]:
        selfkey = self.key
        if selfkey is not None:
            return selfkey.split(" ")
        return []

""",
        "get_max_elements": """    def get_max_elements(self) -> ?int:
        selfmax_elements = self.max_elements
        if selfmax_elements is not None and selfmax_elements != "unbounded":
            return int(selfmax_elements)
        return None

""",
        "get_min_elements": """    def get_min_elements(self) -> int:
        selfmin_elements = self.min_elements
        if selfmin_elements is not None:
            return int(selfmin_elements)
        return 0

""",
        "to_dnode": """    def to_dnode(self) -> DList:
        new_dnode = DList(
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            key=self.keys(),
            config=self.is_config(),
            description=self.description,
            if_feature=self.if_feature,
            max_elements=self.get_max_elements(),
            min_elements=self.get_min_elements(),
            must=self.must,
            reference=self.reference,
            status=self.status,
            when=self.when,
            exts=self.exts,
            children=self.get_dnode_children()
        )
        for child in new_dnode.children:
            child.parent = new_dnode
        return new_dnode

""",
    },
    "leaf": {
        # TODO: keep track of constraints in the derived type(s) that we resolve
        "compile": """    def compile(self, context: Context, new_ns: ?str=None, new_pfx: ?str=None):
        base_typedef = self.type_.resolve_typedef(context)

        new_default = self.default
        if new_default is None:
            new_default = base_typedef.default

        new_units = self.units
        if new_units is None:
            new_units = base_typedef.units

        new = Leaf(self.name,
                   config=self.config,
                   default=new_default,
                   description=self.description,
                   if_feature=self.if_feature,
                   mandatory=self.mandatory,
                   must=self.must,
                   reference=self.reference,
                   status=self.status,
                   type_=base_typedef.type_,
                   units=new_units,
                   when=self.when,
                   exts=self.exts,
                   ns=new_ns if new_ns is not None else self.ns,
                   pfx=new_pfx if new_pfx is not None else self.pfx)

        return new

""",
        "to_dnode": """    def to_dnode(self) -> DLeaf:
        return DLeaf(
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            config=self.is_config(),
            default=self.default,
            description=self.description,
            if_feature=self.if_feature,
            mandatory=self.mandatory,
            must=self.must,
            reference=self.reference,
            status=self.status,
            type_=self.type_,
            units=self.units,
            when=self.when,
            exts=self.exts
        )

"""
    },
    "leaf-list": {
        # TODO: keep track of constraints in the derived type(s) that we resolve
        "compile": """    def compile(self, context: Context, new_ns: ?str=None, new_pfx: ?str=None):
        base_typedef = self.type_.resolve_typedef(context)

        new_units = self.units
        if new_units is None:
            new_units = base_typedef.units

        new = LeafList(self.name,
                       config=self.config,
                       default=self.default,
                       description=self.description,
                       if_feature=self.if_feature,
                       max_elements=self.max_elements,
                       min_elements=self.min_elements,
                       must=self.must,
                       ordered_by=self.ordered_by,
                       reference=self.reference,
                       status=self.status,
                       type_=base_typedef.type_,
                       units=new_units,
                       when=self.when,
                       exts=self.exts,
                       ns=new_ns if new_ns is not None else self.ns,
                       pfx=new_pfx if new_pfx is not None else self.pfx)
        return new

""",
        "get_max_elements": """    def get_max_elements(self) -> ?int:
        selfmax_elements = self.max_elements
        if selfmax_elements is not None and selfmax_elements != "unbounded":
            return int(selfmax_elements)
        return None

""",
        "get_min_elements": """    def get_min_elements(self) -> int:
        selfmin_elements = self.min_elements
        if selfmin_elements is not None:
            return int(selfmin_elements)
        return 0

""",
        "to_dnode": """    def to_dnode(self) -> DLeafList:
        return DLeafList(
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            config=self.is_config(),
            default=self.default,
            description=self.description,
            if_feature=self.if_feature,
            max_elements=self.get_max_elements(),
            min_elements=self.get_min_elements(),
            must=self.must,
            reference=self.reference,
            status=self.status,
            type_=self.type_,
            units=self.units,
            when=self.when,
            exts=self.exts
        )

"""
    },
    "output": {
        "to_dnode": """    def to_dnode(self) -> DOutput:
        new_dnode = DOutput(
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            must=self.must,
            exts=self.exts,
            children=self.get_dnode_children()
        )
        for child in new_dnode.children:
            child.parent = new_dnode
        return new_dnode

""",
        "is_config": """    def is_config(self) -> bool:
        return False

"""
    },
    "rpc": {
        "get": """    def get(self, name: str, ns: ?str=None) -> SchemaNode:
        # TODO: support looking up qualified by namespace
        #tns = ns if ns is not None else self.get_namespace()
        if name == 'input':
            _input = self.input
            if _input is not None:
                return _input
        if name == 'output':
            _output = self.output
            if _output is not None:
                return _output
        return SchemaNode.get(self, name, ns)

""",
        "compile": """    def compile(self, context: Context, new_ns: ?str=None, new_pfx: ?str=None):
        self_input = self.input
        self_output = self.output
        # new_input = self_input.compile(context) if self_input is not None else None # actonc codegen pre-evaluates before None-check
        new_input = None
        if self_input is not None:
            new_input = self_input.compile(context)
        # new_output = self_output.compile(context) if self_output is not None else None # actonc codegen pre-evaluates before None-check
        new_output = None
        if self_output is not None:
            new_output = self_output.compile(context)
        new = Rpc(self.name,
                  description=self.description,
                  if_feature=self.if_feature,
                  input=new_input if new_input is not None and isinstance(new_input, Input) else Input(),
                  output=new_output if new_output is not None and isinstance(new_output, Output) else Output(),
                  reference=self.reference,
                  status=self.status,
                  exts=self.exts,
                  ns=new_ns if new_ns is not None else self.ns,
                  pfx=new_pfx if new_pfx is not None else self.pfx)
        self.expand_children(context, new, new_ns, new_pfx)
        return new

""",
        "to_dnode": """    def to_dnode(self) -> DRpc:
        new_dnode = DRpc(
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            description=self.description,
            if_feature=self.if_feature,
            reference=self.reference,
            status=self.status,
            exts=self.exts,
            children=self.get_dnode_children()
        )
        for child in new_dnode.children:
            child.parent = new_dnode
        return new_dnode

""",
        "is_config": """    def is_config(self) -> bool:
        return False

"""
    },
    "submodule": {
        "get_modrev": """    def get_modrev(self) -> ModRev:
        rev = self.get_revision()
        rev_date = rev.date if rev is not None else None
        return ModRev(self.name, rev_date)

""",
        "get_revision": """    def get_revision(self) -> ?Revision:
        latest = None
        for rev in self.revision:
            if latest is None or (latest is not None and rev.date > latest.date):
                latest = rev
        return latest

""",
    },
    "type": {
        "resolve_union_types": """    def resolve_union_types(self, context: Context) -> Type:
        if self.name == "union":
            resolved_union_types = []
            # Resolve union types
            for ut in self.type_:
                resolved_ut = ut.resolve_typedef(context).type_
                resolved_union_types.append(resolved_ut)
            new = Type(self.name,
                       base=self.base,
                       bit=self.bit,
                       enum=self.enum,
                       fraction_digits=self.fraction_digits,
                       length=self.length,
                       path=self.path,
                       pattern=self.pattern,
                       range_=self.range_,
                       require_instance=self.require_instance,
                       type_=resolved_union_types)
            return new
        else:
            return self

""",
        "resolve_typedef": """    def resolve_typedef(self, context: Context) -> Typedef:
        if self.name in _builtin_types:
            return Typedef(self.name, type_=self.resolve_union_types(context))
        td = self.get_typedef(self.name, context)
        for i in range(RECURSION_LIMIT+1):
            if td.type_.name in _builtin_types:
                new_t = td.type_.resolve_union_types(context)
                td.type_ = new_t
                return td
            td = td.type_.resolve_typedef(context)
            if i == RECURSION_LIMIT:
                raise ValueError("Recursion limit reached for typedef %s" % self.name)
        raise ValueError("Unable to resolve typedef %s" % self.name)

""",
    },
    "typedef": {
        "compile": """    def compile(self, context: Context, new_ns: ?str=None, new_pfx: ?str=None):
        base_typedef = self.type_.resolve_typedef(context)

        new_default = self.default
        if new_default is None:
            new_default = base_typedef.default

        new_units = self.units
        if new_units is None:
            new_units = base_typedef.units

        new = Typedef(self.name,
                      default=new_default,
                      description=self.description,
                      reference=self.reference,
                      status=self.status,
                      type_=base_typedef.type_,
                      units=new_units,
                      exts=self.exts)
        return new

""",
    },
    "uses": {
        "compile": """    def compile(self, context: Context, new_ns: ?str=None, new_pfx: ?str=None):
        raise ValueError("Cannot compile 'uses'")

""",
        "expand_refines": '''    mut def expand_refines(self, target_base: SchemaNode):
        """Expand refinements in the uses statement to the target nodes

        target_base is the SchemaNode where this uses statement is located
        """
        def get_target(target_base, target: str):
            parts = target.lstrip("/").split("/")
            current_node = target_base
            for part in parts:
                prefix, name = split_prefix_name(part)
                if prefix is not None:
                    # TODO: or is prefix OK when it is the local prefix?
                    raise ValueError("Relative path in refine under uses cannot have prefixes")
                current_node = current_node.get(name)
            return current_node

        for refine in self.refine:
            target = get_target(target_base, refine.target_node)
            target.apply_refine(refine)

''',
    },

}

def gen(stmts: dict[str, Stmt]) -> list[str]:
    res = ["", ""]
##    for line in header.splitlines():
##        res.append(line)

    need_takers = []

    res.append("extension SchemaNode (Eq):")
    res.append("    def __eq__(self, other: SchemaNode) -> bool:")
    res.append("        if type(self) != type(other):")
    res.append("            return False")
    for stmt_name in sorted(stmts):
        res.append("        elif isinstance(self, %s) and isinstance(other, %s):" % (_class_name(stmt_name), _class_name(stmt_name)))
        attributes_to_compare = []
        for substmt in stmts[stmt_name].substmts.values():
            if substmt.name not in child_stmts:
                attributes_to_compare.append(_attr_name(substmt.name))
        if len(attributes_to_compare) > 0:
            res.append("            return " + " and ".join(map(lambda x: "self.%s == other.%s" % (x, x), attributes_to_compare)))
        else:
            res.append("            return True")
    res.append("        return False")
    res.append("")


    res.append("def snode_name(sn: SchemaNode) -> str:")
    for stmt_name in sorted(stmts):
        stmt = stmts[stmt_name]
        arg_name = stmt.argument_name
        if arg_name is not None:
            res.append("    if isinstance(sn, %s):" % _class_name(stmt_name))
            res.append("        return sn.%s" % _attr_name(arg_name))
    res.append("    raise ValueError(\"Unknown SchemaNode type in snode_name\")")
    res.append("")

    res.append("def snode_type_name(sn: SchemaNode) -> str:")
    for stmt_name in sorted(stmts):
        stmt = stmts[stmt_name]
        arg_name = stmt.argument_name
        if arg_name is not None:
            res.append("    if isinstance(sn, %s):" % _class_name(stmt_name))
            res.append("        return \"%s\"" % _class_name(stmt_name))
    res.append("    raise ValueError(\"Unknown SchemaNode type in snode_type_name\")")
    res.append("")

    for stmt_name in sorted(stmts):
        stmt = stmts[stmt_name]
        arg_name = stmt.argument_name
        have_children = False

        # Sort the list of YANG substatements for the current statement, which
        # are "consumed" by the current SchemaNode class as attributes (are not
        # in the SchemaNode.children list). This order is then preserved in the
        # to_statement() method.
        # A custom order for "module" / "submodule" substatements has priority
        # so that the module layout conforms to the "typical layout" outlined in
        # the RFC 7950 section 7.1. After that, mandatory substatements
        # (cardinality 1) are added, followed by the rest.
        def sort_attributes(attributes, module_order, mandatory):
            """Sort attributes using list of items in module_order, followed by mandatory.

            Attributes not explicitly listed are appended at the end.
            """
            # Lower number in order dict = higher priority
            order_dict = {}
            # Add module_order items first in their preferred order
            for idx, item in enumerate(module_order):
                order_dict[item] = idx
            # Add mandatory items next in the provided order
            for idx, item in enumerate(mandatory):
                order_dict.setdefault(item, len(module_order) + idx)

            result = list(attributes)

            n = len(result)
            for i in range(n):
                for j in range(0, n - i - 1):
                    pos_j = order_dict.get_def(result[j], len(order_dict))
                    pos_j1 = order_dict.get_def(result[j + 1], len(order_dict))

                    if pos_j > pos_j1:
                        attr_j = result[j]
                        attr_j1 = result[j+1]
                        result[j] = attr_j1
                        result[j+1] = attr_j

            return result

        # Read in YANG substatements for the current statement, which are
        # "consumed" by the current SchemaNode class as attributes (are not in
        # the SchemaNode.children list).
        unsorted_attrs = []
        mandatory = []
        for substmt in stmt.substmts.values():
            if substmt.name == arg_name:
                continue
            if substmt.name not in child_stmts:
                unsorted_attrs.append(substmt.name)
                if substmt.cardinality == "1":
                    mandatory.append(substmt.name)
            else:
                have_children = True
        # Custom order for "module" / "submodule" substatements so that the
        # module layout conforms to the "typical layout" outlined in the RFC
        # 7950 section 7.1.

        # Sort the attributes for the current statement
        if stmt_name in ["module", "submodule"]:
            module_order = [
                "yang-version", "namespace", "prefix", "import", "include",
                "organization", "contact", "description", "reference", "revision"
            ]
        else:
            module_order = []
        kwattrs = sort_attributes(unsorted_attrs, module_order, mandatory)

        # The substatement that is the argument to the current statement is placed first
        cattrs = [arg_name] + kwattrs if arg_name != None else kwattrs

        parent_class = "SchemaNodeInner" if have_children else "SchemaNodeOuter"
        res.append("class %s(%s):" % (_class_name(stmt_name), parent_class))
        res.append("    \"\"\"YANG %s" % stmt_name)
        res.append("")
        res.append("    https://tools.ietf.org/html/rfc7950#section-%s" % stmt.section)
        res.append("    \"\"\"")

        for attr in cattrs:
            res.append("    %s: %s" % (_attr_name(attr), _attr_type(attr, stmt, stmts)))

        res.append("")
        init_attrs = ["self"]
        pos_arg_idx = 1
        if arg_name is not None:
            pos_arg_idx += 1
        for substmt in stmt.substmts.values():
            if substmt.name == stmt.argument_name:
                init_attrs.append("%s: %s" % (_attr_name(substmt.name), _attr_type(substmt.name, stmt, stmts)))
            else:
                if substmt.name not in child_stmts:
                    # Place attributes with cardinality 1 first
                    attr_text = "%s: %s%s" % (_attr_name(substmt.name), _attr_type(substmt.name, stmt, stmts), _attr_defval(substmt.name, stmt, stmts))
                    if substmt.cardinality == "1":
                        init_attrs.insert(pos_arg_idx, attr_text)
                        pos_arg_idx += 1
                    else:
                        init_attrs.append(attr_text)
        init_attrs.append("exts=[]")
        if have_children:
            init_attrs.append("children=[]")
        if "parent" not in set(cattrs):
            init_attrs.append("parent=None")
        if "ns" not in set(cattrs):
            init_attrs.append("ns=None")
        if "pfx" not in set(cattrs):
            init_attrs.append("pfx=None")
        res.append("    def __init__(" + ", ".join(init_attrs) + "):")
        res.append("        self.parent = parent")
        res.append("        new_ns = ns")
        res.append("        new_pfx = pfx")
        if stmt_name == "module":
            res.append("        if new_ns is None:")
            res.append("            new_ns = namespace")
            res.append("        if new_pfx is None:")
            res.append("            new_pfx = prefix")
        else:
            res.append("        if new_ns is None and parent is not None:")
            res.append("            new_ns = parent.ns")
            res.append("        if new_pfx is None and parent is not None:")
            res.append("            new_pfx = parent.pfx")
        res.append("        self.ns = new_ns")
        res.append("        self.pfx = new_pfx")
#        res.append("        self.cname = \"%s\"" % _class_name(stmt_name))
        res.append("        self._yname = \"%s\"" % stmt_name)

        for substmt in stmt.substmts.values():
            if substmt.name == stmt.argument_name:
                continue
            elif substmt.name not in child_stmts: # Attribute
                if substmt.name in stmts: # Another statement (not a child)
                    # Set parent for substatement objects & inherit namespace + prefix
                    if substmt.cardinality == "0..1":
                        res.append("        if %s is not None:" % _attr_name(substmt.name))
                        res.append("            %s.parent = self" % _attr_name(substmt.name))
                        res.append("            n_ns = %s.ns" % _attr_name(substmt.name))
                        res.append("            if n_ns is None:")
                        res.append("                %s.ns = self.ns" % _attr_name(substmt.name))
                        res.append("            n_pfx = %s.pfx" % _attr_name(substmt.name))
                        res.append("            if n_pfx is None:")
                        res.append("                %s.pfx = self.pfx" % _attr_name(substmt.name))
                    elif substmt.cardinality == "1":
                        res.append("        %s.parent = self" % _attr_name(substmt.name))
                        res.append("        n_ns = %s.ns" % _attr_name(substmt.name))
                        res.append("        if n_ns is None:")
                        res.append("            %s.ns = self.ns" % _attr_name(substmt.name))
                        res.append("        n_pfx = %s.pfx" % _attr_name(substmt.name))
                        res.append("        if n_pfx is None:")
                        res.append("            %s.pfx = self.pfx" % _attr_name(substmt.name))
                    elif substmt.cardinality == "0..n":
                        res.append("        for n in %s:" % _attr_name(substmt.name))
                        res.append("            n.parent = self")
                        res.append("            n_ns = n.ns")
                        res.append("            if n_ns is None:")
                        res.append("                n.ns = self.ns")
                        res.append("            n_pfx = n.pfx")
                        res.append("            if n_pfx is None:")
                        res.append("                n.pfx = self.pfx")
                    else:
                        raise ValueError("Unknown cardinality: %s" % substmt.cardinality)

        for substmt in stmt.substmts.values():
            if substmt.name not in child_stmts: # Attribute
                res.append("        self.%s = %s" % (_attr_name(substmt.name), _attr_name(substmt.name)))

        res.append("        self.exts = exts")

        if have_children:
            res.append("        for n in children:")
            res.append("            n.parent = self")
            res.append("            n_ns = n.ns")
            res.append("            if n_ns is None:")
            res.append("                n.ns = self.ns")
            res.append("            n_pfx = n.pfx")
            res.append("            if n_pfx is None:")
            res.append("                n.pfx = self.pfx")
            res.append("        self.children = children")
        res.append("")

        # -- get_attrs
        res.append("    def get_attrs(self) -> list[(str, ?value)]:")
        res.append("        return [")
        for attr in kwattrs:
            res.append("            (\"%s\", self.%s)," % (attr, _attr_name(attr)))
        res.append("            (\"exts\", self.exts),")
        res.append("        ]")
        res.append("")

        # -- apply_refine
        # Note: some of these refinements may end up producing invalid schema.
        # For example:
        # - refining a node to config=true is not allowed if its parent is
        #   already config=false
        # - mandatory and default statements are mutually exclusive
        # We do not validate the schema after applying the refinements in the
        # apply_refine() method, because refines are not the only source of such
        # errors. But we should check for them somewhere else ...
        refine_substatements = set(stmts["refine"].substmts) - {"target-node"}
        refinable_substatements = refine_substatements & set(cattrs)
        if refinable_substatements:
            res.append("    mut def apply_refine(self, refine: Refine):")
            for attr in refinable_substatements:
                target_cardinality = stmt.substmts[attr].cardinality
                refine_cardinality = stmts["refine"].substmts[attr].cardinality
                if target_cardinality == "0..1" and refine_cardinality == "0..1":
                    res.append("        ref_%s = refine.%s" % (_attr_name(attr), _attr_name(attr)))
                    res.append("        if ref_%s != None:" % _attr_name(attr))
                    res.append("            self.%s = ref_%s" % (_attr_name(attr), _attr_name(attr)))
                elif target_cardinality == "0..1" and refine_cardinality == "0..n":
                    res.append("        if len(refine.%s) == 1:" % _attr_name(attr))
                    res.append("            self.%s = refine.%s[0]" % (_attr_name(attr), _attr_name(attr)))
                    res.append("        elif len(refine.%s) > 1:" % _attr_name(attr))
                    res.append("            raise ValueError(\"Attempting to refine %s with multiple values\")" % attr)
                elif target_cardinality == "0..n":
                    res.append("        for ref_%s in refine.%s:" % (_attr_name(attr), _attr_name(attr)))
                    res.append("            if ref_%s not in self.%s:" % (_attr_name(attr), _attr_name(attr)))
                    res.append("                self.%s.append(ref_%s)" % (_attr_name(attr), _attr_name(attr)))
                else:
                    raise ValueError("Unknown cardinality for %s: %s" % (attr, target_cardinality))
            res.append("        self.exts.extend(refine.exts)")
            res.append("")

        # -- prsrc
        res.append("    def prsrc(self, indent=0):")
        res.append('        """Print Acton source of this node"""')
        res.append("        res = []")

        if arg_name is not None:
            res.append("        args = [\"'\" + str(self.%s) + \"'\"]" % _attr_name(arg_name))
        else:
            res.append("        args = []")
        res.append("        attrs_text = _prsrc_attrs(indent, self.get_attrs())")
        res.append("        if len(attrs_text) > 0:")
        res.append("            args.append(_prsrc_attrs(indent, self.get_attrs()))")
        if have_children:
            res.append("        if len(self.children) > 0:")
            res.append("            args.append(\"children=[\")")
        res.append("        args_text = \", \".join(args)")
        text_prscr_attrs = "        text_line = _ind(indent) + \"%s(\" + args_text" % (_class_name(stmt_name))
        if not have_children:
            text_prscr_attrs += " + \")\""
        res.append(text_prscr_attrs)
        if have_children:
            res.append("        if len(self.children) == 0:")
            res.append("            text_line += ')'")
        res.append("        res.append(text_line)")
        if have_children:
            res.append("        if len(self.children) > 0:")
            res.append("            child_res = []")
            res.append("            for child in self.children:")
            res.append("                child_res.append(child.prsrc(indent+1))")
            res.append("            res.append(\",\\n\".join(child_res))")
            res.append("            res.append(_ind(indent) + \"])\")")

        res.append("        return \"\\n\".join(res)")
        res.append("")

        manual_methods = []
        # == Statement specific methods ================================
        for method_name in snode_methods.get_def(stmt_name, {}):
            method = snode_methods[stmt_name][method_name]
            for line in method.splitlines():
                res.append(line)
            manual_methods.append(method_name)
        # ==============================================================

        # -- compile
        if "compile" not in manual_methods:
            res.append("    def compile(self, context: Context, new_ns: ?str=None, new_pfx: ?str=None):")
            new_args = []
            if arg_name is not None:
                new_args += ["self." + _attr_name(arg_name)]
            new_args += list(map(lambda x: "%s=self.%s" % (_attr_name(x), _attr_name(x)), kwattrs))
            new_args.append("exts=self.exts")
            if stmt_name not in {"module", "submodule"}:
                new_args.append("ns=new_ns if new_ns is not None else self.ns")
                new_args.append("pfx=new_pfx if new_pfx is not None else self.pfx")

            res.append("        new = %s(%s)" % (_class_name(stmt_name), (",\n               " + " " * len(_class_name(stmt_name))).join(new_args)))
            if have_children:
                res.append("        self.expand_children(context, new, new_ns)")
            for substmt in stmt.substmts.values():
                if substmt.name == "augment":
                    res.append("        new.expand_augments(context)")
            res.append("        return new")
            res.append("")

        res.append("    def __str__(self):")
        strret = "\"%s \" + self.%s" % (_class_name(stmt_name), _attr_name(arg_name)) if arg_name is not None else "\"%s\"" % (_class_name(stmt_name))
        res.append("        return " + strret)
        res.append("")

        res.append("    def _get_argname(self) -> ?str:")
        if arg_name is not None:
            res.append("        return '%s'" % _attr_name(arg_name))
        else:
            res.append("        return None")
        res.append("")

        res.append("    def _get_arg(self) -> ?str:")
        if arg_name is not None:
            res.append("        return self.%s" % _attr_name(arg_name))
        else:
            res.append("        return None")
        res.append("")

        attributes_to_compare = []
        for substmt in stmts[stmt_name].substmts.values():
            if substmt.name not in child_stmts:
                attributes_to_compare.append(_attr_name(substmt.name))

        if stmt_name == "module":
            res.append("extension %s (Hashable):" % _class_name(stmt_name))
            res.append("    def __hash__(self):")
            res.append("        rev = self.get_revision()")
            res.append("        rev_str = rev.date if rev is not None else \"\"")
            res.append("        return hash(self.get_namespace() + rev_str)")
            res.append("")
            res.append("    def __eq__(self, other: %s):" % _class_name(stmt_name))
            res.append("        return " + " and ".join(map(lambda x: "self.%s == other.%s" % (x, x), attributes_to_compare)))
            res.append("")
            res.append("extension %s (Ord):" % _class_name(stmt_name))
        else:
            res.append("extension %s (Ord):" % _class_name(stmt_name))
            res.append("    def __eq__(self, other: %s):" % _class_name(stmt_name))
            res.append("        return " + " and ".join(map(lambda x: "self.%s == other.%s" % (x, x), attributes_to_compare)))
            res.append("")

        res.append("    def __lt__(a, b):")
        if arg_name is not None:
            res.append("        return a.%s < b.%s" % (_attr_name(arg_name), _attr_name(arg_name)))
        else:
            res.append("        return True")
        res.append("")



    # Generate takers, both singular and plural (i.e. a list)
    for stmt_name in sorted(stmts):
        res.append("def take_opt_%s(stmts: list[Statement]) -> ?%s:" % (_attr_taker_name(stmt_name), _class_name(stmt_name)))
        res.append("    for node in take_nodes(stmts, [\"%s\"]):" % stmt_name)
        res.append("        if isinstance(node, %s):" % _class_name(stmt_name))
        res.append("            return node")
        res.append("")
        res.append("def take_%s(stmts: list[Statement]) -> %s:" % (_attr_taker_name(stmt_name), _class_name(stmt_name)))
        res.append("    for node in take_nodes(stmts, [\"%s\"]):" % stmt_name)
        res.append("        if isinstance(node, %s):" % _class_name(stmt_name))
        res.append("            return node")
        res.append("    raise ValueError(\"No %s in stmts\")" % stmt_name)
        res.append("")
        res.append("def take_%ss(stmts: list[Statement]) -> list[%s]:" % (_attr_taker_name(stmt_name), _class_name(stmt_name)))
        res.append("    res = []")
        res.append("    for node in take_nodes(stmts, [\"%s\"]):" % stmt_name)
        res.append("        if isinstance(node, %s):" % _class_name(stmt_name))
        res.append("            res.append(node)")
        res.append("    return res")
        res.append("")

    res.append("def stmt_to_snode(stmt: Statement, parent: ?SchemaNode=None) -> SchemaNode:")
    res.append("    arg = stmt.arg")
    res.append("    ss = stmt.substatements.copy()")
    for stmt_name in sorted(stmts):
        stmt = stmts[stmt_name]
        arg_name = stmt.argument_name
        have_children = False
        cattrs = []
        valid_children = []
        for substmt in stmt.substmts.values():
            if substmt.name in child_stmts:
                have_children = True
                valid_children.append(substmt.name)
            else:
                cattrs.append(substmt.name)
        kwattrs = cattrs if arg_name is None else cattrs[1:]

        res.append("    if stmt.kw == \"%s\":" % stmt_name)

        if arg_name is not None:
            res.append("        if arg is not None:")
        else:
            res.append("        if arg is None:")

        # take attributes
        attrs_takers = []
        if arg_name is not None:
            attrs_takers.append("arg")
        for attr in kwattrs:
            attr_take = ""
            if attr == "yang-version":
                attr_take = "yang_version=take_yang_version(ss)"
            elif attr != arg_name:
                attr_take = _attr_name(attr) + "=" + _attr_taker(attr, stmt, stmts)
            attrs_takers.append(attr_take)

        attrs_takers.append("exts=take_exts(ss)")
        attrs_takers.append("parent=parent")
        indent = " " * (17+len(_class_name(stmt_name)))
        joiner = ",\n" + indent
        res.append("            n = %s(%s\n" % (_class_name(stmt_name), joiner.join(attrs_takers)) + indent + ")")
        if have_children:
            valid_children_list = ", ".join(map(lambda x: "\"%s\"" % x, valid_children))
            res.append("            n.children=take_nodes(ss, [%s], n)" % valid_children_list)

        res.append("            if len(ss) > 0:")
        res.append("                name = ss[0].kw")
        res.append("                prefix = ss[0].prefix")
        res.append("                raise ValueError(\"Invalid statement under %s: %%s\" %% (name))" % stmt_name)
        res.append("            return n")
    res.append("    raise ValueError(\"Unknown statement:\" + stmt.kw)")
    res.append("")

    return res


# LOL, RFC7950 is missing a table definitions for the substatements of refine,
# so here's our very own bis! =)
rfc7950bis = """
7.13.999.  The refine's Substatements
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | config       | 7.21.1  | 0..1        |
                 | default      | 7.6.4   | 0..n        |
                 | description  | 7.21.3  | 0..1        |
                 | if-feature   | 7.20.2  | 0..n        |
                 | mandatory    | 7.6.5   | 0..1        |
                 | max-elements | 7.7.6   | 0..1        |
                 | min-elements | 7.7.5   | 0..1        |
                 | must         | 7.5.3   | 0..n        |
                 | presence     | 7.5.5   | 0..1        |
                 | reference    | 7.21.4  | 0..1        |
                 +--------------+---------+-------------+
"""

actor main(env):
    file_cap = file.FileCap(env.cap)
    fs = file.FS(file_cap)
    projpath = fs.exepath()[0:-len("out/bin/rfcgen")]

    schema_header = file.ReadFile(
        file.ReadFileCap(file_cap),
        file.join_path([projpath, "schema-header.act"])).read().decode()
    schema_footer = file.ReadFile(
        file.ReadFileCap(file_cap),
        file.join_path([projpath, "schema-footer.act"])).read().decode()

    yang = "\n".join(schema_header.splitlines()[4:]) + "\n".join(gen(parse_stmts(rfc.rfc7950 + rfc7950bis))) + schema_footer
    print(yang)
    env.exit(0)
