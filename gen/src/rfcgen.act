import file
import re

import rfc

"""This module generates the source code for the Acton YANG module that in turn
can be used to parse YANG modules and represent YANG schemas as Acton classes
and objects.

This is pretty meta (like meta-meta-meta), since the YANG module can print
source code of itself and the code that prints source code is in turn generated
by the code in this module. Have a decent amount of coffee before attempting to
work on this.
"""

child_stmts = {
    "action",
    "anydata",
    "anyxml",
    "case",
    "choice",
    "container",
    "grouping",
    "identity",
    "leaf",
    "leaf-list",
    "list",
    "notification",
    "rpc",
    "typedef",
    "uses",
}

class Stmt(object):
    name: str
    section: str
    argument_name: ?str
    substmts: dict[str, SubStmt]
    def __init__(self, name: str, section: str, argument_name: ?str):
        self.name = name
        self.section = section
        self.argument_name = argument_name
        self.substmts = {}

    def __str__(self):
        argname = "None"
        argument_name = self.argument_name
        if argument_name is not None:
            argname = argument_name
        return "<Stmt name: {self.name}  section: {self.section}  argument_name: {argname}  substmts: {str(self.substmts)}>"

class SubStmt(object):
    name: str
    section: str
    cardinality: str

    def __init__(self, name: str, argument_name: ?str, section: str, cardinality: str):
        self.name = name
        self.argument_name = argument_name
        self.section = section
        self.cardinality = cardinality

    def __str__(self):
        argname = "None"
        return "<SubStmt name: {self.name}  section: {self.section}  argument_name: {argname}  cardinality: {self.cardinality}>"

    def __repr__(self):
        argname = "None"
        return "<SubStmt name: {self.name}  section: {self.section}  argument_name: {argname}  cardinality: {self.cardinality}>"

reserved_names = {
    "range",
}

def parse_stmts(rfc_text: str) -> dict[str, Stmt]:
    """
    """
    arg_names = parse_arg_names(rfc_text)
    section = ""
    stmt_name = ""
    tables = {}
    in_table = False
    skip_lines = 1000
    nr = 0
    for line in rfc_text.splitlines():
        nr += 1
        if skip_lines > 0:
            skip_lines -= 1
            continue
        #        +--------------+---------+-------------+
        if in_table:
            m = re.match(r"\+--------------+\+---------\+-------------\+", line)
            if m is not None:
                in_table = False
            else:
                m = re.match(r"\| (\S+) +\| (\S+) +\| (\S+) +\|", line)
                if m is not None:
                    gname = m.group[1]
                    gsection = m.group[2]
                    gcardinality = m.group[3]
                    if gname is not None and gsection is not None and gcardinality is not None:
                        t = SubStmt(name=gname, section=gsection, cardinality=gcardinality)
                        tables[stmt_name].substmts[t.name] = t

        # Match statement chapters to find the start of a statement definition.
        # They look like:
        # 7.1.1.  The module's Substatements
        # 7.1.6.  The "include" Statement
        m = re.match(r"(\d+(\.\d+)+)\.\s+The \"?([a-z-]+)(\"|'s) (Subs|S)tatement", line)
        if m is not None:
            #print("Found statement:", m.group[2], line)
            gsection = m.group[1]
            gstmt_name = m.group[3]
            if gsection is not None and gstmt_name is not None:
                section = gsection
                stmt_name = gstmt_name
        # Find the table of substatements, header looks like:
        #        +--------------+---------+-------------+
        #        | substatement | section | cardinality |
        #        +--------------+---------+-------------+
        m = re.match(r"\| substatement +\| section \| cardinality \|", line)
        if m is not None:
            #print("Found substatement table for", stmt_name)
            in_table = True
            skip_lines = 1
            if stmt_name not in tables:
                arg_name = None
                if stmt_name in arg_names:
                    arg_name = arg_names[stmt_name]
                s = Stmt(name=stmt_name, section=section, argument_name=arg_name)
                if arg_name is not None:
                    s.substmts[arg_name] = SubStmt(name=arg_name, section="", cardinality="1")
                tables[stmt_name] = s
            else:
                print("Warning: duplicate table for", stmt_name, "at line", nr)

    return tables

def parse_arg_names(rfc_text: str) -> dict[str, str]:
    """Parse argument names from RFC
    """
    in_yin = False
    skip_lines = 0
    res = {}
    for line in rfc_text.splitlines():
        if skip_lines > 0:
            skip_lines -= 1
            continue

        if in_yin:
            # Check for end of table
            # +------------------+---------------+-------------+
            m = re.match(r"\+------------------\+---------------\+-------------\+", line)
            if m is not None:
                in_yin = False
                break
            else:
                # Grab table from YIN section that contains the argument name
                # | action           | name          | false       |
                m = re.match(r"\| (\S+) +\| (\S+) +\| (\S+) +\|", line)
                if m is not None:
                    name = m.group[1]
                    arg = m.group[2]
                    if name is not None and arg is not None:
                        res[name] = arg

        # Grab table from YIN section that contains the argument name
        # Match table header
        #             | keyword          | argument name | yin-element |
        m = re.match(r"\| keyword +\| argument name +\| yin-element +\|", line)
        if m is not None:
            in_yin = True
            skip_lines = 1
    return res


def _class_name(name: str):
    res = ""
    i = 0
    while True:
        if i == 0:
            res += name[i].upper()
        elif name[i] == "-":
            i += 1
            res += name[i].upper()
        else:
            res += name[i]
        i += 1
        if i == len(name):
            break
    if res in reserved_names:
        res = res + "_"
    return res

def _attr_name(name: str) -> str:
    res = ""
    i = 0
    while True:
        if name[i] == "-":
            res += "_"
        else:
            res += name[i]
        i += 1
        if i == len(name):
            break
    if res in {"extension", "import", "range", "type"}:
        res = res + "_"

    return res

def _attr_type(name, stmt, stmts) -> str:
    t = "str"
    # If the name is the argument name, it's always a string
    if name == stmt.argument_name:
        return "str"
    cardinality = stmt.substmts[name].cardinality
    if name in stmts:
        t = _class_name(name)
    elif name in {"config", "mandatory", "require-instance"}:
        t = "bool"
    elif name in {"fraction-digits", "length", "position"}:
        t = "int"
    elif name in {"yang-version"}:
        t = "float"


    # TODO: change namespace and prefix cardinality to 1
    #if cardinality == "0..1":
    if cardinality == "0..1":
        return "?{t}"
    elif cardinality == "1":
        return t
    elif cardinality == "0..n":
        return "list[{t}]"
    return "?str"

def _attr_taker_name(name: str):
    res = ""
    i = 0
    while True:
        if name[i] == "-":
            res += "_"
        else:
            res += name[i]
        i += 1
        if i == len(name):
            break

    return res

def _attr_taker(name, stmt, stmts) -> str:
    cardinality = stmt.substmts[name].cardinality
    t = "str"
    #if name in stmt.substmts:
    if name in stmts:
        t = _attr_taker_name(name)
    elif name in {"config", "mandatory", "require-instance"}:
        t = "bool"
    elif name in {"fraction-digits", "length", "position"}:
        t = "int"

    if cardinality == "0..1":
        if name in stmts:
            return "take_opt_{t}(ss)"
        return 'take_opt_{t}(ss, "{name}")'
    elif cardinality == "1":
        if name in stmts:
            return "take_{t}(ss)"
        return 'take_str(ss, "{name}")'
    elif cardinality == "0..n":
        if name in stmts:
            return "take_{t}s(ss)"
        return 'take_strlist(ss, "{name}")'
    else:
        raise ValueError("Unknown cardinality: {cardinality}")

def _attr_defval(name, stmt, stms) -> str:
    if name == stmt.argument_name:
        return ""
    cardinality = stmt.substmts[name].cardinality
    if cardinality == "0..1":
        return "=None"
    elif name == "yang-version":
        return "=1.1"
    elif cardinality == "1":
        return ""
    elif cardinality == "0..n":
        return "=[]"
    raise ValueError("Unknown cardinality: {cardinality}")

snode_methods = {
    "action": {
        "get": """    def get(self, name: str, ns: ?str=None) -> SchemaNode:
        # TODO: support looking up qualified by namespace
        #tns = ns if ns is not None else self.get_namespace()
        if name == 'input':
            _input = self.input
            if _input is not None:
                return _input
        if name == 'output':
            _output = self.output
            if _output is not None:
                return _output
        return SchemaNode.get(self, name, ns)

""",
        "compile": """    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        self_input = self.input
        self_output = self.output
        # new_input = self_input.compile(context) if self_input is not None else None # actonc codegen pre-evaluates before None-check
        new_input = None
        if self_input is not None:
            new_input = self_input.compile(context, new_ns)
        # new_output = self_output.compile(context) if self_output is not None else None # actonc codegen pre-evaluates before None-check
        new_output = None
        if self_output is not None:
            new_output = self_output.compile(context, new_ns)
        new = Action(self.name,
                     description=self.description,
                     if_feature=self.if_feature,
                     input=new_input if new_input is not None and isinstance(new_input, Input) else Input(),
                     output=new_output if new_output is not None and isinstance(new_output, Output) else Output(),
                     reference=self.reference,
                     status=self.status,
                     exts=self.exts,
                     mod=new_mod if new_mod is not None else self.mod,
                     ns=new_ns if new_ns is not None else self.ns,
                     pfx=new_pfx if new_pfx is not None else self.pfx)
        self.expand_children(context, new, new_ns, new_pfx)
        return new

""",
        "to_dnode": """    def to_dnode(self) -> DAction:
        dnode_children = []
        self_input = self.input
        if self_input is not None:
            input_dnode = self_input.to_dnode()
            dnode_children.append(input_dnode)
        self_output = self.output
        if self_output is not None:
            output_dnode = self_output.to_dnode()
            dnode_children.append(output_dnode)

        new_dnode = DAction(
            module=self.get_module_name(),
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            description=self.description,
            if_feature=self.if_feature,
            reference=self.reference,
            status=self.status,
            exts=self.exts,
            children=dnode_children
        )
        for child in new_dnode.children:
            child.parent = new_dnode
        return new_dnode

""",
        "is_config": """    def is_config(self) -> bool:
        return False

"""
    },
    "anydata": {
        "to_dnode": """    def to_dnode(self) -> DAnydata:
        return DAnydata(
            module=self.get_module_name(),
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            config=self.is_config(),
            description=self.description,
            if_feature=self.if_feature,
            mandatory=self.mandatory,
            must=self.must,
            reference=self.reference,
            status=self.status,
            when=self.when,
            exts=self.exts
        )

"""
    },
    "anyxml": {
        "to_dnode": """    def to_dnode(self) -> DAnyxml:
        return DAnyxml(
            module=self.get_module_name(),
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            config=self.is_config(),
            description=self.description,
            if_feature=self.if_feature,
            mandatory=self.mandatory,
            must=self.must,
            reference=self.reference,
            status=self.status,
            when=self.when,
            exts=self.exts
        )

"""
    },
    "container": {
        "is_presence": """    def is_presence(self) -> bool:
        selfpresence = self.presence
        if selfpresence is not None:
            return True
        return False

""",
        "to_dnode": """    def to_dnode(self) -> DContainer:
        new_dnode = DContainer(
            module=self.get_module_name(),
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            config=self.is_config(),
            description=self.description,
            if_feature=self.if_feature,
            must=self.must,
            presence=self.is_presence(),
            reference=self.reference,
            status=self.status,
            when=self.when,
            exts=self.exts,
            children=self.get_dnode_children()
        )
        for child in new_dnode.children:
            child.parent = new_dnode
        return new_dnode

"""
    },
    "input": {
        "to_dnode": """    def to_dnode(self) -> DInput:
        new_dnode = DInput(
            module=self.get_module_name(),
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            must=self.must,
            exts=self.exts,
            children=self.get_dnode_children()
        )
        for child in new_dnode.children:
            child.parent = new_dnode
        return new_dnode

"""
    },
    "identity": {
        "compile": r"""    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        # Normalize identity base to always include the module prefix. In doing
        # so we make it easier to later look up bases in DIdentity.
        fq_base = []
        for base in self.base:
            if ":" not in base:
                base_identity = self.get_identity(base, context)
                fq_base.append("{base_identity.pfx}:{base_identity.name}")
            else:
                fq_base.append(base)

        new = Identity(self.name,
                       base=fq_base,
                       description=self.description,
                       if_feature=self.if_feature,
                       reference=self.reference,
                       status=self.status,
                       exts=self.exts,
                       mod=new_mod if new_mod is not None else self.mod,
                       ns=new_ns if new_ns is not None else self.ns,
                       pfx=new_pfx if new_pfx is not None else self.pfx)
        return new

"""
    },
    "module": {
        "get_import_by_prefix": r"""    def get_import_by_prefix(self, prefix: str) -> Import:
        for imp in self.import_:
            if imp.prefix == prefix:
                return imp
        raise ValueError("No import with prefix {prefix} in module {self.name}")

""",
        "get_modrev": """    def get_modrev(self) -> ModRev:
        rev = self.get_revision()
        rev_date = rev.date if rev is not None else None
        return ModRev(self.name, rev_date)

""",
        "get_namespace": r"""    def get_namespace(self) -> str:
        self_ns = self.ns
        if self_ns is not None:
            return self_ns
        selfnamespace = self.namespace
        if selfnamespace is not None:
            return selfnamespace
        raise ValueError("Module {self.name} has no namespace")

""",
        "get_prefix": r"""    def get_prefix(self) -> str:
        self_pfx = self.pfx
        if self_pfx is not None:
            return self_pfx
        selfprefix = self.prefix
        if selfprefix is not None:
            return selfprefix
        raise ValueError("Module {self.name} has no prefix")

""",
        "get_revision": """    def get_revision(self) -> ?Revision:
        latest = None
        for rev in self.revision:
            if latest is None or (latest is not None and rev.date > latest.date):
                latest = rev
        return latest

""",
        "to_dnode": """    def to_dnode(self) -> DModule:
        new_dnode = DModule(
            module=self.get_module_name(),
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            description=self.description,
            identity=[c for c in self.children if isinstance(c, Identity)],
            revision=self.revision,
            reference=self.reference,
            exts=self.exts,
            children=self.get_dnode_children()
        )
        for child in new_dnode.children:
            child.parent = new_dnode
        return new_dnode

""",
        "is_config": """    def is_config(self) -> bool:
        return False

""",
        "compile": r"""    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        new = Module(self.name,
                     yang_version=self.yang_version,
                     namespace=self.namespace,
                     prefix=self.prefix,
                     import_=self.import_,
                     include=self.include,
                     organization=self.organization,
                     contact=self.contact,
                     description=self.description,
                     reference=self.reference,
                     revision=self.revision,
                     augment=self.augment,
                     deviation=self.deviation,
                     extension_=self.extension_,
                     feature=self.feature,
                     exts=self.exts)
        self.expand_children(context, new, new_mod, new_ns, new_pfx)
        new.expand_augments(context)

        # Normalize import prefixes at compile time
        # When a module imports another module with a different prefix than its actual prefix,
        # we need to normalize all references to use the actual prefix
        for import_ in self.import_:
            try:
                imported_module = context.get_module(import_.module, import_.revision_date)
            except ValueError as e:
                # TODO: import a non-existant module? error!
                print(e.error_message, err=True)
            else:
                if import_.prefix != imported_module.prefix:
                    new.remap_prefix_references(import_.prefix, imported_module.prefix)

        return new

"""
    },
    "notification": {
        "to_dnode": """    def to_dnode(self) -> DNotification:
        new_dnode = DNotification(
            module=self.get_module_name(),
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            description=self.description,
            if_feature=self.if_feature,
            reference=self.reference,
            status=self.status,
            exts=self.exts,
            children=self.get_dnode_children()
        )
        for child in new_dnode.children:
            child.parent = new_dnode
        return new_dnode

""",
        "is_config": """    def is_config(self) -> bool:
        return False

"""
    },
    "list": {
        "keys": """    def keys(self) -> list[str]:
        selfkey = self.key
        if selfkey is not None:
            return selfkey.split(" ")
        return []

""",
        "get_max_elements": """    def get_max_elements(self) -> ?int:
        selfmax_elements = self.max_elements
        if selfmax_elements is not None and selfmax_elements != "unbounded":
            return int(selfmax_elements)
        return None

""",
        "get_min_elements": """    def get_min_elements(self) -> int:
        selfmin_elements = self.min_elements
        if selfmin_elements is not None:
            return int(selfmin_elements)
        return 0

""",
        "to_dnode": """    def to_dnode(self) -> DList:
        new_dnode = DList(
            module=self.get_module_name(),
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            key=self.keys(),
            config=self.is_config(),
            description=self.description,
            if_feature=self.if_feature,
            max_elements=self.get_max_elements(),
            min_elements=self.get_min_elements(),
            must=self.must,
            ordered_by=self.ordered_by,
            reference=self.reference,
            status=self.status,
            when=self.when,
            exts=self.exts,
            children=self.get_dnode_children()
        )
        for child in new_dnode.children:
            child.parent = new_dnode
        return new_dnode

""",
    },
    "leaf": {
        # TODO: keep track of constraints in the derived type(s) that we resolve
        # TODO: look up identity from context, set Identityref as default?!
        "compile": """    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        resolved_type = self.type_.resolve_typedef(context)

        new = Leaf(self.name,
                   config=self.config,
                   default=new_default,
                   description=self.description,
                   if_feature=self.if_feature,
                   mandatory=self.mandatory,
                   must=self.must,
                   reference=self.reference,
                   status=self.status,
                   type_=resolved_type,
                   units=new_units,
                   when=self.when,
                   exts=self.exts,
                   mod=new_mod if new_mod is not None else self.mod,
                   ns=new_ns if new_ns is not None else self.ns,
                   pfx=new_pfx if new_pfx is not None else self.pfx)

        return new

""",
        "to_dnode": """    def to_dnode(self) -> DLeaf:
        return DLeaf(
            module=self.get_module_name(),
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            config=self.is_config(),
            default=self.default,
            description=self.description,
            if_feature=self.if_feature,
            mandatory=self.mandatory,
            must=self.must,
            reference=self.reference,
            status=self.status,
            type_=self.type_.to_dnode(),
            units=self.units,
            when=self.when,
            exts=self.exts
        )

"""
    },
    "leaf-list": {
        # TODO: keep track of constraints in the derived type(s) that we resolve
        "compile": """    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        resolved_type = self.type_.resolve_typedef(context)

        new = LeafList(self.name,
                       config=self.config,
                       default=self.default,
                       description=self.description,
                       if_feature=self.if_feature,
                       max_elements=self.max_elements,
                       min_elements=self.min_elements,
                       must=self.must,
                       ordered_by=self.ordered_by,
                       reference=self.reference,
                       status=self.status,
                       type_=resolved_type,
                       units=new_units,
                       when=self.when,
                       exts=self.exts,
                       mod=new_mod if new_mod is not None else self.mod,
                       ns=new_ns if new_ns is not None else self.ns,
                       pfx=new_pfx if new_pfx is not None else self.pfx)
        return new

""",
        "get_max_elements": """    def get_max_elements(self) -> ?int:
        selfmax_elements = self.max_elements
        if selfmax_elements is not None and selfmax_elements != "unbounded":
            return int(selfmax_elements)
        return None

""",
        "get_min_elements": """    def get_min_elements(self) -> int:
        selfmin_elements = self.min_elements
        if selfmin_elements is not None:
            return int(selfmin_elements)
        return 0

""",
        "to_dnode": """    def to_dnode(self) -> DLeafList:
        return DLeafList(
            module=self.get_module_name(),
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            config=self.is_config(),
            default=self.default,
            description=self.description,
            if_feature=self.if_feature,
            max_elements=self.get_max_elements(),
            min_elements=self.get_min_elements(),
            must=self.must,
            ordered_by=self.ordered_by,
            reference=self.reference,
            status=self.status,
            type_=self.type_.to_dnode(),
            units=self.units,
            when=self.when,
            exts=self.exts
        )

"""
    },
    "output": {
        "to_dnode": """    def to_dnode(self) -> DOutput:
        new_dnode = DOutput(
            module=self.get_module_name(),
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            must=self.must,
            exts=self.exts,
            children=self.get_dnode_children()
        )
        for child in new_dnode.children:
            child.parent = new_dnode
        return new_dnode

""",
        "is_config": """    def is_config(self) -> bool:
        return False

"""
    },
    "rpc": {
        "get": """    def get(self, name: str, ns: ?str=None) -> SchemaNode:
        # TODO: support looking up qualified by namespace
        #tns = ns if ns is not None else self.get_namespace()
        if name == 'input':
            _input = self.input
            if _input is not None:
                return _input
        if name == 'output':
            _output = self.output
            if _output is not None:
                return _output
        return SchemaNode.get(self, name, ns)

""",
        "compile": """    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        self_input = self.input
        self_output = self.output
        # new_input = self_input.compile(context) if self_input is not None else None # actonc codegen pre-evaluates before None-check
        new_input = None
        if self_input is not None:
            new_input = self_input.compile(context)
        # new_output = self_output.compile(context) if self_output is not None else None # actonc codegen pre-evaluates before None-check
        new_output = None
        if self_output is not None:
            new_output = self_output.compile(context)
        new = Rpc(self.name,
                  description=self.description,
                  if_feature=self.if_feature,
                  input=new_input if new_input is not None and isinstance(new_input, Input) else Input(),
                  output=new_output if new_output is not None and isinstance(new_output, Output) else Output(),
                  reference=self.reference,
                  status=self.status,
                  exts=self.exts,
                  mod=new_mod if new_mod is not None else self.mod,
                  ns=new_ns if new_ns is not None else self.ns,
                  pfx=new_pfx if new_pfx is not None else self.pfx)
        self.expand_children(context, new, new_ns, new_pfx)
        return new

""",
        "to_dnode": """    def to_dnode(self) -> DRpc:
        # Convert SchemaNode Rpc.input/output to DRpc.input/output and add to
        # its children, but only if Input and Output actually contain data
        # nodes.
        dnode_children = []
        self_input = self.input
        if self_input is not None and len(self_input.children) > 0:
            input_dnode = self_input.to_dnode()
            dnode_children.append(input_dnode)
        else:
            input_dnode = None
        self_output = self.output
        if self_output is not None and len(self_output.children) > 0:
            output_dnode = self_output.to_dnode()
            dnode_children.append(output_dnode)
        else:
            output_dnode = None

        new_dnode = DRpc(
            module=self.get_module_name(),
            namespace=self.get_namespace(),
            prefix=self.get_prefix(),
            name=self.name,
            description=self.description,
            if_feature=self.if_feature,
            input=input_dnode if isinstance(input_dnode, DInput) else None,
            output=output_dnode if isinstance(output_dnode, DOutput) else None,
            reference=self.reference,
            status=self.status,
            exts=self.exts,
            children=dnode_children
        )
        for child in new_dnode.children:
            child.parent = new_dnode
        return new_dnode

""",
        "is_config": """    def is_config(self) -> bool:
        return False

"""
    },
    "submodule": {
        "get_modrev": """    def get_modrev(self) -> ModRev:
        rev = self.get_revision()
        rev_date = rev.date if rev is not None else None
        return ModRev(self.name, rev_date)

""",
        "get_revision": """    def get_revision(self) -> ?Revision:
        latest = None
        for rev in self.revision:
            if latest is None or (latest is not None and rev.date > latest.date):
                latest = rev
        return latest

""",
    },
    "type": {
        "resolve_type": r"""    def resolve_type(self, context: Context, recursion_level=0, _top_name: ?str=None):
        top_name = _top_name if top_name is not None else self.name
        if recursion_level >= RECURSION_LIMIT:
            raise ValueError("Recursion limit reached for typedef {top_name}")

        if self.name in _builtin_types:
            if self.name == "identityref":
                # Normalize identity base to always include the module prefix. In doing
                # so we make it easier to later look up bases in DIdentity.
                fq_base = []
                for base in self.base:
                    if ":" not in base:
                        base_identity = self.get_identity(base, context)
                        fq_base.append("{base_identity.pfx}:{base_identity.name}")
                    else:
                        fq_base.append(base)

                return ResolvedType(
                        self.name,
                        base=fq_base,
                        require_instance=self.require_instance,
                        exts=self.exts,
                        mod=self.mod,
                        ns=self.ns,
                        pfx=self.pfx)

            elif self.name == "union":
                # Resolve union types
                resolved_union_types = [ut.resolve_type(context, recursion_level + 1, top_name) for ut in self.type_]
                return ResolvedType(self.name,
                           base=self.base,
                           type_=resolved_union_types)

            # Remaining builtin types
            return ResolvedType(
                    self.name,
                    base=self.base,
                    bit=self.bit,
                    enum=self.enum,
                    fraction_digits=self.fraction_digits,
                    length=self.length,
                    path=self.path,
                    pattern=self.pattern,
                    range_=self.range_,
                    require_instance=self.require_instance,
                    type_=self.type_,
                    exts=self.exts,
                    mod=self.mod,
                    ns=self.ns,
                    pfx=self.pfx)

        found_typedef = self.get_typedef(self.name, context)
        resolved_typedef = found_typedef.resolve_typedef(context, recursion_level + 1, top_name)

        return ResolvedType(
                self.name,
                base=self.base,
                bit=self.bit,
                enum=self.enum,
                fraction_digits=self.fraction_digits,
                length=self.length,
                path=self.path,
                pattern=self.pattern,
                range_=self.range_,
                require_instance=self.require_instance,
                type_=self.type_,
                exts=self.exts,
                mod=self.mod,
                ns=self.ns,
                pfx=self.pfx,
                resolved_base_typedef=resolved_typedef)

""",
    },
    "typedef": {
        "resolve_typedef": r"""    def resolve_typedef(self, context: Context, recursion_level=0, _top_name: ?str=None):
        top_name = _top_name if top_name is not None else self.name
        if recursion_level >= RECURSION_LIMIT:
            raise ValueError("Recursion limit reached for typedef {top_name}")

        resolved_base_type = self.type_.resolve_typedef(context)

        new = Typedef(self.name,
                      default=self._default,
                      description=self.description,
                      reference=self.reference,
                      status=self.status,
                      type_=resolved_base_type,
                      units=self.units,
                      exts=self.exts)
        return new

""",
        "compile": r"""    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        return self.resolve_typedef(context)

""",
    },
    "uses": {
        "compile": r"""    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):
        raise ValueError("Cannot compile 'uses'")

""",
        "expand_refines": '''    mut def expand_refines(self, target_base: SchemaNode):
        """Expand refinements in the uses statement to the target nodes

        target_base is the SchemaNode where this uses statement is located
        """
        def get_target(target_base, target: str):
            parts = target.lstrip("/").split("/")
            current_node = target_base
            for part in parts:
                prefix, name = split_prefix_name(part)
                if prefix is not None:
                    # TODO: or is prefix OK when it is the local prefix?
                    raise ValueError("Relative path in refine under uses cannot have prefixes")
                # Must use the Uses statement namespace (self.get_namespace()),
                # not default match with target (current_node).
                # In cross-module augments (Module A augments Module B), the
                # groupings expanded children have Module A namespace while the
                # target has Module B. Without an explicit namespace,
                # current_node.get() would search Module B namespace and fail.
                current_node = current_node.get(name, ns=self.get_namespace())
            return current_node

        for refine in self.refine:
            target = get_target(target_base, refine.target_node)
            target.apply_refine(refine)

''',
    },

}

def gen(stmts: dict[str, Stmt]) -> list[str]:
    res = ["", ""]
##    for line in header.splitlines():
##        res.append(line)

    need_takers = []

    res.append("extension SchemaNode (Eq):")
    res.append("    def __eq__(self, other: SchemaNode) -> bool:")
    res.append("        if type(self) != type(other):")
    res.append("            return False")
    for stmt_name in sorted(stmts):
        stmt = stmts[stmt_name]
        res.append("        elif isinstance(self, {_class_name(stmt_name)}) and isinstance(other, {_class_name(stmt_name)}):")
        attributes_to_compare = [_attr_name(substmt.name) for substmt in stmt.substmts.values() if substmt.name not in child_stmts]
        if len(attributes_to_compare) > 0:
            res.append("            return " + " and ".join(map(lambda x: "self.{x} == other.{x}", attributes_to_compare)))
        else:
            res.append("            return True")
    res.append("        return False")
    res.append("")


    res.append("def snode_name(sn: SchemaNode) -> str:")
    for stmt_name in sorted(stmts):
        stmt = stmts[stmt_name]
        arg_name = stmt.argument_name
        if arg_name is not None:
            res.append("    if isinstance(sn, {_class_name(stmt_name)}):")
            res.append("        return sn.{_attr_name(arg_name)}")
    res.append("    raise ValueError(\"Unknown SchemaNode type in snode_name\")")
    res.append("")

    res.append("def snode_type_name(sn: SchemaNode) -> str:")
    for stmt_name in sorted(stmts):
        stmt = stmts[stmt_name]
        arg_name = stmt.argument_name
        if arg_name is not None:
            res.append("    if isinstance(sn, {_class_name(stmt_name)}):")
            res.append("        return \"{_class_name(stmt_name)}\"")
    res.append("    raise ValueError(\"Unknown SchemaNode type in snode_type_name\")")
    res.append("")

    for stmt_name in sorted(stmts):
        stmt = stmts[stmt_name]
        arg_name = stmt.argument_name
        have_children = False

        # Sort the list of YANG substatements for the current statement, which
        # are "consumed" by the current SchemaNode class as attributes (are not
        # in the SchemaNode.children list). This order is then preserved in the
        # to_statement() method.
        # A custom order for "module" / "submodule" substatements has priority
        # so that the module layout conforms to the "typical layout" outlined in
        # the RFC 7950 section 7.1. After that, mandatory substatements
        # (cardinality 1) are added, followed by the rest.
        def sort_attributes(attributes, module_order, mandatory):
            """Sort attributes using list of items in module_order, followed by mandatory.

            Attributes not explicitly listed are appended at the end.
            """
            # Lower number in order dict = higher priority
            # Add module_order items first in their preferred order
            order_dict = {item: idx for idx, item in enumerate(module_order)}
            # Add mandatory items next in the provided order
            for idx, item in enumerate(mandatory):
                order_dict.setdefault(item, len(module_order) + idx)

            result = list(attributes)

            n = len(result)
            for i in range(n):
                for j in range(0, n - i - 1):
                    pos_j = order_dict.get_def(result[j], len(order_dict))
                    pos_j1 = order_dict.get_def(result[j + 1], len(order_dict))

                    if pos_j > pos_j1:
                        attr_j = result[j]
                        attr_j1 = result[j+1]
                        result[j] = attr_j1
                        result[j+1] = attr_j

            return result

        # Read in YANG substatements for the current statement, which are
        # "consumed" by the current SchemaNode class as attributes (are not in
        # the SchemaNode.children list).
        unsorted_attrs = []
        mandatory = []
        for substmt in stmt.substmts.values():
            if substmt.name == arg_name:
                continue
            if substmt.name not in child_stmts:
                unsorted_attrs.append(substmt.name)
                if substmt.cardinality == "1":
                    mandatory.append(substmt.name)
            else:
                have_children = True
        # Custom order for "module" / "submodule" substatements so that the
        # module layout conforms to the "typical layout" outlined in the RFC
        # 7950 section 7.1.

        # Sort the attributes for the current statement
        if stmt_name in ["module", "submodule"]:
            module_order = [
                "yang-version", "namespace", "prefix", "import", "include",
                "organization", "contact", "description", "reference", "revision"
            ]
        else:
            module_order = []
        kwattrs = sort_attributes(unsorted_attrs, module_order, mandatory)

        # The substatement that is the argument to the current statement is placed first
        cattrs = [arg_name] + kwattrs if arg_name is not None else kwattrs

        parent_class = "SchemaNodeInner" if have_children else "SchemaNodeOuter"
        res.append("class {_class_name(stmt_name)}({parent_class}):")
        res.append('    """YANG {stmt_name}')
        res.append("")
        res.append("    https://tools.ietf.org/html/rfc7950#section-{stmt.section}")
        res.append('    """')

        for attr in cattrs:
            res.append("    {_attr_name(attr)}: {_attr_type(attr, stmt, stmts)}")

        res.append("")
        init_attrs = ["self"]
        pos_arg_idx = 1
        if arg_name is not None:
            pos_arg_idx += 1
        for substmt in stmt.substmts.values():
            if substmt.name == stmt.argument_name:
                init_attrs.append("{_attr_name(substmt.name)}: {_attr_type(substmt.name, stmt, stmts)}")
            else:
                if substmt.name not in child_stmts:
                    # Place attributes with cardinality 1 first
                    attr_text = "{_attr_name(substmt.name)}: {_attr_type(substmt.name, stmt, stmts)}{_attr_defval(substmt.name, stmt, stmts)}"
                    if substmt.cardinality == "1":
                        init_attrs.insert(pos_arg_idx, attr_text)
                        pos_arg_idx += 1
                    else:
                        init_attrs.append(attr_text)
        init_attrs.append("exts=[]")
        if have_children:
            init_attrs.append("children=[]")
        if "parent" not in set(cattrs):
            init_attrs.append("parent=None")
        if "mod" not in set(cattrs):
            init_attrs.append("mod=None")
        if "ns" not in set(cattrs):
            init_attrs.append("ns=None")
        if "pfx" not in set(cattrs):
            init_attrs.append("pfx=None")
        res.append("    def __init__(" + ", ".join(init_attrs) + "):")
        res.append("        self.parent = parent")
        res.append("        new_mod = mod")
        res.append("        new_ns = ns")
        res.append("        new_pfx = pfx")
        if stmt_name == "module":
            res.append("        if new_mod is None:")
            res.append("            new_mod = name")
            res.append("        if new_ns is None:")
            res.append("            new_ns = namespace")
            res.append("        if new_pfx is None:")
            res.append("            new_pfx = prefix")
        else:
            res.append("        if new_mod is None and parent is not None:")
            res.append("            new_mod = parent.mod")
            res.append("        if new_ns is None and parent is not None:")
            res.append("            new_ns = parent.ns")
            res.append("        if new_pfx is None and parent is not None:")
            res.append("            new_pfx = parent.pfx")
        res.append("        self.mod = new_mod")
        res.append("        self.ns = new_ns")
        res.append("        self.pfx = new_pfx")
#        res.append('        self.cname = "{_class_name(stmt_name)}"')
        res.append('        self._yname = "{stmt_name}"')

        for substmt in stmt.substmts.values():
            if substmt.name not in child_stmts: # Attribute
                res.append("        self.{_attr_name(substmt.name)} = {_attr_name(substmt.name)}")

        res.append("        self.exts = exts")

        if have_children:
            res.append("        self.children = children")

        for substmt in stmt.substmts.values():
            if substmt.name == stmt.argument_name:
                continue
            elif substmt.name not in child_stmts: # Attribute
                if substmt.name in stmts: # Another statement (not a child)
                    # Set parent for substatement objects & inherit namespace + prefix
                    if substmt.cardinality == "0..1":
                        res.append("        self_{_attr_name(substmt.name)} = self.{_attr_name(substmt.name)}")
                        res.append("        if self_{_attr_name(substmt.name)} is not None:")
                        res.append("            self_{_attr_name(substmt.name)}.parent = self")
                        res.append("            n_mod = self_{_attr_name(substmt.name)}.mod")
                        res.append("            if n_mod is None:")
                        res.append("                self_{_attr_name(substmt.name)}.mod = self.mod")
                        res.append("            n_ns = self_{_attr_name(substmt.name)}.ns")
                        res.append("            if n_ns is None:")
                        res.append("                self_{_attr_name(substmt.name)}.ns = self.ns")
                        res.append("            n_pfx = self_{_attr_name(substmt.name)}.pfx")
                        res.append("            if n_pfx is None:")
                        res.append("                self_{_attr_name(substmt.name)}.pfx = self.pfx")
                    elif substmt.cardinality == "1":
                        res.append("        self.{_attr_name(substmt.name)}.parent = self")
                        res.append("        n_mod = self.{_attr_name(substmt.name)}.mod")
                        res.append("        if n_mod is None:")
                        res.append("            self.{_attr_name(substmt.name)}.mod = self.mod")
                        res.append("        n_ns = self.{_attr_name(substmt.name)}.ns")
                        res.append("        if n_ns is None:")
                        res.append("            self.{_attr_name(substmt.name)}.ns = self.ns")
                        res.append("        n_pfx = self.{_attr_name(substmt.name)}.pfx")
                        res.append("        if n_pfx is None:")
                        res.append("            self.{_attr_name(substmt.name)}.pfx = self.pfx")
                    elif substmt.cardinality == "0..n":
                        res.append("        for n in self.{_attr_name(substmt.name)}:")
                        res.append("            n.parent = self")
                        res.append("            n_mod = n.mod")
                        res.append("            if n_mod is None:")
                        res.append("                n.mod = self.mod")
                        res.append("            n_ns = n.ns")
                        res.append("            if n_ns is None:")
                        res.append("                n.ns = self.ns")
                        res.append("            n_pfx = n.pfx")
                        res.append("            if n_pfx is None:")
                        res.append("                n.pfx = self.pfx")
                    else:
                        raise ValueError("Unknown cardinality: {substmt.cardinality}")

        if have_children:
            res.append("        for n in self.children:")
            res.append("            n.parent = self")
            res.append("            n_mod = n.mod")
            res.append("            if n_mod is None:")
            res.append("                n.mod = self.mod")
            res.append("            n_ns = n.ns")
            res.append("            if n_ns is None:")
            res.append("                n.ns = self.ns")
            res.append("            n_pfx = n.pfx")
            res.append("            if n_pfx is None:")
            res.append("                n.pfx = self.pfx")
        res.append("")

        # -- get_attrs
        res.append("    def get_attrs(self) -> list[(str, ?value)]:")
        res.append("        return [")
        for attr in kwattrs:
            res.append("            (\"{attr}\", self.{_attr_name(attr)}),")
        res.append("            (\"exts\", self.exts),")
        res.append("        ]")
        res.append("")

        # -- apply_refine
        # Note: some of these refinements may end up producing invalid schema.
        # For example:
        # - refining a node to config=true is not allowed if its parent is
        #   already config=false
        # - mandatory and default statements are mutually exclusive
        # We do not validate the schema after applying the refinements in the
        # apply_refine() method, because refines are not the only source of such
        # errors. But we should check for them somewhere else ...
        refine_substatements = set(stmts["refine"].substmts) - {"target-node"}
        refinable_substatements = refine_substatements & set(cattrs)
        if refinable_substatements:
            res.append("    mut def apply_refine(self, refine: Refine):")
            for attr in sorted(refinable_substatements):
                target_cardinality = stmt.substmts[attr].cardinality
                refine_cardinality = stmts["refine"].substmts[attr].cardinality
                if target_cardinality == "0..1" and refine_cardinality == "0..1":
                    res.append("        ref_{_attr_name(attr)} = refine.{_attr_name(attr)}")
                    res.append("        if ref_{_attr_name(attr)} is not None:")
                    res.append("            self.{_attr_name(attr)} = ref_{_attr_name(attr)}")
                elif target_cardinality == "0..1" and refine_cardinality == "0..n":
                    res.append("        if len(refine.{_attr_name(attr)}) == 1:")
                    res.append("            self.{_attr_name(attr)} = refine.{_attr_name(attr)}[0]")
                    res.append("        elif len(refine.{_attr_name(attr)}) > 1:")
                    res.append("            raise ValueError(\"Attempting to refine {attr} with multiple values\")")
                elif target_cardinality == "0..n":
                    res.append("        for ref_{_attr_name(attr)} in refine.{_attr_name(attr)}:")
                    res.append("            if ref_{_attr_name(attr)} not in self.{_attr_name(attr)}:")
                    res.append("                self.{_attr_name(attr)}.append(ref_{_attr_name(attr)})")
                else:
                    raise ValueError("Unknown cardinality for {attr}: {target_cardinality}")
            res.append("        self.exts.extend(refine.exts)")
            res.append("")

        manual_methods = []
        # == Statement specific methods ================================
        for method_name in snode_methods.get_def(stmt_name, {}):
            method = snode_methods[stmt_name][method_name]
            for line in method.splitlines():
                res.append(line)
            manual_methods.append(method_name)
        # ==============================================================

        # -- compile
        if "compile" not in manual_methods:
            res.append("    def compile(self, context: Context, new_mod: ?str=None, new_ns: ?str=None, new_pfx: ?str=None):")
            new_args = []
            if arg_name is not None:
                new_args += ["self.{_attr_name(arg_name)}"]
            new_args += list(map(lambda x: "{_attr_name(x)}=self.{_attr_name(x)}", kwattrs))
            new_args.append("exts=self.exts")
            if stmt_name not in {"module", "submodule"}:
                new_args.append("mod=new_mod if new_mod is not None else self.mod")
                new_args.append("ns=new_ns if new_ns is not None else self.ns")
                new_args.append("pfx=new_pfx if new_pfx is not None else self.pfx")

            res.append('        new = {_class_name(stmt_name)}({(",\n               " + " " * len(_class_name(stmt_name))).join(new_args)})')
            if have_children:
                res.append("        self.expand_children(context, new, new_mod, new_ns, new_pfx)")
            for substmt in stmt.substmts.values():
                if substmt.name == "augment":
                    res.append("        new.expand_augments(context)")
            res.append("        return new")
            res.append("")
        # ==============================================================

        # -- update_namespace_qualifiers
        if "update_namespace_qualifiers" not in manual_methods:
            res.append("    def update_namespace_qualifiers(self, new_ns: str, new_pfx: str, new_mod: str) -> None:")
            res.append('        """Updates the ns (namespace), pfx (prefix), and mod (module) attributes.')
            res.append('        """')
            res.append("        self.ns = new_ns")
            res.append("        self.pfx = new_pfx")
            res.append("        self.mod = new_mod")
            res.append("")

            if have_children:
                res.append("        # Recursively update children")
                res.append("        for child in self.children:")
                res.append("            child.update_namespace_qualifiers(new_ns, new_pfx, new_mod)")
                res.append("")

            if any(filter(lambda substmt: substmt.name == "type" and substmt.cardinality == "1", stmt.substmts.values())):
                # Type statements in leaf, leaf-list, deviate (unions are handled separately)
                res.append("        self.type_.update_namespace_qualifiers(new_ns, new_pfx, new_mod)")

            # Special handling for specific statement types
            if stmt_name == "uses":
                # Handle refine and augment within uses
                res.append("        for refine in self.refine:")
                res.append("            refine.update_namespace_qualifiers(new_ns, new_pfx, new_mod)")
                res.append("        for aug in self.augment:")
                res.append("            aug.update_namespace_qualifiers(new_ns, new_pfx, new_mod)")

            elif stmt_name == "type":
                # Handle nested types for union
                res.append("        for nested_type in self.type_:")
                res.append("            nested_type.update_namespace_qualifiers(new_ns, new_pfx, new_mod)")

            res.append("")
        # ==============================================================

        # -- remap_prefix_references
        if "remap_prefix_references" not in manual_methods:
            res.append("    def remap_prefix_references(self, old_pfx: str, new_pfx: str) -> None:")
            res.append('        """Remaps prefix references (in paths, defaults, ...) to true module prefix.')
            res.append('        """')
            res.append("")

            if have_children:
                res.append("        for child in self.children:")
                res.append("            child.remap_prefix_references(old_pfx, new_pfx)")
                res.append("")

            for substmt in stmt.substmts.values():
                attr = _attr_name(substmt.name)

                # XPath expressions that need remapping
                if substmt.name == "when":
                    res.append("        self_{attr} = self.{attr}")
                    res.append("        if self_{attr} is not None:")
                    res.append("            self.{attr} = _remap_path_prefix(self_{attr}, old_pfx, new_pfx)")
                elif substmt.name == "path":
                    res.append("        self_{attr} = self.{attr}")
                    res.append("        if self_{attr} is not None:")
                    res.append("            self.{attr} = _remap_path_prefix(self_{attr}, old_pfx, new_pfx)")

                # Must statements need special handling
                elif substmt.name == "must":
                    res.append("        for must in self.{attr}:")
                    res.append("            must.condition = _remap_path_prefix(must.condition, old_pfx, new_pfx)")

                # if-feature expressions
                elif substmt.name == "if-feature":
                    res.append("        self.{attr} = [_remap_path_prefix(f, old_pfx, new_pfx) for f in self.{attr}]")

                # Unique statements (for list)
                elif substmt.name == "unique":
                    res.append("        self.{attr} = [_remap_path_prefix(u, old_pfx, new_pfx) for u in self.{attr}]")

                # Default values that might contain prefixed identities
                elif substmt.name == "default" and stmt.name in {"leaf", "leaf-list", "typedef"}:
                    if substmt.cardinality == "0..1":
                        res.append("        if self.type_.name == 'identityref':")
                        res.append("            self_{attr} = self.{attr}")
                        res.append("            if self_{attr} is not None:")
                        res.append("                self.{attr} = _remap_path_prefix(self_{attr}, old_pfx, new_pfx)")
                    elif substmt.cardinality == "0..n":
                        res.append("        if self.type_.name == 'identityref':")
                        res.append("            self.{attr} = [_remap_path_prefix(d, old_pfx, new_pfx) for d in self.{attr}]")

                # Base identities
                elif substmt.name == "base":
                    res.append("        self.{attr} = [_remap_path_prefix(b, old_pfx, new_pfx) for b in self.{attr}]")

                # Type statements in leaf, leaf-list, deviate (unions are handled separately)
                elif substmt.name == "type":
                    if substmt.cardinality == "1":
                        res.append("        self.{attr}.remap_prefix_references(old_pfx, new_pfx)")

                # Deviation target paths
                elif substmt.name == "deviation":
                    res.append("        self.{attr} = [_remap_path_prefix(d, old_pfx, new_pfx) for d in self.{attr}]")

            # Special handling for specific statement types
            if stmt_name == "uses":
                # Uses name can be prefixed
                res.append("        self.name = _remap_path_prefix(self.name, old_pfx, new_pfx)")
                # Handle refine and augment within uses
                res.append("        for refine in self.refine:")
                res.append("            refine.target_node = _remap_path_prefix(refine.target_node, old_pfx, new_pfx)")
                res.append("            refine.remap_prefix_references(old_pfx, new_pfx)")
                res.append("        for aug in self.augment:")
                res.append("            aug.target_node = _remap_path_prefix(aug.target_node, old_pfx, new_pfx)")
                res.append("            aug.remap_prefix_references(old_pfx, new_pfx)")

            elif stmt_name == "augment":
                # Augment target path
                res.append("        self.target_node = _remap_path_prefix(self.target_node, old_pfx, new_pfx)")

            elif stmt_name == "refine":
                # Refine target path
                res.append("        self.target_node = _remap_path_prefix(self.target_node, old_pfx, new_pfx)")

            elif stmt_name == "type":
                # Type name can be prefixed for user-defined types
                res.append("        self.name = _remap_path_prefix(self.name, old_pfx, new_pfx)")
                # Handle nested types for union
                res.append("        for nested_type in self.type_:")
                res.append("            nested_type.remap_prefix_references(old_pfx, new_pfx)")

            res.append("")

        res.append("    def __str__(self):")
        strret = ""
        if arg_name is not None:
            strret = '"{_class_name(stmt_name)} {{self.{_attr_name(arg_name)}}}"'
        else:
            strret = '"{_class_name(stmt_name)}"'
        res.append("        return {strret}")
        res.append("")

        res.append("    def _get_class_name(self) -> str:")
        res.append('        return "{_class_name(stmt_name)}"')
        res.append("")

        res.append("    def _get_argname(self) -> ?str:")
        if arg_name is not None:
            res.append("        return '{_attr_name(arg_name)}'")
        else:
            res.append("        return None")
        res.append("")

        res.append("    def _get_arg(self) -> ?str:")
        if arg_name is not None:
            res.append("        return self.{_attr_name(arg_name)}")
        else:
            res.append("        return None")
        res.append("")

        attributes_to_compare = [_attr_name(substmt.name) for substmt in stmt.substmts.values() if substmt.name not in child_stmts]

        if stmt_name == "module":
            res.append("extension {_class_name(stmt_name)} (Hashable):")
            res.append("    def hash(self, hasher):")
            res.append("        self.get_namespace().hash(hasher)")
            res.append("        rev = self.get_revision()")
            res.append("        if rev is not None:")
            res.append("            rev.date.hash(hasher)")
            res.append("        else:")
            res.append("            # Hash empty string for None revision")
            res.append("            \"\".hash(hasher)")
            res.append("")
            res.append("    def __eq__(self, other: {_class_name(stmt_name)}):")
            res.append("        return " + " and ".join(["self.{x} == other.{x}" for x in attributes_to_compare]))
            res.append("")
            res.append("extension {_class_name(stmt_name)} (Ord):")
        else:
            res.append("extension {_class_name(stmt_name)} (Ord):")
            res.append("    def __eq__(self, other: {_class_name(stmt_name)}):")
            res.append("        return " + " and ".join(["self.{x} == other.{x}" for x in attributes_to_compare]))
            res.append("")

        res.append("    def __lt__(a, b):")
        if arg_name is not None:
            res.append("        return a.{_attr_name(arg_name)} < b.{_attr_name(arg_name)}")
        else:
            res.append("        return True")
        res.append("")



    # Generate takers, both singular and plural (i.e. a list)
    for stmt_name in sorted(stmts):
        res.append("def take_opt_{_attr_taker_name(stmt_name)}(stmts: list[Statement]) -> ?{_class_name(stmt_name)}:")
        res.append('    for node in take_nodes(stmts, ["{stmt_name}"]):')
        res.append("        if isinstance(node, {_class_name(stmt_name)}):")
        res.append("            return node")
        res.append("")
        res.append("def take_{_attr_taker_name(stmt_name)}(stmts: list[Statement]) -> {_class_name(stmt_name)}:")
        res.append('    for node in take_nodes(stmts, ["{stmt_name}"]):')
        res.append("        if isinstance(node, {_class_name(stmt_name)}):")
        res.append("            return node")
        res.append('    raise ValueError("No {stmt_name} in stmts")')
        res.append("")
        res.append("def take_{_attr_taker_name(stmt_name)}s(stmts: list[Statement]) -> list[{_class_name(stmt_name)}]:")
        res.append("    res = []")
        res.append('    for node in take_nodes(stmts, ["{stmt_name}"]):')
        res.append("        if isinstance(node, {_class_name(stmt_name)}):")
        res.append("            res.append(node)")
        res.append("    return res")
        res.append("")

    res.append("def stmt_to_snode(stmt: Statement, parent: ?SchemaNode=None) -> SchemaNode:")
    res.append("    arg = stmt.arg")
    res.append("    ss = stmt.substatements.copy()")
    for stmt_name in sorted(stmts):
        stmt = stmts[stmt_name]
        arg_name = stmt.argument_name
        have_children = False
        cattrs = []
        valid_children = []
        for substmt in stmt.substmts.values():
            if substmt.name in child_stmts:
                have_children = True
                valid_children.append(substmt.name)
            else:
                cattrs.append(substmt.name)
        kwattrs = cattrs if arg_name is None else cattrs[1:]

        res.append("    if stmt.kw == \"{stmt_name}\":")

        if arg_name is not None:
            res.append("        if arg is not None:")
        else:
            res.append("        if arg is None:")

        # take attributes
        attrs_takers = []
        if arg_name is not None:
            attrs_takers.append("arg")
        for attr in kwattrs:
            attr_take = ""
            if attr == "yang-version":
                attr_take = "yang_version=take_yang_version(ss)"
            elif attr != arg_name:
                attr_take = _attr_name(attr) + "=" + _attr_taker(attr, stmt, stmts)
            attrs_takers.append(attr_take)

        attrs_takers.append("exts=take_exts(ss)")
        attrs_takers.append("parent=parent")
        indent = " " * (17+len(_class_name(stmt_name)))
        joiner = ",\n" + indent
        res.append("            n = {_class_name(stmt_name)}({joiner.join(attrs_takers)}\n{indent})")
        if have_children:
            valid_children_list = ", ".join(['"{x}"' for x in valid_children])
            res.append("            n.children=take_nodes(ss, [{valid_children_list}], n)")

        res.append("            if len(ss) > 0:")
        res.append("                name = ss[0].kw")
        res.append("                prefix = ss[0].prefix")
        res.append('                raise ValueError("Invalid statement under {stmt_name}: {{name}}")')
        res.append("            return n")
    res.append('    raise ValueError("Unknown statement: {{stmt.kw}}")')
    res.append("")

    return res


# LOL, RFC7950 is missing a table definitions for the substatements of refine,
# so here's our very own bis! =)
rfc7950bis = """
7.13.999.  The refine's Substatements
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | config       | 7.21.1  | 0..1        |
                 | default      | 7.6.4   | 0..n        |
                 | description  | 7.21.3  | 0..1        |
                 | if-feature   | 7.20.2  | 0..n        |
                 | mandatory    | 7.6.5   | 0..1        |
                 | max-elements | 7.7.6   | 0..1        |
                 | min-elements | 7.7.5   | 0..1        |
                 | must         | 7.5.3   | 0..n        |
                 | presence     | 7.5.5   | 0..1        |
                 | reference    | 7.21.4  | 0..1        |
                 +--------------+---------+-------------+
"""

actor main(env):
    file_cap = file.FileCap(env.cap)
    fs = file.FS(file_cap)
    projpath = fs.exepath()[0:-len("out/bin/rfcgen")]

    schema_header = file.ReadFile(
        file.ReadFileCap(file_cap),
        file.join_path([projpath, "schema-header.act"])).read().decode()
    schema_footer = file.ReadFile(
        file.ReadFileCap(file_cap),
        file.join_path([projpath, "schema-footer.act"])).read().decode()

    yang = "\n".join(schema_header.splitlines()[4:]) + "\n".join(gen(parse_stmts(rfc.rfc7950 + rfc7950bis))) + schema_footer
    print(yang)
    env.exit(0)
