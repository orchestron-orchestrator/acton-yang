from yang.schema import *
import base64
import json
import xml
import yang.adata
import yang.gdata

# == This file is generated ==


mut def from_json_foo__c1__f_l1(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__c1__l3(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint64', val)

mut def from_json_foo__c1__l_empty(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_json_foo__c1__li__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__c1__li__val(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class foo__c1__li_entry(yang.adata.MNode):
    name: str
    val: ?str

    mut def __init__(self, name: str, val: ?str):
        self._ns = 'http://example.com/foo'
        self.name = name
        self.val = val

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        _val = self.val
        if _val is not None:
            children['val'] = yang.gdata.Leaf('string', _val)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.name)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> foo__c1__li_entry:
        return foo__c1__li_entry(name=n.get_str('name'), val=n.get_opt_str('val'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> foo__c1__li_entry:
        return foo__c1__li_entry(name=yang.gdata.from_xml_str(n, 'name'), val=yang.gdata.from_xml_opt_str(n, 'val'))

class foo__c1__li(yang.adata.MNode):
    elements: list[foo__c1__li_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/foo'
        self._name = 'li'
        self.elements = elements

    mut def create(self, name):
        for e in self.elements:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = foo__c1__li_entry(name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements, user_order=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[foo__c1__li_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(foo__c1__li_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[foo__c1__li_entry]:
        res = []
        for node in nodes:
            res.append(foo__c1__li_entry.from_xml(node))
        return res


mut def from_json_path_foo__c1__li_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_foo__c1__li_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['name'] = from_json_foo__c1__li__name(keys[0])
        if point == 'val':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_foo__c1__li(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_foo__c1__li_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['name'], elements, user_order=True)
    elif len(path) > 1:
        return yang.gdata.List(['name'], [from_json_path_foo__c1__li_element(jd, path, op)], user_order=True)
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_foo__c1__li_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_name = jd.get('name')
    if child_name is not None:
        children['name'] = from_json_foo__c1__li__name(child_name)
    child_val = jd.get('val')
    if child_val is not None:
        children['val'] = from_json_foo__c1__li__val(child_val)
    return yang.gdata.Container(children, [str(child_name if child_name is not None else '')])

mut def from_json_foo__c1__li(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_foo__c1__li_element(e))
    return yang.gdata.List(keys=['name'], elements=elements, user_order=True, ns=None, prefix=None)

mut def to_json_foo__c1__li_element(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_name = n.children.get('name')
    if child_name is not None:
        if isinstance(child_name, yang.gdata.Leaf):
            children['name'] = child_name.val
    child_val = n.children.get('val')
    if child_val is not None:
        if isinstance(child_val, yang.gdata.Leaf):
            children['val'] = child_val.val
    return children

mut def to_json_foo__c1__li(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_foo__c1__li_element(e))
    return elements

mut def from_json_foo__c1__ll_uint64(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList(val)

mut def from_json_foo__c1__ll_str(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList(val)

mut def from_json_foo__c1__l4(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__c1__bar_l1(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__c1__l2(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class foo__c1(yang.adata.MNode):
    f_l1: ?str
    l3: ?int
    l_empty: ?bool
    li: foo__c1__li
    ll_uint64: list[int]
    ll_str: list[str]
    l4: ?str
    bar_l1: ?str
    l2: ?str

    mut def __init__(self, f_l1: ?str, l3: ?int, l_empty: ?bool, li: list[foo__c1__li_entry]=[], ll_uint64: ?list[int]=None, ll_str: ?list[str]=None, l4: ?str, bar_l1: ?str, l2: ?str):
        self._ns = 'http://example.com/foo'
        self.f_l1 = f_l1
        self.l3 = l3
        self.l_empty = l_empty
        self.li = foo__c1__li(elements=li)
        self.ll_uint64 = ll_uint64 if ll_uint64 is not None else []
        self.ll_str = ll_str if ll_str is not None else []
        self.l4 = l4
        self.bar_l1 = bar_l1
        self.l2 = l2

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _f_l1 = self.f_l1
        if _f_l1 is not None:
            children['f:l1'] = yang.gdata.Leaf('string', _f_l1)
        _l3 = self.l3
        if _l3 is not None:
            children['l3'] = yang.gdata.Leaf('uint64', _l3)
        _l_empty = self.l_empty
        if _l_empty is not None:
            children['l_empty'] = yang.gdata.Leaf('empty', _l_empty)
        _li = self.li
        if _li is not None:
            children['li'] = _li.to_gdata()
        children['ll_uint64'] = yang.gdata.LeafList(self.ll_uint64)
        children['ll_str'] = yang.gdata.LeafList(self.ll_str)
        _l4 = self.l4
        if _l4 is not None:
            children['l4'] = yang.gdata.Leaf('string', _l4)
        _bar_l1 = self.bar_l1
        if _bar_l1 is not None:
            children['bar:l1'] = yang.gdata.Leaf('string', _bar_l1, ns='http://example.com/bar')
        _l2 = self.l2
        if _l2 is not None:
            children['l2'] = yang.gdata.Leaf('string', _l2, ns='http://example.com/bar')
        return yang.gdata.Container(children, ns='http://example.com/foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__c1:
        if n != None:
            return foo__c1(f_l1=n.get_opt_str('f:l1'), l3=n.get_opt_int('l3'), l_empty=n.get_opt_bool('l_empty'), li=foo__c1__li.from_gdata(n.get_opt_list('li')), ll_uint64=n.get_opt_ints('ll_uint64'), ll_str=n.get_opt_strs('ll_str'), l4=n.get_opt_str('l4'), bar_l1=n.get_opt_str('bar:l1'), l2=n.get_opt_str('l2'))
        return foo__c1()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> foo__c1:
        if n != None:
            return foo__c1(f_l1=yang.gdata.from_xml_opt_str(n, 'l1'), l3=yang.gdata.from_xml_opt_int(n, 'l3'), l_empty=yang.gdata.from_xml_opt_bool(n, 'l_empty'), li=foo__c1__li.from_xml(yang.gdata.get_xml_children(n, 'li')), ll_uint64=yang.gdata.from_xml_opt_ints(n, 'll_uint64'), ll_str=yang.gdata.from_xml_opt_strs(n, 'll_str'), l4=yang.gdata.from_xml_opt_str(n, 'l4'), bar_l1=yang.gdata.from_xml_opt_str(n, 'l1', 'http://example.com/bar'), l2=yang.gdata.from_xml_opt_str(n, 'l2', 'http://example.com/bar'))
        return foo__c1()


mut def from_json_path_foo__c1(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l1':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l_empty':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'li':
            child = {'li': from_json_path_foo__c1__li(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'll_uint64':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'll_str':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l4':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'bar:l1':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'bar:l2':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__c1(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__c1(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_f_l1 = jd.get('l1')
    if child_f_l1 is not None:
        children['f:l1'] = from_json_foo__c1__f_l1(child_f_l1)
    child_l3 = jd.get('l3')
    if child_l3 is not None:
        children['l3'] = from_json_foo__c1__l3(child_l3)
    child_l_empty = jd.get('l_empty')
    if child_l_empty is not None:
        children['l_empty'] = from_json_foo__c1__l_empty(child_l_empty)
    child_li = jd.get('li')
    if child_li is not None and isinstance(child_li, list):
        children['li'] = from_json_foo__c1__li(child_li)
    child_ll_uint64 = jd.get('ll_uint64')
    if child_ll_uint64 is not None and isinstance(child_ll_uint64, list):
        children['ll_uint64'] = from_json_foo__c1__ll_uint64(child_ll_uint64)
    child_ll_str = jd.get('ll_str')
    if child_ll_str is not None and isinstance(child_ll_str, list):
        children['ll_str'] = from_json_foo__c1__ll_str(child_ll_str)
    child_l4 = jd.get('l4')
    if child_l4 is not None:
        children['l4'] = from_json_foo__c1__l4(child_l4)
    child_bar_l1 = jd.get('bar:l1')
    if child_bar_l1 is not None:
        children['bar:l1'] = from_json_foo__c1__bar_l1(child_bar_l1)
    child_l2 = jd.get('bar:l2')
    if child_l2 is not None:
        children['l2'] = from_json_foo__c1__l2(child_l2)
    return yang.gdata.Container(children)

mut def to_json_foo__c1(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_f_l1 = n.children.get('f:l1')
    if child_f_l1 is not None:
        if isinstance(child_f_l1, yang.gdata.Leaf):
            children['l1'] = child_f_l1.val
    child_l3 = n.children.get('l3')
    if child_l3 is not None:
        if isinstance(child_l3, yang.gdata.Leaf):
            children['l3'] = child_l3.val
    child_l_empty = n.children.get('l_empty')
    if child_l_empty is not None:
        if isinstance(child_l_empty, yang.gdata.Leaf):
            children['l_empty'] = child_l_empty.val
    child_li = n.children.get('li')
    if child_li is not None:
        if isinstance(child_li, yang.gdata.List):
            children['li'] = to_json_foo__c1__li(child_li)
    child_ll_uint64 = n.children.get('ll_uint64')
    if child_ll_uint64 is not None:
        if isinstance(child_ll_uint64, yang.gdata.LeafList):
            children['ll_uint64'] = child_ll_uint64.vals
    child_ll_str = n.children.get('ll_str')
    if child_ll_str is not None:
        if isinstance(child_ll_str, yang.gdata.LeafList):
            children['ll_str'] = child_ll_str.vals
    child_l4 = n.children.get('l4')
    if child_l4 is not None:
        if isinstance(child_l4, yang.gdata.Leaf):
            children['l4'] = child_l4.val
    child_bar_l1 = n.children.get('bar:l1')
    if child_bar_l1 is not None:
        if isinstance(child_bar_l1, yang.gdata.Leaf):
            children['bar:l1'] = child_bar_l1.val
    child_l2 = n.children.get('l2')
    if child_l2 is not None:
        if isinstance(child_l2, yang.gdata.Leaf):
            children['bar:l2'] = child_l2.val
    return children

mut def from_json_foo__pc1__foo__l1(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList(val)

class foo__pc1__foo(yang.adata.MNode):
    l1: list[bytes]

    mut def __init__(self, l1: ?list[bytes]=None):
        self._ns = 'http://example.com/foo'
        self.l1 = l1 if l1 is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        children['l1'] = yang.gdata.LeafList(self.l1)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__pc1__foo:
        if n != None:
            return foo__pc1__foo(l1=n.get_opt_bytess('l1'))
        return foo__pc1__foo()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> foo__pc1__foo:
        if n != None:
            return foo__pc1__foo(l1=yang.gdata.from_xml_opt_bytess(n, 'l1'))
        return foo__pc1__foo()


mut def from_json_path_foo__pc1__foo(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l1':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__pc1__foo(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__pc1__foo(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_l1 = jd.get('l1')
    if child_l1 is not None and isinstance(child_l1, list):
        children['l1'] = from_json_foo__pc1__foo__l1(child_l1)
    return yang.gdata.Container(children)

mut def to_json_foo__pc1__foo(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_l1 = n.children.get('l1')
    if child_l1 is not None:
        if isinstance(child_l1, yang.gdata.LeafList):
            children['l1'] = child_l1.vals
    return children

class foo__pc1(yang.adata.MNode):
    foo: foo__pc1__foo

    mut def __init__(self, foo: ?foo__pc1__foo=None):
        self._ns = 'http://example.com/foo'
        self.foo = foo if foo is not None else foo__pc1__foo()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _foo = self.foo
        if _foo is not None:
            children['foo'] = _foo.to_gdata()
        return yang.gdata.Container(children, presence=True, ns='http://example.com/foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?foo__pc1:
        if n != None:
            return foo__pc1(foo=foo__pc1__foo.from_gdata(n.get_opt_container('foo')))
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?foo__pc1:
        if n != None:
            return foo__pc1(foo=foo__pc1__foo.from_xml(yang.gdata.get_xml_opt_child(n, 'foo')))
        return None


mut def from_json_path_foo__pc1(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'foo':
            child = {'foo': from_json_path_foo__pc1__foo(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__pc1(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__pc1(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_foo = jd.get('foo')
    if child_foo is not None and isinstance(child_foo, dict):
        children['foo'] = from_json_foo__pc1__foo(child_foo)
    return yang.gdata.Container(children)

mut def to_json_foo__pc1(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_foo = n.children.get('foo')
    if child_foo is not None:
        if isinstance(child_foo, yang.gdata.Container):
            children['foo'] = to_json_foo__pc1__foo(child_foo)
    return children

mut def from_json_foo__pc2__foo__l_mandatory(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class foo__pc2__foo(yang.adata.MNode):
    l_mandatory: str

    mut def __init__(self, l_mandatory: str):
        self._ns = 'http://example.com/foo'
        self.l_mandatory = l_mandatory

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _l_mandatory = self.l_mandatory
        if _l_mandatory is not None:
            children['l_mandatory'] = yang.gdata.Leaf('string', _l_mandatory)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__pc2__foo:
        if n != None:
            return foo__pc2__foo(l_mandatory=n.get_str('l_mandatory'))
        raise ValueError('Missing required subtree foo__pc2__foo')

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> foo__pc2__foo:
        if n != None:
            return foo__pc2__foo(l_mandatory=yang.gdata.from_xml_str(n, 'l_mandatory'))
        raise ValueError('Missing required subtree foo__pc2__foo')


mut def from_json_path_foo__pc2__foo(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l_mandatory':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__pc2__foo(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__pc2__foo(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_l_mandatory = jd.get('l_mandatory')
    if child_l_mandatory is not None:
        children['l_mandatory'] = from_json_foo__pc2__foo__l_mandatory(child_l_mandatory)
    return yang.gdata.Container(children)

mut def to_json_foo__pc2__foo(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_l_mandatory = n.children.get('l_mandatory')
    if child_l_mandatory is not None:
        if isinstance(child_l_mandatory, yang.gdata.Leaf):
            children['l_mandatory'] = child_l_mandatory.val
    return children

class foo__pc2(yang.adata.MNode):
    foo: foo__pc2__foo

    mut def __init__(self, foo: foo__pc2__foo):
        self._ns = 'http://example.com/foo'
        self.foo = foo

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _foo = self.foo
        if _foo is not None:
            children['foo'] = _foo.to_gdata()
        return yang.gdata.Container(children, presence=True, ns='http://example.com/foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?foo__pc2:
        if n != None:
            return foo__pc2(foo=foo__pc2__foo.from_gdata(n.get_container('foo')))
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?foo__pc2:
        if n != None:
            return foo__pc2(foo=foo__pc2__foo.from_xml(yang.gdata.get_xml_child(n, 'foo')))
        return None


mut def from_json_path_foo__pc2(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'foo':
            child = {'foo': from_json_path_foo__pc2__foo(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__pc2(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__pc2(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_foo = jd.get('foo')
    if child_foo is not None and isinstance(child_foo, dict):
        children['foo'] = from_json_foo__pc2__foo(child_foo)
    return yang.gdata.Container(children)

mut def to_json_foo__pc2(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_foo = n.children.get('foo')
    if child_foo is not None:
        if isinstance(child_foo, yang.gdata.Container):
            children['foo'] = to_json_foo__pc2__foo(child_foo)
    return children

class foo__empty_presence(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://example.com/foo'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True, ns='http://example.com/foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?foo__empty_presence:
        if n != None:
            return foo__empty_presence()
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?foo__empty_presence:
        if n != None:
            return foo__empty_presence()
        return None


mut def from_json_path_foo__empty_presence(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__empty_presence(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__empty_presence(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def to_json_foo__empty_presence(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    return children

mut def from_json_foo__c_dot__l_dot1(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__c_dot__l_dot2(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class foo__c_dot(yang.adata.MNode):
    l_dot1: ?str
    l_dot2: ?str

    mut def __init__(self, l_dot1: ?str, l_dot2: ?str):
        self._ns = 'http://example.com/foo'
        self.l_dot1 = l_dot1
        self.l_dot2 = l_dot2

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _l_dot1 = self.l_dot1
        if _l_dot1 is not None:
            children['l.dot1'] = yang.gdata.Leaf('string', _l_dot1)
        _l_dot2 = self.l_dot2
        if _l_dot2 is not None:
            children['l.dot2'] = yang.gdata.Leaf('string', _l_dot2, ns='http://example.com/bar')
        return yang.gdata.Container(children, ns='http://example.com/foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__c_dot:
        if n != None:
            return foo__c_dot(l_dot1=n.get_opt_str('l.dot1'), l_dot2=n.get_opt_str('l.dot2'))
        return foo__c_dot()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> foo__c_dot:
        if n != None:
            return foo__c_dot(l_dot1=yang.gdata.from_xml_opt_str(n, 'l.dot1'), l_dot2=yang.gdata.from_xml_opt_str(n, 'l.dot2', 'http://example.com/bar'))
        return foo__c_dot()


mut def from_json_path_foo__c_dot(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l.dot1':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'bar:l.dot2':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__c_dot(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__c_dot(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_l_dot1 = jd.get('l.dot1')
    if child_l_dot1 is not None:
        children['l.dot1'] = from_json_foo__c_dot__l_dot1(child_l_dot1)
    child_l_dot2 = jd.get('bar:l.dot2')
    if child_l_dot2 is not None:
        children['l.dot2'] = from_json_foo__c_dot__l_dot2(child_l_dot2)
    return yang.gdata.Container(children)

mut def to_json_foo__c_dot(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_l_dot1 = n.children.get('l.dot1')
    if child_l_dot1 is not None:
        if isinstance(child_l_dot1, yang.gdata.Leaf):
            children['l.dot1'] = child_l_dot1.val
    child_l_dot2 = n.children.get('l.dot2')
    if child_l_dot2 is not None:
        if isinstance(child_l_dot2, yang.gdata.Leaf):
            children['bar:l.dot2'] = child_l_dot2.val
    return children

mut def from_json_foo__cc__cake(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__cc__death__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class foo__cc__death_entry(yang.adata.MNode):
    name: str

    mut def __init__(self, name: str):
        self._ns = 'http://example.com/foo'
        self.name = name

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.name)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> foo__cc__death_entry:
        return foo__cc__death_entry(name=n.get_str('name'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> foo__cc__death_entry:
        return foo__cc__death_entry(name=yang.gdata.from_xml_str(n, 'name'))

class foo__cc__death(yang.adata.MNode):
    elements: list[foo__cc__death_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/foo'
        self._name = 'death'
        self.elements = elements

    mut def create(self, name):
        for e in self.elements:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = foo__cc__death_entry(name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[foo__cc__death_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(foo__cc__death_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[foo__cc__death_entry]:
        res = []
        for node in nodes:
            res.append(foo__cc__death_entry.from_xml(node))
        return res


mut def from_json_path_foo__cc__death_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_foo__cc__death_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['name'] = from_json_foo__cc__death__name(keys[0])
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_foo__cc__death(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_foo__cc__death_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['name'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['name'], [from_json_path_foo__cc__death_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_foo__cc__death_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_name = jd.get('name')
    if child_name is not None:
        children['name'] = from_json_foo__cc__death__name(child_name)
    return yang.gdata.Container(children, [str(child_name if child_name is not None else '')])

mut def from_json_foo__cc__death(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_foo__cc__death_element(e))
    return yang.gdata.List(keys=['name'], elements=elements, ns=None, prefix=None)

mut def to_json_foo__cc__death_element(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_name = n.children.get('name')
    if child_name is not None:
        if isinstance(child_name, yang.gdata.Leaf):
            children['name'] = child_name.val
    return children

mut def to_json_foo__cc__death(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_foo__cc__death_element(e))
    return elements

class foo__cc(yang.adata.MNode):
    cake: ?str
    death: foo__cc__death

    mut def __init__(self, cake: ?str, death: list[foo__cc__death_entry]=[]):
        self._ns = 'http://example.com/foo'
        self.cake = cake
        self.death = foo__cc__death(elements=death)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _cake = self.cake
        if _cake is not None:
            children['cake'] = yang.gdata.Leaf('string', _cake)
        _death = self.death
        if _death is not None:
            children['death'] = _death.to_gdata()
        return yang.gdata.Container(children, ns='http://example.com/foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__cc:
        if n != None:
            return foo__cc(cake=n.get_opt_str('cake'), death=foo__cc__death.from_gdata(n.get_opt_list('death')))
        return foo__cc()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> foo__cc:
        if n != None:
            return foo__cc(cake=yang.gdata.from_xml_opt_str(n, 'cake'), death=foo__cc__death.from_xml(yang.gdata.get_xml_children(n, 'death')))
        return foo__cc()


mut def from_json_path_foo__cc(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'cake':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'death':
            child = {'death': from_json_path_foo__cc__death(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__cc(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__cc(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_cake = jd.get('cake')
    if child_cake is not None:
        children['cake'] = from_json_foo__cc__cake(child_cake)
    child_death = jd.get('death')
    if child_death is not None and isinstance(child_death, list):
        children['death'] = from_json_foo__cc__death(child_death)
    return yang.gdata.Container(children)

mut def to_json_foo__cc(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_cake = n.children.get('cake')
    if child_cake is not None:
        if isinstance(child_cake, yang.gdata.Leaf):
            children['cake'] = child_cake.val
    child_death = n.children.get('death')
    if child_death is not None:
        if isinstance(child_death, yang.gdata.List):
            children['death'] = to_json_foo__cc__death(child_death)
    return children

mut def from_json_foo__conflict__f_foo(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class foo__conflict__f_inner(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://example.com/foo'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?foo__conflict__f_inner:
        if n != None:
            return foo__conflict__f_inner()
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?foo__conflict__f_inner:
        if n != None:
            return foo__conflict__f_inner()
        return None


mut def from_json_path_foo__conflict__f_inner(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__conflict__f_inner(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__conflict__f_inner(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def to_json_foo__conflict__f_inner(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    return children

mut def from_json_foo__conflict__bar_foo(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class foo__conflict__bar_inner(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://example.com/bar'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True, ns='http://example.com/bar')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?foo__conflict__bar_inner:
        if n != None:
            return foo__conflict__bar_inner()
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?foo__conflict__bar_inner:
        if n != None:
            return foo__conflict__bar_inner()
        return None


mut def from_json_path_foo__conflict__bar_inner(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__conflict__bar_inner(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__conflict__bar_inner(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def to_json_foo__conflict__bar_inner(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    return children

class foo__conflict(yang.adata.MNode):
    f_foo: ?str
    f_inner: ?foo__conflict__f_inner
    bar_foo: ?str
    bar_inner: ?foo__conflict__bar_inner

    mut def __init__(self, f_foo: ?str, f_inner: ?foo__conflict__f_inner=None, bar_foo: ?str, bar_inner: ?foo__conflict__bar_inner=None):
        self._ns = 'http://example.com/foo'
        self.f_foo = f_foo
        self.f_inner = f_inner
        self.bar_foo = bar_foo
        self.bar_inner = bar_inner

    mut def create_f_inner(self):
        res = foo__conflict__f_inner()
        self.f_inner = res
        return res

    mut def create_bar_inner(self):
        res = foo__conflict__bar_inner()
        self.bar_inner = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _f_foo = self.f_foo
        if _f_foo is not None:
            children['f:foo'] = yang.gdata.Leaf('string', _f_foo)
        _f_inner = self.f_inner
        if _f_inner is not None:
            children['f:inner'] = _f_inner.to_gdata()
        _bar_foo = self.bar_foo
        if _bar_foo is not None:
            children['bar:foo'] = yang.gdata.Leaf('string', _bar_foo, ns='http://example.com/bar')
        _bar_inner = self.bar_inner
        if _bar_inner is not None:
            children['bar:inner'] = _bar_inner.to_gdata()
        return yang.gdata.Container(children, ns='http://example.com/foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__conflict:
        if n != None:
            return foo__conflict(f_foo=n.get_opt_str('f:foo'), f_inner=foo__conflict__f_inner.from_gdata(n.get_opt_container('f:inner')), bar_foo=n.get_opt_str('bar:foo'), bar_inner=foo__conflict__bar_inner.from_gdata(n.get_opt_container('bar:inner')))
        return foo__conflict()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> foo__conflict:
        if n != None:
            return foo__conflict(f_foo=yang.gdata.from_xml_opt_str(n, 'foo'), f_inner=foo__conflict__f_inner.from_xml(yang.gdata.get_xml_opt_child(n, 'inner')), bar_foo=yang.gdata.from_xml_opt_str(n, 'foo', 'http://example.com/bar'), bar_inner=foo__conflict__bar_inner.from_xml(yang.gdata.get_xml_opt_child(n, 'inner', 'http://example.com/bar')))
        return foo__conflict()


mut def from_json_path_foo__conflict(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'foo':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'inner':
            child = {'f:inner': from_json_path_foo__conflict__f_inner(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'bar:foo':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'bar:inner':
            child = {'bar:inner': from_json_path_foo__conflict__bar_inner(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__conflict(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__conflict(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_f_foo = jd.get('foo')
    if child_f_foo is not None:
        children['f:foo'] = from_json_foo__conflict__f_foo(child_f_foo)
    child_f_inner = jd.get('inner')
    if child_f_inner is not None and isinstance(child_f_inner, dict):
        children['f:inner'] = from_json_foo__conflict__f_inner(child_f_inner)
    child_bar_foo = jd.get('bar:foo')
    if child_bar_foo is not None:
        children['bar:foo'] = from_json_foo__conflict__bar_foo(child_bar_foo)
    child_bar_inner = jd.get('bar:inner')
    if child_bar_inner is not None and isinstance(child_bar_inner, dict):
        children['bar:inner'] = from_json_foo__conflict__bar_inner(child_bar_inner)
    return yang.gdata.Container(children)

mut def to_json_foo__conflict(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_f_foo = n.children.get('f:foo')
    if child_f_foo is not None:
        if isinstance(child_f_foo, yang.gdata.Leaf):
            children['foo'] = child_f_foo.val
    child_f_inner = n.children.get('f:inner')
    if child_f_inner is not None:
        if isinstance(child_f_inner, yang.gdata.Container):
            children['inner'] = to_json_foo__conflict__f_inner(child_f_inner)
    child_bar_foo = n.children.get('bar:foo')
    if child_bar_foo is not None:
        if isinstance(child_bar_foo, yang.gdata.Leaf):
            children['bar:foo'] = child_bar_foo.val
    child_bar_inner = n.children.get('bar:inner')
    if child_bar_inner is not None:
        if isinstance(child_bar_inner, yang.gdata.Container):
            children['bar:inner'] = to_json_foo__conflict__bar_inner(child_bar_inner)
    return children

mut def from_json_foo__special__yes(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class foo__special_entry(yang.adata.MNode):
    yes: bool

    mut def __init__(self, yes: bool):
        self._ns = 'http://example.com/foo'
        self.yes = yes

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _yes = self.yes
        if _yes is not None:
            children['yes'] = yang.gdata.Leaf('boolean', _yes)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.yes)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> foo__special_entry:
        return foo__special_entry(yes=n.get_bool('yes'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> foo__special_entry:
        return foo__special_entry(yes=yang.gdata.from_xml_bool(n, 'yes'))

class foo__special(yang.adata.MNode):
    elements: list[foo__special_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/foo'
        self._name = 'special'
        self.elements = elements

    mut def create(self, yes):
        for e in self.elements:
            match = True
            if e.yes != yes:
                match = False
                continue
            if match:
                return e

        res = foo__special_entry(yes)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['yes'], elements, ns='http://example.com/foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[foo__special_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(foo__special_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[foo__special_entry]:
        res = []
        for node in nodes:
            res.append(foo__special_entry.from_xml(node))
        return res


mut def from_json_path_foo__special_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_foo__special_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['yes'] = from_json_foo__special__yes(keys[0])
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_foo__special(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['yes']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_foo__special_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['yes'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['yes'], [from_json_path_foo__special_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_foo__special_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_yes = jd.get('yes')
    if child_yes is not None:
        children['yes'] = from_json_foo__special__yes(child_yes)
    return yang.gdata.Container(children, [str(child_yes if child_yes is not None else '')])

mut def from_json_foo__special(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_foo__special_element(e))
    return yang.gdata.List(keys=['yes'], elements=elements, ns=None, prefix=None)

mut def to_json_foo__special_element(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_yes = n.children.get('yes')
    if child_yes is not None:
        if isinstance(child_yes, yang.gdata.Leaf):
            children['yes'] = child_yes.val
    return children

mut def to_json_foo__special(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_foo__special_element(e))
    return elements

mut def from_json_foo__nested__f_inner__foo(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__nested__f_inner__li1__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__nested__f_inner__li1__f_bar(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__nested__f_inner__li1__li2__key1(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__nested__f_inner__li1__li2__key2(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__nested__f_inner__li1__li2__baz(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class foo__nested__f_inner__li1__li2_entry(yang.adata.MNode):
    key1: str
    key2: str
    baz: ?str

    mut def __init__(self, key1: str, key2: str, baz: ?str):
        self._ns = 'http://example.com/foo'
        self.key1 = key1
        self.key2 = key2
        self.baz = baz

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _key1 = self.key1
        if _key1 is not None:
            children['key1'] = yang.gdata.Leaf('string', _key1)
        _key2 = self.key2
        if _key2 is not None:
            children['key2'] = yang.gdata.Leaf('string', _key2)
        _baz = self.baz
        if _baz is not None:
            children['baz'] = yang.gdata.Leaf('string', _baz)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.key1), yang.gdata.yang_str(self.key2)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> foo__nested__f_inner__li1__li2_entry:
        return foo__nested__f_inner__li1__li2_entry(key1=n.get_str('key1'), key2=n.get_str('key2'), baz=n.get_opt_str('baz'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> foo__nested__f_inner__li1__li2_entry:
        return foo__nested__f_inner__li1__li2_entry(key1=yang.gdata.from_xml_str(n, 'key1'), key2=yang.gdata.from_xml_str(n, 'key2'), baz=yang.gdata.from_xml_opt_str(n, 'baz'))

class foo__nested__f_inner__li1__li2(yang.adata.MNode):
    elements: list[foo__nested__f_inner__li1__li2_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/foo'
        self._name = 'li2'
        self.elements = elements

    mut def create(self, key1, key2):
        for e in self.elements:
            match = True
            if e.key1 != key1:
                match = False
                continue
            if e.key2 != key2:
                match = False
                continue
            if match:
                return e

        res = foo__nested__f_inner__li1__li2_entry(key1, key2)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['key1', 'key2'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[foo__nested__f_inner__li1__li2_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(foo__nested__f_inner__li1__li2_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[foo__nested__f_inner__li1__li2_entry]:
        res = []
        for node in nodes:
            res.append(foo__nested__f_inner__li1__li2_entry.from_xml(node))
        return res


mut def from_json_path_foo__nested__f_inner__li1__li2_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_foo__nested__f_inner__li1__li2_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['key1'] = from_json_foo__nested__f_inner__li1__li2__key1(keys[0])
        children['key2'] = from_json_foo__nested__f_inner__li1__li2__key2(keys[1])
        if point == 'baz':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_foo__nested__f_inner__li1__li2(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['key1', 'key2']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_foo__nested__f_inner__li1__li2_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['key1', 'key2'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['key1', 'key2'], [from_json_path_foo__nested__f_inner__li1__li2_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_foo__nested__f_inner__li1__li2_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_key1 = jd.get('key1')
    if child_key1 is not None:
        children['key1'] = from_json_foo__nested__f_inner__li1__li2__key1(child_key1)
    child_key2 = jd.get('key2')
    if child_key2 is not None:
        children['key2'] = from_json_foo__nested__f_inner__li1__li2__key2(child_key2)
    child_baz = jd.get('baz')
    if child_baz is not None:
        children['baz'] = from_json_foo__nested__f_inner__li1__li2__baz(child_baz)
    return yang.gdata.Container(children, [str(child_key1 if child_key1 is not None else ''), str(child_key2 if child_key2 is not None else '')])

mut def from_json_foo__nested__f_inner__li1__li2(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_foo__nested__f_inner__li1__li2_element(e))
    return yang.gdata.List(keys=['key1', 'key2'], elements=elements, ns=None, prefix=None)

mut def to_json_foo__nested__f_inner__li1__li2_element(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_key1 = n.children.get('key1')
    if child_key1 is not None:
        if isinstance(child_key1, yang.gdata.Leaf):
            children['key1'] = child_key1.val
    child_key2 = n.children.get('key2')
    if child_key2 is not None:
        if isinstance(child_key2, yang.gdata.Leaf):
            children['key2'] = child_key2.val
    child_baz = n.children.get('baz')
    if child_baz is not None:
        if isinstance(child_baz, yang.gdata.Leaf):
            children['baz'] = child_baz.val
    return children

mut def to_json_foo__nested__f_inner__li1__li2(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_foo__nested__f_inner__li1__li2_element(e))
    return elements

mut def from_json_foo__nested__f_inner__li1__bar_bar(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class foo__nested__f_inner__li1_entry(yang.adata.MNode):
    name: str
    f_bar: ?str
    li2: foo__nested__f_inner__li1__li2
    bar_bar: ?str

    mut def __init__(self, name: str, f_bar: ?str, li2: list[foo__nested__f_inner__li1__li2_entry]=[], bar_bar: ?str):
        self._ns = 'http://example.com/foo'
        self.name = name
        self.f_bar = f_bar
        self.li2 = foo__nested__f_inner__li1__li2(elements=li2)
        self.bar_bar = bar_bar

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        _f_bar = self.f_bar
        if _f_bar is not None:
            children['f:bar'] = yang.gdata.Leaf('string', _f_bar)
        _li2 = self.li2
        if _li2 is not None:
            children['li2'] = _li2.to_gdata()
        _bar_bar = self.bar_bar
        if _bar_bar is not None:
            children['bar:bar'] = yang.gdata.Leaf('string', _bar_bar, ns='http://example.com/bar')
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.name)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> foo__nested__f_inner__li1_entry:
        return foo__nested__f_inner__li1_entry(name=n.get_str('name'), f_bar=n.get_opt_str('f:bar'), li2=foo__nested__f_inner__li1__li2.from_gdata(n.get_opt_list('li2')), bar_bar=n.get_opt_str('bar:bar'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> foo__nested__f_inner__li1_entry:
        return foo__nested__f_inner__li1_entry(name=yang.gdata.from_xml_str(n, 'name'), f_bar=yang.gdata.from_xml_opt_str(n, 'bar'), li2=foo__nested__f_inner__li1__li2.from_xml(yang.gdata.get_xml_children(n, 'li2')), bar_bar=yang.gdata.from_xml_opt_str(n, 'bar', 'http://example.com/bar'))

class foo__nested__f_inner__li1(yang.adata.MNode):
    elements: list[foo__nested__f_inner__li1_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/foo'
        self._name = 'li1'
        self.elements = elements

    mut def create(self, name):
        for e in self.elements:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = foo__nested__f_inner__li1_entry(name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[foo__nested__f_inner__li1_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(foo__nested__f_inner__li1_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[foo__nested__f_inner__li1_entry]:
        res = []
        for node in nodes:
            res.append(foo__nested__f_inner__li1_entry.from_xml(node))
        return res


mut def from_json_path_foo__nested__f_inner__li1_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_foo__nested__f_inner__li1_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['name'] = from_json_foo__nested__f_inner__li1__name(keys[0])
        if point == 'bar':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'li2':
            children['li2'] = from_json_path_foo__nested__f_inner__li1__li2(jd, rest_path, op)
        if point == 'bar:bar':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_foo__nested__f_inner__li1(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_foo__nested__f_inner__li1_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['name'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['name'], [from_json_path_foo__nested__f_inner__li1_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_foo__nested__f_inner__li1_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_name = jd.get('name')
    if child_name is not None:
        children['name'] = from_json_foo__nested__f_inner__li1__name(child_name)
    child_f_bar = jd.get('bar')
    if child_f_bar is not None:
        children['f:bar'] = from_json_foo__nested__f_inner__li1__f_bar(child_f_bar)
    child_li2 = jd.get('li2')
    if child_li2 is not None and isinstance(child_li2, list):
        children['li2'] = from_json_foo__nested__f_inner__li1__li2(child_li2)
    child_bar_bar = jd.get('bar:bar')
    if child_bar_bar is not None:
        children['bar:bar'] = from_json_foo__nested__f_inner__li1__bar_bar(child_bar_bar)
    return yang.gdata.Container(children, [str(child_name if child_name is not None else '')])

mut def from_json_foo__nested__f_inner__li1(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_foo__nested__f_inner__li1_element(e))
    return yang.gdata.List(keys=['name'], elements=elements, ns=None, prefix=None)

mut def to_json_foo__nested__f_inner__li1_element(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_name = n.children.get('name')
    if child_name is not None:
        if isinstance(child_name, yang.gdata.Leaf):
            children['name'] = child_name.val
    child_f_bar = n.children.get('f:bar')
    if child_f_bar is not None:
        if isinstance(child_f_bar, yang.gdata.Leaf):
            children['bar'] = child_f_bar.val
    child_li2 = n.children.get('li2')
    if child_li2 is not None:
        if isinstance(child_li2, yang.gdata.List):
            children['li2'] = to_json_foo__nested__f_inner__li1__li2(child_li2)
    child_bar_bar = n.children.get('bar:bar')
    if child_bar_bar is not None:
        if isinstance(child_bar_bar, yang.gdata.Leaf):
            children['bar:bar'] = child_bar_bar.val
    return children

mut def to_json_foo__nested__f_inner__li1(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_foo__nested__f_inner__li1_element(e))
    return elements

class foo__nested__f_inner(yang.adata.MNode):
    foo: ?str
    li1: foo__nested__f_inner__li1

    mut def __init__(self, foo: ?str, li1: list[foo__nested__f_inner__li1_entry]=[]):
        self._ns = 'http://example.com/foo'
        self.foo = foo
        self.li1 = foo__nested__f_inner__li1(elements=li1)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _foo = self.foo
        if _foo is not None:
            children['foo'] = yang.gdata.Leaf('string', _foo)
        _li1 = self.li1
        if _li1 is not None:
            children['li1'] = _li1.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__nested__f_inner:
        if n != None:
            return foo__nested__f_inner(foo=n.get_opt_str('foo'), li1=foo__nested__f_inner__li1.from_gdata(n.get_opt_list('li1')))
        return foo__nested__f_inner()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> foo__nested__f_inner:
        if n != None:
            return foo__nested__f_inner(foo=yang.gdata.from_xml_opt_str(n, 'foo'), li1=foo__nested__f_inner__li1.from_xml(yang.gdata.get_xml_children(n, 'li1')))
        return foo__nested__f_inner()


mut def from_json_path_foo__nested__f_inner(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'foo':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'li1':
            child = {'li1': from_json_path_foo__nested__f_inner__li1(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__nested__f_inner(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__nested__f_inner(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_foo = jd.get('foo')
    if child_foo is not None:
        children['foo'] = from_json_foo__nested__f_inner__foo(child_foo)
    child_li1 = jd.get('li1')
    if child_li1 is not None and isinstance(child_li1, list):
        children['li1'] = from_json_foo__nested__f_inner__li1(child_li1)
    return yang.gdata.Container(children)

mut def to_json_foo__nested__f_inner(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_foo = n.children.get('foo')
    if child_foo is not None:
        if isinstance(child_foo, yang.gdata.Leaf):
            children['foo'] = child_foo.val
    child_li1 = n.children.get('li1')
    if child_li1 is not None:
        if isinstance(child_li1, yang.gdata.List):
            children['li1'] = to_json_foo__nested__f_inner__li1(child_li1)
    return children

mut def from_json_foo__nested__bar_inner__foo(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class foo__nested__bar_inner(yang.adata.MNode):
    foo: ?str

    mut def __init__(self, foo: ?str):
        self._ns = 'http://example.com/bar'
        self.foo = foo

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _foo = self.foo
        if _foo is not None:
            children['foo'] = yang.gdata.Leaf('string', _foo)
        return yang.gdata.Container(children, ns='http://example.com/bar')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__nested__bar_inner:
        if n != None:
            return foo__nested__bar_inner(foo=n.get_opt_str('foo'))
        return foo__nested__bar_inner()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> foo__nested__bar_inner:
        if n != None:
            return foo__nested__bar_inner(foo=yang.gdata.from_xml_opt_str(n, 'foo'))
        return foo__nested__bar_inner()


mut def from_json_path_foo__nested__bar_inner(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'foo':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__nested__bar_inner(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__nested__bar_inner(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_foo = jd.get('foo')
    if child_foo is not None:
        children['foo'] = from_json_foo__nested__bar_inner__foo(child_foo)
    return yang.gdata.Container(children)

mut def to_json_foo__nested__bar_inner(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_foo = n.children.get('foo')
    if child_foo is not None:
        if isinstance(child_foo, yang.gdata.Leaf):
            children['foo'] = child_foo.val
    return children

class foo__nested(yang.adata.MNode):
    f_inner: foo__nested__f_inner
    bar_inner: foo__nested__bar_inner

    mut def __init__(self, f_inner: ?foo__nested__f_inner=None, bar_inner: ?foo__nested__bar_inner=None):
        self._ns = 'http://example.com/foo'
        self.f_inner = f_inner if f_inner is not None else foo__nested__f_inner()
        self.bar_inner = bar_inner if bar_inner is not None else foo__nested__bar_inner()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _f_inner = self.f_inner
        if _f_inner is not None:
            children['f:inner'] = _f_inner.to_gdata()
        _bar_inner = self.bar_inner
        if _bar_inner is not None:
            children['bar:inner'] = _bar_inner.to_gdata()
        return yang.gdata.Container(children, ns='http://example.com/foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__nested:
        if n != None:
            return foo__nested(f_inner=foo__nested__f_inner.from_gdata(n.get_opt_container('f:inner')), bar_inner=foo__nested__bar_inner.from_gdata(n.get_opt_container('bar:inner')))
        return foo__nested()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> foo__nested:
        if n != None:
            return foo__nested(f_inner=foo__nested__f_inner.from_xml(yang.gdata.get_xml_opt_child(n, 'inner')), bar_inner=foo__nested__bar_inner.from_xml(yang.gdata.get_xml_opt_child(n, 'inner', 'http://example.com/bar')))
        return foo__nested()


mut def from_json_path_foo__nested(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'inner':
            child = {'f:inner': from_json_path_foo__nested__f_inner(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'bar:inner':
            child = {'bar:inner': from_json_path_foo__nested__bar_inner(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__nested(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__nested(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_f_inner = jd.get('inner')
    if child_f_inner is not None and isinstance(child_f_inner, dict):
        children['f:inner'] = from_json_foo__nested__f_inner(child_f_inner)
    child_bar_inner = jd.get('bar:inner')
    if child_bar_inner is not None and isinstance(child_bar_inner, dict):
        children['bar:inner'] = from_json_foo__nested__bar_inner(child_bar_inner)
    return yang.gdata.Container(children)

mut def to_json_foo__nested(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_f_inner = n.children.get('f:inner')
    if child_f_inner is not None:
        if isinstance(child_f_inner, yang.gdata.Container):
            children['inner'] = to_json_foo__nested__f_inner(child_f_inner)
    child_bar_inner = n.children.get('bar:inner')
    if child_bar_inner is not None:
        if isinstance(child_bar_inner, yang.gdata.Container):
            children['bar:inner'] = to_json_foo__nested__bar_inner(child_bar_inner)
    return children

mut def from_json_foo__li_union__k1(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__li_union__k2(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_json_foo__li_union__k3(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('binary', val)

class foo__li_union_entry(yang.adata.MNode):
    k1: str
    k2: value
    k3: bytes

    mut def __init__(self, k1: str, k2: value, k3: bytes):
        self._ns = 'http://example.com/foo'
        self.k1 = k1
        self.k2 = k2
        self.k3 = k3

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _k1 = self.k1
        if _k1 is not None:
            children['k1'] = yang.gdata.Leaf('string', _k1)
        _k2 = self.k2
        if _k2 is not None:
            children['k2'] = yang.gdata.Leaf('union', _k2)
        _k3 = self.k3
        if _k3 is not None:
            children['k3'] = yang.gdata.Leaf('binary', _k3)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.k1), yang.gdata.yang_str(self.k2), yang.gdata.yang_str(self.k3)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> foo__li_union_entry:
        return foo__li_union_entry(k1=n.get_str('k1'), k2=n.get_value('k2'), k3=n.get_bytes('k3'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> foo__li_union_entry:
        return foo__li_union_entry(k1=yang.gdata.from_xml_str(n, 'k1'), k2=yang.gdata.from_xml_value(n, 'k2'), k3=yang.gdata.from_xml_bytes(n, 'k3'))

class foo__li_union(yang.adata.MNode):
    elements: list[foo__li_union_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/foo'
        self._name = 'li-union'
        self.elements = elements

    mut def create(self, k1, k2, k3):
        for e in self.elements:
            match = True
            if e.k1 != k1:
                match = False
                continue
            e_k2 = e.k2
            if isinstance(e_k2, bytes) and isinstance(k2, bytes):
                if e_k2 != k2:
                    match = False
                    continue
            e_k2 = e.k2
            if isinstance(e_k2, str) and isinstance(k2, str):
                if e_k2 != k2:
                    match = False
                    continue
            e_k2 = e.k2
            if isinstance(e_k2, int) and isinstance(k2, int):
                if e_k2 != k2:
                    match = False
                    continue
            if e.k3 != k3:
                match = False
                continue
            if match:
                return e

        res = foo__li_union_entry(k1, k2, k3)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['k1', 'k2', 'k3'], elements, ns='http://example.com/foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[foo__li_union_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(foo__li_union_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[foo__li_union_entry]:
        res = []
        for node in nodes:
            res.append(foo__li_union_entry.from_xml(node))
        return res


mut def from_json_path_foo__li_union_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_foo__li_union_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['k1'] = from_json_foo__li_union__k1(keys[0])
        children['k2'] = from_json_foo__li_union__k2(keys[1])
        children['k3'] = from_json_foo__li_union__k3(keys[2])
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_foo__li_union(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['k1', 'k2', 'k3']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_foo__li_union_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['k1', 'k2', 'k3'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['k1', 'k2', 'k3'], [from_json_path_foo__li_union_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_foo__li_union_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_k1 = jd.get('k1')
    if child_k1 is not None:
        children['k1'] = from_json_foo__li_union__k1(child_k1)
    child_k2 = jd.get('k2')
    if child_k2 is not None:
        children['k2'] = from_json_foo__li_union__k2(child_k2)
    child_k3 = jd.get('k3')
    if child_k3 is not None:
        children['k3'] = from_json_foo__li_union__k3(child_k3)
    return yang.gdata.Container(children, [str(child_k1 if child_k1 is not None else ''), str(child_k2 if child_k2 is not None else ''), str(child_k3 if child_k3 is not None else '')])

mut def from_json_foo__li_union(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_foo__li_union_element(e))
    return yang.gdata.List(keys=['k1', 'k2', 'k3'], elements=elements, ns=None, prefix=None)

mut def to_json_foo__li_union_element(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_k1 = n.children.get('k1')
    if child_k1 is not None:
        if isinstance(child_k1, yang.gdata.Leaf):
            children['k1'] = child_k1.val
    child_k2 = n.children.get('k2')
    if child_k2 is not None:
        if isinstance(child_k2, yang.gdata.Leaf):
            children['k2'] = child_k2.val
    child_k3 = n.children.get('k3')
    if child_k3 is not None:
        if isinstance(child_k3, yang.gdata.Leaf):
            children['k3'] = child_k3.val
    return children

mut def to_json_foo__li_union(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_foo__li_union_element(e))
    return elements

mut def from_json_foo__state__c1__l1(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__state__c1__l2(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class foo__state__c1(yang.adata.MNode):
    l1: ?str
    l2: ?str

    mut def __init__(self, l1: ?str, l2: ?str):
        self._ns = 'http://example.com/foo'
        self.l1 = l1
        self.l2 = l2

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _l1 = self.l1
        if _l1 is not None:
            children['l1'] = yang.gdata.Leaf('string', _l1)
        _l2 = self.l2
        if _l2 is not None:
            children['l2'] = yang.gdata.Leaf('string', _l2)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__state__c1:
        if n != None:
            return foo__state__c1(l1=n.get_opt_str('l1'), l2=n.get_opt_str('l2'))
        return foo__state__c1()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> foo__state__c1:
        if n != None:
            return foo__state__c1(l1=yang.gdata.from_xml_opt_str(n, 'l1'), l2=yang.gdata.from_xml_opt_str(n, 'l2'))
        return foo__state__c1()


mut def from_json_path_foo__state__c1(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l1':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l2':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__state__c1(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__state__c1(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_l1 = jd.get('l1')
    if child_l1 is not None:
        children['l1'] = from_json_foo__state__c1__l1(child_l1)
    child_l2 = jd.get('l2')
    if child_l2 is not None:
        children['l2'] = from_json_foo__state__c1__l2(child_l2)
    return yang.gdata.Container(children)

mut def to_json_foo__state__c1(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_l1 = n.children.get('l1')
    if child_l1 is not None:
        if isinstance(child_l1, yang.gdata.Leaf):
            children['l1'] = child_l1.val
    child_l2 = n.children.get('l2')
    if child_l2 is not None:
        if isinstance(child_l2, yang.gdata.Leaf):
            children['l2'] = child_l2.val
    return children

class foo__state(yang.adata.MNode):
    c1: foo__state__c1

    mut def __init__(self, c1: ?foo__state__c1=None):
        self._ns = 'http://example.com/foo'
        self.c1 = c1 if c1 is not None else foo__state__c1()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _c1 = self.c1
        if _c1 is not None:
            children['c1'] = _c1.to_gdata()
        return yang.gdata.Container(children, ns='http://example.com/foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__state:
        if n != None:
            return foo__state(c1=foo__state__c1.from_gdata(n.get_opt_container('c1')))
        return foo__state()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> foo__state:
        if n != None:
            return foo__state(c1=foo__state__c1.from_xml(yang.gdata.get_xml_opt_child(n, 'c1')))
        return foo__state()


mut def from_json_path_foo__state(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'c1':
            child = {'c1': from_json_path_foo__state__c1(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__state(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__state(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_c1 = jd.get('c1')
    if child_c1 is not None and isinstance(child_c1, dict):
        children['c1'] = from_json_foo__state__c1(child_c1)
    return yang.gdata.Container(children)

mut def to_json_foo__state(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_c1 = n.children.get('c1')
    if child_c1 is not None:
        if isinstance(child_c1, yang.gdata.Container):
            children['c1'] = to_json_foo__state__c1(child_c1)
    return children

mut def from_json_foo__c2__l1(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class foo__c2(yang.adata.MNode):
    l1: ?str

    mut def __init__(self, l1: ?str):
        self._ns = 'http://example.com/foo'
        self.l1 = l1

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _l1 = self.l1
        if _l1 is not None:
            children['l1'] = yang.gdata.Leaf('string', _l1)
        return yang.gdata.Container(children, ns='http://example.com/foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__c2:
        if n != None:
            return foo__c2(l1=n.get_opt_str('l1'))
        return foo__c2()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> foo__c2:
        if n != None:
            return foo__c2(l1=yang.gdata.from_xml_opt_str(n, 'l1'))
        return foo__c2()


mut def from_json_path_foo__c2(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l1':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__c2(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__c2(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_l1 = jd.get('l1')
    if child_l1 is not None:
        children['l1'] = from_json_foo__c2__l1(child_l1)
    return yang.gdata.Container(children)

mut def to_json_foo__c2(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_l1 = n.children.get('l1')
    if child_l1 is not None:
        if isinstance(child_l1, yang.gdata.Leaf):
            children['l1'] = child_l1.val
    return children

mut def from_json_bar__conflict__foo(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class bar__conflict(yang.adata.MNode):
    foo: ?str

    mut def __init__(self, foo: ?str):
        self._ns = 'http://example.com/bar'
        self.foo = foo

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _foo = self.foo
        if _foo is not None:
            children['foo'] = yang.gdata.Leaf('string', _foo)
        return yang.gdata.Container(children, ns='http://example.com/bar')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> bar__conflict:
        if n != None:
            return bar__conflict(foo=n.get_opt_str('foo'))
        return bar__conflict()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> bar__conflict:
        if n != None:
            return bar__conflict(foo=yang.gdata.from_xml_opt_str(n, 'foo'))
        return bar__conflict()


mut def from_json_path_bar__conflict(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'foo':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_bar__conflict(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_bar__conflict(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_foo = jd.get('foo')
    if child_foo is not None:
        children['foo'] = from_json_bar__conflict__foo(child_foo)
    return yang.gdata.Container(children)

mut def to_json_bar__conflict(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_foo = n.children.get('foo')
    if child_foo is not None:
        if isinstance(child_foo, yang.gdata.Leaf):
            children['foo'] = child_foo.val
    return children

class root(yang.adata.MNode):
    c1: foo__c1
    pc1: ?foo__pc1
    pc2: ?foo__pc2
    empty_presence: ?foo__empty_presence
    c_dot: foo__c_dot
    cc: foo__cc
    f_conflict: foo__conflict
    special: foo__special
    nested: foo__nested
    li_union: foo__li_union
    state: foo__state
    c2: foo__c2
    bar_conflict: bar__conflict

    mut def __init__(self, c1: ?foo__c1=None, pc1: ?foo__pc1=None, pc2: ?foo__pc2=None, empty_presence: ?foo__empty_presence=None, c_dot: ?foo__c_dot=None, cc: ?foo__cc=None, f_conflict: ?foo__conflict=None, special: list[foo__special_entry]=[], nested: ?foo__nested=None, li_union: list[foo__li_union_entry]=[], state: ?foo__state=None, c2: ?foo__c2=None, bar_conflict: ?bar__conflict=None):
        self._ns = ''
        self.c1 = c1 if c1 is not None else foo__c1()
        self.pc1 = pc1
        self.pc2 = pc2
        self.empty_presence = empty_presence
        self.c_dot = c_dot if c_dot is not None else foo__c_dot()
        self.cc = cc if cc is not None else foo__cc()
        self.f_conflict = f_conflict if f_conflict is not None else foo__conflict()
        self.special = foo__special(elements=special)
        self.nested = nested if nested is not None else foo__nested()
        self.li_union = foo__li_union(elements=li_union)
        self.state = state if state is not None else foo__state()
        self.c2 = c2 if c2 is not None else foo__c2()
        self.bar_conflict = bar_conflict if bar_conflict is not None else bar__conflict()

    mut def create_pc1(self):
        res = foo__pc1()
        self.pc1 = res
        return res

    mut def create_pc2(self, foo):
        res = foo__pc2(foo)
        self.pc2 = res
        return res

    mut def create_empty_presence(self):
        res = foo__empty_presence()
        self.empty_presence = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _c1 = self.c1
        if _c1 is not None:
            children['c1'] = _c1.to_gdata()
        _pc1 = self.pc1
        if _pc1 is not None:
            children['pc1'] = _pc1.to_gdata()
        _pc2 = self.pc2
        if _pc2 is not None:
            children['pc2'] = _pc2.to_gdata()
        _empty_presence = self.empty_presence
        if _empty_presence is not None:
            children['empty-presence'] = _empty_presence.to_gdata()
        _c_dot = self.c_dot
        if _c_dot is not None:
            children['c.dot'] = _c_dot.to_gdata()
        _cc = self.cc
        if _cc is not None:
            children['cc'] = _cc.to_gdata()
        _f_conflict = self.f_conflict
        if _f_conflict is not None:
            children['f:conflict'] = _f_conflict.to_gdata()
        _special = self.special
        if _special is not None:
            children['special'] = _special.to_gdata()
        _nested = self.nested
        if _nested is not None:
            children['nested'] = _nested.to_gdata()
        _li_union = self.li_union
        if _li_union is not None:
            children['li-union'] = _li_union.to_gdata()
        _state = self.state
        if _state is not None:
            children['state'] = _state.to_gdata()
        _c2 = self.c2
        if _c2 is not None:
            children['c2'] = _c2.to_gdata()
        _bar_conflict = self.bar_conflict
        if _bar_conflict is not None:
            children['bar:conflict'] = _bar_conflict.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> root:
        if n != None:
            return root(c1=foo__c1.from_gdata(n.get_opt_container('c1')), pc1=foo__pc1.from_gdata(n.get_opt_container('pc1')), pc2=foo__pc2.from_gdata(n.get_opt_container('pc2')), empty_presence=foo__empty_presence.from_gdata(n.get_opt_container('empty-presence')), c_dot=foo__c_dot.from_gdata(n.get_opt_container('c.dot')), cc=foo__cc.from_gdata(n.get_opt_container('cc')), f_conflict=foo__conflict.from_gdata(n.get_opt_container('f:conflict')), special=foo__special.from_gdata(n.get_opt_list('special')), nested=foo__nested.from_gdata(n.get_opt_container('nested')), li_union=foo__li_union.from_gdata(n.get_opt_list('li-union')), state=foo__state.from_gdata(n.get_opt_container('state')), c2=foo__c2.from_gdata(n.get_opt_container('c2')), bar_conflict=bar__conflict.from_gdata(n.get_opt_container('bar:conflict')))
        return root()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> root:
        if n != None:
            return root(c1=foo__c1.from_xml(yang.gdata.get_xml_opt_child(n, 'c1', 'http://example.com/foo')), pc1=foo__pc1.from_xml(yang.gdata.get_xml_opt_child(n, 'pc1', 'http://example.com/foo')), pc2=foo__pc2.from_xml(yang.gdata.get_xml_opt_child(n, 'pc2', 'http://example.com/foo')), empty_presence=foo__empty_presence.from_xml(yang.gdata.get_xml_opt_child(n, 'empty-presence', 'http://example.com/foo')), c_dot=foo__c_dot.from_xml(yang.gdata.get_xml_opt_child(n, 'c.dot', 'http://example.com/foo')), cc=foo__cc.from_xml(yang.gdata.get_xml_opt_child(n, 'cc', 'http://example.com/foo')), f_conflict=foo__conflict.from_xml(yang.gdata.get_xml_opt_child(n, 'conflict', 'http://example.com/foo')), special=foo__special.from_xml(yang.gdata.get_xml_children(n, 'special', 'http://example.com/foo')), nested=foo__nested.from_xml(yang.gdata.get_xml_opt_child(n, 'nested', 'http://example.com/foo')), li_union=foo__li_union.from_xml(yang.gdata.get_xml_children(n, 'li-union', 'http://example.com/foo')), state=foo__state.from_xml(yang.gdata.get_xml_opt_child(n, 'state', 'http://example.com/foo')), c2=foo__c2.from_xml(yang.gdata.get_xml_opt_child(n, 'c2', 'http://example.com/foo')), bar_conflict=bar__conflict.from_xml(yang.gdata.get_xml_opt_child(n, 'conflict', 'http://example.com/bar')))
        return root()


mut def from_json_path(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'foo:c1':
            child = {'c1': from_json_path_foo__c1(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'foo:pc1':
            child = {'pc1': from_json_path_foo__pc1(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'foo:pc2':
            child = {'pc2': from_json_path_foo__pc2(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'foo:empty-presence':
            child = {'empty-presence': from_json_path_foo__empty_presence(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'foo:c.dot':
            child = {'c.dot': from_json_path_foo__c_dot(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'foo:cc':
            child = {'cc': from_json_path_foo__cc(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'foo:conflict':
            child = {'f:conflict': from_json_path_foo__conflict(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'foo:special':
            child = {'special': from_json_path_foo__special(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'foo:nested':
            child = {'nested': from_json_path_foo__nested(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'foo:li-union':
            child = {'li-union': from_json_path_foo__li_union(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'foo:state':
            child = {'state': from_json_path_foo__state(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'foo:c2':
            child = {'c2': from_json_path_foo__c2(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'bar:conflict':
            child = {'bar:conflict': from_json_path_bar__conflict(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_c1 = jd.get('foo:c1')
    if child_c1 is not None and isinstance(child_c1, dict):
        children['c1'] = from_json_foo__c1(child_c1)
    child_pc1 = jd.get('foo:pc1')
    if child_pc1 is not None and isinstance(child_pc1, dict):
        children['pc1'] = from_json_foo__pc1(child_pc1)
    child_pc2 = jd.get('foo:pc2')
    if child_pc2 is not None and isinstance(child_pc2, dict):
        children['pc2'] = from_json_foo__pc2(child_pc2)
    child_empty_presence = jd.get('foo:empty-presence')
    if child_empty_presence is not None and isinstance(child_empty_presence, dict):
        children['empty-presence'] = from_json_foo__empty_presence(child_empty_presence)
    child_c_dot = jd.get('foo:c.dot')
    if child_c_dot is not None and isinstance(child_c_dot, dict):
        children['c.dot'] = from_json_foo__c_dot(child_c_dot)
    child_cc = jd.get('foo:cc')
    if child_cc is not None and isinstance(child_cc, dict):
        children['cc'] = from_json_foo__cc(child_cc)
    child_f_conflict = jd.get('foo:conflict')
    if child_f_conflict is not None and isinstance(child_f_conflict, dict):
        children['f:conflict'] = from_json_foo__conflict(child_f_conflict)
    child_special = jd.get('foo:special')
    if child_special is not None and isinstance(child_special, list):
        children['special'] = from_json_foo__special(child_special)
    child_nested = jd.get('foo:nested')
    if child_nested is not None and isinstance(child_nested, dict):
        children['nested'] = from_json_foo__nested(child_nested)
    child_li_union = jd.get('foo:li-union')
    if child_li_union is not None and isinstance(child_li_union, list):
        children['li-union'] = from_json_foo__li_union(child_li_union)
    child_state = jd.get('foo:state')
    if child_state is not None and isinstance(child_state, dict):
        children['state'] = from_json_foo__state(child_state)
    child_c2 = jd.get('foo:c2')
    if child_c2 is not None and isinstance(child_c2, dict):
        children['c2'] = from_json_foo__c2(child_c2)
    child_bar_conflict = jd.get('bar:conflict')
    if child_bar_conflict is not None and isinstance(child_bar_conflict, dict):
        children['bar:conflict'] = from_json_bar__conflict(child_bar_conflict)
    return yang.gdata.Container(children)

mut def to_json(n: yang.gdata.Node) -> dict[str, ?value]:
    children = {}
    child_c1 = n.children.get('c1')
    if child_c1 is not None:
        if isinstance(child_c1, yang.gdata.Container):
            children['foo:c1'] = to_json_foo__c1(child_c1)
    child_pc1 = n.children.get('pc1')
    if child_pc1 is not None:
        if isinstance(child_pc1, yang.gdata.Container):
            children['foo:pc1'] = to_json_foo__pc1(child_pc1)
    child_pc2 = n.children.get('pc2')
    if child_pc2 is not None:
        if isinstance(child_pc2, yang.gdata.Container):
            children['foo:pc2'] = to_json_foo__pc2(child_pc2)
    child_empty_presence = n.children.get('empty-presence')
    if child_empty_presence is not None:
        if isinstance(child_empty_presence, yang.gdata.Container):
            children['foo:empty-presence'] = to_json_foo__empty_presence(child_empty_presence)
    child_c_dot = n.children.get('c.dot')
    if child_c_dot is not None:
        if isinstance(child_c_dot, yang.gdata.Container):
            children['foo:c.dot'] = to_json_foo__c_dot(child_c_dot)
    child_cc = n.children.get('cc')
    if child_cc is not None:
        if isinstance(child_cc, yang.gdata.Container):
            children['foo:cc'] = to_json_foo__cc(child_cc)
    child_f_conflict = n.children.get('f:conflict')
    if child_f_conflict is not None:
        if isinstance(child_f_conflict, yang.gdata.Container):
            children['foo:conflict'] = to_json_foo__conflict(child_f_conflict)
    child_special = n.children.get('special')
    if child_special is not None:
        if isinstance(child_special, yang.gdata.List):
            children['foo:special'] = to_json_foo__special(child_special)
    child_nested = n.children.get('nested')
    if child_nested is not None:
        if isinstance(child_nested, yang.gdata.Container):
            children['foo:nested'] = to_json_foo__nested(child_nested)
    child_li_union = n.children.get('li-union')
    if child_li_union is not None:
        if isinstance(child_li_union, yang.gdata.List):
            children['foo:li-union'] = to_json_foo__li_union(child_li_union)
    child_state = n.children.get('state')
    if child_state is not None:
        if isinstance(child_state, yang.gdata.Container):
            children['foo:state'] = to_json_foo__state(child_state)
    child_c2 = n.children.get('c2')
    if child_c2 is not None:
        if isinstance(child_c2, yang.gdata.Container):
            children['foo:c2'] = to_json_foo__c2(child_c2)
    child_bar_conflict = n.children.get('bar:conflict')
    if child_bar_conflict is not None:
        if isinstance(child_bar_conflict, yang.gdata.Container):
            children['bar:conflict'] = to_json_bar__conflict(child_bar_conflict)
    return children

schema_namespaces: set[str] = {
    'http://example.com/foo',
    'http://example.com/bar',
}
def src_yang():
    res = []
    res.append("""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "f";
    include qux;
    grouping g1 {
        leaf l1 {
            type string;
        }
        leaf l2 {
            type string;
        }
    }
    container c1 {
        leaf l1 {
            type string;
        }
        leaf l3 {
            type uint64;
        }
        leaf l_empty {
            type empty;
        }
        list li {
            ordered-by user;
            key name;
            leaf name {
                type string;
            }
            leaf val {
                type string;
            }
        }
        leaf-list ll_uint64 {
            type uint64;
        }
        leaf-list ll_str {
            type string;
        }
    }
    container pc1 {
        presence "p";
        container foo {
            leaf-list l1 {
                type binary;
            }
        }
    }
    container pc2 {
        presence "p";
        container foo {
            leaf l_mandatory {
                type string;
                mandatory true;
            }
        }
    }
    container empty-presence {
        presence "nothing else here";
    }
    container c.dot {
        leaf l.dot1 {
            type string;
        }
    }
    container cc {
        choice cake-or-death {
            case cake {
                leaf cake {
                    type string;
                    mandatory true;
                }
            }
            case death {
                list death {
                    key name;
                    leaf name {
                        type string;
                    }
                }
            }
            mandatory true;
        }
    }
    container conflict {
        leaf foo {
            type string;
        }
        container inner {
            presence "inner presence";
        }
    }
    list special {
        key yes;
        leaf yes {
            type boolean;
        }
    }
    container nested {
        container inner {
            leaf foo {
                type string;
            }
            list li1 {
                key name;
                leaf name {
                    type string;
                }
                leaf bar {
                    type string;
                }
                list li2 {
                    key "key1 key2";
                    leaf key1 {
                        type string;
                    }
                    leaf key2 {
                        type string;
                    }
                    leaf baz {
                        type string;
                    }
                }
            }
        }
    }
    list li-union {
        key "k1 k2 k3";
        leaf k1 {
            type string;
        }
        leaf k2 {
            type union {
                type uint32;
                type enumeration {
                    enum "unlimited";
                }
                type binary;
            }
        }
        leaf k3 {
            type binary;
        }
    }
    container state {
        config false;
        container c1 {
            uses g1;
        }
    }
}""")
    res.append("""submodule qux {
    yang-version "1.1";
    belongs-to foo {
        prefix "f";
    }
    // Must not conflict with /f:c1
    container c2 {
        leaf l1 {
            type string;
        }
    }
    augment /f:c1 {
        leaf l4 {
            type string;
        }
    }
}""")
    res.append("""module bar {
    yang-version "1.1";
    namespace "http://example.com/bar";
    prefix "bar";
    import foo {
        prefix "f";
    }
    augment /f:c1 {
        // create a conflict with /f:c1/l1
        uses f:g1;
    }
    augment /f:c.dot {
        leaf l.dot2 {
            type string;
        }
    }
    container conflict {
        leaf foo {
            type string;
        }
    }
    augment /f:conflict {
        leaf foo {
            type string;
        }
        container inner {
            presence "inner presence from bar";
        }
    }
    augment /f:nested {
        // conflict with /f:nested/inner
        container inner {
            leaf foo {
                type string;
            }
        }
    }
    augment /f:nested/inner/li1 {
        leaf bar {
            type string;
        }
    }
}""")
    return res

def src_schema():
    res = {}
    res["foo"] = Module('foo', yang_version=1.1, namespace='http://example.com/foo', prefix='f', include=[
        Include('qux')
    ], children=[
    Grouping('g1', children=[
        Leaf('l1', type_=Type('string')),
        Leaf('l2', type_=Type('string'))
    ]),
    Container('c1', children=[
        Leaf('l1', type_=Type('string')),
        Leaf('l3', type_=Type('uint64')),
        Leaf('l_empty', type_=Type('empty')),
        List('li', key='name', ordered_by='user', children=[
            Leaf('name', type_=Type('string')),
            Leaf('val', type_=Type('string'))
        ]),
        LeafList('ll_uint64', type_=Type('uint64')),
        LeafList('ll_str', type_=Type('string'))
    ]),
    Container('pc1', presence='p', children=[
        Container('foo', children=[
            LeafList('l1', type_=Type('binary'))
        ])
    ]),
    Container('pc2', presence='p', children=[
        Container('foo', children=[
            Leaf('l_mandatory', type_=Type('string'), mandatory=True)
        ])
    ]),
    Container('empty-presence', presence='nothing else here'),
    Container('c.dot', children=[
        Leaf('l.dot1', type_=Type('string'))
    ]),
    Container('cc', children=[
        Choice('cake-or-death', mandatory=True, children=[
            Case('cake', children=[
                Leaf('cake', type_=Type('string'), mandatory=True)
            ]),
            Case('death', children=[
                List('death', key='name', children=[
                    Leaf('name', type_=Type('string'))
                ])
            ])
        ])
    ]),
    Container('conflict', children=[
        Leaf('foo', type_=Type('string')),
        Container('inner', presence='inner presence')
    ]),
    List('special', key='yes', children=[
        Leaf('yes', type_=Type('boolean'))
    ]),
    Container('nested', children=[
        Container('inner', children=[
            Leaf('foo', type_=Type('string')),
            List('li1', key='name', children=[
                Leaf('name', type_=Type('string')),
                Leaf('bar', type_=Type('string')),
                List('li2', key='key1 key2', children=[
                    Leaf('key1', type_=Type('string')),
                    Leaf('key2', type_=Type('string')),
                    Leaf('baz', type_=Type('string'))
                ])
            ])
        ])
    ]),
    List('li-union', key='k1 k2 k3', children=[
        Leaf('k1', type_=Type('string')),
        Leaf('k2', type_=Type('union', type_=[
        Type('uint32'),
        Type('enumeration', enum=[
                Enum('unlimited')
            ]),
        Type('binary')
    ])),
        Leaf('k3', type_=Type('binary'))
    ]),
    Container('state', config=False, children=[
        Container('c1', children=[
            Uses('g1')
        ])
    ])
])
    res["qux"] = Submodule('qux', yang_version=1.1, belongs_to=BelongsTo('foo', prefix='f'), augment=[
        Augment('/f:c1', children=[
            Leaf('l4', type_=Type('string'))
        ])
    ], children=[
    Container('c2', children=[
        Leaf('l1', type_=Type('string'))
    ])
])
    res["bar"] = Module('bar', yang_version=1.1, namespace='http://example.com/bar', prefix='bar', import_=[
        Import('foo', prefix='f')
    ], augment=[
        Augment('/f:c1', children=[
            Uses('f:g1')
        ]),
        Augment('/f:c.dot', children=[
            Leaf('l.dot2', type_=Type('string'))
        ]),
        Augment('/f:conflict', children=[
            Leaf('foo', type_=Type('string')),
            Container('inner', presence='inner presence from bar')
        ]),
        Augment('/f:nested', children=[
            Container('inner', children=[
                Leaf('foo', type_=Type('string'))
            ])
        ]),
        Augment('/f:nested/inner/li1', children=[
            Leaf('bar', type_=Type('string'))
        ])
    ], children=[
    Container('conflict', children=[
        Leaf('foo', type_=Type('string'))
    ])
])
    return res

def src_schema_compiled():
    res = {}
    res["foo"] = Module('foo', yang_version=1.1, namespace='http://example.com/foo', prefix='f', augment=[
        Augment('/f:c1', children=[
            Leaf('l4', type_=Type('string'))
        ])
    ], children=[
    Grouping('g1', children=[
        Leaf('l1', type_=Type('string')),
        Leaf('l2', type_=Type('string'))
    ]),
    Container('c1', children=[
        Leaf('l1', type_=Type('string')),
        Leaf('l3', type_=Type('uint64')),
        Leaf('l_empty', type_=Type('empty')),
        List('li', key='name', ordered_by='user', children=[
            Leaf('name', type_=Type('string')),
            Leaf('val', type_=Type('string'))
        ]),
        LeafList('ll_uint64', type_=Type('uint64')),
        LeafList('ll_str', type_=Type('string')),
        Leaf('l4', type_=Type('string')),
        Leaf('l1', type_=Type('string')),
        Leaf('l2', type_=Type('string'))
    ]),
    Container('pc1', presence='p', children=[
        Container('foo', children=[
            LeafList('l1', type_=Type('binary'))
        ])
    ]),
    Container('pc2', presence='p', children=[
        Container('foo', children=[
            Leaf('l_mandatory', type_=Type('string'), mandatory=True)
        ])
    ]),
    Container('empty-presence', presence='nothing else here'),
    Container('c.dot', children=[
        Leaf('l.dot1', type_=Type('string')),
        Leaf('l.dot2', type_=Type('string'))
    ]),
    Container('cc', children=[
        Choice('cake-or-death', mandatory=True, children=[
            Case('cake', children=[
                Leaf('cake', type_=Type('string'), mandatory=True)
            ]),
            Case('death', children=[
                List('death', key='name', children=[
                    Leaf('name', type_=Type('string'))
                ])
            ])
        ])
    ]),
    Container('conflict', children=[
        Leaf('foo', type_=Type('string')),
        Container('inner', presence='inner presence'),
        Leaf('foo', type_=Type('string')),
        Container('inner', presence='inner presence from bar')
    ]),
    List('special', key='yes', children=[
        Leaf('yes', type_=Type('boolean'))
    ]),
    Container('nested', children=[
        Container('inner', children=[
            Leaf('foo', type_=Type('string')),
            List('li1', key='name', children=[
                Leaf('name', type_=Type('string')),
                Leaf('bar', type_=Type('string')),
                List('li2', key='key1 key2', children=[
                    Leaf('key1', type_=Type('string')),
                    Leaf('key2', type_=Type('string')),
                    Leaf('baz', type_=Type('string'))
                ]),
                Leaf('bar', type_=Type('string'))
            ])
        ]),
        Container('inner', children=[
            Leaf('foo', type_=Type('string'))
        ])
    ]),
    List('li-union', key='k1 k2 k3', children=[
        Leaf('k1', type_=Type('string')),
        Leaf('k2', type_=Type('union', type_=[
        Type('uint32'),
        Type('enumeration', enum=[
                Enum('unlimited')
            ]),
        Type('binary')
    ])),
        Leaf('k3', type_=Type('binary'))
    ]),
    Container('state', config=False, children=[
        Container('c1', children=[
            Leaf('l1', type_=Type('string')),
            Leaf('l2', type_=Type('string'))
        ])
    ]),
    Container('c2', children=[
        Leaf('l1', type_=Type('string'))
    ])
])
    res["bar"] = Module('bar', yang_version=1.1, namespace='http://example.com/bar', prefix='bar', import_=[
        Import('foo', prefix='f')
    ], augment=[
        Augment('/f:c1', children=[
            Uses('f:g1')
        ]),
        Augment('/f:c.dot', children=[
            Leaf('l.dot2', type_=Type('string'))
        ]),
        Augment('/f:conflict', children=[
            Leaf('foo', type_=Type('string')),
            Container('inner', presence='inner presence from bar')
        ]),
        Augment('/f:nested', children=[
            Container('inner', children=[
                Leaf('foo', type_=Type('string'))
            ])
        ]),
        Augment('/f:nested/inner/li1', children=[
            Leaf('bar', type_=Type('string'))
        ])
    ], children=[
    Container('conflict', children=[
        Leaf('foo', type_=Type('string'))
    ])
])
    return res
