import base64
import json
import xml
import yang
import yang.adata
import yang.gdata
import yang.gen3
from yang.identityref import Identityref, PartialIdentityref
from yang.pattern import YangPattern
from yang.schema import *
from yang.type import Decimal, Ranges

# == This file is generated ==




_base_foo_basey = DIdentity(module='foo', namespace='http://example.com/foo', prefix='f', name='basey', base=[])
_base_foo_fooy = DIdentity(module='foo', namespace='http://example.com/foo', prefix='f', name='fooy', base=[_base_foo_basey])
_base_bar_bary = DIdentity(module='bar', namespace='http://example.com/bar', prefix='bar', name='bary', base=[_base_foo_basey])
_identities = [
    _base_foo_fooy,
    _base_foo_basey,
    _base_bar_bary,
]


# Identityref constants
foo_fooy = Identityref('fooy', ns='http://example.com/foo', mod='foo', pfx='f')
foo_basey = Identityref('basey', ns='http://example.com/foo', mod='foo', pfx='f')
bar_bary = Identityref('bary', ns='http://example.com/bar', mod='bar', pfx='bar')


SRC_DNODE = DRoot(identities=[
        DIdentity(module='foo', namespace='http://example.com/foo', prefix='f', name='fooy', base=[
                DIdentity(module='foo', namespace='http://example.com/foo', prefix='f', name='basey')
            ]),
        DIdentity(module='foo', namespace='http://example.com/foo', prefix='f', name='basey'),
        DIdentity(module='bar', namespace='http://example.com/bar', prefix='bar', name='bary', base=[
                DIdentity(module='foo', namespace='http://example.com/foo', prefix='f', name='basey')
            ])
    ], children=[
    DContainer(module='foo', namespace='http://example.com/foo', prefix='f', name='c1', config=True, presence=False, children=[
        DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='l1', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
        DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='l3', config=True, mandatory=False, type_=DTypeInteger(name='uint64', description=None, reference=None, exts=[], builtin_type='uint64', default=None, ranges=Ranges([(bigint("0"), bigint("18446744073709551615"))]))),
        DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='l_empty', config=True, mandatory=False, type_=DTypeEmpty(name='empty', description=None, reference=None, exts=[], builtin_type='empty', default=None)),
        DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='l_empty_delete', config=True, mandatory=False, type_=DTypeEmpty(name='empty', description=None, reference=None, exts=[], builtin_type='empty', default=None)),
        DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='l_decimal64', config=True, mandatory=False, type_=DTypeDecimal64(name='decimal64', description=None, reference=None, exts=[], builtin_type='decimal64', default=None, fraction_digits=2, ranges=Ranges([(Decimal(bigint("-9223372036854775808"), bigint("-2")), Decimal(bigint("9223372036854775807"), bigint("-2")))]))),
        DList(module='foo', namespace='http://example.com/foo', prefix='f', name='li', key=['name'], config=True, min_elements=0, ordered_by='user', children=[
            DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='name', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
            DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='val', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
            DContainer(module='foo', namespace='http://example.com/foo', prefix='f', name='c4', config=True, presence=False, children=[
                DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='l5', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
            ])
        ]),
        DLeafList(module='foo', namespace='http://example.com/foo', prefix='f', name='ll_uint64', config=True, min_elements=0, ordered_by='system', type_=DTypeInteger(name='uint64', description=None, reference=None, exts=[], builtin_type='uint64', default=None, ranges=Ranges([(bigint("0"), bigint("18446744073709551615"))]))),
        DLeafList(module='foo', namespace='http://example.com/foo', prefix='f', name='ll_str', config=True, min_elements=0, ordered_by='system', type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
        DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='l_identityref', config=True, mandatory=False, type_=DTypeIdentityref(name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_foo_basey], identities=_identities)),
        DLeafList(module='foo', namespace='http://example.com/foo', prefix='f', name='ll_identityref', config=True, min_elements=0, ordered_by='system', type_=DTypeIdentityref(name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_foo_basey], identities=_identities)),
        DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='l_identityref_noval', config=True, mandatory=False, type_=DTypeIdentityref(name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_foo_fooy], identities=_identities)),
        DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='l4', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
        DLeaf(module='bar', namespace='http://example.com/bar', prefix='bar', name='l1', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
        DLeaf(module='bar', namespace='http://example.com/bar', prefix='bar', name='l2', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
    ]),
    DContainer(module='foo', namespace='http://example.com/foo', prefix='f', name='pc1', config=True, presence=True, children=[
        DContainer(module='foo', namespace='http://example.com/foo', prefix='f', name='foo', config=True, presence=False, children=[
            DLeafList(module='foo', namespace='http://example.com/foo', prefix='f', name='l1', config=True, min_elements=0, ordered_by='system', type_=DTypeBinary(name='binary', description=None, reference=None, exts=[], builtin_type='binary', default=None, length=None))
        ])
    ]),
    DContainer(module='foo', namespace='http://example.com/foo', prefix='f', name='pc2', config=True, presence=True, children=[
        DContainer(module='foo', namespace='http://example.com/foo', prefix='f', name='foo', config=True, presence=False, children=[
            DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='l_mandatory', config=True, mandatory=True, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
        ])
    ]),
    DContainer(module='foo', namespace='http://example.com/foo', prefix='f', name='pc3', config=True, presence=True, children=[
        DContainer(module='foo', namespace='http://example.com/foo', prefix='f', name='level1', config=True, presence=False, children=[
            DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='l1', config=True, mandatory=True, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
            DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='l1-optional', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
            DContainer(module='foo', namespace='http://example.com/foo', prefix='f', name='level2', config=True, presence=False, children=[
                DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='l2', config=True, mandatory=True, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='l2-optional', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                DContainer(module='foo', namespace='http://example.com/foo', prefix='f', name='level3', config=True, presence=False, children=[
                    DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='l3', config=True, mandatory=True, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='l3-optional', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                ])
            ])
        ])
    ]),
    DContainer(module='foo', namespace='http://example.com/foo', prefix='f', name='empty-presence', config=True, presence=True),
    DContainer(module='foo', namespace='http://example.com/foo', prefix='f', name='c.dot', config=True, presence=False, children=[
        DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='l.dot1', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
        DLeaf(module='bar', namespace='http://example.com/bar', prefix='bar', name='l.dot2', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
    ]),
    DContainer(module='foo', namespace='http://example.com/foo', prefix='f', name='cc', config=True, presence=False, children=[
        DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='cake', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
        DList(module='foo', namespace='http://example.com/foo', prefix='f', name='death', key=['name'], config=True, min_elements=0, ordered_by='system', children=[
            DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='name', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
        ])
    ]),
    DContainer(module='foo', namespace='http://example.com/foo', prefix='f', name='conflict', config=True, presence=False, children=[
        DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='foo', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
        DContainer(module='foo', namespace='http://example.com/foo', prefix='f', name='inner', config=True, presence=True),
        DLeaf(module='bar', namespace='http://example.com/bar', prefix='bar', name='foo', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
        DContainer(module='bar', namespace='http://example.com/bar', prefix='bar', name='inner', config=True, presence=True)
    ]),
    DList(module='foo', namespace='http://example.com/foo', prefix='f', name='special', key=['yes'], config=True, min_elements=0, ordered_by='system', children=[
        DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='yes', config=True, mandatory=False, type_=DTypeBoolean(name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None))
    ]),
    DContainer(module='foo', namespace='http://example.com/foo', prefix='f', name='nested', config=True, presence=False, children=[
        DContainer(module='foo', namespace='http://example.com/foo', prefix='f', name='inner', config=True, presence=False, children=[
            DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='foo', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
            DList(module='foo', namespace='http://example.com/foo', prefix='f', name='li1', key=['name'], config=True, min_elements=0, ordered_by='system', children=[
                DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='name', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='bar', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                DList(module='foo', namespace='http://example.com/foo', prefix='f', name='li2', key=[
'key1',
'key2'
                    ], config=True, min_elements=0, ordered_by='system', children=[
                    DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='key1', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='key2', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='baz', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                ]),
                DLeaf(module='bar', namespace='http://example.com/bar', prefix='bar', name='bar', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
            ])
        ]),
        DContainer(module='bar', namespace='http://example.com/bar', prefix='bar', name='inner', config=True, presence=False, children=[
            DLeaf(module='bar', namespace='http://example.com/bar', prefix='bar', name='foo', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
        ])
    ]),
    DList(module='foo', namespace='http://example.com/foo', prefix='f', name='li-union', key=[
'k1',
'k2',
'k3'
        ], config=True, min_elements=0, ordered_by='system', children=[
        DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='k1', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
        DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='k2', config=True, mandatory=False, type_=DTypeUnion(name='union', description=None, reference=None, exts=[], builtin_type='union', default=None, types=[DTypeInteger(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(bigint("0"), bigint("4294967295"))])), DTypeEnum(name='enumeration', description=None, reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'unlimited':0}), DTypeBinary(name='binary', description=None, reference=None, exts=[], builtin_type='binary', default=None, length=None)])),
        DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='k3', config=True, mandatory=False, type_=DTypeBinary(name='binary', description=None, reference=None, exts=[], builtin_type='binary', default=None, length=None)),
        DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='checker', config=True, mandatory=False, type_=DTypeUnion(name='union', description=None, reference=None, exts=[], builtin_type='union', default=None, types=[DTypeInteger(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(bigint("1514"), bigint("1514"))])), DTypeInteger(name='uint8', description=None, reference=None, exts=[], builtin_type='uint8', default=None, ranges=Ranges([(bigint("47"), bigint("47"))])), DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])]))
    ]),
    DContainer(module='foo', namespace='http://example.com/foo', prefix='f', name='state', config=False, presence=False, children=[
        DContainer(module='foo', namespace='http://example.com/foo', prefix='f', name='c1', config=False, presence=False, children=[
            DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='l1', config=False, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
            DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='l2', config=False, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
        ])
    ]),
    DLeafList(module='foo', namespace='http://example.com/foo', prefix='f', name='ll-empty', config=True, min_elements=0, ordered_by='system', type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
    DContainer(module='foo', namespace='http://example.com/foo', prefix='f', name='c2', config=True, presence=False, children=[
        DLeaf(module='foo', namespace='http://example.com/foo', prefix='f', name='l1', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
    ]),
    DContainer(module='bar', namespace='http://example.com/bar', prefix='bar', name='test-idref', config=True, presence=False, children=[
        DLeafList(module='bar', namespace='http://example.com/bar', prefix='bar', name='idref', config=True, min_elements=0, ordered_by='system', type_=DTypeIdentityref(name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_foo_basey], identities=_identities))
    ]),
    DContainer(module='bar', namespace='http://example.com/bar', prefix='bar', name='conflict', config=True, presence=False, children=[
        DLeaf(module='bar', namespace='http://example.com/bar', prefix='bar', name='foo', config=True, mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
    ])
])

def src_yang():
    res = []
    res.append(r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "f";
    include qux;
    identity fooy {
        base basey;
    }
    grouping g1 {
        leaf l1 {
            type string;
        }
        leaf l2 {
            type string;
        }
    }
    container c1 {
        leaf l1 {
            type string;
        }
        leaf l3 {
            type uint64;
        }
        leaf l_empty {
            type empty;
        }
        leaf l_empty_delete {
            type empty;
        }
        leaf l_decimal64 {
            type decimal64 {
                fraction-digits 2;
            }
        }
        list li {
            ordered-by user;
            key name;
            leaf name {
                type string;
            }
            leaf val {
                type string;
            }
            container c4 {
                leaf l5 {
                    type string;
                }
            }
        }
        leaf-list ll_uint64 {
            type uint64;
        }
        leaf-list ll_str {
            type string;
        }
        leaf l_identityref {
            type identityref {
                base basey;
            }
        }
        leaf-list ll_identityref {
            type identityref {
                base basey;
            }
        }
        leaf l_identityref_noval {
            // There are no identities derived from base fooy, this leaf has no valid value!
            type identityref {
                base fooy;
            }
        }
    }
    container pc1 {
        presence "p";
        container foo {
            leaf-list l1 {
                type binary;
            }
        }
    }
    container pc2 {
        presence "p";
        container foo {
            leaf l_mandatory {
                type string;
                mandatory true;
            }
        }
    }
    container pc3 {
        presence "p";
        container level1 {
            leaf l1 {
                type string;
                mandatory true;
            }
            leaf l1-optional {
                type string;
            }
            container level2 {
                leaf l2 {
                    type string;
                    mandatory true;
                }
                leaf l2-optional {
                    type string;
                }
                container level3 {
                    leaf l3 {
                        type string;
                        mandatory true;
                    }
                    leaf l3-optional {
                        type string;
                    }
                }
            }
        }
    }
    container empty-presence {
        presence "nothing else here";
    }
    container c.dot {
        leaf l.dot1 {
            type string;
        }
    }
    container cc {
        choice cake-or-death {
            case cake {
                leaf cake {
                    type string;
                    mandatory true;
                }
            }
            case death {
                list death {
                    key name;
                    leaf name {
                        type string;
                    }
                }
            }
            mandatory true;
        }
    }
    container conflict {
        leaf foo {
            type string;
        }
        container inner {
            presence "inner presence";
        }
    }
    list special {
        key yes;
        leaf yes {
            type boolean;
        }
    }
    container nested {
        container inner {
            leaf foo {
                type string;
            }
            list li1 {
                key name;
                leaf name {
                    type string;
                }
                leaf bar {
                    type string;
                }
                list li2 {
                    key "key1 key2";
                    leaf key1 {
                        type string;
                    }
                    leaf key2 {
                        type string;
                    }
                    leaf baz {
                        type string;
                    }
                }
            }
        }
    }
    list li-union {
        key "k1 k2 k3";
        leaf k1 {
            type string;
        }
        leaf k2 {
            type union {
                type uint32;
                type enumeration {
                    enum "unlimited";
                }
                type binary;
            }
        }
        leaf k3 {
            type binary;
        }
        leaf checker {
            type union {
                type uint32 {
                    range "1514..1514";
                }
                type uint8 {
                    range "47..47";
                }
                type string;
            }
        }
    }
    container state {
        config false;
        container c1 {
            uses g1;
        }
    }
    leaf-list ll-empty {
        // Leave this empty, we check that empty leaf-list is not printed
        type string;
    }

}""")
    res.append(r"""submodule qux {
    yang-version "1.1";
    belongs-to foo {
        prefix "f";
    }
    identity basey;
    // Must not conflict with /f:c1
    container c2 {
        leaf l1 {
            type string;
        }
    }
    augment /f:c1 {
        leaf l4 {
            type string;
        }
    }
}""")
    res.append(r"""module bar {
    yang-version "1.1";
    namespace "http://example.com/bar";
    prefix "bar";
    import foo {
        prefix "foo-local";
    }
    identity bary {
        base foo-local:basey;
    }
    container test-idref {
        leaf-list idref {
            type identityref {
                base foo-local:basey;
            }
        }
    }
    augment /foo-local:c1 {
        // create a conflict with /foo-local:c1/l1
        uses foo-local:g1;
    }
    augment /foo-local:c.dot {
        leaf l.dot2 {
            type string;
        }
    }
    container conflict {
        leaf foo {
            type string;
        }
    }
    augment /foo-local:conflict {
        leaf foo {
            type string;
        }
        container inner {
            presence "inner presence from bar";
        }
    }
    augment /foo-local:nested {
        // conflict with /foo-local:nested/inner
        container inner {
            leaf foo {
                type string;
            }
        }
    }
    augment /foo-local:nested/foo-local:inner/foo-local:li1 {
        leaf bar {
            type string;
        }
    }
}""")
    return res


class foo__c1__li__c4(yang.adata.MNode):
    l5: ?str

    mut def __init__(self, l5: ?str):
        self._ns = 'http://example.com/foo'
        self.l5 = l5

    def _get_attr(self, name: str) -> ?value:
        if name == 'l5':
            return self.l5
        raise ValueError('Attribute {name} not found in foo__c1__li__c4')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:c1', 'li', 'c4'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__c1__li__c4:
        if n is not None:
            return foo__c1__li__c4(l5=n.get_opt_str(yang.gdata.Id('http://example.com/foo', 'l5')))
        return foo__c1__li__c4()

    def copy(self):
        """Create a deep copy of this adata object"""
        return foo__c1__li__c4.from_gdata(self.to_gdata())


class foo__c1__li_entry(yang.adata.MNode):
    name: str
    val: ?str
    c4: foo__c1__li__c4

    mut def __init__(self, name: str, val: ?str, c4: ?foo__c1__li__c4=None):
        self._ns = 'http://example.com/foo'
        self.name = name
        self.val = val
        self.c4 = c4 if c4 is not None else foo__c1__li__c4()

    def _get_attr(self, name: str) -> ?value:
        if name == 'name':
            return self.name
        if name == 'val':
            return self.val
        if name == 'c4':
            return self.c4
        raise ValueError('Attribute {name} not found in foo__c1__li')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:c1', 'li'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> foo__c1__li_entry:
        return foo__c1__li_entry(name=n.get_str(yang.gdata.Id('http://example.com/foo', 'name')), val=n.get_opt_str(yang.gdata.Id('http://example.com/foo', 'val')), c4=foo__c1__li__c4.from_gdata(n.get_opt_cnt(yang.gdata.Id('http://example.com/foo', 'c4'))))

    def copy(self):
        """Create a deep copy of this adata object"""
        return foo__c1__li_entry.from_gdata(self.to_gdata())

class foo__c1__li(yang.adata.MNode):
    elements: list[foo__c1__li_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/foo'
        self._name = 'li'
        self.elements = elements

    mut def create(self, name):
        for e in self:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = foo__c1__li_entry(name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[foo__c1__li_entry]:
        if n is not None:
            return [foo__c1__li_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return foo__c1__li(elements=copied_elements)

extension foo__c1__li(Iterable[foo__c1__li_entry]):
    def __iter__(self) -> Iterator[foo__c1__li_entry]:
        return self.elements.__iter__()

class foo__c1(yang.adata.MNode):
    f_l1: ?str
    l3: ?bigint
    l_empty: ?bool
    l_empty_delete: ?bool
    l_decimal64: ?Decimal
    li: foo__c1__li
    ll_uint64: list[bigint]
    ll_str: list[str]
    l_identityref: ?Identityref
    ll_identityref: list[Identityref]
    l_identityref_noval: ?Identityref
    l4: ?str
    bar_l1: ?str
    l2: ?str

    mut def __init__(self, f_l1: ?str, l3: ?bigint, l_empty: ?bool, l_empty_delete: ?bool, l_decimal64: ?Decimal, li: list[foo__c1__li_entry]=[], ll_uint64: ?list[bigint]=None, ll_str: ?list[str]=None, l_identityref: ?Identityref, ll_identityref: ?list[Identityref]=None, l_identityref_noval: ?Identityref, l4: ?str, bar_l1: ?str, l2: ?str):
        self._ns = 'http://example.com/foo'
        self.f_l1 = f_l1
        self.l3 = l3
        self.l_empty = l_empty
        self.l_empty_delete = l_empty_delete
        self.l_decimal64 = l_decimal64
        self.li = foo__c1__li(elements=li)
        self.ll_uint64 = ll_uint64 if ll_uint64 is not None else []
        self.ll_str = ll_str if ll_str is not None else []
        self.l_identityref = l_identityref
        self.ll_identityref = ll_identityref if ll_identityref is not None else []
        self.l_identityref_noval = l_identityref_noval
        self.l4 = l4
        self.bar_l1 = bar_l1
        self.l2 = l2

    def _get_attr(self, name: str) -> ?value:
        if name == 'f_l1':
            return self.f_l1
        if name == 'l3':
            return self.l3
        if name == 'l_empty':
            return self.l_empty
        if name == 'l_empty_delete':
            return self.l_empty_delete
        if name == 'l_decimal64':
            return self.l_decimal64
        if name == 'li':
            return iter(self.li)
        if name == 'll_uint64':
            return self.ll_uint64
        if name == 'll_str':
            return self.ll_str
        if name == 'l_identityref':
            return self.l_identityref
        if name == 'll_identityref':
            return self.ll_identityref
        if name == 'l_identityref_noval':
            return self.l_identityref_noval
        if name == 'l4':
            return self.l4
        if name == 'bar_l1':
            return self.bar_l1
        if name == 'l2':
            return self.l2
        raise ValueError('Attribute {name} not found in foo__c1')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:c1'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__c1:
        if n is not None:
            return foo__c1(f_l1=n.get_opt_str(yang.gdata.Id('http://example.com/foo', 'l1')), l3=n.get_opt_bigint(yang.gdata.Id('http://example.com/foo', 'l3')), l_empty=n.get_opt_empty(yang.gdata.Id('http://example.com/foo', 'l_empty')), l_empty_delete=n.get_opt_empty(yang.gdata.Id('http://example.com/foo', 'l_empty_delete')), l_decimal64=n.get_opt_Decimal(yang.gdata.Id('http://example.com/foo', 'l_decimal64')), li=foo__c1__li.from_gdata(n.get_opt_list(yang.gdata.Id('http://example.com/foo', 'li'))), ll_uint64=n.get_opt_bigints(yang.gdata.Id('http://example.com/foo', 'll_uint64')), ll_str=n.get_opt_strs(yang.gdata.Id('http://example.com/foo', 'll_str')), l_identityref=n.get_opt_Identityref(yang.gdata.Id('http://example.com/foo', 'l_identityref')), ll_identityref=n.get_opt_Identityrefs(yang.gdata.Id('http://example.com/foo', 'll_identityref')), l_identityref_noval=n.get_opt_Identityref(yang.gdata.Id('http://example.com/foo', 'l_identityref_noval')), l4=n.get_opt_str(yang.gdata.Id('http://example.com/foo', 'l4')), bar_l1=n.get_opt_str(yang.gdata.Id('http://example.com/bar', 'l1')), l2=n.get_opt_str(yang.gdata.Id('http://example.com/bar', 'l2')))
        return foo__c1()

    def copy(self):
        """Create a deep copy of this adata object"""
        return foo__c1.from_gdata(self.to_gdata())


class foo__pc1__foo(yang.adata.MNode):
    l1: list[bytes]

    mut def __init__(self, l1: ?list[bytes]=None):
        self._ns = 'http://example.com/foo'
        self.l1 = l1 if l1 is not None else []

    def _get_attr(self, name: str) -> ?value:
        if name == 'l1':
            return self.l1
        raise ValueError('Attribute {name} not found in foo__pc1__foo')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:pc1', 'foo'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__pc1__foo:
        if n is not None:
            return foo__pc1__foo(l1=n.get_opt_bytess(yang.gdata.Id('http://example.com/foo', 'l1')))
        return foo__pc1__foo()

    def copy(self):
        """Create a deep copy of this adata object"""
        return foo__pc1__foo.from_gdata(self.to_gdata())


class foo__pc1(yang.adata.MNode):
    foo: foo__pc1__foo

    mut def __init__(self, foo: ?foo__pc1__foo=None):
        self._ns = 'http://example.com/foo'
        self.foo = foo if foo is not None else foo__pc1__foo()

    def _get_attr(self, name: str) -> ?value:
        if name == 'foo':
            return self.foo
        raise ValueError('Attribute {name} not found in foo__pc1')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:pc1'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?foo__pc1:
        if n is not None:
            return foo__pc1(foo=foo__pc1__foo.from_gdata(n.get_opt_cnt(yang.gdata.Id('http://example.com/foo', 'foo'))))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = foo__pc1.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in foo__pc1.copy()')


class foo__pc2__foo(yang.adata.MNode):
    l_mandatory: str

    mut def __init__(self, l_mandatory: str):
        self._ns = 'http://example.com/foo'
        self.l_mandatory = l_mandatory

    def _get_attr(self, name: str) -> ?value:
        if name == 'l_mandatory':
            return self.l_mandatory
        raise ValueError('Attribute {name} not found in foo__pc2__foo')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:pc2', 'foo'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__pc2__foo:
        if n is not None:
            return foo__pc2__foo(l_mandatory=n.get_str(yang.gdata.Id('http://example.com/foo', 'l_mandatory')))
        raise ValueError('Missing required subtree foo__pc2__foo')

    def copy(self):
        """Create a deep copy of this adata object"""
        return foo__pc2__foo.from_gdata(self.to_gdata())


class foo__pc2(yang.adata.MNode):
    foo: foo__pc2__foo

    mut def __init__(self, foo: foo__pc2__foo):
        self._ns = 'http://example.com/foo'
        self.foo = foo

    def _get_attr(self, name: str) -> ?value:
        if name == 'foo':
            return self.foo
        raise ValueError('Attribute {name} not found in foo__pc2')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:pc2'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?foo__pc2:
        if n is not None:
            return foo__pc2(foo=foo__pc2__foo.from_gdata(n.get_cnt(yang.gdata.Id('http://example.com/foo', 'foo'))))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = foo__pc2.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in foo__pc2.copy()')


class foo__pc3__level1__level2__level3(yang.adata.MNode):
    l3: str
    l3_optional: ?str

    mut def __init__(self, l3: str, l3_optional: ?str):
        self._ns = 'http://example.com/foo'
        self.l3 = l3
        self.l3_optional = l3_optional

    def _get_attr(self, name: str) -> ?value:
        if name == 'l3':
            return self.l3
        if name == 'l3_optional':
            return self.l3_optional
        raise ValueError('Attribute {name} not found in foo__pc3__level1__level2__level3')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:pc3', 'level1', 'level2', 'level3'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__pc3__level1__level2__level3:
        if n is not None:
            return foo__pc3__level1__level2__level3(l3=n.get_str(yang.gdata.Id('http://example.com/foo', 'l3')), l3_optional=n.get_opt_str(yang.gdata.Id('http://example.com/foo', 'l3-optional')))
        raise ValueError('Missing required subtree foo__pc3__level1__level2__level3')

    def copy(self):
        """Create a deep copy of this adata object"""
        return foo__pc3__level1__level2__level3.from_gdata(self.to_gdata())


class foo__pc3__level1__level2(yang.adata.MNode):
    l2: str
    l2_optional: ?str
    level3: foo__pc3__level1__level2__level3

    mut def __init__(self, l2: str, level3: foo__pc3__level1__level2__level3, l2_optional: ?str):
        self._ns = 'http://example.com/foo'
        self.l2 = l2
        self.l2_optional = l2_optional
        self.level3 = level3

    def _get_attr(self, name: str) -> ?value:
        if name == 'l2':
            return self.l2
        if name == 'l2_optional':
            return self.l2_optional
        if name == 'level3':
            return self.level3
        raise ValueError('Attribute {name} not found in foo__pc3__level1__level2')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:pc3', 'level1', 'level2'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__pc3__level1__level2:
        if n is not None:
            return foo__pc3__level1__level2(l2=n.get_str(yang.gdata.Id('http://example.com/foo', 'l2')), l2_optional=n.get_opt_str(yang.gdata.Id('http://example.com/foo', 'l2-optional')), level3=foo__pc3__level1__level2__level3.from_gdata(n.get_cnt(yang.gdata.Id('http://example.com/foo', 'level3'))))
        raise ValueError('Missing required subtree foo__pc3__level1__level2')

    def copy(self):
        """Create a deep copy of this adata object"""
        return foo__pc3__level1__level2.from_gdata(self.to_gdata())


class foo__pc3__level1(yang.adata.MNode):
    l1: str
    l1_optional: ?str
    level2: foo__pc3__level1__level2

    mut def __init__(self, l1: str, level2: foo__pc3__level1__level2, l1_optional: ?str):
        self._ns = 'http://example.com/foo'
        self.l1 = l1
        self.l1_optional = l1_optional
        self.level2 = level2

    def _get_attr(self, name: str) -> ?value:
        if name == 'l1':
            return self.l1
        if name == 'l1_optional':
            return self.l1_optional
        if name == 'level2':
            return self.level2
        raise ValueError('Attribute {name} not found in foo__pc3__level1')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:pc3', 'level1'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__pc3__level1:
        if n is not None:
            return foo__pc3__level1(l1=n.get_str(yang.gdata.Id('http://example.com/foo', 'l1')), l1_optional=n.get_opt_str(yang.gdata.Id('http://example.com/foo', 'l1-optional')), level2=foo__pc3__level1__level2.from_gdata(n.get_cnt(yang.gdata.Id('http://example.com/foo', 'level2'))))
        raise ValueError('Missing required subtree foo__pc3__level1')

    def copy(self):
        """Create a deep copy of this adata object"""
        return foo__pc3__level1.from_gdata(self.to_gdata())


class foo__pc3(yang.adata.MNode):
    level1: foo__pc3__level1

    mut def __init__(self, level1: foo__pc3__level1):
        self._ns = 'http://example.com/foo'
        self.level1 = level1

    def _get_attr(self, name: str) -> ?value:
        if name == 'level1':
            return self.level1
        raise ValueError('Attribute {name} not found in foo__pc3')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:pc3'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?foo__pc3:
        if n is not None:
            return foo__pc3(level1=foo__pc3__level1.from_gdata(n.get_cnt(yang.gdata.Id('http://example.com/foo', 'level1'))))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = foo__pc3.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in foo__pc3.copy()')


class foo__empty_presence(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://example.com/foo'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:empty-presence'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?foo__empty_presence:
        if n is not None:
            return foo__empty_presence()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = foo__empty_presence.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in foo__empty_presence.copy()')


class foo__c_dot(yang.adata.MNode):
    l_dot1: ?str
    l_dot2: ?str

    mut def __init__(self, l_dot1: ?str, l_dot2: ?str):
        self._ns = 'http://example.com/foo'
        self.l_dot1 = l_dot1
        self.l_dot2 = l_dot2

    def _get_attr(self, name: str) -> ?value:
        if name == 'l_dot1':
            return self.l_dot1
        if name == 'l_dot2':
            return self.l_dot2
        raise ValueError('Attribute {name} not found in foo__c_dot')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:c.dot'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__c_dot:
        if n is not None:
            return foo__c_dot(l_dot1=n.get_opt_str(yang.gdata.Id('http://example.com/foo', 'l.dot1')), l_dot2=n.get_opt_str(yang.gdata.Id('http://example.com/bar', 'l.dot2')))
        return foo__c_dot()

    def copy(self):
        """Create a deep copy of this adata object"""
        return foo__c_dot.from_gdata(self.to_gdata())


class foo__cc__death_entry(yang.adata.MNode):
    name: str

    mut def __init__(self, name: str):
        self._ns = 'http://example.com/foo'
        self.name = name

    def _get_attr(self, name: str) -> ?value:
        if name == 'name':
            return self.name
        raise ValueError('Attribute {name} not found in foo__cc__death')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:cc', 'death'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> foo__cc__death_entry:
        return foo__cc__death_entry(name=n.get_str(yang.gdata.Id('http://example.com/foo', 'name')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return foo__cc__death_entry.from_gdata(self.to_gdata())

class foo__cc__death(yang.adata.MNode):
    elements: list[foo__cc__death_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/foo'
        self._name = 'death'
        self.elements = elements

    mut def create(self, name):
        for e in self:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = foo__cc__death_entry(name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[foo__cc__death_entry]:
        if n is not None:
            return [foo__cc__death_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return foo__cc__death(elements=copied_elements)

extension foo__cc__death(Iterable[foo__cc__death_entry]):
    def __iter__(self) -> Iterator[foo__cc__death_entry]:
        return self.elements.__iter__()

class foo__cc(yang.adata.MNode):
    cake: ?str
    death: foo__cc__death

    mut def __init__(self, cake: ?str, death: list[foo__cc__death_entry]=[]):
        self._ns = 'http://example.com/foo'
        self.cake = cake
        self.death = foo__cc__death(elements=death)

    def _get_attr(self, name: str) -> ?value:
        if name == 'cake':
            return self.cake
        if name == 'death':
            return iter(self.death)
        raise ValueError('Attribute {name} not found in foo__cc')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:cc'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__cc:
        if n is not None:
            return foo__cc(cake=n.get_opt_str(yang.gdata.Id('http://example.com/foo', 'cake')), death=foo__cc__death.from_gdata(n.get_opt_list(yang.gdata.Id('http://example.com/foo', 'death'))))
        return foo__cc()

    def copy(self):
        """Create a deep copy of this adata object"""
        return foo__cc.from_gdata(self.to_gdata())


class foo__f_conflict__f_inner(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://example.com/foo'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:conflict', 'inner'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?foo__f_conflict__f_inner:
        if n is not None:
            return foo__f_conflict__f_inner()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = foo__f_conflict__f_inner.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in foo__f_conflict__f_inner.copy()')


class foo__f_conflict__bar_inner(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://example.com/bar'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:conflict', 'bar:inner'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?foo__f_conflict__bar_inner:
        if n is not None:
            return foo__f_conflict__bar_inner()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = foo__f_conflict__bar_inner.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in foo__f_conflict__bar_inner.copy()')


class foo__f_conflict(yang.adata.MNode):
    f_foo: ?str
    f_inner: ?foo__f_conflict__f_inner
    bar_foo: ?str
    bar_inner: ?foo__f_conflict__bar_inner

    mut def __init__(self, f_foo: ?str, f_inner: ?foo__f_conflict__f_inner=None, bar_foo: ?str, bar_inner: ?foo__f_conflict__bar_inner=None):
        self._ns = 'http://example.com/foo'
        self.f_foo = f_foo
        self.f_inner = f_inner
        self.bar_foo = bar_foo
        self.bar_inner = bar_inner

    mut def create_f_inner(self):
        existing = self.f_inner
        if existing is not None:
            return existing
        res = foo__f_conflict__f_inner()
        self.f_inner = res
        return res

    mut def create_bar_inner(self):
        existing = self.bar_inner
        if existing is not None:
            return existing
        res = foo__f_conflict__bar_inner()
        self.bar_inner = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'f_foo':
            return self.f_foo
        if name == 'f_inner':
            return self.f_inner
        if name == 'bar_foo':
            return self.bar_foo
        if name == 'bar_inner':
            return self.bar_inner
        raise ValueError('Attribute {name} not found in foo__f_conflict')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:conflict'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__f_conflict:
        if n is not None:
            return foo__f_conflict(f_foo=n.get_opt_str(yang.gdata.Id('http://example.com/foo', 'foo')), f_inner=foo__f_conflict__f_inner.from_gdata(n.get_opt_cnt(yang.gdata.Id('http://example.com/foo', 'inner'))), bar_foo=n.get_opt_str(yang.gdata.Id('http://example.com/bar', 'foo')), bar_inner=foo__f_conflict__bar_inner.from_gdata(n.get_opt_cnt(yang.gdata.Id('http://example.com/bar', 'inner'))))
        return foo__f_conflict()

    def copy(self):
        """Create a deep copy of this adata object"""
        return foo__f_conflict.from_gdata(self.to_gdata())


class foo__special_entry(yang.adata.MNode):
    yes: bool

    mut def __init__(self, yes: bool):
        self._ns = 'http://example.com/foo'
        self.yes = yes

    def _get_attr(self, name: str) -> ?value:
        if name == 'yes':
            return self.yes
        raise ValueError('Attribute {name} not found in foo__special')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:special'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> foo__special_entry:
        return foo__special_entry(yes=n.get_bool(yang.gdata.Id('http://example.com/foo', 'yes')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return foo__special_entry.from_gdata(self.to_gdata())

class foo__special(yang.adata.MNode):
    elements: list[foo__special_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/foo'
        self._name = 'special'
        self.elements = elements

    mut def create(self, yes):
        for e in self:
            match = True
            if e.yes != yes:
                match = False
                continue
            if match:
                return e

        res = foo__special_entry(yes)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[foo__special_entry]:
        if n is not None:
            return [foo__special_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return foo__special(elements=copied_elements)

extension foo__special(Iterable[foo__special_entry]):
    def __iter__(self) -> Iterator[foo__special_entry]:
        return self.elements.__iter__()

class foo__nested__f_inner__li1__li2_entry(yang.adata.MNode):
    key1: str
    key2: str
    baz: ?str

    mut def __init__(self, key1: str, key2: str, baz: ?str):
        self._ns = 'http://example.com/foo'
        self.key1 = key1
        self.key2 = key2
        self.baz = baz

    def _get_attr(self, name: str) -> ?value:
        if name == 'key1':
            return self.key1
        if name == 'key2':
            return self.key2
        if name == 'baz':
            return self.baz
        raise ValueError('Attribute {name} not found in foo__nested__f_inner__li1__li2')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:nested', 'inner', 'li1', 'li2'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> foo__nested__f_inner__li1__li2_entry:
        return foo__nested__f_inner__li1__li2_entry(key1=n.get_str(yang.gdata.Id('http://example.com/foo', 'key1')), key2=n.get_str(yang.gdata.Id('http://example.com/foo', 'key2')), baz=n.get_opt_str(yang.gdata.Id('http://example.com/foo', 'baz')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return foo__nested__f_inner__li1__li2_entry.from_gdata(self.to_gdata())

class foo__nested__f_inner__li1__li2(yang.adata.MNode):
    elements: list[foo__nested__f_inner__li1__li2_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/foo'
        self._name = 'li2'
        self.elements = elements

    mut def create(self, key1, key2):
        for e in self:
            match = True
            if e.key1 != key1:
                match = False
                continue
            if e.key2 != key2:
                match = False
                continue
            if match:
                return e

        res = foo__nested__f_inner__li1__li2_entry(key1, key2)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[foo__nested__f_inner__li1__li2_entry]:
        if n is not None:
            return [foo__nested__f_inner__li1__li2_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return foo__nested__f_inner__li1__li2(elements=copied_elements)

extension foo__nested__f_inner__li1__li2(Iterable[foo__nested__f_inner__li1__li2_entry]):
    def __iter__(self) -> Iterator[foo__nested__f_inner__li1__li2_entry]:
        return self.elements.__iter__()

class foo__nested__f_inner__li1_entry(yang.adata.MNode):
    name: str
    f_bar: ?str
    li2: foo__nested__f_inner__li1__li2
    bar_bar: ?str

    mut def __init__(self, name: str, f_bar: ?str, li2: list[foo__nested__f_inner__li1__li2_entry]=[], bar_bar: ?str):
        self._ns = 'http://example.com/foo'
        self.name = name
        self.f_bar = f_bar
        self.li2 = foo__nested__f_inner__li1__li2(elements=li2)
        self.bar_bar = bar_bar

    def _get_attr(self, name: str) -> ?value:
        if name == 'name':
            return self.name
        if name == 'f_bar':
            return self.f_bar
        if name == 'li2':
            return iter(self.li2)
        if name == 'bar_bar':
            return self.bar_bar
        raise ValueError('Attribute {name} not found in foo__nested__f_inner__li1')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:nested', 'inner', 'li1'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> foo__nested__f_inner__li1_entry:
        return foo__nested__f_inner__li1_entry(name=n.get_str(yang.gdata.Id('http://example.com/foo', 'name')), f_bar=n.get_opt_str(yang.gdata.Id('http://example.com/foo', 'bar')), li2=foo__nested__f_inner__li1__li2.from_gdata(n.get_opt_list(yang.gdata.Id('http://example.com/foo', 'li2'))), bar_bar=n.get_opt_str(yang.gdata.Id('http://example.com/bar', 'bar')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return foo__nested__f_inner__li1_entry.from_gdata(self.to_gdata())

class foo__nested__f_inner__li1(yang.adata.MNode):
    elements: list[foo__nested__f_inner__li1_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/foo'
        self._name = 'li1'
        self.elements = elements

    mut def create(self, name):
        for e in self:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = foo__nested__f_inner__li1_entry(name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[foo__nested__f_inner__li1_entry]:
        if n is not None:
            return [foo__nested__f_inner__li1_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return foo__nested__f_inner__li1(elements=copied_elements)

extension foo__nested__f_inner__li1(Iterable[foo__nested__f_inner__li1_entry]):
    def __iter__(self) -> Iterator[foo__nested__f_inner__li1_entry]:
        return self.elements.__iter__()

class foo__nested__f_inner(yang.adata.MNode):
    foo: ?str
    li1: foo__nested__f_inner__li1

    mut def __init__(self, foo: ?str, li1: list[foo__nested__f_inner__li1_entry]=[]):
        self._ns = 'http://example.com/foo'
        self.foo = foo
        self.li1 = foo__nested__f_inner__li1(elements=li1)

    def _get_attr(self, name: str) -> ?value:
        if name == 'foo':
            return self.foo
        if name == 'li1':
            return iter(self.li1)
        raise ValueError('Attribute {name} not found in foo__nested__f_inner')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:nested', 'inner'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__nested__f_inner:
        if n is not None:
            return foo__nested__f_inner(foo=n.get_opt_str(yang.gdata.Id('http://example.com/foo', 'foo')), li1=foo__nested__f_inner__li1.from_gdata(n.get_opt_list(yang.gdata.Id('http://example.com/foo', 'li1'))))
        return foo__nested__f_inner()

    def copy(self):
        """Create a deep copy of this adata object"""
        return foo__nested__f_inner.from_gdata(self.to_gdata())


class foo__nested__bar_inner(yang.adata.MNode):
    foo: ?str

    mut def __init__(self, foo: ?str):
        self._ns = 'http://example.com/bar'
        self.foo = foo

    def _get_attr(self, name: str) -> ?value:
        if name == 'foo':
            return self.foo
        raise ValueError('Attribute {name} not found in foo__nested__bar_inner')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:nested', 'bar:inner'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__nested__bar_inner:
        if n is not None:
            return foo__nested__bar_inner(foo=n.get_opt_str(yang.gdata.Id('http://example.com/bar', 'foo')))
        return foo__nested__bar_inner()

    def copy(self):
        """Create a deep copy of this adata object"""
        return foo__nested__bar_inner.from_gdata(self.to_gdata())


class foo__nested(yang.adata.MNode):
    f_inner: foo__nested__f_inner
    bar_inner: foo__nested__bar_inner

    mut def __init__(self, f_inner: ?foo__nested__f_inner=None, bar_inner: ?foo__nested__bar_inner=None):
        self._ns = 'http://example.com/foo'
        self.f_inner = f_inner if f_inner is not None else foo__nested__f_inner()
        self.bar_inner = bar_inner if bar_inner is not None else foo__nested__bar_inner()

    def _get_attr(self, name: str) -> ?value:
        if name == 'f_inner':
            return self.f_inner
        if name == 'bar_inner':
            return self.bar_inner
        raise ValueError('Attribute {name} not found in foo__nested')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:nested'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__nested:
        if n is not None:
            return foo__nested(f_inner=foo__nested__f_inner.from_gdata(n.get_opt_cnt(yang.gdata.Id('http://example.com/foo', 'inner'))), bar_inner=foo__nested__bar_inner.from_gdata(n.get_opt_cnt(yang.gdata.Id('http://example.com/bar', 'inner'))))
        return foo__nested()

    def copy(self):
        """Create a deep copy of this adata object"""
        return foo__nested.from_gdata(self.to_gdata())


class foo__li_union_entry(yang.adata.MNode):
    k1: str
    k2: value
    k3: bytes
    checker: ?value

    mut def __init__(self, k1: str, k2: value, k3: bytes, checker: ?value):
        self._ns = 'http://example.com/foo'
        self.k1 = k1
        self.k2 = k2
        self.k3 = k3
        self.checker = checker

    def _get_attr(self, name: str) -> ?value:
        if name == 'k1':
            return self.k1
        if name == 'k2':
            return self.k2
        if name == 'k3':
            return self.k3
        if name == 'checker':
            return self.checker
        raise ValueError('Attribute {name} not found in foo__li_union')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:li-union'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> foo__li_union_entry:
        return foo__li_union_entry(k1=n.get_str(yang.gdata.Id('http://example.com/foo', 'k1')), k2=n.get_value(yang.gdata.Id('http://example.com/foo', 'k2')), k3=n.get_bytes(yang.gdata.Id('http://example.com/foo', 'k3')), checker=n.get_opt_value(yang.gdata.Id('http://example.com/foo', 'checker')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return foo__li_union_entry.from_gdata(self.to_gdata())

class foo__li_union(yang.adata.MNode):
    elements: list[foo__li_union_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/foo'
        self._name = 'li-union'
        self.elements = elements

    mut def create(self, k1, k2, k3):
        for e in self:
            match = True
            if e.k1 != k1:
                match = False
                continue
            e_k2 = e.k2
            if isinstance(e_k2, bigint) and isinstance(k2, bigint):
                if e_k2 != k2:
                    match = False
                    continue
            e_k2 = e.k2
            if isinstance(e_k2, str) and isinstance(k2, str):
                if e_k2 != k2:
                    match = False
                    continue
            e_k2 = e.k2
            if isinstance(e_k2, bytes) and isinstance(k2, bytes):
                if e_k2 != k2:
                    match = False
                    continue
            if e.k3 != k3:
                match = False
                continue
            if match:
                return e

        res = foo__li_union_entry(k1, k2, k3)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[foo__li_union_entry]:
        if n is not None:
            return [foo__li_union_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return foo__li_union(elements=copied_elements)

extension foo__li_union(Iterable[foo__li_union_entry]):
    def __iter__(self) -> Iterator[foo__li_union_entry]:
        return self.elements.__iter__()

class foo__state__c1(yang.adata.MNode):
    l1: ?str
    l2: ?str

    mut def __init__(self, l1: ?str, l2: ?str):
        self._ns = 'http://example.com/foo'
        self.l1 = l1
        self.l2 = l2

    def _get_attr(self, name: str) -> ?value:
        if name == 'l1':
            return self.l1
        if name == 'l2':
            return self.l2
        raise ValueError('Attribute {name} not found in foo__state__c1')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:state', 'c1'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__state__c1:
        if n is not None:
            return foo__state__c1(l1=n.get_opt_str(yang.gdata.Id('http://example.com/foo', 'l1')), l2=n.get_opt_str(yang.gdata.Id('http://example.com/foo', 'l2')))
        return foo__state__c1()

    def copy(self):
        """Create a deep copy of this adata object"""
        return foo__state__c1.from_gdata(self.to_gdata())


class foo__state(yang.adata.MNode):
    c1: foo__state__c1

    mut def __init__(self, c1: ?foo__state__c1=None):
        self._ns = 'http://example.com/foo'
        self.c1 = c1 if c1 is not None else foo__state__c1()

    def _get_attr(self, name: str) -> ?value:
        if name == 'c1':
            return self.c1
        raise ValueError('Attribute {name} not found in foo__state')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:state'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__state:
        if n is not None:
            return foo__state(c1=foo__state__c1.from_gdata(n.get_opt_cnt(yang.gdata.Id('http://example.com/foo', 'c1'))))
        return foo__state()

    def copy(self):
        """Create a deep copy of this adata object"""
        return foo__state.from_gdata(self.to_gdata())


class foo__c2(yang.adata.MNode):
    l1: ?str

    mut def __init__(self, l1: ?str):
        self._ns = 'http://example.com/foo'
        self.l1 = l1

    def _get_attr(self, name: str) -> ?value:
        if name == 'l1':
            return self.l1
        raise ValueError('Attribute {name} not found in foo__c2')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['foo:c2'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__c2:
        if n is not None:
            return foo__c2(l1=n.get_opt_str(yang.gdata.Id('http://example.com/foo', 'l1')))
        return foo__c2()

    def copy(self):
        """Create a deep copy of this adata object"""
        return foo__c2.from_gdata(self.to_gdata())


class bar__test_idref(yang.adata.MNode):
    idref: list[Identityref]

    mut def __init__(self, idref: ?list[Identityref]=None):
        self._ns = 'http://example.com/bar'
        self.idref = idref if idref is not None else []

    def _get_attr(self, name: str) -> ?value:
        if name == 'idref':
            return self.idref
        raise ValueError('Attribute {name} not found in bar__test_idref')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['bar:test-idref'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> bar__test_idref:
        if n is not None:
            return bar__test_idref(idref=n.get_opt_Identityrefs(yang.gdata.Id('http://example.com/bar', 'idref')))
        return bar__test_idref()

    def copy(self):
        """Create a deep copy of this adata object"""
        return bar__test_idref.from_gdata(self.to_gdata())


class bar__bar_conflict(yang.adata.MNode):
    foo: ?str

    mut def __init__(self, foo: ?str):
        self._ns = 'http://example.com/bar'
        self.foo = foo

    def _get_attr(self, name: str) -> ?value:
        if name == 'foo':
            return self.foo
        raise ValueError('Attribute {name} not found in bar__bar_conflict')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False, root_path=['bar:conflict'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> bar__bar_conflict:
        if n is not None:
            return bar__bar_conflict(foo=n.get_opt_str(yang.gdata.Id('http://example.com/bar', 'foo')))
        return bar__bar_conflict()

    def copy(self):
        """Create a deep copy of this adata object"""
        return bar__bar_conflict.from_gdata(self.to_gdata())


class root(yang.adata.MNode):
    c1: foo__c1
    pc1: ?foo__pc1
    pc2: ?foo__pc2
    pc3: ?foo__pc3
    empty_presence: ?foo__empty_presence
    c_dot: foo__c_dot
    cc: foo__cc
    f_conflict: foo__f_conflict
    special: foo__special
    nested: foo__nested
    li_union: foo__li_union
    state: foo__state
    ll_empty: list[str]
    c2: foo__c2
    test_idref: bar__test_idref
    bar_conflict: bar__bar_conflict

    mut def __init__(self, c1: ?foo__c1=None, pc1: ?foo__pc1=None, pc2: ?foo__pc2=None, pc3: ?foo__pc3=None, empty_presence: ?foo__empty_presence=None, c_dot: ?foo__c_dot=None, cc: ?foo__cc=None, f_conflict: ?foo__f_conflict=None, special: list[foo__special_entry]=[], nested: ?foo__nested=None, li_union: list[foo__li_union_entry]=[], state: ?foo__state=None, ll_empty: ?list[str]=None, c2: ?foo__c2=None, test_idref: ?bar__test_idref=None, bar_conflict: ?bar__bar_conflict=None):
        self._ns = ''
        self.c1 = c1 if c1 is not None else foo__c1()
        self.pc1 = pc1
        self.pc2 = pc2
        self.pc3 = pc3
        self.empty_presence = empty_presence
        self.c_dot = c_dot if c_dot is not None else foo__c_dot()
        self.cc = cc if cc is not None else foo__cc()
        self.f_conflict = f_conflict if f_conflict is not None else foo__f_conflict()
        self.special = foo__special(elements=special)
        self.nested = nested if nested is not None else foo__nested()
        self.li_union = foo__li_union(elements=li_union)
        self.state = state if state is not None else foo__state()
        self.ll_empty = ll_empty if ll_empty is not None else []
        self.c2 = c2 if c2 is not None else foo__c2()
        self.test_idref = test_idref if test_idref is not None else bar__test_idref()
        self.bar_conflict = bar_conflict if bar_conflict is not None else bar__bar_conflict()

    mut def create_pc1(self):
        existing = self.pc1
        if existing is not None:
            return existing
        res = foo__pc1()
        self.pc1 = res
        return res

    mut def create_pc2(self, foo):
        existing = self.pc2
        if existing is not None:
            return existing
        res = foo__pc2(foo)
        self.pc2 = res
        return res

    mut def create_pc3(self, level1):
        existing = self.pc3
        if existing is not None:
            return existing
        res = foo__pc3(level1)
        self.pc3 = res
        return res

    mut def create_empty_presence(self):
        existing = self.empty_presence
        if existing is not None:
            return existing
        res = foo__empty_presence()
        self.empty_presence = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'c1':
            return self.c1
        if name == 'pc1':
            return self.pc1
        if name == 'pc2':
            return self.pc2
        if name == 'pc3':
            return self.pc3
        if name == 'empty_presence':
            return self.empty_presence
        if name == 'c_dot':
            return self.c_dot
        if name == 'cc':
            return self.cc
        if name == 'f_conflict':
            return self.f_conflict
        if name == 'special':
            return iter(self.special)
        if name == 'nested':
            return self.nested
        if name == 'li_union':
            return iter(self.li_union)
        if name == 'state':
            return self.state
        if name == 'll_empty':
            return self.ll_empty
        if name == 'c2':
            return self.c2
        if name == 'test_idref':
            return self.test_idref
        if name == 'bar_conflict':
            return self.bar_conflict
        raise ValueError('Attribute {name} not found in root')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(SRC_DNODE, self, loose=False)
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> root:
        if n is not None:
            return root(c1=foo__c1.from_gdata(n.get_opt_cnt(yang.gdata.Id('http://example.com/foo', 'c1'))), pc1=foo__pc1.from_gdata(n.get_opt_cnt(yang.gdata.Id('http://example.com/foo', 'pc1'))), pc2=foo__pc2.from_gdata(n.get_opt_cnt(yang.gdata.Id('http://example.com/foo', 'pc2'))), pc3=foo__pc3.from_gdata(n.get_opt_cnt(yang.gdata.Id('http://example.com/foo', 'pc3'))), empty_presence=foo__empty_presence.from_gdata(n.get_opt_cnt(yang.gdata.Id('http://example.com/foo', 'empty-presence'))), c_dot=foo__c_dot.from_gdata(n.get_opt_cnt(yang.gdata.Id('http://example.com/foo', 'c.dot'))), cc=foo__cc.from_gdata(n.get_opt_cnt(yang.gdata.Id('http://example.com/foo', 'cc'))), f_conflict=foo__f_conflict.from_gdata(n.get_opt_cnt(yang.gdata.Id('http://example.com/foo', 'conflict'))), special=foo__special.from_gdata(n.get_opt_list(yang.gdata.Id('http://example.com/foo', 'special'))), nested=foo__nested.from_gdata(n.get_opt_cnt(yang.gdata.Id('http://example.com/foo', 'nested'))), li_union=foo__li_union.from_gdata(n.get_opt_list(yang.gdata.Id('http://example.com/foo', 'li-union'))), state=foo__state.from_gdata(n.get_opt_cnt(yang.gdata.Id('http://example.com/foo', 'state'))), ll_empty=n.get_opt_strs(yang.gdata.Id('http://example.com/foo', 'll-empty')), c2=foo__c2.from_gdata(n.get_opt_cnt(yang.gdata.Id('http://example.com/foo', 'c2'))), test_idref=bar__test_idref.from_gdata(n.get_opt_cnt(yang.gdata.Id('http://example.com/bar', 'test-idref'))), bar_conflict=bar__bar_conflict.from_gdata(n.get_opt_cnt(yang.gdata.Id('http://example.com/bar', 'conflict'))))
        return root()

    def copy(self):
        """Create a deep copy of this adata object"""
        return root.from_gdata(self.to_gdata())


schema_namespaces: set[str] = {
    'http://example.com/bar',
    'http://example.com/foo',
}
def src_schema():
    res = {}
    res["foo"] = Module('foo', yang_version=1.1, namespace='http://example.com/foo', prefix='f', include=[
        Include('qux')
    ], children=[
    Identity('fooy', base=['basey']),
    Grouping('g1', children=[
        Leaf('l1', type_=Type('string')),
        Leaf('l2', type_=Type('string'))
    ]),
    Container('c1', children=[
        Leaf('l1', type_=Type('string')),
        Leaf('l3', type_=Type('uint64')),
        Leaf('l_empty', type_=Type('empty')),
        Leaf('l_empty_delete', type_=Type('empty')),
        Leaf('l_decimal64', type_=Type('decimal64', fraction_digits=2)),
        List('li', key='name', ordered_by='user', children=[
            Leaf('name', type_=Type('string')),
            Leaf('val', type_=Type('string')),
            Container('c4', children=[
                Leaf('l5', type_=Type('string'))
            ])
        ]),
        LeafList('ll_uint64', type_=Type('uint64')),
        LeafList('ll_str', type_=Type('string')),
        Leaf('l_identityref', type_=Type('identityref', base=['basey'])),
        LeafList('ll_identityref', type_=Type('identityref', base=['basey'])),
        Leaf('l_identityref_noval', type_=Type('identityref', base=['fooy']))
    ]),
    Container('pc1', presence='p', children=[
        Container('foo', children=[
            LeafList('l1', type_=Type('binary'))
        ])
    ]),
    Container('pc2', presence='p', children=[
        Container('foo', children=[
            Leaf('l_mandatory', type_=Type('string'), mandatory=True)
        ])
    ]),
    Container('pc3', presence='p', children=[
        Container('level1', children=[
            Leaf('l1', type_=Type('string'), mandatory=True),
            Leaf('l1-optional', type_=Type('string')),
            Container('level2', children=[
                Leaf('l2', type_=Type('string'), mandatory=True),
                Leaf('l2-optional', type_=Type('string')),
                Container('level3', children=[
                    Leaf('l3', type_=Type('string'), mandatory=True),
                    Leaf('l3-optional', type_=Type('string'))
                ])
            ])
        ])
    ]),
    Container('empty-presence', presence='nothing else here'),
    Container('c.dot', children=[
        Leaf('l.dot1', type_=Type('string'))
    ]),
    Container('cc', children=[
        Choice('cake-or-death', mandatory=True, children=[
            Case('cake', children=[
                Leaf('cake', type_=Type('string'), mandatory=True)
            ]),
            Case('death', children=[
                List('death', key='name', children=[
                    Leaf('name', type_=Type('string'))
                ])
            ])
        ])
    ]),
    Container('conflict', children=[
        Leaf('foo', type_=Type('string')),
        Container('inner', presence='inner presence')
    ]),
    List('special', key='yes', children=[
        Leaf('yes', type_=Type('boolean'))
    ]),
    Container('nested', children=[
        Container('inner', children=[
            Leaf('foo', type_=Type('string')),
            List('li1', key='name', children=[
                Leaf('name', type_=Type('string')),
                Leaf('bar', type_=Type('string')),
                List('li2', key='key1 key2', children=[
                    Leaf('key1', type_=Type('string')),
                    Leaf('key2', type_=Type('string')),
                    Leaf('baz', type_=Type('string'))
                ])
            ])
        ])
    ]),
    List('li-union', key='k1 k2 k3', children=[
        Leaf('k1', type_=Type('string')),
        Leaf('k2', type_=Type('union', type_=[
        Type('uint32'),
        Type('enumeration', enum=[
                Enum('unlimited')
            ]),
        Type('binary')
    ])),
        Leaf('k3', type_=Type('binary')),
        Leaf('checker', type_=Type('union', type_=[
        Type('uint32', range_=Range('1514..1514')),
        Type('uint8', range_=Range('47..47')),
        Type('string')
    ]))
    ]),
    Container('state', config=False, children=[
        Container('c1', children=[
            Uses('g1')
        ])
    ]),
    LeafList('ll-empty', type_=Type('string'))
])
    res["qux"] = Submodule('qux', yang_version=1.1, belongs_to=BelongsTo('foo', prefix='f'), augment=[
        Augment('/f:c1', children=[
            Leaf('l4', type_=Type('string'))
        ])
    ], children=[
    Identity('basey'),
    Container('c2', children=[
        Leaf('l1', type_=Type('string'))
    ])
])
    res["bar"] = Module('bar', yang_version=1.1, namespace='http://example.com/bar', prefix='bar', import_=[
        Import('foo', prefix='foo-local')
    ], augment=[
        Augment('/foo-local:c1', children=[
            Uses('foo-local:g1')
        ]),
        Augment('/foo-local:c.dot', children=[
            Leaf('l.dot2', type_=Type('string'))
        ]),
        Augment('/foo-local:conflict', children=[
            Leaf('foo', type_=Type('string')),
            Container('inner', presence='inner presence from bar')
        ]),
        Augment('/foo-local:nested', children=[
            Container('inner', children=[
                Leaf('foo', type_=Type('string'))
            ])
        ]),
        Augment('/foo-local:nested/foo-local:inner/foo-local:li1', children=[
            Leaf('bar', type_=Type('string'))
        ])
    ], children=[
    Identity('bary', base=['foo-local:basey']),
    Container('test-idref', children=[
        LeafList('idref', type_=Type('identityref', base=['foo-local:basey']))
    ]),
    Container('conflict', children=[
        Leaf('foo', type_=Type('string'))
    ])
])
    return res

