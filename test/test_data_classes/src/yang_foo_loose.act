from yang.schema import *
import base64
import json
import xml
import yang.adata
import yang.gdata

# == This file is generated ==


mut def from_json_foo__c1__f_l1(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__c1__f_l1(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__c1__l3(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint64', val)

mut def from_xml_foo__c1__l3(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint64', val)

mut def from_json_foo__c1__l_empty(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_xml_foo__c1__l_empty(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_json_foo__c1__li__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__c1__li__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__c1__li__val(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__c1__li__val(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class foo__c1__li_entry(yang.adata.MNode):
    name: str
    val: ?str

    mut def __init__(self, name: str, val: ?str):
        self._ns = 'http://example.com/foo'
        self.name = name
        self.val = val

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        _val = self.val
        if _val is not None:
            children['val'] = yang.gdata.Leaf('string', _val)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> foo__c1__li_entry:
        return foo__c1__li_entry(name=n.get_str('name'), val=n.get_opt_str('val'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /c1/li')
            res.append('{self_name} = foo__c1__li({repr(self.name)})')
        leaves = []
        _val = self.val
        if _val is not None:
            leaves.append('{self_name}.val = {repr(_val)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /c1/li'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class foo__c1__li(yang.adata.MNode):
    elements: list[foo__c1__li_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/foo'
        self._name = 'li'
        self.elements = elements

    mut def create(self, name):
        for e in self.elements:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = foo__c1__li_entry(name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements, user_order=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[foo__c1__li_entry]:
        if n is not None:
            return [foo__c1__li_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_foo__c1__li_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.from_xml_str(node, 'name')
    yang.gdata.maybe_add(children, 'name', from_xml_foo__c1__li__name, child_name)
    child_val = yang.gdata.from_xml_opt_str(node, 'val')
    yang.gdata.maybe_add(children, 'val', from_xml_foo__c1__li__val, child_val)
    return yang.gdata.Container(children)

mut def from_xml_foo__c1__li(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_foo__c1__li_element(e) for e in nodes]
    return yang.gdata.List(keys=['name'], elements=elements, user_order=True)

mut def from_json_path_foo__c1__li_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_foo__c1__li_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['name']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['name'] = from_json_foo__c1__li__name(keys[0])
        if point == 'val':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_foo__c1__li(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_foo__c1__li_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['name'])))
        return yang.gdata.List(['name'], elements, user_order=True)
    elif len(path) > 1:
        return yang.gdata.List(['name'], [from_json_path_foo__c1__li_element(jd, path, op)], user_order=True)
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_foo__c1__li_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.take_json_str(jd, 'name')
    yang.gdata.maybe_add(children, 'name', from_json_foo__c1__li__name, child_name)
    child_val = yang.gdata.take_json_opt_str(jd, 'val')
    yang.gdata.maybe_add(children, 'val', from_json_foo__c1__li__val, child_val)
    return yang.gdata.Container(children)

mut def from_json_foo__c1__li(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_foo__c1__li_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['name'], elements=elements, user_order=True)

mut def from_json_foo__c1__ll_uint64(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('uint64', val)

mut def from_xml_foo__c1__ll_uint64(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('uint64', val)

mut def from_json_foo__c1__ll_str(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_xml_foo__c1__ll_str(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_json_foo__c1__l4(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__c1__l4(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__c1__bar_l1(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val, ns='http://example.com/bar', module='bar')

mut def from_xml_foo__c1__bar_l1(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val, ns='http://example.com/bar', module='bar')

mut def from_json_foo__c1__l2(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val, ns='http://example.com/bar', module='bar')

mut def from_xml_foo__c1__l2(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val, ns='http://example.com/bar', module='bar')

class foo__c1(yang.adata.MNode):
    f_l1: ?str
    l3: ?int
    l_empty: ?bool
    li: foo__c1__li
    ll_uint64: list[int]
    ll_str: list[str]
    l4: ?str
    bar_l1: ?str
    l2: ?str

    mut def __init__(self, f_l1: ?str, l3: ?int, l_empty: ?bool, li: list[foo__c1__li_entry]=[], ll_uint64: ?list[int]=None, ll_str: ?list[str]=None, l4: ?str, bar_l1: ?str, l2: ?str):
        self._ns = 'http://example.com/foo'
        self.f_l1 = f_l1
        self.l3 = l3
        self.l_empty = l_empty
        self.li = foo__c1__li(elements=li)
        self.ll_uint64 = ll_uint64 if ll_uint64 is not None else []
        self.ll_str = ll_str if ll_str is not None else []
        self.l4 = l4
        self.bar_l1 = bar_l1
        self.l2 = l2

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _f_l1 = self.f_l1
        if _f_l1 is not None:
            children['f:l1'] = yang.gdata.Leaf('string', _f_l1)
        _l3 = self.l3
        if _l3 is not None:
            children['l3'] = yang.gdata.Leaf('uint64', _l3)
        _l_empty = self.l_empty
        if _l_empty is not None:
            children['l_empty'] = yang.gdata.Leaf('empty', _l_empty)
        _li = self.li
        if _li is not None:
            children['li'] = _li.to_gdata()
        children['ll_uint64'] = yang.gdata.LeafList('uint64', self.ll_uint64)
        children['ll_str'] = yang.gdata.LeafList('string', self.ll_str)
        _l4 = self.l4
        if _l4 is not None:
            children['l4'] = yang.gdata.Leaf('string', _l4)
        _bar_l1 = self.bar_l1
        if _bar_l1 is not None:
            children['bar:l1'] = yang.gdata.Leaf('string', _bar_l1, ns='http://example.com/bar', module='bar')
        _l2 = self.l2
        if _l2 is not None:
            children['l2'] = yang.gdata.Leaf('string', _l2, ns='http://example.com/bar', module='bar')
        return yang.gdata.Container(children, ns='http://example.com/foo', module='foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__c1:
        if n != None:
            return foo__c1(f_l1=n.get_opt_str('f:l1'), l3=n.get_opt_int('l3'), l_empty=n.get_opt_bool('l_empty'), li=foo__c1__li.from_gdata(n.get_opt_list('li')), ll_uint64=n.get_opt_ints('ll_uint64'), ll_str=n.get_opt_strs('ll_str'), l4=n.get_opt_str('l4'), bar_l1=n.get_opt_str('bar:l1'), l2=n.get_opt_str('l2'))
        return foo__c1()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /c1')
            res.append('{self_name} = foo__c1()')
        leaves = []
        _f_l1 = self.f_l1
        if _f_l1 is not None:
            leaves.append('{self_name}.f_l1 = {repr(_f_l1)}')
        _l3 = self.l3
        if _l3 is not None:
            leaves.append('{self_name}.l3 = {repr(_l3)}')
        _l_empty = self.l_empty
        if _l_empty is not None:
            leaves.append('{self_name}.l_empty = {repr(_l_empty)}')
        _li = self.li
        for _element in _li.elements:
            res.append('')
            res.append("# List /c1/li element: {_element.to_gdata().key_str(['name'])}")
            list_elem = 'li_element = {self_name}.li.create({repr(_element.name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('li_element', False, list_element=True).splitlines())
        _ll_uint64 = self.ll_uint64
        if _ll_uint64 is not None:
            leaves.append('{self_name}.ll_uint64 = {repr(_ll_uint64)}')
        _ll_str = self.ll_str
        if _ll_str is not None:
            leaves.append('{self_name}.ll_str = {repr(_ll_str)}')
        _l4 = self.l4
        if _l4 is not None:
            leaves.append('{self_name}.l4 = {repr(_l4)}')
        _bar_l1 = self.bar_l1
        if _bar_l1 is not None:
            leaves.append('{self_name}.bar_l1 = {repr(_bar_l1)}')
        _l2 = self.l2
        if _l2 is not None:
            leaves.append('{self_name}.l2 = {repr(_l2)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /c1'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_foo__c1(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_f_l1 = yang.gdata.from_xml_opt_str(node, 'l1')
    yang.gdata.maybe_add(children, 'f:l1', from_xml_foo__c1__f_l1, child_f_l1)
    child_l3 = yang.gdata.from_xml_opt_int(node, 'l3')
    yang.gdata.maybe_add(children, 'l3', from_xml_foo__c1__l3, child_l3)
    child_l_empty = yang.gdata.from_xml_opt_empty(node, 'l_empty')
    yang.gdata.maybe_add(children, 'l_empty', from_xml_foo__c1__l_empty, child_l_empty)
    child_li = yang.gdata.from_xml_opt_list(node, 'li')
    yang.gdata.maybe_add(children, 'li', from_xml_foo__c1__li, child_li)
    child_ll_uint64 = yang.gdata.from_xml_opt_ints(node, 'll_uint64')
    yang.gdata.maybe_add(children, 'll_uint64', from_xml_foo__c1__ll_uint64, child_ll_uint64)
    child_ll_str = yang.gdata.from_xml_opt_strs(node, 'll_str')
    yang.gdata.maybe_add(children, 'll_str', from_xml_foo__c1__ll_str, child_ll_str)
    child_l4 = yang.gdata.from_xml_opt_str(node, 'l4')
    yang.gdata.maybe_add(children, 'l4', from_xml_foo__c1__l4, child_l4)
    child_bar_l1 = yang.gdata.from_xml_opt_str(node, 'l1', 'http://example.com/bar')
    yang.gdata.maybe_add(children, 'bar:l1', from_xml_foo__c1__bar_l1, child_bar_l1)
    child_l2 = yang.gdata.from_xml_opt_str(node, 'l2', 'http://example.com/bar')
    yang.gdata.maybe_add(children, 'l2', from_xml_foo__c1__l2, child_l2)
    return yang.gdata.Container(children, ns='http://example.com/foo', module='foo')

mut def from_json_path_foo__c1(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l1':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l_empty':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'li':
            child = {'li': from_json_path_foo__c1__li(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='http://example.com/foo', module='foo')
        if point == 'll_uint64':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'll_str':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l4':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'bar:l1':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'bar:l2':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__c1(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__c1(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_f_l1 = yang.gdata.take_json_opt_str(jd, 'l1')
    yang.gdata.maybe_add(children, 'f:l1', from_json_foo__c1__f_l1, child_f_l1)
    child_l3 = yang.gdata.take_json_opt_int64(jd, 'l3')
    yang.gdata.maybe_add(children, 'l3', from_json_foo__c1__l3, child_l3)
    child_l_empty = yang.gdata.take_json_opt_empty(jd, 'l_empty')
    yang.gdata.maybe_add(children, 'l_empty', from_json_foo__c1__l_empty, child_l_empty)
    child_li = yang.gdata.take_json_opt_list(jd, 'li')
    yang.gdata.maybe_add(children, 'li', from_json_foo__c1__li, child_li)
    child_ll_uint64 = yang.gdata.take_json_opt_int64s(jd, 'll_uint64')
    yang.gdata.maybe_add(children, 'll_uint64', from_json_foo__c1__ll_uint64, child_ll_uint64)
    child_ll_str = yang.gdata.take_json_opt_strs(jd, 'll_str')
    yang.gdata.maybe_add(children, 'll_str', from_json_foo__c1__ll_str, child_ll_str)
    child_l4 = yang.gdata.take_json_opt_str(jd, 'l4')
    yang.gdata.maybe_add(children, 'l4', from_json_foo__c1__l4, child_l4)
    child_bar_l1 = yang.gdata.take_json_opt_str(jd, 'l1', 'bar')
    yang.gdata.maybe_add(children, 'bar:l1', from_json_foo__c1__bar_l1, child_bar_l1)
    child_l2 = yang.gdata.take_json_opt_str(jd, 'l2', 'bar')
    yang.gdata.maybe_add(children, 'l2', from_json_foo__c1__l2, child_l2)
    return yang.gdata.Container(children, ns='http://example.com/foo', module='foo')

mut def from_json_foo__pc1__foo__l1(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('binary', val)

mut def from_xml_foo__pc1__foo__l1(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('binary', val)

class foo__pc1__foo(yang.adata.MNode):
    l1: list[bytes]

    mut def __init__(self, l1: ?list[bytes]=None):
        self._ns = 'http://example.com/foo'
        self.l1 = l1 if l1 is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        children['l1'] = yang.gdata.LeafList('binary', self.l1)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__pc1__foo:
        if n != None:
            return foo__pc1__foo(l1=n.get_opt_bytess('l1'))
        return foo__pc1__foo()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /pc1/foo')
            res.append('{self_name} = foo__pc1__foo()')
        leaves = []
        _l1 = self.l1
        if _l1 is not None:
            leaves.append('{self_name}.l1 = {repr(_l1)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /pc1/foo'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_foo__pc1__foo(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_l1 = yang.gdata.from_xml_opt_bytess(node, 'l1')
    yang.gdata.maybe_add(children, 'l1', from_xml_foo__pc1__foo__l1, child_l1)
    return yang.gdata.Container(children)

mut def from_json_path_foo__pc1__foo(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l1':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__pc1__foo(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__pc1__foo(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_l1 = yang.gdata.take_json_opt_bytess(jd, 'l1')
    yang.gdata.maybe_add(children, 'l1', from_json_foo__pc1__foo__l1, child_l1)
    return yang.gdata.Container(children)

class foo__pc1(yang.adata.MNode):
    foo: foo__pc1__foo

    mut def __init__(self, foo: ?foo__pc1__foo=None):
        self._ns = 'http://example.com/foo'
        self.foo = foo if foo is not None else foo__pc1__foo()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _foo = self.foo
        if _foo is not None:
            children['foo'] = _foo.to_gdata()
        return yang.gdata.Container(children, presence=True, ns='http://example.com/foo', module='foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?foo__pc1:
        if n != None:
            return foo__pc1(foo=foo__pc1__foo.from_gdata(n.get_opt_cnt('foo')))
        return None

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /pc1')
            res.append('{self_name} = foo__pc1()')
        leaves = []
        _foo = self.foo
        if _foo is not None:
            res.extend(_foo.prsrc('{self_name}.foo', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /pc1'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_foo__pc1(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_foo = yang.gdata.from_xml_opt_cnt(node, 'foo')
    yang.gdata.maybe_add(children, 'foo', from_xml_foo__pc1__foo, child_foo)
    return yang.gdata.Container(children, presence=True, ns='http://example.com/foo', module='foo')

mut def from_json_path_foo__pc1(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'foo':
            child = {'foo': from_json_path_foo__pc1__foo(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='http://example.com/foo', module='foo')
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__pc1(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__pc1(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_foo = yang.gdata.take_json_opt_cnt(jd, 'foo')
    yang.gdata.maybe_add(children, 'foo', from_json_foo__pc1__foo, child_foo)
    return yang.gdata.Container(children, presence=True, ns='http://example.com/foo', module='foo')

mut def from_json_foo__pc2__foo__l_mandatory(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__pc2__foo__l_mandatory(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class foo__pc2__foo(yang.adata.MNode):
    l_mandatory: ?str

    mut def __init__(self, l_mandatory: ?str):
        self._ns = 'http://example.com/foo'
        self.l_mandatory = l_mandatory

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _l_mandatory = self.l_mandatory
        if _l_mandatory is not None:
            children['l_mandatory'] = yang.gdata.Leaf('string', _l_mandatory)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__pc2__foo:
        if n != None:
            return foo__pc2__foo(l_mandatory=n.get_opt_str('l_mandatory'))
        raise ValueError('Missing required subtree foo__pc2__foo')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /pc2/foo')
            res.append('{self_name} = foo__pc2__foo()')
        leaves = []
        _l_mandatory = self.l_mandatory
        if _l_mandatory is not None:
            leaves.append('{self_name}.l_mandatory = {repr(_l_mandatory)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /pc2/foo'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_foo__pc2__foo(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_l_mandatory = yang.gdata.from_xml_opt_str(node, 'l_mandatory')
    yang.gdata.maybe_add(children, 'l_mandatory', from_xml_foo__pc2__foo__l_mandatory, child_l_mandatory)
    return yang.gdata.Container(children)

mut def from_json_path_foo__pc2__foo(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l_mandatory':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__pc2__foo(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__pc2__foo(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_l_mandatory = yang.gdata.take_json_opt_str(jd, 'l_mandatory')
    yang.gdata.maybe_add(children, 'l_mandatory', from_json_foo__pc2__foo__l_mandatory, child_l_mandatory)
    return yang.gdata.Container(children)

class foo__pc2(yang.adata.MNode):
    foo: foo__pc2__foo

    mut def __init__(self, foo: ?foo__pc2__foo=None):
        self._ns = 'http://example.com/foo'
        self.foo = foo if foo is not None else foo__pc2__foo()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _foo = self.foo
        if _foo is not None:
            children['foo'] = _foo.to_gdata()
        return yang.gdata.Container(children, presence=True, ns='http://example.com/foo', module='foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?foo__pc2:
        if n != None:
            return foo__pc2(foo=foo__pc2__foo.from_gdata(n.get_opt_cnt('foo')))
        return None

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /pc2')
            res.append('{self_name} = foo__pc2()')
        leaves = []
        _foo = self.foo
        if _foo is not None:
            res.extend(_foo.prsrc('{self_name}.foo', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /pc2'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_foo__pc2(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_foo = yang.gdata.from_xml_opt_cnt(node, 'foo')
    yang.gdata.maybe_add(children, 'foo', from_xml_foo__pc2__foo, child_foo)
    return yang.gdata.Container(children, presence=True, ns='http://example.com/foo', module='foo')

mut def from_json_path_foo__pc2(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'foo':
            child = {'foo': from_json_path_foo__pc2__foo(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='http://example.com/foo', module='foo')
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__pc2(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__pc2(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_foo = yang.gdata.take_json_opt_cnt(jd, 'foo')
    yang.gdata.maybe_add(children, 'foo', from_json_foo__pc2__foo, child_foo)
    return yang.gdata.Container(children, presence=True, ns='http://example.com/foo', module='foo')

mut def from_json_foo__pc3__level1__l1(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__pc3__level1__l1(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__pc3__level1__l1_optional(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__pc3__level1__l1_optional(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__pc3__level1__level2__l2(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__pc3__level1__level2__l2(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__pc3__level1__level2__l2_optional(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__pc3__level1__level2__l2_optional(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__pc3__level1__level2__level3__l3(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__pc3__level1__level2__level3__l3(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__pc3__level1__level2__level3__l3_optional(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__pc3__level1__level2__level3__l3_optional(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class foo__pc3__level1__level2__level3(yang.adata.MNode):
    l3: ?str
    l3_optional: ?str

    mut def __init__(self, l3: ?str, l3_optional: ?str):
        self._ns = 'http://example.com/foo'
        self.l3 = l3
        self.l3_optional = l3_optional

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _l3 = self.l3
        if _l3 is not None:
            children['l3'] = yang.gdata.Leaf('string', _l3)
        _l3_optional = self.l3_optional
        if _l3_optional is not None:
            children['l3-optional'] = yang.gdata.Leaf('string', _l3_optional)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__pc3__level1__level2__level3:
        if n != None:
            return foo__pc3__level1__level2__level3(l3=n.get_opt_str('l3'), l3_optional=n.get_opt_str('l3-optional'))
        raise ValueError('Missing required subtree foo__pc3__level1__level2__level3')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /pc3/level1/level2/level3')
            res.append('{self_name} = foo__pc3__level1__level2__level3()')
        leaves = []
        _l3 = self.l3
        if _l3 is not None:
            leaves.append('{self_name}.l3 = {repr(_l3)}')
        _l3_optional = self.l3_optional
        if _l3_optional is not None:
            leaves.append('{self_name}.l3_optional = {repr(_l3_optional)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /pc3/level1/level2/level3'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_foo__pc3__level1__level2__level3(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_l3 = yang.gdata.from_xml_opt_str(node, 'l3')
    yang.gdata.maybe_add(children, 'l3', from_xml_foo__pc3__level1__level2__level3__l3, child_l3)
    child_l3_optional = yang.gdata.from_xml_opt_str(node, 'l3-optional')
    yang.gdata.maybe_add(children, 'l3-optional', from_xml_foo__pc3__level1__level2__level3__l3_optional, child_l3_optional)
    return yang.gdata.Container(children)

mut def from_json_path_foo__pc3__level1__level2__level3(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l3-optional':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__pc3__level1__level2__level3(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__pc3__level1__level2__level3(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_l3 = yang.gdata.take_json_opt_str(jd, 'l3')
    yang.gdata.maybe_add(children, 'l3', from_json_foo__pc3__level1__level2__level3__l3, child_l3)
    child_l3_optional = yang.gdata.take_json_opt_str(jd, 'l3-optional')
    yang.gdata.maybe_add(children, 'l3-optional', from_json_foo__pc3__level1__level2__level3__l3_optional, child_l3_optional)
    return yang.gdata.Container(children)

class foo__pc3__level1__level2(yang.adata.MNode):
    l2: ?str
    l2_optional: ?str
    level3: foo__pc3__level1__level2__level3

    mut def __init__(self, l2: ?str, l2_optional: ?str, level3: ?foo__pc3__level1__level2__level3=None):
        self._ns = 'http://example.com/foo'
        self.l2 = l2
        self.l2_optional = l2_optional
        self.level3 = level3 if level3 is not None else foo__pc3__level1__level2__level3()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _l2 = self.l2
        if _l2 is not None:
            children['l2'] = yang.gdata.Leaf('string', _l2)
        _l2_optional = self.l2_optional
        if _l2_optional is not None:
            children['l2-optional'] = yang.gdata.Leaf('string', _l2_optional)
        _level3 = self.level3
        if _level3 is not None:
            children['level3'] = _level3.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__pc3__level1__level2:
        if n != None:
            return foo__pc3__level1__level2(l2=n.get_opt_str('l2'), l2_optional=n.get_opt_str('l2-optional'), level3=foo__pc3__level1__level2__level3.from_gdata(n.get_opt_cnt('level3')))
        raise ValueError('Missing required subtree foo__pc3__level1__level2')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /pc3/level1/level2')
            res.append('{self_name} = foo__pc3__level1__level2()')
        leaves = []
        _l2 = self.l2
        if _l2 is not None:
            leaves.append('{self_name}.l2 = {repr(_l2)}')
        _l2_optional = self.l2_optional
        if _l2_optional is not None:
            leaves.append('{self_name}.l2_optional = {repr(_l2_optional)}')
        _level3 = self.level3
        if _level3 is not None:
            res.extend(_level3.prsrc('{self_name}.level3', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /pc3/level1/level2'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_foo__pc3__level1__level2(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_l2 = yang.gdata.from_xml_opt_str(node, 'l2')
    yang.gdata.maybe_add(children, 'l2', from_xml_foo__pc3__level1__level2__l2, child_l2)
    child_l2_optional = yang.gdata.from_xml_opt_str(node, 'l2-optional')
    yang.gdata.maybe_add(children, 'l2-optional', from_xml_foo__pc3__level1__level2__l2_optional, child_l2_optional)
    child_level3 = yang.gdata.from_xml_opt_cnt(node, 'level3')
    yang.gdata.maybe_add(children, 'level3', from_xml_foo__pc3__level1__level2__level3, child_level3)
    return yang.gdata.Container(children)

mut def from_json_path_foo__pc3__level1__level2(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l2':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l2-optional':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'level3':
            child = {'level3': from_json_path_foo__pc3__level1__level2__level3(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__pc3__level1__level2(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__pc3__level1__level2(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_l2 = yang.gdata.take_json_opt_str(jd, 'l2')
    yang.gdata.maybe_add(children, 'l2', from_json_foo__pc3__level1__level2__l2, child_l2)
    child_l2_optional = yang.gdata.take_json_opt_str(jd, 'l2-optional')
    yang.gdata.maybe_add(children, 'l2-optional', from_json_foo__pc3__level1__level2__l2_optional, child_l2_optional)
    child_level3 = yang.gdata.take_json_opt_cnt(jd, 'level3')
    yang.gdata.maybe_add(children, 'level3', from_json_foo__pc3__level1__level2__level3, child_level3)
    return yang.gdata.Container(children)

class foo__pc3__level1(yang.adata.MNode):
    l1: ?str
    l1_optional: ?str
    level2: foo__pc3__level1__level2

    mut def __init__(self, l1: ?str, l1_optional: ?str, level2: ?foo__pc3__level1__level2=None):
        self._ns = 'http://example.com/foo'
        self.l1 = l1
        self.l1_optional = l1_optional
        self.level2 = level2 if level2 is not None else foo__pc3__level1__level2()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _l1 = self.l1
        if _l1 is not None:
            children['l1'] = yang.gdata.Leaf('string', _l1)
        _l1_optional = self.l1_optional
        if _l1_optional is not None:
            children['l1-optional'] = yang.gdata.Leaf('string', _l1_optional)
        _level2 = self.level2
        if _level2 is not None:
            children['level2'] = _level2.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__pc3__level1:
        if n != None:
            return foo__pc3__level1(l1=n.get_opt_str('l1'), l1_optional=n.get_opt_str('l1-optional'), level2=foo__pc3__level1__level2.from_gdata(n.get_opt_cnt('level2')))
        raise ValueError('Missing required subtree foo__pc3__level1')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /pc3/level1')
            res.append('{self_name} = foo__pc3__level1()')
        leaves = []
        _l1 = self.l1
        if _l1 is not None:
            leaves.append('{self_name}.l1 = {repr(_l1)}')
        _l1_optional = self.l1_optional
        if _l1_optional is not None:
            leaves.append('{self_name}.l1_optional = {repr(_l1_optional)}')
        _level2 = self.level2
        if _level2 is not None:
            res.extend(_level2.prsrc('{self_name}.level2', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /pc3/level1'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_foo__pc3__level1(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_l1 = yang.gdata.from_xml_opt_str(node, 'l1')
    yang.gdata.maybe_add(children, 'l1', from_xml_foo__pc3__level1__l1, child_l1)
    child_l1_optional = yang.gdata.from_xml_opt_str(node, 'l1-optional')
    yang.gdata.maybe_add(children, 'l1-optional', from_xml_foo__pc3__level1__l1_optional, child_l1_optional)
    child_level2 = yang.gdata.from_xml_opt_cnt(node, 'level2')
    yang.gdata.maybe_add(children, 'level2', from_xml_foo__pc3__level1__level2, child_level2)
    return yang.gdata.Container(children)

mut def from_json_path_foo__pc3__level1(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l1':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l1-optional':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'level2':
            child = {'level2': from_json_path_foo__pc3__level1__level2(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__pc3__level1(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__pc3__level1(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_l1 = yang.gdata.take_json_opt_str(jd, 'l1')
    yang.gdata.maybe_add(children, 'l1', from_json_foo__pc3__level1__l1, child_l1)
    child_l1_optional = yang.gdata.take_json_opt_str(jd, 'l1-optional')
    yang.gdata.maybe_add(children, 'l1-optional', from_json_foo__pc3__level1__l1_optional, child_l1_optional)
    child_level2 = yang.gdata.take_json_opt_cnt(jd, 'level2')
    yang.gdata.maybe_add(children, 'level2', from_json_foo__pc3__level1__level2, child_level2)
    return yang.gdata.Container(children)

class foo__pc3(yang.adata.MNode):
    level1: foo__pc3__level1

    mut def __init__(self, level1: ?foo__pc3__level1=None):
        self._ns = 'http://example.com/foo'
        self.level1 = level1 if level1 is not None else foo__pc3__level1()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _level1 = self.level1
        if _level1 is not None:
            children['level1'] = _level1.to_gdata()
        return yang.gdata.Container(children, presence=True, ns='http://example.com/foo', module='foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?foo__pc3:
        if n != None:
            return foo__pc3(level1=foo__pc3__level1.from_gdata(n.get_opt_cnt('level1')))
        return None

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /pc3')
            res.append('{self_name} = foo__pc3()')
        leaves = []
        _level1 = self.level1
        if _level1 is not None:
            res.extend(_level1.prsrc('{self_name}.level1', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /pc3'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_foo__pc3(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_level1 = yang.gdata.from_xml_opt_cnt(node, 'level1')
    yang.gdata.maybe_add(children, 'level1', from_xml_foo__pc3__level1, child_level1)
    return yang.gdata.Container(children, presence=True, ns='http://example.com/foo', module='foo')

mut def from_json_path_foo__pc3(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'level1':
            child = {'level1': from_json_path_foo__pc3__level1(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='http://example.com/foo', module='foo')
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__pc3(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__pc3(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_level1 = yang.gdata.take_json_opt_cnt(jd, 'level1')
    yang.gdata.maybe_add(children, 'level1', from_json_foo__pc3__level1, child_level1)
    return yang.gdata.Container(children, presence=True, ns='http://example.com/foo', module='foo')

class foo__empty_presence(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://example.com/foo'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True, ns='http://example.com/foo', module='foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?foo__empty_presence:
        if n != None:
            return foo__empty_presence()
        return None

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /empty-presence')
            res.append('{self_name} = foo__empty_presence()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /empty-presence'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_foo__empty_presence(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True, ns='http://example.com/foo', module='foo')

mut def from_json_path_foo__empty_presence(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__empty_presence(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__empty_presence(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True, ns='http://example.com/foo', module='foo')

mut def from_json_foo__c_dot__l_dot1(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__c_dot__l_dot1(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__c_dot__l_dot2(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val, ns='http://example.com/bar', module='bar')

mut def from_xml_foo__c_dot__l_dot2(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val, ns='http://example.com/bar', module='bar')

class foo__c_dot(yang.adata.MNode):
    l_dot1: ?str
    l_dot2: ?str

    mut def __init__(self, l_dot1: ?str, l_dot2: ?str):
        self._ns = 'http://example.com/foo'
        self.l_dot1 = l_dot1
        self.l_dot2 = l_dot2

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _l_dot1 = self.l_dot1
        if _l_dot1 is not None:
            children['l.dot1'] = yang.gdata.Leaf('string', _l_dot1)
        _l_dot2 = self.l_dot2
        if _l_dot2 is not None:
            children['l.dot2'] = yang.gdata.Leaf('string', _l_dot2, ns='http://example.com/bar', module='bar')
        return yang.gdata.Container(children, ns='http://example.com/foo', module='foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__c_dot:
        if n != None:
            return foo__c_dot(l_dot1=n.get_opt_str('l.dot1'), l_dot2=n.get_opt_str('l.dot2'))
        return foo__c_dot()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /c.dot')
            res.append('{self_name} = foo__c_dot()')
        leaves = []
        _l_dot1 = self.l_dot1
        if _l_dot1 is not None:
            leaves.append('{self_name}.l_dot1 = {repr(_l_dot1)}')
        _l_dot2 = self.l_dot2
        if _l_dot2 is not None:
            leaves.append('{self_name}.l_dot2 = {repr(_l_dot2)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /c.dot'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_foo__c_dot(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_l_dot1 = yang.gdata.from_xml_opt_str(node, 'l.dot1')
    yang.gdata.maybe_add(children, 'l.dot1', from_xml_foo__c_dot__l_dot1, child_l_dot1)
    child_l_dot2 = yang.gdata.from_xml_opt_str(node, 'l.dot2', 'http://example.com/bar')
    yang.gdata.maybe_add(children, 'l.dot2', from_xml_foo__c_dot__l_dot2, child_l_dot2)
    return yang.gdata.Container(children, ns='http://example.com/foo', module='foo')

mut def from_json_path_foo__c_dot(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l.dot1':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'bar:l.dot2':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__c_dot(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__c_dot(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_l_dot1 = yang.gdata.take_json_opt_str(jd, 'l.dot1')
    yang.gdata.maybe_add(children, 'l.dot1', from_json_foo__c_dot__l_dot1, child_l_dot1)
    child_l_dot2 = yang.gdata.take_json_opt_str(jd, 'l.dot2', 'bar')
    yang.gdata.maybe_add(children, 'l.dot2', from_json_foo__c_dot__l_dot2, child_l_dot2)
    return yang.gdata.Container(children, ns='http://example.com/foo', module='foo')

mut def from_json_foo__cc__cake(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__cc__cake(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__cc__death__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__cc__death__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class foo__cc__death_entry(yang.adata.MNode):
    name: str

    mut def __init__(self, name: str):
        self._ns = 'http://example.com/foo'
        self.name = name

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> foo__cc__death_entry:
        return foo__cc__death_entry(name=n.get_str('name'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /cc/death')
            res.append('{self_name} = foo__cc__death({repr(self.name)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /cc/death'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class foo__cc__death(yang.adata.MNode):
    elements: list[foo__cc__death_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/foo'
        self._name = 'death'
        self.elements = elements

    mut def create(self, name):
        for e in self.elements:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = foo__cc__death_entry(name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[foo__cc__death_entry]:
        if n is not None:
            return [foo__cc__death_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_foo__cc__death_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.from_xml_str(node, 'name')
    yang.gdata.maybe_add(children, 'name', from_xml_foo__cc__death__name, child_name)
    return yang.gdata.Container(children)

mut def from_xml_foo__cc__death(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_foo__cc__death_element(e) for e in nodes]
    return yang.gdata.List(keys=['name'], elements=elements)

mut def from_json_path_foo__cc__death_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_foo__cc__death_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['name']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['name'] = from_json_foo__cc__death__name(keys[0])
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_foo__cc__death(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_foo__cc__death_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['name'])))
        return yang.gdata.List(['name'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['name'], [from_json_path_foo__cc__death_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_foo__cc__death_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.take_json_str(jd, 'name')
    yang.gdata.maybe_add(children, 'name', from_json_foo__cc__death__name, child_name)
    return yang.gdata.Container(children)

mut def from_json_foo__cc__death(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_foo__cc__death_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['name'], elements=elements)

class foo__cc(yang.adata.MNode):
    cake: ?str
    death: foo__cc__death

    mut def __init__(self, cake: ?str, death: list[foo__cc__death_entry]=[]):
        self._ns = 'http://example.com/foo'
        self.cake = cake
        self.death = foo__cc__death(elements=death)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _cake = self.cake
        if _cake is not None:
            children['cake'] = yang.gdata.Leaf('string', _cake)
        _death = self.death
        if _death is not None:
            children['death'] = _death.to_gdata()
        return yang.gdata.Container(children, ns='http://example.com/foo', module='foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__cc:
        if n != None:
            return foo__cc(cake=n.get_opt_str('cake'), death=foo__cc__death.from_gdata(n.get_opt_list('death')))
        return foo__cc()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /cc')
            res.append('{self_name} = foo__cc()')
        leaves = []
        _cake = self.cake
        if _cake is not None:
            leaves.append('{self_name}.cake = {repr(_cake)}')
        _death = self.death
        for _element in _death.elements:
            res.append('')
            res.append("# List /cc/death element: {_element.to_gdata().key_str(['name'])}")
            list_elem = 'death_element = {self_name}.death.create({repr(_element.name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('death_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /cc'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_foo__cc(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_cake = yang.gdata.from_xml_opt_str(node, 'cake')
    yang.gdata.maybe_add(children, 'cake', from_xml_foo__cc__cake, child_cake)
    child_death = yang.gdata.from_xml_opt_list(node, 'death')
    yang.gdata.maybe_add(children, 'death', from_xml_foo__cc__death, child_death)
    return yang.gdata.Container(children, ns='http://example.com/foo', module='foo')

mut def from_json_path_foo__cc(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'cake':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'death':
            child = {'death': from_json_path_foo__cc__death(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='http://example.com/foo', module='foo')
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__cc(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__cc(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_cake = yang.gdata.take_json_opt_str(jd, 'cake')
    yang.gdata.maybe_add(children, 'cake', from_json_foo__cc__cake, child_cake)
    child_death = yang.gdata.take_json_opt_list(jd, 'death')
    yang.gdata.maybe_add(children, 'death', from_json_foo__cc__death, child_death)
    return yang.gdata.Container(children, ns='http://example.com/foo', module='foo')

mut def from_json_foo__conflict__f_foo(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__conflict__f_foo(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class foo__conflict__f_inner(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://example.com/foo'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?foo__conflict__f_inner:
        if n != None:
            return foo__conflict__f_inner()
        return None

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /conflict/f:inner')
            res.append('{self_name} = foo__conflict__f_inner()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /conflict/f:inner'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_foo__conflict__f_inner(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

mut def from_json_path_foo__conflict__f_inner(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__conflict__f_inner(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__conflict__f_inner(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

mut def from_json_foo__conflict__bar_foo(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val, ns='http://example.com/bar', module='bar')

mut def from_xml_foo__conflict__bar_foo(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val, ns='http://example.com/bar', module='bar')

class foo__conflict__bar_inner(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://example.com/bar'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True, ns='http://example.com/bar', module='bar')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?foo__conflict__bar_inner:
        if n != None:
            return foo__conflict__bar_inner()
        return None

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /conflict/bar:inner')
            res.append('{self_name} = foo__conflict__bar_inner()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /conflict/bar:inner'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_foo__conflict__bar_inner(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True, ns='http://example.com/bar', module='bar')

mut def from_json_path_foo__conflict__bar_inner(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__conflict__bar_inner(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__conflict__bar_inner(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True, ns='http://example.com/bar', module='bar')

class foo__conflict(yang.adata.MNode):
    f_foo: ?str
    f_inner: ?foo__conflict__f_inner
    bar_foo: ?str
    bar_inner: ?foo__conflict__bar_inner

    mut def __init__(self, f_foo: ?str, f_inner: ?foo__conflict__f_inner=None, bar_foo: ?str, bar_inner: ?foo__conflict__bar_inner=None):
        self._ns = 'http://example.com/foo'
        self.f_foo = f_foo
        self.f_inner = f_inner
        self.bar_foo = bar_foo
        self.bar_inner = bar_inner

    mut def create_f_inner(self):
        res = foo__conflict__f_inner()
        self.f_inner = res
        return res

    mut def create_bar_inner(self):
        res = foo__conflict__bar_inner()
        self.bar_inner = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _f_foo = self.f_foo
        if _f_foo is not None:
            children['f:foo'] = yang.gdata.Leaf('string', _f_foo)
        _f_inner = self.f_inner
        if _f_inner is not None:
            children['f:inner'] = _f_inner.to_gdata()
        _bar_foo = self.bar_foo
        if _bar_foo is not None:
            children['bar:foo'] = yang.gdata.Leaf('string', _bar_foo, ns='http://example.com/bar', module='bar')
        _bar_inner = self.bar_inner
        if _bar_inner is not None:
            children['bar:inner'] = _bar_inner.to_gdata()
        return yang.gdata.Container(children, ns='http://example.com/foo', module='foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__conflict:
        if n != None:
            return foo__conflict(f_foo=n.get_opt_str('f:foo'), f_inner=foo__conflict__f_inner.from_gdata(n.get_opt_cnt('f:inner')), bar_foo=n.get_opt_str('bar:foo'), bar_inner=foo__conflict__bar_inner.from_gdata(n.get_opt_cnt('bar:inner')))
        return foo__conflict()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /conflict')
            res.append('{self_name} = foo__conflict()')
        leaves = []
        _f_foo = self.f_foo
        if _f_foo is not None:
            leaves.append('{self_name}.f_foo = {repr(_f_foo)}')
        _f_inner = self.f_inner
        if _f_inner is not None:
            res.append('')
            res.append('# P-container: /conflict/f:inner')
            res.append('inner = {self_name}.create_f_inner()')
            res.extend(_f_inner.prsrc('f_inner', False).splitlines())
        _bar_foo = self.bar_foo
        if _bar_foo is not None:
            leaves.append('{self_name}.bar_foo = {repr(_bar_foo)}')
        _bar_inner = self.bar_inner
        if _bar_inner is not None:
            res.append('')
            res.append('# P-container: /conflict/bar:inner')
            res.append('inner = {self_name}.create_bar_inner()')
            res.extend(_bar_inner.prsrc('bar_inner', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /conflict'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_foo__conflict(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_f_foo = yang.gdata.from_xml_opt_str(node, 'foo')
    yang.gdata.maybe_add(children, 'f:foo', from_xml_foo__conflict__f_foo, child_f_foo)
    child_f_inner = yang.gdata.from_xml_opt_cnt(node, 'inner')
    yang.gdata.maybe_add(children, 'f:inner', from_xml_foo__conflict__f_inner, child_f_inner)
    child_bar_foo = yang.gdata.from_xml_opt_str(node, 'foo', 'http://example.com/bar')
    yang.gdata.maybe_add(children, 'bar:foo', from_xml_foo__conflict__bar_foo, child_bar_foo)
    child_bar_inner = yang.gdata.from_xml_opt_cnt(node, 'inner', 'http://example.com/bar')
    yang.gdata.maybe_add(children, 'bar:inner', from_xml_foo__conflict__bar_inner, child_bar_inner)
    return yang.gdata.Container(children, ns='http://example.com/foo', module='foo')

mut def from_json_path_foo__conflict(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'foo':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'inner':
            child = {'f:inner': from_json_path_foo__conflict__f_inner(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='http://example.com/foo', module='foo')
        if point == 'bar:foo':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'bar:inner':
            child = {'bar:inner': from_json_path_foo__conflict__bar_inner(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='http://example.com/foo', module='foo')
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__conflict(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__conflict(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_f_foo = yang.gdata.take_json_opt_str(jd, 'foo')
    yang.gdata.maybe_add(children, 'f:foo', from_json_foo__conflict__f_foo, child_f_foo)
    child_f_inner = yang.gdata.take_json_opt_cnt(jd, 'inner')
    yang.gdata.maybe_add(children, 'f:inner', from_json_foo__conflict__f_inner, child_f_inner)
    child_bar_foo = yang.gdata.take_json_opt_str(jd, 'foo', 'bar')
    yang.gdata.maybe_add(children, 'bar:foo', from_json_foo__conflict__bar_foo, child_bar_foo)
    child_bar_inner = yang.gdata.take_json_opt_cnt(jd, 'inner', 'bar')
    yang.gdata.maybe_add(children, 'bar:inner', from_json_foo__conflict__bar_inner, child_bar_inner)
    return yang.gdata.Container(children, ns='http://example.com/foo', module='foo')

mut def from_json_foo__special__yes(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_foo__special__yes(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class foo__special_entry(yang.adata.MNode):
    yes: bool

    mut def __init__(self, yes: bool):
        self._ns = 'http://example.com/foo'
        self.yes = yes

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _yes = self.yes
        if _yes is not None:
            children['yes'] = yang.gdata.Leaf('boolean', _yes)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> foo__special_entry:
        return foo__special_entry(yes=n.get_bool('yes'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /special')
            res.append('{self_name} = foo__special({repr(self.yes)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /special'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class foo__special(yang.adata.MNode):
    elements: list[foo__special_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/foo'
        self._name = 'special'
        self.elements = elements

    mut def create(self, yes):
        for e in self.elements:
            match = True
            if e.yes != yes:
                match = False
                continue
            if match:
                return e

        res = foo__special_entry(yes)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['yes'], elements, ns='http://example.com/foo', module='foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[foo__special_entry]:
        if n is not None:
            return [foo__special_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_foo__special_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_yes = yang.gdata.from_xml_bool(node, 'yes')
    yang.gdata.maybe_add(children, 'yes', from_xml_foo__special__yes, child_yes)
    return yang.gdata.Container(children)

mut def from_xml_foo__special(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_foo__special_element(e) for e in nodes]
    return yang.gdata.List(keys=['yes'], elements=elements, ns='http://example.com/foo', module='foo')

mut def from_json_path_foo__special_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_foo__special_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['yes']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['yes'] = from_json_foo__special__yes(keys[0])
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_foo__special(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['yes']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_foo__special_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['yes'])))
        return yang.gdata.List(['yes'], elements, ns='http://example.com/foo', module='foo')
    elif len(path) > 1:
        return yang.gdata.List(['yes'], [from_json_path_foo__special_element(jd, path, op)], ns='http://example.com/foo', module='foo')
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_foo__special_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_yes = yang.gdata.take_json_bool(jd, 'yes')
    yang.gdata.maybe_add(children, 'yes', from_json_foo__special__yes, child_yes)
    return yang.gdata.Container(children)

mut def from_json_foo__special(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_foo__special_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['yes'], elements=elements, ns='http://example.com/foo', module='foo')

mut def from_json_foo__nested__f_inner__foo(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__nested__f_inner__foo(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__nested__f_inner__li1__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__nested__f_inner__li1__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__nested__f_inner__li1__f_bar(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__nested__f_inner__li1__f_bar(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__nested__f_inner__li1__li2__key1(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__nested__f_inner__li1__li2__key1(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__nested__f_inner__li1__li2__key2(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__nested__f_inner__li1__li2__key2(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__nested__f_inner__li1__li2__baz(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__nested__f_inner__li1__li2__baz(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class foo__nested__f_inner__li1__li2_entry(yang.adata.MNode):
    key1: str
    key2: str
    baz: ?str

    mut def __init__(self, key1: str, key2: str, baz: ?str):
        self._ns = 'http://example.com/foo'
        self.key1 = key1
        self.key2 = key2
        self.baz = baz

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _key1 = self.key1
        if _key1 is not None:
            children['key1'] = yang.gdata.Leaf('string', _key1)
        _key2 = self.key2
        if _key2 is not None:
            children['key2'] = yang.gdata.Leaf('string', _key2)
        _baz = self.baz
        if _baz is not None:
            children['baz'] = yang.gdata.Leaf('string', _baz)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> foo__nested__f_inner__li1__li2_entry:
        return foo__nested__f_inner__li1__li2_entry(key1=n.get_str('key1'), key2=n.get_str('key2'), baz=n.get_opt_str('baz'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /nested/f:inner/li1/li2')
            res.append('{self_name} = foo__nested__f_inner__li1__li2({repr(self.key1)}, {repr(self.key2)})')
        leaves = []
        _baz = self.baz
        if _baz is not None:
            leaves.append('{self_name}.baz = {repr(_baz)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /nested/f:inner/li1/li2'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class foo__nested__f_inner__li1__li2(yang.adata.MNode):
    elements: list[foo__nested__f_inner__li1__li2_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/foo'
        self._name = 'li2'
        self.elements = elements

    mut def create(self, key1, key2):
        for e in self.elements:
            match = True
            if e.key1 != key1:
                match = False
                continue
            if e.key2 != key2:
                match = False
                continue
            if match:
                return e

        res = foo__nested__f_inner__li1__li2_entry(key1, key2)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['key1', 'key2'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[foo__nested__f_inner__li1__li2_entry]:
        if n is not None:
            return [foo__nested__f_inner__li1__li2_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_foo__nested__f_inner__li1__li2_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_key1 = yang.gdata.from_xml_str(node, 'key1')
    yang.gdata.maybe_add(children, 'key1', from_xml_foo__nested__f_inner__li1__li2__key1, child_key1)
    child_key2 = yang.gdata.from_xml_str(node, 'key2')
    yang.gdata.maybe_add(children, 'key2', from_xml_foo__nested__f_inner__li1__li2__key2, child_key2)
    child_baz = yang.gdata.from_xml_opt_str(node, 'baz')
    yang.gdata.maybe_add(children, 'baz', from_xml_foo__nested__f_inner__li1__li2__baz, child_baz)
    return yang.gdata.Container(children)

mut def from_xml_foo__nested__f_inner__li1__li2(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_foo__nested__f_inner__li1__li2_element(e) for e in nodes]
    return yang.gdata.List(keys=['key1', 'key2'], elements=elements)

mut def from_json_path_foo__nested__f_inner__li1__li2_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_foo__nested__f_inner__li1__li2_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['key1', 'key2']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['key1'] = from_json_foo__nested__f_inner__li1__li2__key1(keys[0])
        children['key2'] = from_json_foo__nested__f_inner__li1__li2__key2(keys[1])
        if point == 'baz':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_foo__nested__f_inner__li1__li2(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['key1', 'key2']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_foo__nested__f_inner__li1__li2_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['key1', 'key2'])))
        return yang.gdata.List(['key1', 'key2'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['key1', 'key2'], [from_json_path_foo__nested__f_inner__li1__li2_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_foo__nested__f_inner__li1__li2_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_key1 = yang.gdata.take_json_str(jd, 'key1')
    yang.gdata.maybe_add(children, 'key1', from_json_foo__nested__f_inner__li1__li2__key1, child_key1)
    child_key2 = yang.gdata.take_json_str(jd, 'key2')
    yang.gdata.maybe_add(children, 'key2', from_json_foo__nested__f_inner__li1__li2__key2, child_key2)
    child_baz = yang.gdata.take_json_opt_str(jd, 'baz')
    yang.gdata.maybe_add(children, 'baz', from_json_foo__nested__f_inner__li1__li2__baz, child_baz)
    return yang.gdata.Container(children)

mut def from_json_foo__nested__f_inner__li1__li2(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_foo__nested__f_inner__li1__li2_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['key1', 'key2'], elements=elements)

mut def from_json_foo__nested__f_inner__li1__bar_bar(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val, ns='http://example.com/bar', module='bar')

mut def from_xml_foo__nested__f_inner__li1__bar_bar(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val, ns='http://example.com/bar', module='bar')

class foo__nested__f_inner__li1_entry(yang.adata.MNode):
    name: str
    f_bar: ?str
    li2: foo__nested__f_inner__li1__li2
    bar_bar: ?str

    mut def __init__(self, name: str, f_bar: ?str, li2: list[foo__nested__f_inner__li1__li2_entry]=[], bar_bar: ?str):
        self._ns = 'http://example.com/foo'
        self.name = name
        self.f_bar = f_bar
        self.li2 = foo__nested__f_inner__li1__li2(elements=li2)
        self.bar_bar = bar_bar

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        _f_bar = self.f_bar
        if _f_bar is not None:
            children['f:bar'] = yang.gdata.Leaf('string', _f_bar)
        _li2 = self.li2
        if _li2 is not None:
            children['li2'] = _li2.to_gdata()
        _bar_bar = self.bar_bar
        if _bar_bar is not None:
            children['bar:bar'] = yang.gdata.Leaf('string', _bar_bar, ns='http://example.com/bar', module='bar')
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> foo__nested__f_inner__li1_entry:
        return foo__nested__f_inner__li1_entry(name=n.get_str('name'), f_bar=n.get_opt_str('f:bar'), li2=foo__nested__f_inner__li1__li2.from_gdata(n.get_opt_list('li2')), bar_bar=n.get_opt_str('bar:bar'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /nested/f:inner/li1')
            res.append('{self_name} = foo__nested__f_inner__li1({repr(self.name)})')
        leaves = []
        _f_bar = self.f_bar
        if _f_bar is not None:
            leaves.append('{self_name}.f_bar = {repr(_f_bar)}')
        _li2 = self.li2
        for _element in _li2.elements:
            res.append('')
            res.append("# List /nested/f:inner/li1/li2 element: {_element.to_gdata().key_str(['key1', 'key2'])}")
            list_elem = 'li2_element = {self_name}.li2.create({repr(_element.key1)}, {repr(_element.key2)})'
            res.append(list_elem)
            res.extend(_element.prsrc('li2_element', False, list_element=True).splitlines())
        _bar_bar = self.bar_bar
        if _bar_bar is not None:
            leaves.append('{self_name}.bar_bar = {repr(_bar_bar)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /nested/f:inner/li1'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class foo__nested__f_inner__li1(yang.adata.MNode):
    elements: list[foo__nested__f_inner__li1_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/foo'
        self._name = 'li1'
        self.elements = elements

    mut def create(self, name):
        for e in self.elements:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = foo__nested__f_inner__li1_entry(name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[foo__nested__f_inner__li1_entry]:
        if n is not None:
            return [foo__nested__f_inner__li1_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_foo__nested__f_inner__li1_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.from_xml_str(node, 'name')
    yang.gdata.maybe_add(children, 'name', from_xml_foo__nested__f_inner__li1__name, child_name)
    child_f_bar = yang.gdata.from_xml_opt_str(node, 'bar')
    yang.gdata.maybe_add(children, 'f:bar', from_xml_foo__nested__f_inner__li1__f_bar, child_f_bar)
    child_li2 = yang.gdata.from_xml_opt_list(node, 'li2')
    yang.gdata.maybe_add(children, 'li2', from_xml_foo__nested__f_inner__li1__li2, child_li2)
    child_bar_bar = yang.gdata.from_xml_opt_str(node, 'bar', 'http://example.com/bar')
    yang.gdata.maybe_add(children, 'bar:bar', from_xml_foo__nested__f_inner__li1__bar_bar, child_bar_bar)
    return yang.gdata.Container(children)

mut def from_xml_foo__nested__f_inner__li1(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_foo__nested__f_inner__li1_element(e) for e in nodes]
    return yang.gdata.List(keys=['name'], elements=elements)

mut def from_json_path_foo__nested__f_inner__li1_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_foo__nested__f_inner__li1_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['name']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['name'] = from_json_foo__nested__f_inner__li1__name(keys[0])
        if point == 'bar':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'li2':
            children['li2'] = from_json_path_foo__nested__f_inner__li1__li2(jd, rest_path, op)
        if point == 'bar:bar':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_foo__nested__f_inner__li1(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_foo__nested__f_inner__li1_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['name'])))
        return yang.gdata.List(['name'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['name'], [from_json_path_foo__nested__f_inner__li1_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_foo__nested__f_inner__li1_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.take_json_str(jd, 'name')
    yang.gdata.maybe_add(children, 'name', from_json_foo__nested__f_inner__li1__name, child_name)
    child_f_bar = yang.gdata.take_json_opt_str(jd, 'bar')
    yang.gdata.maybe_add(children, 'f:bar', from_json_foo__nested__f_inner__li1__f_bar, child_f_bar)
    child_li2 = yang.gdata.take_json_opt_list(jd, 'li2')
    yang.gdata.maybe_add(children, 'li2', from_json_foo__nested__f_inner__li1__li2, child_li2)
    child_bar_bar = yang.gdata.take_json_opt_str(jd, 'bar', 'bar')
    yang.gdata.maybe_add(children, 'bar:bar', from_json_foo__nested__f_inner__li1__bar_bar, child_bar_bar)
    return yang.gdata.Container(children)

mut def from_json_foo__nested__f_inner__li1(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_foo__nested__f_inner__li1_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['name'], elements=elements)

class foo__nested__f_inner(yang.adata.MNode):
    foo: ?str
    li1: foo__nested__f_inner__li1

    mut def __init__(self, foo: ?str, li1: list[foo__nested__f_inner__li1_entry]=[]):
        self._ns = 'http://example.com/foo'
        self.foo = foo
        self.li1 = foo__nested__f_inner__li1(elements=li1)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _foo = self.foo
        if _foo is not None:
            children['foo'] = yang.gdata.Leaf('string', _foo)
        _li1 = self.li1
        if _li1 is not None:
            children['li1'] = _li1.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__nested__f_inner:
        if n != None:
            return foo__nested__f_inner(foo=n.get_opt_str('foo'), li1=foo__nested__f_inner__li1.from_gdata(n.get_opt_list('li1')))
        return foo__nested__f_inner()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /nested/f:inner')
            res.append('{self_name} = foo__nested__f_inner()')
        leaves = []
        _foo = self.foo
        if _foo is not None:
            leaves.append('{self_name}.foo = {repr(_foo)}')
        _li1 = self.li1
        for _element in _li1.elements:
            res.append('')
            res.append("# List /nested/f:inner/li1 element: {_element.to_gdata().key_str(['name'])}")
            list_elem = 'li1_element = {self_name}.li1.create({repr(_element.name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('li1_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /nested/f:inner'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_foo__nested__f_inner(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_foo = yang.gdata.from_xml_opt_str(node, 'foo')
    yang.gdata.maybe_add(children, 'foo', from_xml_foo__nested__f_inner__foo, child_foo)
    child_li1 = yang.gdata.from_xml_opt_list(node, 'li1')
    yang.gdata.maybe_add(children, 'li1', from_xml_foo__nested__f_inner__li1, child_li1)
    return yang.gdata.Container(children)

mut def from_json_path_foo__nested__f_inner(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'foo':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'li1':
            child = {'li1': from_json_path_foo__nested__f_inner__li1(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__nested__f_inner(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__nested__f_inner(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_foo = yang.gdata.take_json_opt_str(jd, 'foo')
    yang.gdata.maybe_add(children, 'foo', from_json_foo__nested__f_inner__foo, child_foo)
    child_li1 = yang.gdata.take_json_opt_list(jd, 'li1')
    yang.gdata.maybe_add(children, 'li1', from_json_foo__nested__f_inner__li1, child_li1)
    return yang.gdata.Container(children)

mut def from_json_foo__nested__bar_inner__foo(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__nested__bar_inner__foo(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class foo__nested__bar_inner(yang.adata.MNode):
    foo: ?str

    mut def __init__(self, foo: ?str):
        self._ns = 'http://example.com/bar'
        self.foo = foo

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _foo = self.foo
        if _foo is not None:
            children['foo'] = yang.gdata.Leaf('string', _foo)
        return yang.gdata.Container(children, ns='http://example.com/bar', module='bar')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__nested__bar_inner:
        if n != None:
            return foo__nested__bar_inner(foo=n.get_opt_str('foo'))
        return foo__nested__bar_inner()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /nested/bar:inner')
            res.append('{self_name} = foo__nested__bar_inner()')
        leaves = []
        _foo = self.foo
        if _foo is not None:
            leaves.append('{self_name}.foo = {repr(_foo)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /nested/bar:inner'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_foo__nested__bar_inner(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_foo = yang.gdata.from_xml_opt_str(node, 'foo')
    yang.gdata.maybe_add(children, 'foo', from_xml_foo__nested__bar_inner__foo, child_foo)
    return yang.gdata.Container(children, ns='http://example.com/bar', module='bar')

mut def from_json_path_foo__nested__bar_inner(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'foo':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__nested__bar_inner(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__nested__bar_inner(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_foo = yang.gdata.take_json_opt_str(jd, 'foo')
    yang.gdata.maybe_add(children, 'foo', from_json_foo__nested__bar_inner__foo, child_foo)
    return yang.gdata.Container(children, ns='http://example.com/bar', module='bar')

class foo__nested(yang.adata.MNode):
    f_inner: foo__nested__f_inner
    bar_inner: foo__nested__bar_inner

    mut def __init__(self, f_inner: ?foo__nested__f_inner=None, bar_inner: ?foo__nested__bar_inner=None):
        self._ns = 'http://example.com/foo'
        self.f_inner = f_inner if f_inner is not None else foo__nested__f_inner()
        self.bar_inner = bar_inner if bar_inner is not None else foo__nested__bar_inner()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _f_inner = self.f_inner
        if _f_inner is not None:
            children['f:inner'] = _f_inner.to_gdata()
        _bar_inner = self.bar_inner
        if _bar_inner is not None:
            children['bar:inner'] = _bar_inner.to_gdata()
        return yang.gdata.Container(children, ns='http://example.com/foo', module='foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__nested:
        if n != None:
            return foo__nested(f_inner=foo__nested__f_inner.from_gdata(n.get_opt_cnt('f:inner')), bar_inner=foo__nested__bar_inner.from_gdata(n.get_opt_cnt('bar:inner')))
        return foo__nested()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /nested')
            res.append('{self_name} = foo__nested()')
        leaves = []
        _f_inner = self.f_inner
        if _f_inner is not None:
            res.extend(_f_inner.prsrc('{self_name}.f_inner', False).splitlines())
        _bar_inner = self.bar_inner
        if _bar_inner is not None:
            res.extend(_bar_inner.prsrc('{self_name}.bar_inner', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /nested'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_foo__nested(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_f_inner = yang.gdata.from_xml_opt_cnt(node, 'inner')
    yang.gdata.maybe_add(children, 'f:inner', from_xml_foo__nested__f_inner, child_f_inner)
    child_bar_inner = yang.gdata.from_xml_opt_cnt(node, 'inner', 'http://example.com/bar')
    yang.gdata.maybe_add(children, 'bar:inner', from_xml_foo__nested__bar_inner, child_bar_inner)
    return yang.gdata.Container(children, ns='http://example.com/foo', module='foo')

mut def from_json_path_foo__nested(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'inner':
            child = {'f:inner': from_json_path_foo__nested__f_inner(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='http://example.com/foo', module='foo')
        if point == 'bar:inner':
            child = {'bar:inner': from_json_path_foo__nested__bar_inner(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='http://example.com/foo', module='foo')
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__nested(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__nested(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_f_inner = yang.gdata.take_json_opt_cnt(jd, 'inner')
    yang.gdata.maybe_add(children, 'f:inner', from_json_foo__nested__f_inner, child_f_inner)
    child_bar_inner = yang.gdata.take_json_opt_cnt(jd, 'inner', 'bar')
    yang.gdata.maybe_add(children, 'bar:inner', from_json_foo__nested__bar_inner, child_bar_inner)
    return yang.gdata.Container(children, ns='http://example.com/foo', module='foo')

mut def from_json_foo__li_union__k1(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__li_union__k1(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__li_union__k2(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_xml_foo__li_union__k2(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_json_foo__li_union__k3(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('binary', val)

mut def from_xml_foo__li_union__k3(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('binary', val)

class foo__li_union_entry(yang.adata.MNode):
    k1: str
    k2: value
    k3: bytes

    mut def __init__(self, k1: str, k2: value, k3: bytes):
        self._ns = 'http://example.com/foo'
        self.k1 = k1
        self.k2 = k2
        self.k3 = k3

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _k1 = self.k1
        if _k1 is not None:
            children['k1'] = yang.gdata.Leaf('string', _k1)
        _k2 = self.k2
        if _k2 is not None:
            children['k2'] = yang.gdata.Leaf('union', _k2)
        _k3 = self.k3
        if _k3 is not None:
            children['k3'] = yang.gdata.Leaf('binary', _k3)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> foo__li_union_entry:
        return foo__li_union_entry(k1=n.get_str('k1'), k2=n.get_value('k2'), k3=n.get_bytes('k3'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /li-union')
            res.append('{self_name} = foo__li_union({repr(self.k1)}, {repr(self.k2)}, {repr(self.k3)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /li-union'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class foo__li_union(yang.adata.MNode):
    elements: list[foo__li_union_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/foo'
        self._name = 'li-union'
        self.elements = elements

    mut def create(self, k1, k2, k3):
        for e in self.elements:
            match = True
            if e.k1 != k1:
                match = False
                continue
            e_k2 = e.k2
            if isinstance(e_k2, int) and isinstance(k2, int):
                if e_k2 != k2:
                    match = False
                    continue
            e_k2 = e.k2
            if isinstance(e_k2, str) and isinstance(k2, str):
                if e_k2 != k2:
                    match = False
                    continue
            e_k2 = e.k2
            if isinstance(e_k2, bytes) and isinstance(k2, bytes):
                if e_k2 != k2:
                    match = False
                    continue
            if e.k3 != k3:
                match = False
                continue
            if match:
                return e

        res = foo__li_union_entry(k1, k2, k3)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['k1', 'k2', 'k3'], elements, ns='http://example.com/foo', module='foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[foo__li_union_entry]:
        if n is not None:
            return [foo__li_union_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_foo__li_union_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_k1 = yang.gdata.from_xml_str(node, 'k1')
    yang.gdata.maybe_add(children, 'k1', from_xml_foo__li_union__k1, child_k1)
    child_k2 = yang.gdata.from_xml_value(node, 'k2')
    yang.gdata.maybe_add(children, 'k2', from_xml_foo__li_union__k2, child_k2)
    child_k3 = yang.gdata.from_xml_bytes(node, 'k3')
    yang.gdata.maybe_add(children, 'k3', from_xml_foo__li_union__k3, child_k3)
    return yang.gdata.Container(children)

mut def from_xml_foo__li_union(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_foo__li_union_element(e) for e in nodes]
    return yang.gdata.List(keys=['k1', 'k2', 'k3'], elements=elements, ns='http://example.com/foo', module='foo')

mut def from_json_path_foo__li_union_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_foo__li_union_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['k1', 'k2', 'k3']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['k1'] = from_json_foo__li_union__k1(keys[0])
        children['k2'] = from_json_foo__li_union__k2(keys[1])
        children['k3'] = from_json_foo__li_union__k3(keys[2])
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_foo__li_union(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['k1', 'k2', 'k3']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_foo__li_union_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['k1', 'k2', 'k3'])))
        return yang.gdata.List(['k1', 'k2', 'k3'], elements, ns='http://example.com/foo', module='foo')
    elif len(path) > 1:
        return yang.gdata.List(['k1', 'k2', 'k3'], [from_json_path_foo__li_union_element(jd, path, op)], ns='http://example.com/foo', module='foo')
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_foo__li_union_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_k1 = yang.gdata.take_json_str(jd, 'k1')
    yang.gdata.maybe_add(children, 'k1', from_json_foo__li_union__k1, child_k1)
    child_k2 = yang.gdata.take_json_value(jd, 'k2')
    yang.gdata.maybe_add(children, 'k2', from_json_foo__li_union__k2, child_k2)
    child_k3 = yang.gdata.take_json_bytes(jd, 'k3')
    yang.gdata.maybe_add(children, 'k3', from_json_foo__li_union__k3, child_k3)
    return yang.gdata.Container(children)

mut def from_json_foo__li_union(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_foo__li_union_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['k1', 'k2', 'k3'], elements=elements, ns='http://example.com/foo', module='foo')

mut def from_json_foo__state__c1__l1(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__state__c1__l1(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_foo__state__c1__l2(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__state__c1__l2(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class foo__state__c1(yang.adata.MNode):
    l1: ?str
    l2: ?str

    mut def __init__(self, l1: ?str, l2: ?str):
        self._ns = 'http://example.com/foo'
        self.l1 = l1
        self.l2 = l2

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _l1 = self.l1
        if _l1 is not None:
            children['l1'] = yang.gdata.Leaf('string', _l1)
        _l2 = self.l2
        if _l2 is not None:
            children['l2'] = yang.gdata.Leaf('string', _l2)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__state__c1:
        if n != None:
            return foo__state__c1(l1=n.get_opt_str('l1'), l2=n.get_opt_str('l2'))
        return foo__state__c1()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /state/c1')
            res.append('{self_name} = foo__state__c1()')
        leaves = []
        _l1 = self.l1
        if _l1 is not None:
            leaves.append('{self_name}.l1 = {repr(_l1)}')
        _l2 = self.l2
        if _l2 is not None:
            leaves.append('{self_name}.l2 = {repr(_l2)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /state/c1'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_foo__state__c1(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_l1 = yang.gdata.from_xml_opt_str(node, 'l1')
    yang.gdata.maybe_add(children, 'l1', from_xml_foo__state__c1__l1, child_l1)
    child_l2 = yang.gdata.from_xml_opt_str(node, 'l2')
    yang.gdata.maybe_add(children, 'l2', from_xml_foo__state__c1__l2, child_l2)
    return yang.gdata.Container(children)

mut def from_json_path_foo__state__c1(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l1':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l2':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__state__c1(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__state__c1(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_l1 = yang.gdata.take_json_opt_str(jd, 'l1')
    yang.gdata.maybe_add(children, 'l1', from_json_foo__state__c1__l1, child_l1)
    child_l2 = yang.gdata.take_json_opt_str(jd, 'l2')
    yang.gdata.maybe_add(children, 'l2', from_json_foo__state__c1__l2, child_l2)
    return yang.gdata.Container(children)

class foo__state(yang.adata.MNode):
    c1: foo__state__c1

    mut def __init__(self, c1: ?foo__state__c1=None):
        self._ns = 'http://example.com/foo'
        self.c1 = c1 if c1 is not None else foo__state__c1()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _c1 = self.c1
        if _c1 is not None:
            children['c1'] = _c1.to_gdata()
        return yang.gdata.Container(children, ns='http://example.com/foo', module='foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__state:
        if n != None:
            return foo__state(c1=foo__state__c1.from_gdata(n.get_opt_cnt('c1')))
        return foo__state()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /state')
            res.append('{self_name} = foo__state()')
        leaves = []
        _c1 = self.c1
        if _c1 is not None:
            res.extend(_c1.prsrc('{self_name}.c1', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /state'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_foo__state(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_c1 = yang.gdata.from_xml_opt_cnt(node, 'c1')
    yang.gdata.maybe_add(children, 'c1', from_xml_foo__state__c1, child_c1)
    return yang.gdata.Container(children, ns='http://example.com/foo', module='foo')

mut def from_json_path_foo__state(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'c1':
            child = {'c1': from_json_path_foo__state__c1(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='http://example.com/foo', module='foo')
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__state(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__state(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_c1 = yang.gdata.take_json_opt_cnt(jd, 'c1')
    yang.gdata.maybe_add(children, 'c1', from_json_foo__state__c1, child_c1)
    return yang.gdata.Container(children, ns='http://example.com/foo', module='foo')

mut def from_json_foo__c2__l1(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_foo__c2__l1(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class foo__c2(yang.adata.MNode):
    l1: ?str

    mut def __init__(self, l1: ?str):
        self._ns = 'http://example.com/foo'
        self.l1 = l1

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _l1 = self.l1
        if _l1 is not None:
            children['l1'] = yang.gdata.Leaf('string', _l1)
        return yang.gdata.Container(children, ns='http://example.com/foo', module='foo')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> foo__c2:
        if n != None:
            return foo__c2(l1=n.get_opt_str('l1'))
        return foo__c2()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /c2')
            res.append('{self_name} = foo__c2()')
        leaves = []
        _l1 = self.l1
        if _l1 is not None:
            leaves.append('{self_name}.l1 = {repr(_l1)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /c2'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_foo__c2(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_l1 = yang.gdata.from_xml_opt_str(node, 'l1')
    yang.gdata.maybe_add(children, 'l1', from_xml_foo__c2__l1, child_l1)
    return yang.gdata.Container(children, ns='http://example.com/foo', module='foo')

mut def from_json_path_foo__c2(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l1':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_foo__c2(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_foo__c2(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_l1 = yang.gdata.take_json_opt_str(jd, 'l1')
    yang.gdata.maybe_add(children, 'l1', from_json_foo__c2__l1, child_l1)
    return yang.gdata.Container(children, ns='http://example.com/foo', module='foo')

mut def from_json_bar__conflict__foo(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_bar__conflict__foo(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class bar__conflict(yang.adata.MNode):
    foo: ?str

    mut def __init__(self, foo: ?str):
        self._ns = 'http://example.com/bar'
        self.foo = foo

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _foo = self.foo
        if _foo is not None:
            children['foo'] = yang.gdata.Leaf('string', _foo)
        return yang.gdata.Container(children, ns='http://example.com/bar', module='bar')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> bar__conflict:
        if n != None:
            return bar__conflict(foo=n.get_opt_str('foo'))
        return bar__conflict()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /conflict')
            res.append('{self_name} = bar__conflict()')
        leaves = []
        _foo = self.foo
        if _foo is not None:
            leaves.append('{self_name}.foo = {repr(_foo)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /conflict'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_bar__conflict(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_foo = yang.gdata.from_xml_opt_str(node, 'foo')
    yang.gdata.maybe_add(children, 'foo', from_xml_bar__conflict__foo, child_foo)
    return yang.gdata.Container(children, ns='http://example.com/bar', module='bar')

mut def from_json_path_bar__conflict(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'foo':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_bar__conflict(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_bar__conflict(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_foo = yang.gdata.take_json_opt_str(jd, 'foo')
    yang.gdata.maybe_add(children, 'foo', from_json_bar__conflict__foo, child_foo)
    return yang.gdata.Container(children, ns='http://example.com/bar', module='bar')

class root(yang.adata.MNode):
    c1: foo__c1
    pc1: ?foo__pc1
    pc2: ?foo__pc2
    pc3: ?foo__pc3
    empty_presence: ?foo__empty_presence
    c_dot: foo__c_dot
    cc: foo__cc
    f_conflict: foo__conflict
    special: foo__special
    nested: foo__nested
    li_union: foo__li_union
    state: foo__state
    c2: foo__c2
    bar_conflict: bar__conflict

    mut def __init__(self, c1: ?foo__c1=None, pc1: ?foo__pc1=None, pc2: ?foo__pc2=None, pc3: ?foo__pc3=None, empty_presence: ?foo__empty_presence=None, c_dot: ?foo__c_dot=None, cc: ?foo__cc=None, f_conflict: ?foo__conflict=None, special: list[foo__special_entry]=[], nested: ?foo__nested=None, li_union: list[foo__li_union_entry]=[], state: ?foo__state=None, c2: ?foo__c2=None, bar_conflict: ?bar__conflict=None):
        self._ns = ''
        self.c1 = c1 if c1 is not None else foo__c1()
        self.pc1 = pc1
        self.pc2 = pc2
        self.pc3 = pc3
        self.empty_presence = empty_presence
        self.c_dot = c_dot if c_dot is not None else foo__c_dot()
        self.cc = cc if cc is not None else foo__cc()
        self.f_conflict = f_conflict if f_conflict is not None else foo__conflict()
        self.special = foo__special(elements=special)
        self.nested = nested if nested is not None else foo__nested()
        self.li_union = foo__li_union(elements=li_union)
        self.state = state if state is not None else foo__state()
        self.c2 = c2 if c2 is not None else foo__c2()
        self.bar_conflict = bar_conflict if bar_conflict is not None else bar__conflict()

    mut def create_pc1(self):
        res = foo__pc1()
        self.pc1 = res
        return res

    mut def create_pc2(self):
        res = foo__pc2()
        self.pc2 = res
        return res

    mut def create_pc3(self):
        res = foo__pc3()
        self.pc3 = res
        return res

    mut def create_empty_presence(self):
        res = foo__empty_presence()
        self.empty_presence = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _c1 = self.c1
        if _c1 is not None:
            children['c1'] = _c1.to_gdata()
        _pc1 = self.pc1
        if _pc1 is not None:
            children['pc1'] = _pc1.to_gdata()
        _pc2 = self.pc2
        if _pc2 is not None:
            children['pc2'] = _pc2.to_gdata()
        _pc3 = self.pc3
        if _pc3 is not None:
            children['pc3'] = _pc3.to_gdata()
        _empty_presence = self.empty_presence
        if _empty_presence is not None:
            children['empty-presence'] = _empty_presence.to_gdata()
        _c_dot = self.c_dot
        if _c_dot is not None:
            children['c.dot'] = _c_dot.to_gdata()
        _cc = self.cc
        if _cc is not None:
            children['cc'] = _cc.to_gdata()
        _f_conflict = self.f_conflict
        if _f_conflict is not None:
            children['f:conflict'] = _f_conflict.to_gdata()
        _special = self.special
        if _special is not None:
            children['special'] = _special.to_gdata()
        _nested = self.nested
        if _nested is not None:
            children['nested'] = _nested.to_gdata()
        _li_union = self.li_union
        if _li_union is not None:
            children['li-union'] = _li_union.to_gdata()
        _state = self.state
        if _state is not None:
            children['state'] = _state.to_gdata()
        _c2 = self.c2
        if _c2 is not None:
            children['c2'] = _c2.to_gdata()
        _bar_conflict = self.bar_conflict
        if _bar_conflict is not None:
            children['bar:conflict'] = _bar_conflict.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> root:
        if n != None:
            return root(c1=foo__c1.from_gdata(n.get_opt_cnt('c1')), pc1=foo__pc1.from_gdata(n.get_opt_cnt('pc1')), pc2=foo__pc2.from_gdata(n.get_opt_cnt('pc2')), pc3=foo__pc3.from_gdata(n.get_opt_cnt('pc3')), empty_presence=foo__empty_presence.from_gdata(n.get_opt_cnt('empty-presence')), c_dot=foo__c_dot.from_gdata(n.get_opt_cnt('c.dot')), cc=foo__cc.from_gdata(n.get_opt_cnt('cc')), f_conflict=foo__conflict.from_gdata(n.get_opt_cnt('f:conflict')), special=foo__special.from_gdata(n.get_opt_list('special')), nested=foo__nested.from_gdata(n.get_opt_cnt('nested')), li_union=foo__li_union.from_gdata(n.get_opt_list('li-union')), state=foo__state.from_gdata(n.get_opt_cnt('state')), c2=foo__c2.from_gdata(n.get_opt_cnt('c2')), bar_conflict=bar__conflict.from_gdata(n.get_opt_cnt('bar:conflict')))
        return root()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /root')
            res.append('{self_name} = root()')
        leaves = []
        _c1 = self.c1
        if _c1 is not None:
            res.extend(_c1.prsrc('{self_name}.c1', False).splitlines())
        _pc1 = self.pc1
        if _pc1 is not None:
            res.append('')
            res.append('# P-container: /pc1')
            res.append('pc1 = {self_name}.create_pc1()')
            res.extend(_pc1.prsrc('pc1', False).splitlines())
        _pc2 = self.pc2
        if _pc2 is not None:
            res.append('')
            res.append('# P-container: /pc2')
            res.append('pc2 = {self_name}.create_pc2()')
            res.extend(_pc2.prsrc('pc2', False).splitlines())
        _pc3 = self.pc3
        if _pc3 is not None:
            res.append('')
            res.append('# P-container: /pc3')
            res.append('pc3 = {self_name}.create_pc3()')
            res.extend(_pc3.prsrc('pc3', False).splitlines())
        _empty_presence = self.empty_presence
        if _empty_presence is not None:
            res.append('')
            res.append('# P-container: /empty-presence')
            res.append('empty_presence = {self_name}.create_empty_presence()')
            res.extend(_empty_presence.prsrc('empty_presence', False).splitlines())
        _c_dot = self.c_dot
        if _c_dot is not None:
            res.extend(_c_dot.prsrc('{self_name}.c_dot', False).splitlines())
        _cc = self.cc
        if _cc is not None:
            res.extend(_cc.prsrc('{self_name}.cc', False).splitlines())
        _f_conflict = self.f_conflict
        if _f_conflict is not None:
            res.extend(_f_conflict.prsrc('{self_name}.f_conflict', False).splitlines())
        _special = self.special
        for _element in _special.elements:
            res.append('')
            res.append("# List /special element: {_element.to_gdata().key_str(['yes'])}")
            list_elem = 'special_element = {self_name}.special.create({repr(_element.yes)})'
            res.append(list_elem)
            res.extend(_element.prsrc('special_element', False, list_element=True).splitlines())
        _nested = self.nested
        if _nested is not None:
            res.extend(_nested.prsrc('{self_name}.nested', False).splitlines())
        _li_union = self.li_union
        for _element in _li_union.elements:
            res.append('')
            res.append("# List /li-union element: {_element.to_gdata().key_str(['k1', 'k2', 'k3'])}")
            list_elem = 'li_union_element = {self_name}.li_union.create({repr(_element.k1)}, {repr(_element.k2)}, {repr(_element.k3)})'
            res.append(list_elem)
            res.extend(_element.prsrc('li_union_element', False, list_element=True).splitlines())
        _state = self.state
        if _state is not None:
            res.extend(_state.prsrc('{self_name}.state', False).splitlines())
        _c2 = self.c2
        if _c2 is not None:
            res.extend(_c2.prsrc('{self_name}.c2', False).splitlines())
        _bar_conflict = self.bar_conflict
        if _bar_conflict is not None:
            res.extend(_bar_conflict.prsrc('{self_name}.bar_conflict', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /root'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_c1 = yang.gdata.from_xml_opt_cnt(node, 'c1', 'http://example.com/foo')
    yang.gdata.maybe_add(children, 'c1', from_xml_foo__c1, child_c1)
    child_pc1 = yang.gdata.from_xml_opt_cnt(node, 'pc1', 'http://example.com/foo')
    yang.gdata.maybe_add(children, 'pc1', from_xml_foo__pc1, child_pc1)
    child_pc2 = yang.gdata.from_xml_opt_cnt(node, 'pc2', 'http://example.com/foo')
    yang.gdata.maybe_add(children, 'pc2', from_xml_foo__pc2, child_pc2)
    child_pc3 = yang.gdata.from_xml_opt_cnt(node, 'pc3', 'http://example.com/foo')
    yang.gdata.maybe_add(children, 'pc3', from_xml_foo__pc3, child_pc3)
    child_empty_presence = yang.gdata.from_xml_opt_cnt(node, 'empty-presence', 'http://example.com/foo')
    yang.gdata.maybe_add(children, 'empty-presence', from_xml_foo__empty_presence, child_empty_presence)
    child_c_dot = yang.gdata.from_xml_opt_cnt(node, 'c.dot', 'http://example.com/foo')
    yang.gdata.maybe_add(children, 'c.dot', from_xml_foo__c_dot, child_c_dot)
    child_cc = yang.gdata.from_xml_opt_cnt(node, 'cc', 'http://example.com/foo')
    yang.gdata.maybe_add(children, 'cc', from_xml_foo__cc, child_cc)
    child_f_conflict = yang.gdata.from_xml_opt_cnt(node, 'conflict', 'http://example.com/foo')
    yang.gdata.maybe_add(children, 'f:conflict', from_xml_foo__conflict, child_f_conflict)
    child_special = yang.gdata.from_xml_opt_list(node, 'special', 'http://example.com/foo')
    yang.gdata.maybe_add(children, 'special', from_xml_foo__special, child_special)
    child_nested = yang.gdata.from_xml_opt_cnt(node, 'nested', 'http://example.com/foo')
    yang.gdata.maybe_add(children, 'nested', from_xml_foo__nested, child_nested)
    child_li_union = yang.gdata.from_xml_opt_list(node, 'li-union', 'http://example.com/foo')
    yang.gdata.maybe_add(children, 'li-union', from_xml_foo__li_union, child_li_union)
    child_state = yang.gdata.from_xml_opt_cnt(node, 'state', 'http://example.com/foo')
    yang.gdata.maybe_add(children, 'state', from_xml_foo__state, child_state)
    child_c2 = yang.gdata.from_xml_opt_cnt(node, 'c2', 'http://example.com/foo')
    yang.gdata.maybe_add(children, 'c2', from_xml_foo__c2, child_c2)
    child_bar_conflict = yang.gdata.from_xml_opt_cnt(node, 'conflict', 'http://example.com/bar')
    yang.gdata.maybe_add(children, 'bar:conflict', from_xml_bar__conflict, child_bar_conflict)
    return yang.gdata.Container(children)

mut def from_json_path(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'foo:c1':
            child = {'c1': from_json_path_foo__c1(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'foo:pc1':
            child = {'pc1': from_json_path_foo__pc1(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'foo:pc2':
            child = {'pc2': from_json_path_foo__pc2(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'foo:pc3':
            child = {'pc3': from_json_path_foo__pc3(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'foo:empty-presence':
            child = {'empty-presence': from_json_path_foo__empty_presence(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'foo:c.dot':
            child = {'c.dot': from_json_path_foo__c_dot(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'foo:cc':
            child = {'cc': from_json_path_foo__cc(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'foo:conflict':
            child = {'f:conflict': from_json_path_foo__conflict(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'foo:special':
            child = {'special': from_json_path_foo__special(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'foo:nested':
            child = {'nested': from_json_path_foo__nested(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'foo:li-union':
            child = {'li-union': from_json_path_foo__li_union(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'foo:state':
            child = {'state': from_json_path_foo__state(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'foo:c2':
            child = {'c2': from_json_path_foo__c2(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'bar:conflict':
            child = {'bar:conflict': from_json_path_bar__conflict(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_c1 = yang.gdata.take_json_opt_cnt(jd, 'c1', 'foo')
    yang.gdata.maybe_add(children, 'c1', from_json_foo__c1, child_c1)
    child_pc1 = yang.gdata.take_json_opt_cnt(jd, 'pc1', 'foo')
    yang.gdata.maybe_add(children, 'pc1', from_json_foo__pc1, child_pc1)
    child_pc2 = yang.gdata.take_json_opt_cnt(jd, 'pc2', 'foo')
    yang.gdata.maybe_add(children, 'pc2', from_json_foo__pc2, child_pc2)
    child_pc3 = yang.gdata.take_json_opt_cnt(jd, 'pc3', 'foo')
    yang.gdata.maybe_add(children, 'pc3', from_json_foo__pc3, child_pc3)
    child_empty_presence = yang.gdata.take_json_opt_cnt(jd, 'empty-presence', 'foo')
    yang.gdata.maybe_add(children, 'empty-presence', from_json_foo__empty_presence, child_empty_presence)
    child_c_dot = yang.gdata.take_json_opt_cnt(jd, 'c.dot', 'foo')
    yang.gdata.maybe_add(children, 'c.dot', from_json_foo__c_dot, child_c_dot)
    child_cc = yang.gdata.take_json_opt_cnt(jd, 'cc', 'foo')
    yang.gdata.maybe_add(children, 'cc', from_json_foo__cc, child_cc)
    child_f_conflict = yang.gdata.take_json_opt_cnt(jd, 'conflict', 'foo')
    yang.gdata.maybe_add(children, 'f:conflict', from_json_foo__conflict, child_f_conflict)
    child_special = yang.gdata.take_json_opt_list(jd, 'special', 'foo')
    yang.gdata.maybe_add(children, 'special', from_json_foo__special, child_special)
    child_nested = yang.gdata.take_json_opt_cnt(jd, 'nested', 'foo')
    yang.gdata.maybe_add(children, 'nested', from_json_foo__nested, child_nested)
    child_li_union = yang.gdata.take_json_opt_list(jd, 'li-union', 'foo')
    yang.gdata.maybe_add(children, 'li-union', from_json_foo__li_union, child_li_union)
    child_state = yang.gdata.take_json_opt_cnt(jd, 'state', 'foo')
    yang.gdata.maybe_add(children, 'state', from_json_foo__state, child_state)
    child_c2 = yang.gdata.take_json_opt_cnt(jd, 'c2', 'foo')
    yang.gdata.maybe_add(children, 'c2', from_json_foo__c2, child_c2)
    child_bar_conflict = yang.gdata.take_json_opt_cnt(jd, 'conflict', 'bar')
    yang.gdata.maybe_add(children, 'bar:conflict', from_json_bar__conflict, child_bar_conflict)
    return yang.gdata.Container(children)

schema_namespaces: set[str] = {
    'http://example.com/bar',
    'http://example.com/foo',
}
def src_yang():
    res = []
    res.append(r"""module foo {
    yang-version "1.1";
    namespace "http://example.com/foo";
    prefix "f";
    include qux;
    grouping g1 {
        leaf l1 {
            type string;
        }
        leaf l2 {
            type string;
        }
    }
    container c1 {
        leaf l1 {
            type string;
        }
        leaf l3 {
            type uint64;
        }
        leaf l_empty {
            type empty;
        }
        list li {
            ordered-by user;
            key name;
            leaf name {
                type string;
            }
            leaf val {
                type string;
            }
        }
        leaf-list ll_uint64 {
            type uint64;
        }
        leaf-list ll_str {
            type string;
        }
    }
    container pc1 {
        presence "p";
        container foo {
            leaf-list l1 {
                type binary;
            }
        }
    }
    container pc2 {
        presence "p";
        container foo {
            leaf l_mandatory {
                type string;
                mandatory true;
            }
        }
    }
    container pc3 {
        presence "p";
        container level1 {
            leaf l1 {
                type string;
                mandatory true;
            }
            leaf l1-optional {
                type string;
            }
            container level2 {
                leaf l2 {
                    type string;
                    mandatory true;
                }
                leaf l2-optional {
                    type string;
                }
                container level3 {
                    leaf l3 {
                        type string;
                        mandatory true;
                    }
                    leaf l3-optional {
                        type string;
                    }
                }
            }
        }
    }
    container empty-presence {
        presence "nothing else here";
    }
    container c.dot {
        leaf l.dot1 {
            type string;
        }
    }
    container cc {
        choice cake-or-death {
            case cake {
                leaf cake {
                    type string;
                    mandatory true;
                }
            }
            case death {
                list death {
                    key name;
                    leaf name {
                        type string;
                    }
                }
            }
            mandatory true;
        }
    }
    container conflict {
        leaf foo {
            type string;
        }
        container inner {
            presence "inner presence";
        }
    }
    list special {
        key yes;
        leaf yes {
            type boolean;
        }
    }
    container nested {
        container inner {
            leaf foo {
                type string;
            }
            list li1 {
                key name;
                leaf name {
                    type string;
                }
                leaf bar {
                    type string;
                }
                list li2 {
                    key "key1 key2";
                    leaf key1 {
                        type string;
                    }
                    leaf key2 {
                        type string;
                    }
                    leaf baz {
                        type string;
                    }
                }
            }
        }
    }
    list li-union {
        key "k1 k2 k3";
        leaf k1 {
            type string;
        }
        leaf k2 {
            type union {
                type uint32;
                type enumeration {
                    enum "unlimited";
                }
                type binary;
            }
        }
        leaf k3 {
            type binary;
        }
    }
    container state {
        config false;
        container c1 {
            uses g1;
        }
    }
}""")
    res.append(r"""submodule qux {
    yang-version "1.1";
    belongs-to foo {
        prefix "f";
    }
    // Must not conflict with /f:c1
    container c2 {
        leaf l1 {
            type string;
        }
    }
    augment /f:c1 {
        leaf l4 {
            type string;
        }
    }
}""")
    res.append(r"""module bar {
    yang-version "1.1";
    namespace "http://example.com/bar";
    prefix "bar";
    import foo {
        prefix "f";
    }
    augment /f:c1 {
        // create a conflict with /f:c1/l1
        uses f:g1;
    }
    augment /f:c.dot {
        leaf l.dot2 {
            type string;
        }
    }
    container conflict {
        leaf foo {
            type string;
        }
    }
    augment /f:conflict {
        leaf foo {
            type string;
        }
        container inner {
            presence "inner presence from bar";
        }
    }
    augment /f:nested {
        // conflict with /f:nested/inner
        container inner {
            leaf foo {
                type string;
            }
        }
    }
    augment /f:nested/inner/li1 {
        leaf bar {
            type string;
        }
    }
}""")
    return res

def src_schema():
    res = {}
    res["foo"] = Module('foo', yang_version=1.1, namespace='http://example.com/foo', prefix='f', include=[
        Include('qux')
    ], children=[
    Grouping('g1', children=[
        Leaf('l1', type_=Type('string')),
        Leaf('l2', type_=Type('string'))
    ]),
    Container('c1', children=[
        Leaf('l1', type_=Type('string')),
        Leaf('l3', type_=Type('uint64')),
        Leaf('l_empty', type_=Type('empty')),
        List('li', key='name', ordered_by='user', children=[
            Leaf('name', type_=Type('string')),
            Leaf('val', type_=Type('string'))
        ]),
        LeafList('ll_uint64', type_=Type('uint64')),
        LeafList('ll_str', type_=Type('string'))
    ]),
    Container('pc1', presence='p', children=[
        Container('foo', children=[
            LeafList('l1', type_=Type('binary'))
        ])
    ]),
    Container('pc2', presence='p', children=[
        Container('foo', children=[
            Leaf('l_mandatory', type_=Type('string'), mandatory=True)
        ])
    ]),
    Container('pc3', presence='p', children=[
        Container('level1', children=[
            Leaf('l1', type_=Type('string'), mandatory=True),
            Leaf('l1-optional', type_=Type('string')),
            Container('level2', children=[
                Leaf('l2', type_=Type('string'), mandatory=True),
                Leaf('l2-optional', type_=Type('string')),
                Container('level3', children=[
                    Leaf('l3', type_=Type('string'), mandatory=True),
                    Leaf('l3-optional', type_=Type('string'))
                ])
            ])
        ])
    ]),
    Container('empty-presence', presence='nothing else here'),
    Container('c.dot', children=[
        Leaf('l.dot1', type_=Type('string'))
    ]),
    Container('cc', children=[
        Choice('cake-or-death', mandatory=True, children=[
            Case('cake', children=[
                Leaf('cake', type_=Type('string'), mandatory=True)
            ]),
            Case('death', children=[
                List('death', key='name', children=[
                    Leaf('name', type_=Type('string'))
                ])
            ])
        ])
    ]),
    Container('conflict', children=[
        Leaf('foo', type_=Type('string')),
        Container('inner', presence='inner presence')
    ]),
    List('special', key='yes', children=[
        Leaf('yes', type_=Type('boolean'))
    ]),
    Container('nested', children=[
        Container('inner', children=[
            Leaf('foo', type_=Type('string')),
            List('li1', key='name', children=[
                Leaf('name', type_=Type('string')),
                Leaf('bar', type_=Type('string')),
                List('li2', key='key1 key2', children=[
                    Leaf('key1', type_=Type('string')),
                    Leaf('key2', type_=Type('string')),
                    Leaf('baz', type_=Type('string'))
                ])
            ])
        ])
    ]),
    List('li-union', key='k1 k2 k3', children=[
        Leaf('k1', type_=Type('string')),
        Leaf('k2', type_=Type('union', type_=[
        Type('uint32'),
        Type('enumeration', enum=[
                Enum('unlimited')
            ]),
        Type('binary')
    ])),
        Leaf('k3', type_=Type('binary'))
    ]),
    Container('state', config=False, children=[
        Container('c1', children=[
            Uses('g1')
        ])
    ])
])
    res["qux"] = Submodule('qux', yang_version=1.1, belongs_to=BelongsTo('foo', prefix='f'), augment=[
        Augment('/f:c1', children=[
            Leaf('l4', type_=Type('string'))
        ])
    ], children=[
    Container('c2', children=[
        Leaf('l1', type_=Type('string'))
    ])
])
    res["bar"] = Module('bar', yang_version=1.1, namespace='http://example.com/bar', prefix='bar', import_=[
        Import('foo', prefix='f')
    ], augment=[
        Augment('/f:c1', children=[
            Uses('f:g1')
        ]),
        Augment('/f:c.dot', children=[
            Leaf('l.dot2', type_=Type('string'))
        ]),
        Augment('/f:conflict', children=[
            Leaf('foo', type_=Type('string')),
            Container('inner', presence='inner presence from bar')
        ]),
        Augment('/f:nested', children=[
            Container('inner', children=[
                Leaf('foo', type_=Type('string'))
            ])
        ]),
        Augment('/f:nested/inner/li1', children=[
            Leaf('bar', type_=Type('string'))
        ])
    ], children=[
    Container('conflict', children=[
        Leaf('foo', type_=Type('string'))
    ])
])
    return res

def src_schema_compiled():
    res = {}
    res["foo"] = Module('foo', yang_version=1.1, namespace='http://example.com/foo', prefix='f', augment=[
        Augment('/f:c1', children=[
            Leaf('l4', type_=Type('string'))
        ])
    ], children=[
    Grouping('g1', children=[
        Leaf('l1', type_=Type('string')),
        Leaf('l2', type_=Type('string'))
    ]),
    Container('c1', children=[
        Leaf('l1', type_=Type('string')),
        Leaf('l3', type_=Type('uint64')),
        Leaf('l_empty', type_=Type('empty')),
        List('li', key='name', ordered_by='user', children=[
            Leaf('name', type_=Type('string')),
            Leaf('val', type_=Type('string'))
        ]),
        LeafList('ll_uint64', type_=Type('uint64')),
        LeafList('ll_str', type_=Type('string')),
        Leaf('l4', type_=Type('string')),
        Leaf('l1', type_=Type('string')),
        Leaf('l2', type_=Type('string'))
    ]),
    Container('pc1', presence='p', children=[
        Container('foo', children=[
            LeafList('l1', type_=Type('binary'))
        ])
    ]),
    Container('pc2', presence='p', children=[
        Container('foo', children=[
            Leaf('l_mandatory', type_=Type('string'), mandatory=True)
        ])
    ]),
    Container('pc3', presence='p', children=[
        Container('level1', children=[
            Leaf('l1', type_=Type('string'), mandatory=True),
            Leaf('l1-optional', type_=Type('string')),
            Container('level2', children=[
                Leaf('l2', type_=Type('string'), mandatory=True),
                Leaf('l2-optional', type_=Type('string')),
                Container('level3', children=[
                    Leaf('l3', type_=Type('string'), mandatory=True),
                    Leaf('l3-optional', type_=Type('string'))
                ])
            ])
        ])
    ]),
    Container('empty-presence', presence='nothing else here'),
    Container('c.dot', children=[
        Leaf('l.dot1', type_=Type('string')),
        Leaf('l.dot2', type_=Type('string'))
    ]),
    Container('cc', children=[
        Choice('cake-or-death', mandatory=True, children=[
            Case('cake', children=[
                Leaf('cake', type_=Type('string'), mandatory=True)
            ]),
            Case('death', children=[
                List('death', key='name', children=[
                    Leaf('name', type_=Type('string'))
                ])
            ])
        ])
    ]),
    Container('conflict', children=[
        Leaf('foo', type_=Type('string')),
        Container('inner', presence='inner presence'),
        Leaf('foo', type_=Type('string')),
        Container('inner', presence='inner presence from bar')
    ]),
    List('special', key='yes', children=[
        Leaf('yes', type_=Type('boolean'))
    ]),
    Container('nested', children=[
        Container('inner', children=[
            Leaf('foo', type_=Type('string')),
            List('li1', key='name', children=[
                Leaf('name', type_=Type('string')),
                Leaf('bar', type_=Type('string')),
                List('li2', key='key1 key2', children=[
                    Leaf('key1', type_=Type('string')),
                    Leaf('key2', type_=Type('string')),
                    Leaf('baz', type_=Type('string'))
                ]),
                Leaf('bar', type_=Type('string'))
            ])
        ]),
        Container('inner', children=[
            Leaf('foo', type_=Type('string'))
        ])
    ]),
    List('li-union', key='k1 k2 k3', children=[
        Leaf('k1', type_=Type('string')),
        Leaf('k2', type_=Type('union', type_=[
        Type('uint32'),
        Type('enumeration', enum=[
                Enum('unlimited')
            ]),
        Type('binary')
    ])),
        Leaf('k3', type_=Type('binary'))
    ]),
    Container('state', config=False, children=[
        Container('c1', children=[
            Leaf('l1', type_=Type('string')),
            Leaf('l2', type_=Type('string'))
        ])
    ]),
    Container('c2', children=[
        Leaf('l1', type_=Type('string'))
    ])
])
    res["bar"] = Module('bar', yang_version=1.1, namespace='http://example.com/bar', prefix='bar', import_=[
        Import('foo', prefix='f')
    ], augment=[
        Augment('/f:c1', children=[
            Uses('f:g1')
        ]),
        Augment('/f:c.dot', children=[
            Leaf('l.dot2', type_=Type('string'))
        ]),
        Augment('/f:conflict', children=[
            Leaf('foo', type_=Type('string')),
            Container('inner', presence='inner presence from bar')
        ]),
        Augment('/f:nested', children=[
            Container('inner', children=[
                Leaf('foo', type_=Type('string'))
            ])
        ]),
        Augment('/f:nested/inner/li1', children=[
            Leaf('bar', type_=Type('string'))
        ])
    ], children=[
    Container('conflict', children=[
        Leaf('foo', type_=Type('string'))
    ])
])
    return res
