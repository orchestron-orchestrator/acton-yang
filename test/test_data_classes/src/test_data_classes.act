
import diff
import file
import testing
import json
import xml

import yang
import yang.gen3
import yang.adata
import yang.gdata
from yang.identityref import Identityref

import yang_one
import yang_foo
import yang_foo_loose
from yang_foo import root as yang_foo_root
import yang_basics

def _test_mandatory1():
    xml_text = """<data><tc1 xmlns="http://example.com/foo"><l1>foo</l1></tc1></data>"""
    r = yang_one.from_xml(xml.decode(xml_text))

def _test_mandatory2():
    xml_text = """<data><tc1 xmlns="http://example.com/foo"><l1>foo</l1></tc1><li xmlns="http://example.com/foo"><name>foo</name><c1><l1>foo</l1></c1></li></data>"""
    r = yang_one.from_xml(xml.decode(xml_text))

# YANG model used to generate yang_foo
#
# module foo {
#     yang-version "1.1";
#     namespace "http://example.com/foo";
#     prefix "foo";
#     container c1 {
#         leaf l1 {
#             type string;
#         }
#         leaf l3 {
#             type uint64;
#         }
#         leaf l_empty {
#             type empty;
#         }
#         list li {
#             key name;
#             leaf name {
#                 type string;
#             }
#             leaf val {
#                 type string;
#             }
#         }
#         leaf-list ll_uint64 {
#             type uint64;
#         }
#         leaf-list ll_str {
#             type string;
#         }
#     }
#     container pc1 {
#         presence "p";
#         container foo {
#             leaf l1 {
#                 type binary;
#             }
#         }
#     }
#     container c.dot {
#         leaf l.dot1 {
#             type string;
#         }
#     }
#     list special {
#         key yes;
#         leaf yes {
#             type boolean;
#         }
#     }
# }

xml_text_full = """<data>
<c1 xmlns="http://example.com/foo">
  <l1>foo-foo</l1>
  <l3>18446744073709551615</l3>
  <l_empty/>
  <li>
    <name>tuta</name>
    <val>baba</val>
    <c4>
      <l5>riba></l5>
    </c4>
  </li>
  <ll_uint64>4</ll_uint64>
  <ll_uint64>42</ll_uint64>
  <ll_str>kava</ll_str>
  <ll_str>ƒçaj</ll_str>
  <l_identityref xmlns:foo="http://example.com/foo">foo:fooy</l_identityref>
  <ll_identityref xmlns:bar="http://example.com/bar">bar:bary</ll_identityref>
  <l4>foo-qux</l4>
  <l1 xmlns="http://example.com/bar">foo-bar</l1>
  <l2 xmlns="http://example.com/bar">bar</l2>
</c1>
<pc1 xmlns="http://example.com/foo">
  <foo>
    <l1>SGVsbG8gQWN0b24g8J+roQ==</l1>
  </foo>
</pc1>
<pc2 xmlns="http://example.com/foo">
  <foo>
    <l_mandatory>baz</l_mandatory>
  </foo>
</pc2>
<pc3 xmlns="http://example.com/foo">
  <level1>
    <l1>l1-foo</l1>
    <l1-optional>l1-optional</l1-optional>
    <level2>
      <l2>l2-bar</l2>
      <l2-optional>l2-optional</l2-optional>
      <level3>
        <l3>l3-baz</l3>
        <l3-optional>l3-optional</l3-optional>
      </level3>
    </level2>
  </level1>
</pc3>
<c.dot xmlns="http://example.com/foo">
  <l.dot1>who put that here?!</l.dot1>
</c.dot>
<cc xmlns="http://example.com/foo">
  <cake>cake</cake>
</cc>
<conflict xmlns="http://example.com/foo">
  <foo>foo-foo</foo>
  <inner/>
  <foo xmlns="http://example.com/bar">foo-augmented-from-bar</foo>
  <inner xmlns="http://example.com/bar"/>
</conflict>
<special xmlns="http://example.com/foo">
  <yes>false</yes>
</special>
<special xmlns="http://example.com/foo">
  <yes>true</yes>
</special>
<li-union xmlns="http://example.com/foo">
  <k1>first</k1>
  <k2>4</k2>
  <k3>SGVsbG8gQWN0b24g8J+roQ==</k3>
  <checker>47</checker>
</li-union>
<li-union xmlns="http://example.com/foo">
  <k1>second</k1>
  <k2>unlimited</k2>
  <k3>SGVsbG8gQWN0b24g8J+roQ==</k3>
  <checker>1514</checker>
</li-union>
<li-union xmlns="http://example.com/foo">
  <k1>third</k1>
  <k2>aGk=</k2>
  <k3>SGVsbG8gQWN0b24g8J+roQ==</k3>
  <checker>Frank</checker>
</li-union>
<c2 xmlns="http://example.com/foo">
  <l1>foo-qux</l1>
</c2>
<test-idref xmlns="http://example.com/bar">
  <idref xmlns:bar="http://example.com/bar">bar:bary</idref>
  <idref xmlns:foo="http://example.com/foo">foo:fooy</idref>
</test-idref>
<conflict xmlns="http://example.com/bar">
  <foo>foo-bar</foo>
</conflict>
</data>"""

def _test_foo_from_xml_full():
    xml_in = xml.decode(xml_text_full)
    gd2 = yang_foo.from_xml(xml_in)
    # In this test we also use the gdata to "fill in" the foo module adata
    # classes and then compare the result of adata.to_gdata() with the input.
    ad = yang_foo_root.from_gdata(gd2)
    gd_adata = ad.to_gdata()
    gdiff = yang.gdata.diff(gd2, gd_adata)
    # TODO: (XML -> gdata) -> adata -> gdata differs from XML -> gdata in that
    # it includes "default" (empty) containers and lists. We could improve
    # adata.to_gdata() methods to skip empty subtrees ...
    # testing.assertEqual(gd1, gd2)
    if gdiff is not None:
        diff = r"""Container({
  'nested': Container({
    'f:inner': Container(),
    'bar:inner': Container(ns='http://example.com/bar', module='bar')
  }, ns='http://example.com/foo', module='foo'),
  'state': Container({
    'c1': Container()
  }, ns='http://example.com/foo', module='foo')
})"""
        testing.assertEqual(gdiff.prsrc(), diff)
    else:
        testing.assertNotNone(gdiff)

    # Prove roundtrip XML -> gdata -> XML is idempotent
    xml_out_text = gd2.to_xmlstr()
    xml_out = xml.decode("<data>\n{xml_out_text}\n</data>")
    testing.assertEqual(xml_in.encode(), xml_out.encode())
    # Return golden gdata
    return gd2.prsrc()

actor _test_gdata_source_roundtrip_xml_full(t: testing.EnvT):
    wfcap = file.WriteFileCap(file.FileCap(t.env.cap))
    xml_in = xml.decode(xml_text_full)
    gd = yang_foo.from_xml(xml_in)
    wf = file.WriteFile(wfcap, "../test_data_source_roundtrip/src/xml_full_gdata.act")
    await async wf.write("from yang.gdata import *\nfrom yang.identityref import Identityref\n\nxml_full = {gd.prsrc()}".encode())
    await async wf.close()
    t.success()

def _test_adata_foo_pc2():
    ad = yang_foo_root()
    foo = yang_foo.foo__pc2__foo("baz")
    pc2 = ad.create_pc2(foo)
    testing.assertEqual(pc2.foo.l_mandatory, "baz")
    return ad.to_gdata().prsrc()

def _indent_lines(text, indent=4):
    """Indent each line of the given text with the specified indent."""
    return "\n".join([(" " * indent) + line for line in text.splitlines()])

actor _test_adata_source_roundtrip_xml_full(t: testing.EnvT):
    wfcap = file.WriteFileCap(file.FileCap(t.env.cap))
    xml_in = xml.decode(xml_text_full)
    gd = yang_foo.from_xml(xml_in)
    ad = yang_foo_root.from_gdata(gd)
    wf = file.WriteFile(wfcap, "../test_data_source_roundtrip/src/xml_full_adata.act")
    await async wf.write("""from yang_foo import *
from yang.identityref import Identityref

def adata():
{_indent_lines(ad.prsrc("ad"))}
    return ad
""".encode())
    await async wf.close()
    t.success()

actor _test_adata_source_roundtrip_xml_full_loose(t: testing.EnvT):
    wfcap = file.WriteFileCap(file.FileCap(t.env.cap))
    xml_in = xml.decode(xml_text_full)
    gd = yang_foo.from_xml(xml_in)
    ad = yang_foo_loose.root.from_gdata(gd)
    wf = file.WriteFile(wfcap, "../test_data_source_roundtrip/src/xml_full_adata_loose.act")
    await async wf.write("""from yang_foo_loose import *
from yang.identityref import Identityref

def adata():
{_indent_lines(ad.prsrc("ad"))}
    return ad
""".encode())
    await async wf.close()
    t.success()

def _test_foo_from_xml1():
    """"""
    xml_text = """<data>
<pc1 xmlns="http://example.com/foo">
  <foo>
    <l1>SGVsbG8gQWN0b24g8J+roQ==</l1>
  </foo>
</pc1>
</data>"""
    xml_in = xml.decode(xml_text)
    gd2 = yang_foo.from_xml(xml_in)
    xml_out_text = gd2.to_xmlstr()
    xml_out = xml.decode("<data>\n{xml_out_text}\n</data>")
    testing.assertEqual(xml_in.encode(), xml_out.encode())

def _test_foo_from_xml_pc1():
    """"""
    xml_text = """<data>
<pc1 xmlns="http://example.com/foo"></pc1>
</data>"""
    xml_in = xml.decode(xml_text)
    gd2 = yang_foo.from_xml(xml_in)
    print(gd2.prsrc(), err=True)
    pc1_gdata = gd2.get_opt_cnt("pc1")
    if pc1_gdata is not None:
        testing.assertTrue(pc1_gdata.presence)
    else:
        testing.error("pc1 not found in gdata")
    ad = yang_foo_root.from_gdata(gd2)
    pc1 = ad.pc1
    if pc1 is None:
        testing.error("pc1 not found in adata")
    xml_out_text = gd2.to_xmlstr()
    xml_out = xml.decode("<data>\n{xml_out_text}\n</data>")
    testing.assertEqual(xml_in.encode(), xml_out.encode())

def _test_foo_from_xml_pc2():
    """"""
    xml_text = """<data>
<pc2 xmlns="http://example.com/foo"></pc2>
</data>"""
    xml_in = xml.decode(xml_text)
    try:
        d = yang_foo.from_xml(xml_in)
        testing.error("Expected exception on missing mandatory leaf")
    except ValueError as e:
        testing.assertIn("Cannot find xml child with name foo", e.error_message)

def _test_foo_from_xml2():
    """"""
    xml_text = """<data>
<c1 xmlns="http://example.com/foo">
  <l1>foo</l1>
</c1>
</data>"""
    xml_in = xml.decode(xml_text)
    gd2 = yang_foo.from_xml(xml_in)
    print(gd2.prsrc(), err=True)
    # The sibling presence container pc1 must not appear here
    pc1_gdata = gd2.get_opt_cnt("pc1")
    if pc1_gdata is not None:
        testing.error("pc1 found in gdata")
    ad = yang_foo_root.from_gdata(gd2)
    pc1 = ad.pc1
    if pc1 is not None:
        testing.error("pc1 found in adata")
    xml_out_text = gd2.to_xmlstr()
    xml_out = xml.decode("<data>\n{xml_out_text}\n</data>")
    testing.assertEqual(xml_in.encode(), xml_out.encode())

def _test_foo_from_xml_leaf_ns():
    xml_text = """<data>
<c1 xmlns="http://example.com/foo">
  <l1>foo</l1>
  <l2 xmlns="http://example.com/bar">bar</l2>
</c1>
</data>"""
    xml_in = xml.decode(xml_text)
    gd2 = yang_foo.from_xml(xml_in)
    xml_out_text = gd2.to_xmlstr()
    xml_out = xml.decode("<data>\n{xml_out_text}\n</data>")
    #testing.assertEqual(xml_in.encode(), xml_out.encode())
    return xml_out_text

def _test_foo_from_xml_named_ns():
    xml_text = """<data>
<c1 xmlns="http://example.com/foo">
  <l1>foo</l1>
  <bar:l2 xmlns:bar="http://example.com/bar">bar</bar:l2>
</c1>
</data>"""
    xml_in = xml.decode(xml_text)
    gd2 = yang_foo.from_xml(xml_in)
    xml_out_text = gd2.to_xmlstr()
    xml_out = xml.decode("<data>\n{xml_out_text}\n</data>")
    #testing.assertEqual(xml_in.encode(), xml_out.encode())
    return xml_out_text

def _test_foo_from_xml_dots():
    xml_text = """<data>
<c.dot xmlns="http://example.com/foo">
  <l.dot1>foo</l.dot1>
  <l.dot2 xmlns="http://example.com/bar">bar</l.dot2>
</c.dot>
</data>"""
    xml_in = xml.decode(xml_text)
    gd2 = yang_foo.from_xml(xml_in)
    xml_out_text = gd2.to_xmlstr()
    xml_out = xml.decode("<data>\n{xml_out_text}</data>")
    #testing.assertEqual(xml_in.encode(), xml_out.encode())
    return xml_out_text

def _test_foo_from_xml_li_union():
    xml_text = """<data>
<li-union xmlns="http://example.com/foo">
  <k1>first</k1>
  <k2>4</k2>
  <k3>SGVsbG8gQWN0b24g8J+roQ==</k3>
  <checker>47</checker>
</li-union>
<li-union xmlns="http://example.com/foo">
  <k1>second</k1>
  <k2>unlimited</k2>
  <k3>SGVsbG8gQWN0b24g8J+roQ==</k3>
  <checker>1514</checker>
</li-union>
<li-union xmlns="http://example.com/foo">
  <k1>third</k1>
  <k2>aGk=</k2>
  <k3>SGVsbG8gQWN0b24g8J+roQ==</k3>
  <checker>Frank</checker>
</li-union>
</data>"""
    xml_in = xml.decode(xml_text)
    gd2 = yang_foo.from_xml(xml_in)
    root = yang_foo_root.from_gdata(gd2)

    li1 = root.li_union.elements[0]
    testing.assertEqual(li1.k1, "first")
    k2 = li1.k2
    if isinstance(k2, int):
        testing.assertEqual(k2, 4)
#    TODO: uh, this is failing, so we are expecting the wrong type?
#    else:
#        testing.error("k2 in gdata is not an int, actual type: {type(k2)}")
    testing.assertEqual(li1.k3, "Hello Acton ü´°".encode())

    li2 = root.li_union.elements[1]
    testing.assertEqual(li2.k1, "second")
    k2 = li2.k2
    if isinstance(k2, str):
        testing.assertEqual(k2, "unlimited")
    else:
        testing.error("k2 in gdata is not a str, actual type: {type(k2)}")
    testing.assertEqual(li1.k3, "Hello Acton ü´°".encode())

    li3 = root.li_union.elements[2]
    testing.assertEqual(li3.k1, "third")
    li3_k2 = li3.k2
    if isinstance(li3_k2, bytes):
        testing.assertEqual(li3_k2, "hi".encode())
    else:
        testing.error("li3_k2 in gdata is not a bytes, actual type: {type(li3_k2)}")
    testing.assertEqual(li1.k3, "Hello Acton ü´°".encode())

def _test_foo_from_xml_empty_leaf():
    """"""
    xml_text = """<data>
<c1 xmlns="http://example.com/foo">
  <l_empty/>
</c1>
</data>"""
    xml_in = xml.decode(xml_text)
    gd2 = yang_foo.from_xml(xml_in)
    ad = yang_foo_root.from_gdata(gd2)
    testing.assertNotNone(ad.c1.l_empty)
    l_empty = ad.c1.l_empty
    if l_empty is not None:
        testing.assertTrue(l_empty)
    xml_out_text = gd2.to_xmlstr()
    xml_out = xml.decode("<data>\n{xml_out_text}\n</data>")
    testing.assertEqual(xml_in.encode(), xml_out.encode())

def _test_list_create_idempotency():
    r = yang_foo_root()
    e1 = r.c1.li.create("a")
    e1.val = "1"
    e2 = r.c1.li.create("a")
    e2.val = "2"
    # TODO: fix this!!!
    return r.to_gdata().to_xmlstr()

def _test_p_container_create_idempotency():
    r = yang_foo_root()
    pc1 = r.create_pc1()
    pc1.foo.l1 = [b"asdf"]
    pc2 = r.create_pc1()
    testing.assertEqual(pc1.foo.l1, pc2.foo.l1)

def _test_foo_from_gdata_int():
    xml_text = """<data>
<c1 xmlns="http://example.com/foo">
  <l3>1337</l3>
</c1>
</data>"""
    xml_in = xml.decode(xml_text)
    gd2 = yang_foo.from_xml(xml_in)
    l3 = gd2.get_cnt("c1").get_leaf("l3").val
    if isinstance(l3, bigint):
        testing.assertEqual(l3, 1337)
    else:
        testing.error("l3 in gdata is not an int")
    nr = yang_foo_root.from_gdata(gd2)
    testing.assertEqual(nr.c1.l3, 1337)

def _test_foo_from_gdata_empty():
    gd = yang.gdata.Container(children={})
    d = yang_foo_root.from_gdata(gd)
    return d.to_gdata().prsrc()

def _test_foo_from_xml_empty():
    xml_in = xml.decode("<data/>")
    gd2 = yang_foo.from_xml(xml_in)
    return gd2.prsrc()

def _test_foo_from_json_empty():
    json_in = json.decode(r"{}")
    gd2 = yang_foo.from_json(json_in)
    return gd2.prsrc()

def _test_foo_from_gdata_c1_l1():
    gd = yang.gdata.Container(children={
        "c1": yang.gdata.Container(children={
            "foo:l1": yang.gdata.Leaf("str", "foo-foo"),
            "bar:l1": yang.gdata.Leaf("str", "foo-bar", ns="http://example.com/bar", module="bar"),
            "l2": yang.gdata.Leaf("str", "bar", ns="http://example.com/bar", module="bar"),
        })
    })
    # ValueError: Cannot find list child with name li
    d = yang_foo_root.from_gdata(gd)
    return d.to_gdata().prsrc()

def _test_empty_true():
    r = yang_foo_root()
    r.c1.l_empty = True
    return r.to_gdata().to_xmlstr()

def _test_empty_false():
    r = yang_foo_root()
    r.c1.l_empty = False
    return r.to_gdata().to_xmlstr()


def basics_leaf_defaults(r):
    testing.assertEqual(r.c.l_str_def, "foo")
    testing.assertEqual(r.c.l_uint64_def, 1234567890)
    testing.assertEqual(r.c.l_str_def_quoted, '"foo"')
    testing.assertEqual(r.c.l_binary_def, "Hello Acton ü´°".encode())
    testing.assertEqual(r.c.l_identityref_def, yang_basics.basics_id1)

    # union types
    uds = r.c.l_union_def_str
    if isinstance(uds, str):
        testing.assertEqual(uds, "foo")
    else:
        raise ValueError("Expected str, got {type(uds)}")
    udi = r.c.l_union_def_int
    if isinstance(udi, int):
        testing.assertEqual(udi, 1234567890)
    else:
        raise ValueError("Expected int, got {type(udi)}")
    udf = r.c.l_union_def_float
    if isinstance(udf, float):
        testing.assertEqual(udf, 1.23)
    else:
        raise ValueError("Expected float, got {type(udf)}")
    udb = r.c.l_union_def_bool
    if isinstance(udb, bool):
        testing.assertEqual(udb, False)
    else:
        raise ValueError("Expected bool, got {type(udb)}")
    ude = r.c.l_union_def_enumeration
    if isinstance(ude, str):
        testing.assertEqual(ude, "unlimited")
    else:
        raise ValueError("Expected str, got {type(ude)}")

def _test_leaf_defaults():
    r = yang_basics.root()
    basics_leaf_defaults(r)

def _test_leaf_default_from_xml():
    xml_text = """<data><c xmlns="http://example.com/basics"/></data>"""
    xml_in = xml.decode(xml_text)
    gd2 = yang_basics.from_xml(xml_in)
    r = yang_basics.root.from_gdata(gd2)
    basics_leaf_defaults(r)

def _test_leaf_default_from_json():
    json_text = r"""{"basics:c": {}}"""
    json_in = json.decode(json_text)
    gd2 = yang_basics.from_json(json_in)
    r = yang_basics.root.from_gdata(gd2)
    basics_leaf_defaults(r)

def _test_leaf_default_from_gdata():
    gd = yang.gdata.Container(children={
        "c": yang.gdata.Container(children={})
    })
    r = yang_basics.root.from_gdata(gd)
    basics_leaf_defaults(r)

def _test_union_default_other_type():
    # set union leaf to value of a different Acton type than default
    c = yang_basics.basics__c()
    c.l_union_def_str = 42
    c.l_union_def_int = "foo"
    c.l_union_def_float = "foo"
    c.l_union_def_enumeration = 42

def _test_empty_presence():
    xml_text = """<data><empty-presence xmlns="http://example.com/foo"/></data>"""
    xml_in = xml.decode(xml_text)
    gd2 = yang_foo.from_xml(xml_in)
    ad = yang_foo_root.from_gdata(gd2)
    testing.assertNotNone(ad.empty_presence)
    xml_out_text = gd2.to_xmlstr()
    xml_out = xml.decode("<data>\n{xml_out_text}\n</data>")
    # testing.assertEqual(xml_in.encode(), xml_out.encode())
    return xml_out_text

# JSON

# TODO: "l_empty": [null],
json_full = {
    "foo:c1": {
        "l1": "foo-foo",
        "l3": "18446744073709551615",
        "li": [
            {
                "name": "tuta",
                "val": "baba",
                "c4": {
                    "l5": "riba>"
                }
            }
        ],
        "ll_uint64": ["4", "42"],
        "ll_str": ["kava", "ƒçaj"],
        "l4": "foo-qux",
        "bar:l1": "foo-bar",
        "bar:l2": "bar"
    },
    "foo:pc1": {
        "foo": {
            "l1": ["SGVsbG8gQWN0b24g8J+roQ=="]
        }
    },
    "foo:pc2": {
        "foo": {
            "l_mandatory": "baz"
        }
    },
    "foo:c.dot": {
        "l.dot1": "who put that here?!"
    },
    "foo:cc": {
        "cake": "cake"
    },
    "foo:conflict": {
        "foo": "foo-foo",
        "inner": {},
        "bar:foo": "foo-augmented-from-bar",
        "bar:inner": {}
    },
    "foo:special": [
        {
            "yes": True
        }
    ],
    "foo:nested": {
        "inner": {
            "foo": "WINNING",
            "li1": [
                {
                    "name": "AAA",
                    "bar": "WINNING",
                    "li2": [
                        {
                            "key1": "BBB",
                            "key2": "CCC",
                            "baz": "WINNING"
                        }
                    ]
                }
            ]
        }
    },
    "foo:li-union": [
        {
            "k1": "first",
            "k2": 4,
            "k3": "SGVsbG8gQWN0b24g8J+roQ==",
            "checker": 47
        },
        {
            "k1": "second",
            "k2": "unlimited",
            "k3": "SGVsbG8gQWN0b24g8J+roQ==",
            "checker": 1514
        },
        {
            "k1": "third",
            "k2": "aGk=",
            "k3": "SGVsbG8gQWN0b24g8J+roQ==",
            "checker": "Frank"
        }
    ],
    "foo:c2": {
        "l1": "foo-qux"
    },
    "bar:conflict":
    {
        "foo": "foo-bar"
    }
}

def _test_foo_from_json_full():
    gd2 = yang_foo.from_json(json_full)
    print(gd2.prsrc(), err=True)
    json_out = gd2.to_json()
    testing.assertEqual(json.encode(json_full, pretty=True), json_out)
    return gd2.prsrc()

def _test_foo_from_json_empty_leaf():
    json_text = r"""{"foo:c1":{"l_empty":[null]}}"""
    json_in = json.decode(json_text)
    gd2 = yang_foo.from_json(json_in)
    ad = yang_foo_root.from_gdata(gd2)
    testing.assertNotNone(ad.c1.l_empty)
    l_empty = ad.c1.l_empty
    if l_empty is not None:
        testing.assertTrue(l_empty)
    json_out_text = gd2.to_json(pretty=False)
    testing.assertEqual(json_text, json_out_text)

def _test_from_json():
    """Test mandatory field handling - success case"""
    json_data = {
        "foo:tc1": {
            "l1": "foo"
        }
    }
    # Should successfully parse since mandatory field is present
    gd2 = yang_one.from_json(json_data)
    #root = yang_one.root.from_gdata(gd2)
    #testing.assertEqual(root.children["tc1"].children["l1"].val, "foo")
    return gd2.to_xmlstr()

# example JSON data
jd1 = {
    "foo:c1": {
        "l1": "foo-foo",
        "l3": "18446744073709551615",
        "li": [
            {
                "name": "tuta",
                "val": "baba"
            },
            {
                "name": "tata",
                "val": "baba"
            }
        ],
        "ll_uint64": ["4", "42"],
        "ll_str": ["kava", "ƒçaj"],
        "bar:l1": "foo-bar",
        "bar:l2": "bar",
    },
    "foo:pc1": {
        "foo": {
            "l1": ["SGVsbG8gQWN0b24g8J+roQ=="]
        }
    },
    "foo:c.dot": {
        "l.dot1": "who put that here?!"
    },
    "foo:cc": {
        "cake": "cake"
    }
}

def _test_json_to_gdata():
    """Test JSON to GData conversion"""
    gd2 = yang_foo.from_json(jd1)
    return gd2.prsrc()

def _test_json_roundtrip():
    """Test JSON roundtrip"""
    gd2 = yang_foo.from_json(jd1)
    json_out = gd2.to_json()
    testing.assertEqual(json.encode(jd1, pretty=True), json_out)


def _test_json_path():
    jda = {
        "foo:nested": {
            "inner": {
                "foo": "WINNING"
            }
        }
    }
    gda = yang_foo.from_json(jda)

    jdb = {
        "foo": "WINNING"
        }
    gdb2 = yang_foo.from_json_path(jdb, ["foo:nested", "inner"])

    testing.assertEqual(gda.prsrc(), gdb2.prsrc())

def _test_json_path_nested_key_in_payload():
    jda = {
        "foo:nested": {
            "inner": {
                "li1": [
                    {
                        "name": "AAA",
                        "bar": "WINNING"
                    }
                ]
            }
        }
    }
    gda = yang_foo.from_json(jda)

    jdb = {
        "name": "AAA",
        "bar": "WINNING"
        }
    gdb2 = yang_foo.from_json_path(jdb, ["foo:nested", "inner", "li1", "AAA"])

    testing.assertEqual(gda.prsrc(), gdb2.prsrc())
    return gdb2.prsrc()

def _test_json_path_nested_no_key_in_payload():
    jda = {
        "foo:nested": {
            "inner": {
                "li1": [
                    {
                        "name": "AAA",
                        "bar": "WINNING"
                    }
                ]
            }
        }
    }
    gda = yang_foo.from_json(jda)

    jdb = {
        "bar": "WINNING"
        }
    gdb2 = yang_foo.from_json_path(jdb, ["foo:nested", "inner", "li1", "AAA"])

    testing.assertEqual(gda.prsrc(), gdb2.prsrc())
    return gdb2.prsrc()

def _test_json_path_nested_key_mismatch():
    jda = {
        "foo:nested": {
            "inner": {
                "li1": [
                    {
                        "name": "AAA",
                        "bar": "WINNING"
                    }
                ]
            }
        }
    }
    gda = yang_foo.from_json(jda)

    jdb = {
        "name": "banana",
        "bar": "WINNING"
        }
    try:
        gdb2 = yang_foo.from_json_path(jdb, ["foo:nested", "inner", "li1", "AAA"])
        testing.error("Expected exception on key mismatch")
    except ValueError:
        pass
    # Also test with gen3 - should fail the same way
    try:
        gdb3 = yang_foo.from_json_path(jdb, ["foo:nested", "inner", "li1", "AAA"])
        testing.error("Expected exception on key mismatch from gen3")
    except ValueError:
        return

def _test_json_path_nested():
    jda = {
        "foo:nested": {
            "inner": {
                "li1": [
                    {
                        "name": "AAA",
                        "li2": [
                            {
                                "key1": "BBB",
                                "key2": "CCC",
                                "baz": "WINNING"
                            }
                        ]
                    }
                ]
            }
        }
    }
    gda = yang_foo.from_json(jda)

    jdb = {
        "baz": "WINNING"
        }
    gdb2 = yang_foo.from_json_path(jdb, ["foo:nested", "inner", "li1", "AAA", "li2", "BBB,CCC"])

    testing.assertEqual(gda.prsrc(), gdb2.prsrc())
    return gdb2.prsrc()

def _test_json_path_conflict():
    jda = {
        "foo:nested": {
            "inner": {
                "li1": [
                    {
                        "name": "AAA",
                        "bar": "WINNING",
                        "bar:bar": "WINNING2"
                    }
                ]
            },
        }
    }
    gda = yang_foo.from_json(jda)

    jdb = {
        "bar": "WINNING",
        "bar:bar": "WINNING2"
    }
    gdb2 = yang_foo.from_json_path(jdb, ["foo:nested", "inner", "li1", "AAA"])
    testing.assertEqual(gda.prsrc(), gdb2.prsrc())
    return gdb2.prsrc()

def _test_json_path_conflict_other():
    jda = {
        "foo:nested": {
            "bar:inner": {
                "foo": "WINNING",
            }
        }
    }
    gda = yang_foo.from_json(jda)

    jdb = {
        "foo": "WINNING"
    }
    gdb2 = yang_foo.from_json_path(jdb, ["foo:nested", "bar:inner"])
    testing.assertEqual(gda.prsrc(), gdb2.prsrc())
    return gdb2.prsrc()

def _test_json_path_conflict_supefluous_namespace_qualifier():
    jda = {
        "foo:nested": {
            "inner": {
                "foo": "WINNING"
            }
        }
    }
    gda = yang_foo.from_json(jda)
    try:
        # We must not use the namespace qualifier on the inner container
        # because it is defined in the same module as its parent
        yang_foo.from_json_path({}, ["foo:nested", "foo:inner"])
    except ValueError as e:
        if str(e) != "ValueError: Invalid path":
            testing.error("Expected exception on invalid path")

def _test_json_path_remove():
    gd2 = yang_foo.from_json_path({}, ["foo:nested", "inner"], "remove")
    return gd2.prsrc()

def _test_json_path_remove_list_element():
    gd2 = yang_foo.from_json_path({}, ["foo:nested", "inner", "li1", "AAA"], "remove")
    return gd2.prsrc()

def _test_json_ops():
    ds1 = yang_foo.from_json({})
    p1_2 = yang_foo.from_json_path({"bar": "p1"}, ["foo:nested", "inner", "li1", "AAA"])
    ds2 = yang.gdata.patch(ds1, p1_2)
    if ds2 is not None:
        p2_2 = yang_foo.from_json_path({"bar": "p2"}, ["foo:nested", "inner", "li1", "BBB"])
        ds3 = yang.gdata.patch(ds2, p2_2)
        if ds3 is not None:
            p3_2 = yang_foo.from_json_path({}, ["foo:nested", "inner", "li1", "AAA"], "remove")
            ds4 = yang.gdata.patch(ds3, p3_2)
            if ds4 is not None:
                return ds4.prsrc()
    return ""

def _test_validate_identityref_xml_qual():
    # Test validation through XML parsing - valid case
    xml_text = """<data>
<c1 xmlns="http://example.com/foo">
  <l_identityref xmlns:foo="http://example.com/foo">foo:fooy</l_identityref>
</c1>
</data>"""
    xml_in = xml.decode(xml_text)
    gd2 = yang_foo.from_xml(xml_in)
    return gd2.prsrc()

def _test_validate_identityref_xml_no_qual():
    # Test validation through XML parsing - valid case
    xml_text = """<data>
<c1 xmlns="http://example.com/foo">
  <l_identityref>fooy</l_identityref>
</c1>
</data>"""
    xml_in = xml.decode(xml_text)
    gd2 = yang_foo.from_xml(xml_in)
    return gd2.prsrc()

def _test_validate_identityref_xml_invalid():
    # Test validation through XML parsing - invalid case
    xml_text_invalid = """<data>
<c1 xmlns="http://example.com/foo">
  <l_identityref>invalid-identity</l_identityref>
</c1>
</data>"""
    xml_in = xml.decode(xml_text_invalid)
    try:
        d = yang_foo.from_xml(xml_in)
        testing.error("Expected ValueError for invalid identityref value")
    except ValueError as exc:
        if "Invalid value for identityref" not in exc.error_message:
            raise exc

def _test_validate_identityref_leaflist_xml_qual():
    # Test validation through XML parsing - valid case with namespace qualifier
    xml_text = """<data>
<c1 xmlns="http://example.com/foo">
  <ll_identityref xmlns:foo="http://example.com/foo">foo:fooy</ll_identityref>
  <ll_identityref xmlns:bar="http://example.com/bar">bar:bary</ll_identityref>
</c1>
</data>"""
    xml_in = xml.decode(xml_text)
    gd2 = yang_foo.from_xml(xml_in)
    return gd2.prsrc()

def _test_validate_identityref_leaflist_xml_no_qual():
    # Test validation through XML parsing - valid case without qualifier
    xml_text = """<data>
<c1 xmlns="http://example.com/foo">
  <ll_identityref>fooy</ll_identityref>
</c1>
</data>"""
    xml_in = xml.decode(xml_text)
    gd2 = yang_foo.from_xml(xml_in)
    return gd2.prsrc()

def _test_validate_identityref_leaflist_xml_invalid():
    # Test validation through XML parsing - invalid case
    xml_text_invalid = """<data>
<c1 xmlns="http://example.com/foo">
  <ll_identityref>fooy</ll_identityref>
  <ll_identityref xmlns:foo="http://example.com/foo">foo:invalid-identity</ll_identityref>
</c1>
</data>"""
    xml_in = xml.decode(xml_text_invalid)
    try:
        gd2 = yang_foo.from_xml(xml_in)
        ad = yang_foo_root.from_gdata(gd2)
        # Try to convert back to gdata to trigger validation
        gd_out = ad.to_gdata()
        testing.error("Expected ValueError for invalid identityref value in leaf-list")
    except ValueError as exc:
        if "Invalid value for identityref" not in exc.error_message:
            raise exc

# JSON tests for identityref validation

def _test_validate_identityref_json_qual():
    # Test validation through JSON parsing - valid case with module qualifier
    json_text = {
        "foo:c1": {
            "l_identityref": "foo:fooy"
        }
    }
    gd2 = yang_foo.from_json(json_text)
    return gd2.prsrc()

def _test_validate_identityref_json_no_qual():
    # Test validation through JSON parsing - valid case without qualifier (should use current module)
    json_text = {
        "foo:c1": {
            "l_identityref": "fooy"
        }
    }
    gd2 = yang_foo.from_json(json_text)
    return gd2.prsrc()

def _test_validate_identityref_json_invalid():
    # Test validation through JSON parsing - invalid case
    json_text = {
        "foo:c1": {
            "l_identityref": "invalid-identity"
        }
    }
    try:
        gd2 = yang_foo.from_json(json_text)
        ad = yang_foo_root.from_gdata(gd2)
        # Try to convert back to gdata to trigger validation
        gd_out = ad.to_gdata()
        testing.error("Expected ValueError for invalid identityref value")
    except ValueError as exc:
        if "Invalid value for identityref" not in exc.error_message:
            raise exc


# JSON tests for identityref leaf-list validation

def _test_validate_identityref_leaflist_json_qual():
    # Test validation through JSON parsing - valid case with module qualifier
    json_text = {
        "foo:c1": {
            "ll_identityref": ["foo:fooy", "bar:bary"]
        }
    }
    gd2 = yang_foo.from_json(json_text)
    return gd2.prsrc()

def _test_validate_identityref_leaflist_json_no_qual():
    # Test validation through JSON parsing - valid case without qualifier
    json_text = {
        "foo:c1": {
            "ll_identityref": ["fooy"]
        }
    }
    gd2 = yang_foo.from_json(json_text)
    return gd2.prsrc()

def _test_validate_identityref_leaflist_json_invalid():
    # Test validation through JSON parsing - invalid case
    json_text = {
        "foo:c1": {
            "ll_identityref": ["fooy", "foo:invalid-identity"]
        }
    }
    try:
        gd2 = yang_foo.from_json(json_text)
        ad = yang_foo_root.from_gdata(gd2)
        # Try to convert back to gdata to trigger validation
        gd_out = ad.to_gdata()
        testing.error("Expected ValueError for invalid identityref value in leaf-list")
    except ValueError as exc:
        if "Invalid value for identityref" not in exc.error_message:
            raise exc

def _test_gen3_from_xml_full():
    s = yang.compile(yang_foo.src_yang())
    gd = yang.gen3.from_data(s, xml.decode(xml_text_full))
    return gd.prsrc()

def _test_copy_full_xml_tree():
    """Test copying a full XML tree and comparing gdata outputs"""
    gd = yang_foo.from_xml(xml.decode(xml_text_full))
    original = yang_foo_root.from_gdata(gd)

    copied = original.copy()
    original_gdata = original.to_gdata()
    copied_gdata = copied.to_gdata()

    gdiff = yang.gdata.diff(original_gdata, copied_gdata)
    testing.assertNone(gdiff)
